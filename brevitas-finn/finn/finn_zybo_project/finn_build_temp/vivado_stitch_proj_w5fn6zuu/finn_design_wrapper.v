//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/vivado_stitch_proj_w5fn6zuu/finn_vivado_stitch_proj.gen/sources_1/bd/finn_design/ip/finn_design_ConvolutionInputGenerator_rtl_0_0/synth/finn_design_ConvolutionInputGenerator_rtl_0_0.v


// (c) Copyright 1995-2026 Xilinx, Inc. All rights reserved.
// 
// This file contains confidential and proprietary information
// of Xilinx, Inc. and is protected under U.S. and
// international copyright and other intellectual property
// laws.
// 
// DISCLAIMER
// This disclaimer is not a license and does not grant any
// rights to the materials distributed herewith. Except as
// otherwise provided in a valid license issued to you by
// Xilinx, and to the maximum extent permitted by applicable
// law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
// WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
// AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
// BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
// INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
// (2) Xilinx shall not be liable (whether in contract or tort,
// including negligence, or under any other theory of
// liability) for any loss or damage of any kind or nature
// related to, arising under or in connection with these
// materials, including for any direct, or any indirect,
// special, incidental, or consequential loss or damage
// (including loss of data, profits, goodwill, or any type of
// loss or damage suffered as a result of any action brought
// by a third party) even if such damage or loss was
// reasonably foreseeable or Xilinx had been advised of the
// possibility of the same.
// 
// CRITICAL APPLICATIONS
// Xilinx products are not designed or intended to be fail-
// safe, or for use in any application requiring fail-safe
// performance, such as life-support or safety devices or
// systems, Class III medical devices, nuclear facilities,
// applications related to the deployment of airbags, or any
// other applications that could lead to death, personal
// injury, or severe property or environmental damage
// (individually and collectively, "Critical
// Applications"). Customer assumes the sole risk and
// liability of any use of Xilinx products in Critical
// Applications, subject only to applicable laws and
// regulations governing limitations on product liability.
// 
// THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
// PART OF THIS FILE AT ALL TIMES.
// 
// DO NOT MODIFY THIS FILE.


// IP VLNV: xilinx.com:module_ref:ConvolutionInputGenerator_rtl_0:1.0
// IP Revision: 1

(* X_CORE_INFO = "ConvolutionInputGenerator_rtl_0,Vivado 2022.2" *)
(* CHECK_LICENSE_TYPE = "finn_design_ConvolutionInputGenerator_rtl_0_0,ConvolutionInputGenerator_rtl_0,{}" *)
(* CORE_GENERATION_INFO = "finn_design_ConvolutionInputGenerator_rtl_0_0,ConvolutionInputGenerator_rtl_0,{x_ipProduct=Vivado 2022.2,x_ipVendor=xilinx.com,x_ipLibrary=module_ref,x_ipName=ConvolutionInputGenerator_rtl_0,x_ipVersion=1.0,x_ipCoreRevision=1,x_ipLanguage=VERILOG,x_ipSimLanguage=MIXED,BIT_WIDTH=8,SIMD=1,MMV_IN=1,MMV_OUT=1,IN_WIDTH_PADDED=8,OUT_WIDTH_PADDED=8,BUF_IN_WIDTH=8,BUF_OUT_WIDTH=8}" *)
(* IP_DEFINITION_SOURCE = "module_ref" *)
(* DowngradeIPIdentifiedWarnings = "yes" *)
module finn_design_ConvolutionInputGenerator_rtl_0_0 (
  ap_clk,
  ap_rst_n,
  in0_V_TDATA,
  in0_V_TVALID,
  in0_V_TREADY,
  out_V_TDATA,
  out_V_TVALID,
  out_V_TREADY
);

(* X_INTERFACE_PARAMETER = "XIL_INTERFACENAME ap_clk, ASSOCIATED_RESET ap_rst_n, ASSOCIATED_BUSIF in0_V:out_V, FREQ_HZ 100000000, FREQ_TOLERANCE_HZ 0, PHASE 0.0, CLK_DOMAIN finn_design_ap_clk_0, INSERT_VIP 0" *)
(* X_INTERFACE_INFO = "xilinx.com:signal:clock:1.0 ap_clk CLK" *)
input wire ap_clk;
(* X_INTERFACE_PARAMETER = "XIL_INTERFACENAME ap_rst_n, POLARITY ACTIVE_LOW, INSERT_VIP 0" *)
(* X_INTERFACE_INFO = "xilinx.com:signal:reset:1.0 ap_rst_n RST" *)
input wire ap_rst_n;
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 in0_V TDATA" *)
input wire [7 : 0] in0_V_TDATA;
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 in0_V TVALID" *)
input wire in0_V_TVALID;
(* X_INTERFACE_PARAMETER = "XIL_INTERFACENAME in0_V, TDATA_NUM_BYTES 1, TDEST_WIDTH 0, TID_WIDTH 0, TUSER_WIDTH 0, HAS_TREADY 1, HAS_TSTRB 0, HAS_TKEEP 0, HAS_TLAST 0, FREQ_HZ 100000000, PHASE 0.0, CLK_DOMAIN finn_design_ap_clk_0, LAYERED_METADATA undef, INSERT_VIP 0" *)
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 in0_V TREADY" *)
output wire in0_V_TREADY;
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 out_V TDATA" *)
output wire [7 : 0] out_V_TDATA;
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 out_V TVALID" *)
output wire out_V_TVALID;
(* X_INTERFACE_PARAMETER = "XIL_INTERFACENAME out_V, TDATA_NUM_BYTES 1, TDEST_WIDTH 0, TID_WIDTH 0, TUSER_WIDTH 0, HAS_TREADY 1, HAS_TSTRB 0, HAS_TKEEP 0, HAS_TLAST 0, FREQ_HZ 100000000, PHASE 0.0, CLK_DOMAIN finn_design_ap_clk_0, LAYERED_METADATA undef, INSERT_VIP 0" *)
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 out_V TREADY" *)
input wire out_V_TREADY;

  ConvolutionInputGenerator_rtl_0 #(
    .BIT_WIDTH(8),
    .SIMD(1),
    .MMV_IN(1),
    .MMV_OUT(1),
    .IN_WIDTH_PADDED(8),
    .OUT_WIDTH_PADDED(8),
    .BUF_IN_WIDTH(8),
    .BUF_OUT_WIDTH(8)
  ) inst (
    .ap_clk(ap_clk),
    .ap_rst_n(ap_rst_n),
    .in0_V_TDATA(in0_V_TDATA),
    .in0_V_TVALID(in0_V_TVALID),
    .in0_V_TREADY(in0_V_TREADY),
    .out_V_TDATA(out_V_TDATA),
    .out_V_TVALID(out_V_TVALID),
    .out_V_TREADY(out_V_TREADY)
  );
endmodule
//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/code_gen_ipgen_StreamingDataWidthConverter_rtl_1_6qz_oquq/StreamingDataWidthConverter_rtl_1.v


/******************************************************************************
 * Copyright (C) 2023, Advanced Micro Devices, Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *  1. Redistributions of source code must retain the above copyright notice,
 *     this list of conditions and the following disclaimer.
 *
 *  2. Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *
 *  3. Neither the name of the copyright holder nor the names of its
 *     contributors may be used to endorse or promote products derived from
 *     this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION). HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *****************************************************************************/

module StreamingDataWidthConverter_rtl_1 #(
	parameter  IBITS = 4,
	parameter  OBITS = 64,

	parameter  AXI_IBITS = (IBITS+7)/8 * 8,
	parameter  AXI_OBITS = (OBITS+7)/8 * 8
)(
	//- Global Control ------------------
	(* X_INTERFACE_INFO = "xilinx.com:signal:clock:1.0 ap_clk CLK" *)
	(* X_INTERFACE_PARAMETER = "ASSOCIATED_BUSIF in0_V:out_V, ASSOCIATED_RESET ap_rst_n" *)
	input	ap_clk,
	(* X_INTERFACE_PARAMETER = "POLARITY ACTIVE_LOW" *)
	input	ap_rst_n,

	//- AXI Stream - Input --------------
	output	in0_V_TREADY,
	input	in0_V_TVALID,
	input	[AXI_IBITS-1:0]  in0_V_TDATA,

	//- AXI Stream - Output -------------
	input	out_V_TREADY,
	output	out_V_TVALID,
	output	[AXI_OBITS-1:0]  out_V_TDATA
);

	dwc_axi #(
		.IBITS(IBITS),
		.OBITS(OBITS)
	) impl (
		.ap_clk(ap_clk),
		.ap_rst_n(ap_rst_n),
		.s_axis_tready(in0_V_TREADY),
		.s_axis_tvalid(in0_V_TVALID),
		.s_axis_tdata(in0_V_TDATA),
		.m_axis_tready(out_V_TREADY),
		.m_axis_tvalid(out_V_TVALID),
		.m_axis_tdata(out_V_TDATA)
	);

endmodule
//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/vivado_stitch_proj_w5fn6zuu/finn_vivado_stitch_proj.gen/sources_1/bd/finn_design/ip/finn_design_StreamingFIFO_rtl_1_0/synth/finn_design_StreamingFIFO_rtl_1_0.v


// (c) Copyright 1995-2026 Xilinx, Inc. All rights reserved.
// 
// This file contains confidential and proprietary information
// of Xilinx, Inc. and is protected under U.S. and
// international copyright and other intellectual property
// laws.
// 
// DISCLAIMER
// This disclaimer is not a license and does not grant any
// rights to the materials distributed herewith. Except as
// otherwise provided in a valid license issued to you by
// Xilinx, and to the maximum extent permitted by applicable
// law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
// WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
// AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
// BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
// INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
// (2) Xilinx shall not be liable (whether in contract or tort,
// including negligence, or under any other theory of
// liability) for any loss or damage of any kind or nature
// related to, arising under or in connection with these
// materials, including for any direct, or any indirect,
// special, incidental, or consequential loss or damage
// (including loss of data, profits, goodwill, or any type of
// loss or damage suffered as a result of any action brought
// by a third party) even if such damage or loss was
// reasonably foreseeable or Xilinx had been advised of the
// possibility of the same.
// 
// CRITICAL APPLICATIONS
// Xilinx products are not designed or intended to be fail-
// safe, or for use in any application requiring fail-safe
// performance, such as life-support or safety devices or
// systems, Class III medical devices, nuclear facilities,
// applications related to the deployment of airbags, or any
// other applications that could lead to death, personal
// injury, or severe property or environmental damage
// (individually and collectively, "Critical
// Applications"). Customer assumes the sole risk and
// liability of any use of Xilinx products in Critical
// Applications, subject only to applicable laws and
// regulations governing limitations on product liability.
// 
// THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
// PART OF THIS FILE AT ALL TIMES.
// 
// DO NOT MODIFY THIS FILE.


// IP VLNV: xilinx.com:module_ref:StreamingFIFO_rtl_1:1.0
// IP Revision: 1

(* X_CORE_INFO = "StreamingFIFO_rtl_1,Vivado 2022.2" *)
(* CHECK_LICENSE_TYPE = "finn_design_StreamingFIFO_rtl_1_0,StreamingFIFO_rtl_1,{}" *)
(* CORE_GENERATION_INFO = "finn_design_StreamingFIFO_rtl_1_0,StreamingFIFO_rtl_1,{x_ipProduct=Vivado 2022.2,x_ipVendor=xilinx.com,x_ipLibrary=module_ref,x_ipName=StreamingFIFO_rtl_1,x_ipVersion=1.0,x_ipCoreRevision=1,x_ipLanguage=VERILOG,x_ipSimLanguage=MIXED}" *)
(* IP_DEFINITION_SOURCE = "module_ref" *)
(* DowngradeIPIdentifiedWarnings = "yes" *)
module finn_design_StreamingFIFO_rtl_1_0 (
  ap_clk,
  ap_rst_n,
  count,
  maxcount,
  in0_V_TREADY,
  in0_V_TVALID,
  in0_V_TDATA,
  out_V_TREADY,
  out_V_TVALID,
  out_V_TDATA
);

(* X_INTERFACE_PARAMETER = "XIL_INTERFACENAME ap_clk, ASSOCIATED_RESET ap_rst_n, ASSOCIATED_BUSIF in0_V:out_V, FREQ_HZ 100000000, FREQ_TOLERANCE_HZ 0, PHASE 0.0, CLK_DOMAIN finn_design_ap_clk_0, INSERT_VIP 0" *)
(* X_INTERFACE_INFO = "xilinx.com:signal:clock:1.0 ap_clk CLK" *)
input wire ap_clk;
(* X_INTERFACE_PARAMETER = "XIL_INTERFACENAME ap_rst_n, POLARITY ACTIVE_LOW, INSERT_VIP 0" *)
(* X_INTERFACE_INFO = "xilinx.com:signal:reset:1.0 ap_rst_n RST" *)
input wire ap_rst_n;
output wire [9 : 0] count;
output wire [9 : 0] maxcount;
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 in0_V TREADY" *)
output wire in0_V_TREADY;
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 in0_V TVALID" *)
input wire in0_V_TVALID;
(* X_INTERFACE_PARAMETER = "XIL_INTERFACENAME in0_V, TDATA_NUM_BYTES 3, TDEST_WIDTH 0, TID_WIDTH 0, TUSER_WIDTH 0, HAS_TREADY 1, HAS_TSTRB 0, HAS_TKEEP 0, HAS_TLAST 0, FREQ_HZ 100000000, PHASE 0.0, CLK_DOMAIN finn_design_ap_clk_0, LAYERED_METADATA undef, INSERT_VIP 0" *)
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 in0_V TDATA" *)
input wire [23 : 0] in0_V_TDATA;
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 out_V TREADY" *)
input wire out_V_TREADY;
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 out_V TVALID" *)
output wire out_V_TVALID;
(* X_INTERFACE_PARAMETER = "XIL_INTERFACENAME out_V, TDATA_NUM_BYTES 3, TDEST_WIDTH 0, TID_WIDTH 0, TUSER_WIDTH 0, HAS_TREADY 1, HAS_TSTRB 0, HAS_TKEEP 0, HAS_TLAST 0, FREQ_HZ 100000000, PHASE 0.0, CLK_DOMAIN finn_design_ap_clk_0, LAYERED_METADATA undef, INSERT_VIP 0" *)
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 out_V TDATA" *)
output wire [23 : 0] out_V_TDATA;

  StreamingFIFO_rtl_1 inst (
    .ap_clk(ap_clk),
    .ap_rst_n(ap_rst_n),
    .count(count),
    .maxcount(maxcount),
    .in0_V_TREADY(in0_V_TREADY),
    .in0_V_TVALID(in0_V_TVALID),
    .in0_V_TDATA(in0_V_TDATA),
    .out_V_TREADY(out_V_TREADY),
    .out_V_TVALID(out_V_TVALID),
    .out_V_TDATA(out_V_TDATA)
  );
endmodule
//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/vivado_stitch_proj_w5fn6zuu/finn_vivado_stitch_proj.gen/sources_1/bd/finn_design/ip/finn_design_StreamingFIFO_rtl_6_0/synth/finn_design_StreamingFIFO_rtl_6_0.v


// (c) Copyright 1995-2026 Xilinx, Inc. All rights reserved.
// 
// This file contains confidential and proprietary information
// of Xilinx, Inc. and is protected under U.S. and
// international copyright and other intellectual property
// laws.
// 
// DISCLAIMER
// This disclaimer is not a license and does not grant any
// rights to the materials distributed herewith. Except as
// otherwise provided in a valid license issued to you by
// Xilinx, and to the maximum extent permitted by applicable
// law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
// WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
// AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
// BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
// INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
// (2) Xilinx shall not be liable (whether in contract or tort,
// including negligence, or under any other theory of
// liability) for any loss or damage of any kind or nature
// related to, arising under or in connection with these
// materials, including for any direct, or any indirect,
// special, incidental, or consequential loss or damage
// (including loss of data, profits, goodwill, or any type of
// loss or damage suffered as a result of any action brought
// by a third party) even if such damage or loss was
// reasonably foreseeable or Xilinx had been advised of the
// possibility of the same.
// 
// CRITICAL APPLICATIONS
// Xilinx products are not designed or intended to be fail-
// safe, or for use in any application requiring fail-safe
// performance, such as life-support or safety devices or
// systems, Class III medical devices, nuclear facilities,
// applications related to the deployment of airbags, or any
// other applications that could lead to death, personal
// injury, or severe property or environmental damage
// (individually and collectively, "Critical
// Applications"). Customer assumes the sole risk and
// liability of any use of Xilinx products in Critical
// Applications, subject only to applicable laws and
// regulations governing limitations on product liability.
// 
// THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
// PART OF THIS FILE AT ALL TIMES.
// 
// DO NOT MODIFY THIS FILE.


// IP VLNV: xilinx.com:module_ref:StreamingFIFO_rtl_6:1.0
// IP Revision: 1

(* X_CORE_INFO = "StreamingFIFO_rtl_6,Vivado 2022.2" *)
(* CHECK_LICENSE_TYPE = "finn_design_StreamingFIFO_rtl_6_0,StreamingFIFO_rtl_6,{}" *)
(* CORE_GENERATION_INFO = "finn_design_StreamingFIFO_rtl_6_0,StreamingFIFO_rtl_6,{x_ipProduct=Vivado 2022.2,x_ipVendor=xilinx.com,x_ipLibrary=module_ref,x_ipName=StreamingFIFO_rtl_6,x_ipVersion=1.0,x_ipCoreRevision=1,x_ipLanguage=VERILOG,x_ipSimLanguage=MIXED}" *)
(* IP_DEFINITION_SOURCE = "module_ref" *)
(* DowngradeIPIdentifiedWarnings = "yes" *)
module finn_design_StreamingFIFO_rtl_6_0 (
  ap_clk,
  ap_rst_n,
  count,
  maxcount,
  in0_V_TREADY,
  in0_V_TVALID,
  in0_V_TDATA,
  out_V_TREADY,
  out_V_TVALID,
  out_V_TDATA
);

(* X_INTERFACE_PARAMETER = "XIL_INTERFACENAME ap_clk, ASSOCIATED_RESET ap_rst_n, ASSOCIATED_BUSIF in0_V:out_V, FREQ_HZ 100000000, FREQ_TOLERANCE_HZ 0, PHASE 0.0, CLK_DOMAIN finn_design_ap_clk_0, INSERT_VIP 0" *)
(* X_INTERFACE_INFO = "xilinx.com:signal:clock:1.0 ap_clk CLK" *)
input wire ap_clk;
(* X_INTERFACE_PARAMETER = "XIL_INTERFACENAME ap_rst_n, POLARITY ACTIVE_LOW, INSERT_VIP 0" *)
(* X_INTERFACE_INFO = "xilinx.com:signal:reset:1.0 ap_rst_n RST" *)
input wire ap_rst_n;
output wire [7 : 0] count;
output wire [7 : 0] maxcount;
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 in0_V TREADY" *)
output wire in0_V_TREADY;
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 in0_V TVALID" *)
input wire in0_V_TVALID;
(* X_INTERFACE_PARAMETER = "XIL_INTERFACENAME in0_V, TDATA_NUM_BYTES 8, TDEST_WIDTH 0, TID_WIDTH 0, TUSER_WIDTH 0, HAS_TREADY 1, HAS_TSTRB 0, HAS_TKEEP 0, HAS_TLAST 0, FREQ_HZ 100000000, PHASE 0.0, CLK_DOMAIN finn_design_ap_clk_0, LAYERED_METADATA undef, INSERT_VIP 0" *)
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 in0_V TDATA" *)
input wire [63 : 0] in0_V_TDATA;
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 out_V TREADY" *)
input wire out_V_TREADY;
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 out_V TVALID" *)
output wire out_V_TVALID;
(* X_INTERFACE_PARAMETER = "XIL_INTERFACENAME out_V, TDATA_NUM_BYTES 8, TDEST_WIDTH 0, TID_WIDTH 0, TUSER_WIDTH 0, HAS_TREADY 1, HAS_TSTRB 0, HAS_TKEEP 0, HAS_TLAST 0, FREQ_HZ 100000000, PHASE 0.0, CLK_DOMAIN finn_design_ap_clk_0, LAYERED_METADATA undef, INSERT_VIP 0" *)
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 out_V TDATA" *)
output wire [63 : 0] out_V_TDATA;

  StreamingFIFO_rtl_6 inst (
    .ap_clk(ap_clk),
    .ap_rst_n(ap_rst_n),
    .count(count),
    .maxcount(maxcount),
    .in0_V_TREADY(in0_V_TREADY),
    .in0_V_TVALID(in0_V_TVALID),
    .in0_V_TDATA(in0_V_TDATA),
    .out_V_TREADY(out_V_TREADY),
    .out_V_TVALID(out_V_TVALID),
    .out_V_TDATA(out_V_TDATA)
  );
endmodule
//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/code_gen_ipgen_StreamingFIFO_rtl_1_1vyz9xjq/StreamingFIFO_rtl_1.v


/******************************************************************************
 * Copyright (C) 2024, Advanced Micro Devices, Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *  1. Redistributions of source code must retain the above copyright notice,
 *     this list of conditions and the following disclaimer.
 *
 *  2. Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *
 *  3. Neither the name of the copyright holder nor the names of its
 *     contributors may be used to endorse or promote products derived from
 *     this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION). HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *****************************************************************************/

module StreamingFIFO_rtl_1(
//- Global Control ------------------
(* X_INTERFACE_PARAMETER = "ASSOCIATED_BUSIF in0_V:out_V, ASSOCIATED_RESET = ap_rst_n" *)
(* X_INTERFACE_INFO = "xilinx.com:signal:clock:1.0 ap_clk CLK" *)
input   ap_clk,
(* X_INTERFACE_PARAMETER = "POLARITY ACTIVE_LOW" *)
input   ap_rst_n,

output [9:0] count,
output [9:0] maxcount,

//- AXI Stream - Input --------------
output   in0_V_TREADY,
input   in0_V_TVALID,
input  [23:0] in0_V_TDATA,

//- AXI Stream - Output --------------
input   out_V_TREADY,
output   out_V_TVALID,
output  [23:0] out_V_TDATA
);

Q_srl #(
.depth(900),
.width(24)
)
impl
(
 .clock(ap_clk),
 .reset(!ap_rst_n),
 .count(count),
 .maxcount(maxcount),
 .i_d(in0_V_TDATA),
 .i_v(in0_V_TVALID),
 .i_r(in0_V_TREADY),
 .o_d(out_V_TDATA),
 .o_v(out_V_TVALID),
 .o_r(out_V_TREADY)
);

endmodule
//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/code_gen_ipgen_StreamingFIFO_rtl_5_pvgvb9s1/Q_srl.v


// original source:
// https://github.com/nachiket/tdfc/blob/master/verilog/queues/Q_srl_oreg3_prefull_SIMPLE.v


// Copyright (c) 1999 The Regents of the University of California
// Copyright (c) 2010 The Regents of the University of Pennsylvania
// Copyright (c) 2011 Department of Electrical and Electronic Engineering, Imperial College London
// Copyright (c) 2020 Xilinx
//
// Permission to use, copy, modify, and distribute this software and
// its documentation for any purpose, without fee, and without a
// written agreement is hereby granted, provided that the above copyright
// notice and this paragraph and the following two paragraphs appear in
// all copies.
//
// IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR
// DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
// LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION,
// EVEN IF THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
// THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
// INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
// AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE PROVIDED HEREUNDER IS ON
// AN "AS IS" BASIS, AND THE UNIVERSITY OF CALIFORNIA HAS NO OBLIGATIONS TO
// PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
//

// Q_srl_oreg3_prefull_SIMPLE.v
//
//  - In-page queue with parameterizable depth, bit width
//  - Stream I/O is triple (data, valid, back-pressure),
//      with EOS concatenated into the data
//  - Flow control for input & output is combinationally decoupled
//  - 2 <= depth <= 256
//      * (depth >= 2)  is required to decouple I/O flow control,
//          where empty => no produce,  full => no consume,
//          and depth 1 would ping-pong between the two at half rate
//      * (depth <= 256) can be modified
//           by changing ''synthesis loop_limit X'' below
//          and changing ''addrwidth'' or its log computation
//  - 1 <= width
//  - Queue storage is in SRL16E, up to depth 16 per LUT per bit-slice,
//      plus output register (for fast output)
//  - Queue addressing is done by ''addr'' up-down counter
//  - Queue fullness is checked by comparator (addr==depth)
//  - Queue fullness                           is pre-computed for next cycle
//  - Queue input back-pressure                is pre-computed for next cycle
//  - Queue output valid (state!=state__empty) is pre-computed for next cycle
//      (necessary since SRL data output reg requires non-boolean state)
//  - FSM has 3 states (empty, one, more)
//  - When empty, continue to emit most recently emitted value (for debugging)
//
//  - Queue slots used      = / (state==state_empty) ? 0
//                            | (state==state_one)   ? 1
//                            \ (state==state_more)  ? addr+2
//  - Queue slots used     <=  depth
//  - Queue slots remaining =  depth - used
//                          = / (state==state_empty) ? depth
//                            | (state==state_one)   ? depth-1
//                            \ (state==state_more)  ? depth-2-addr
//
//  - Synplify 7.1 / 8.0
//  - Eylon Caspi,  9/11/03, 8/18/04, 3/29/05


`ifdef  Q_srl
`else
`define Q_srl


module Q_srl (clock, reset, i_d, i_v, i_r, o_d, o_v, o_r, count, maxcount);

   parameter depth = 16;   // - greatest #items in queue  (2 <= depth <= 256)
   parameter width = 16;   // - width of data (i_d, o_d)

   localparam countwidth = $clog2(depth + 1);
   localparam addrwidth = $clog2(depth);

   input     clock;
   input     reset;

   input  [width-1:0] i_d;	// - input  stream data (concat data + eos)
   input              i_v;	// - input  stream valid
   output             i_r;	// - input  stream ready
   wire               i_b;  // - input  stream back-pressure

   output [width-1:0] o_d;	// - output stream data (concat data + eos)
   output             o_v;	// - output stream valid
   input              o_r;	// - output stream ready
   wire               o_b;	// - output stream back-pressure

   output [countwidth-1:0] count;  // - output number of elems in queue
   output [countwidth-1:0] maxcount;  // - maximum observed count since reset

   reg [countwidth-1:0] maxcount_reg;  // - maximum count seen until now
   reg    [addrwidth-1:0] addr, addr_, a_;		// - SRL16 address
							//     for data output
   reg 			  shift_en_;			// - SRL16 shift enable
   reg    [width-1:0] 	  srl [depth-2:0];		// - SRL16 memory
   reg 			  shift_en_o_;			// - SRLO  shift enable
   reg    [width-1:0] 	  srlo_, srlo			// - SRLO  output reg
			  /* synthesis syn_allow_retiming=0 */ ;

   parameter state_empty = 2'd0;    // - state empty : o_v=0 o_d=UNDEFINED
   parameter state_one   = 2'd1;    // - state one   : o_v=1 o_d=srlo
   parameter state_more  = 2'd2;    // - state more  : o_v=1 o_d=srlo
				    //     #items in srl = addr+2

   reg [1:0] state, state_;	    // - state register

   wire      addr_full_;	    // - true iff addr==depth-2 on NEXT cycle
   reg       addr_full; 	    // - true iff addr==depth-2
   wire      addr_zero_;	    // - true iff addr==0
   wire      o_v_reg_;		    // - true iff state_empty   on NEXT cycle
   reg       o_v_reg  		    // - true iff state_empty
	     /* synthesis syn_allow_retiming=0 */ ;
   wire      i_b_reg_;		    // - true iff !full         on NEXT cycle
   reg       i_b_reg  		    // - true iff !full
	     /* synthesis syn_allow_retiming=0 */ ;

   assign addr_full_ = (state_==state_more) && (addr_==depth-2);
						// - queue full
   assign addr_zero_ = (addr==0);		// - queue contains 2 (or 1,0)
   assign o_v_reg_   = (state_!=state_empty);	// - output valid if non-empty
   assign i_b_reg_   = addr_full_;		// - input bp if full
   assign o_d = srlo;				// - output data from queue
   assign o_v = o_v_reg;			// - output valid if non-empty
   assign i_b = i_b_reg;			// - input bp if full
   assign maxcount = maxcount_reg;

   assign i_r = !i_b;
   assign o_b = !o_r;

   assign count = (state==state_more ? addr+2 : (state==state_one ? 1 : 0));

   // - ''always'' block with both FFs and SRL16 does not work,
   //      since FFs need reset but SRL16 does not

   always @(posedge clock) begin	// - seq always: FFs
      if (reset) begin
	 state     <= state_empty;
	 addr      <= 0;
         addr_full <= 0;
	 o_v_reg   <= 0;

	 i_b_reg   <= 0;
	 maxcount_reg <= 0;

      end
      else begin
	 state     <= state_;
	 addr      <= addr_;
         addr_full <= addr_full_;
	 o_v_reg   <= o_v_reg_;
	 i_b_reg   <= i_b_reg_;
	 maxcount_reg <= (count > maxcount_reg ? count : maxcount_reg);
      end
   end // always @ (posedge clock)

   always @(posedge clock) begin	// - seq always: srlo
      // - infer enabled output reg at end of shift chain
      // - input first element from i_d, all subsequent elements from SRL16
      if (reset) begin
	 srlo <= 0;
      end
      else begin
	 if (shift_en_o_) begin
	    srlo <= srlo_;
	 end
      end
   end // always @ (posedge clock)

   always @(posedge clock) begin			// - seq always: srl
      // - infer enabled SRL16E from shifting srl array
      // - no reset capability;  srl[] contents undefined on reset
      if (shift_en_) begin
	 // synthesis loop_limit 256
	 for (a_=depth-2; a_>0; a_=a_-1) begin
	    srl[a_] = srl[a_-1];
	 end
	 srl[0] <= i_d;
      end
   end // always @ (posedge clock or negedge reset)

   always @* begin					// - combi always
        srlo_       <=  'bx;
        shift_en_o_ <= 1'bx;
        shift_en_   <= 1'bx;
        addr_       <=  'bx;
        state_      <= 2'bx;
      case (state)

	state_empty: begin		    // - (empty, will not produce)
	      if (i_v) begin		    // - empty & i_v => consume
		 srlo_       <= i_d;
		 shift_en_o_ <= 1;
		 shift_en_   <= 1'bx;
		 addr_       <= 0;
		 state_      <= state_one;
	      end
	      else	begin		    // - empty & !i_v => idle
		 srlo_       <= 'bx;
		 shift_en_o_ <= 0;
		 shift_en_   <= 1'bx;
		 addr_       <= 0;
		 state_      <= state_empty;
	      end
	end

	state_one: begin		    // - (contains one)
	      if (i_v && o_b) begin	    // - one & i_v & o_b => consume
		 srlo_       <= 'bx;
		 shift_en_o_ <= 0;
		 shift_en_   <= 1;
		 addr_       <= 0;
		 state_      <= state_more;
	      end
	      else if (i_v && !o_b) begin   // - one & i_v & !o_b => cons+prod
		 srlo_       <= i_d;
		 shift_en_o_ <= 1;
		 shift_en_   <= 1;
		 addr_       <= 0;
		 state_      <= state_one;
	      end
	      else if (!i_v && o_b) begin   // - one & !i_v & o_b => idle
		 srlo_       <= 'bx;
		 shift_en_o_ <= 0;
		 shift_en_   <= 1'bx;
		 addr_       <= 0;
		 state_      <= state_one;
	      end
	      else if (!i_v && !o_b) begin  // - one & !i_v & !o_b => produce
		 srlo_       <= 'bx;
		 shift_en_o_ <= 0;
		 shift_en_   <= 1'bx;
		 addr_       <= 0;
		 state_      <= state_empty;
	      end
	end // case: state_one

	state_more: begin		    // - (contains more than one)
	   if (addr_full || (depth==2)) begin
					    // - (full, will not consume)
					    // - (full here if depth==2)
	      if (o_b) begin		    // - full & o_b => idle
		 srlo_       <= 'bx;
		 shift_en_o_ <= 0;
		 shift_en_   <= 0;
		 addr_       <= addr;
		 state_      <= state_more;
	      end
	      else begin		    // - full & !o_b => produce
		 srlo_       <= srl[addr];
		 shift_en_o_ <= 1;
		 shift_en_   <= 0;
//		 addr_       <= addr-1;
//		 state_      <= state_more;
		 addr_       <= addr_zero_ ? 0         : addr-1;
		 state_      <= addr_zero_ ? state_one : state_more;
	      end
	   end
	   else begin			    // - (mid: neither empty nor full)
	      if (i_v && o_b) begin	    // - mid & i_v & o_b => consume
		 srlo_       <= 'bx;
		 shift_en_o_ <= 0;
		 shift_en_   <= 1;
		 addr_       <= addr+1;
		 state_      <= state_more;
	      end
	      else if (i_v && !o_b) begin   // - mid & i_v & !o_b => cons+prod
		 srlo_       <= srl[addr];
		 shift_en_o_ <= 1;
		 shift_en_   <= 1;
		 addr_       <= addr;
		 state_      <= state_more;
	      end
	      else if (!i_v && o_b) begin   // - mid & !i_v & o_b => idle
		 srlo_       <= 'bx;
		 shift_en_o_ <= 0;
		 shift_en_   <= 0;
		 addr_       <= addr;
		 state_      <= state_more;
	      end
	      else if (!i_v && !o_b) begin  // - mid & !i_v & !o_b => produce
		 srlo_       <= srl[addr];
		 shift_en_o_ <= 1;
		 shift_en_   <= 0;
		 addr_       <= addr_zero_ ? 0         : addr-1;
		 state_      <= addr_zero_ ? state_one : state_more;
	      end
	   end // else: !if(addr_full)
	end // case: state_more

	default: begin
		 srlo_       <=  'bx;
		 shift_en_o_ <= 1'bx;
		 shift_en_   <= 1'bx;
		 addr_       <=  'bx;
		 state_      <= 2'bx;
	end // case: default

      endcase // case(state)
   end // always @ *

endmodule // Q_srl


`endif  // `ifdef  Q_srl
//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/vivado_stitch_proj_w5fn6zuu/finn_vivado_stitch_proj.gen/sources_1/bd/finn_design/ipshared/18e4/hdl/verilog/MVAU_hls_0_Matrix_Vector_Activate_Stream_Batch_p_ZL7threshs_9_ROM_AUTO_1R.v


// ==============================================================
// Vitis HLS - High-Level Synthesis from C, C++ and OpenCL v2022.2 (64-bit)
// Version: 2022.2
// Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.
// ==============================================================
`timescale 1 ns / 1 ps
module MVAU_hls_0_Matrix_Vector_Activate_Stream_Batch_p_ZL7threshs_9_ROM_AUTO_1R (
    address0, ce0, q0, 
    reset, clk);

parameter DataWidth = 13;
parameter AddressWidth = 4;
parameter AddressRange = 16;
 
input[AddressWidth-1:0] address0;
input ce0;
output reg[DataWidth-1:0] q0;

input reset;
input clk;

 
reg [DataWidth-1:0] rom0[0:AddressRange-1];


initial begin
     
    $readmemh("/home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/code_gen_ipgen_MVAU_hls_0_z2r2fzak/project_MVAU_hls_0/sol1/impl/ip/hdl/verilog/MVAU_hls_0_Matrix_Vector_Activate_Stream_Batch_p_ZL7threshs_9_ROM_AUTO_1R.dat", rom0);
end

  
always @(posedge clk) 
begin 
    if (ce0) 
    begin
        q0 <= rom0[address0];
    end
end


endmodule

//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/code_gen_ipgen_StreamingFIFO_rtl_11_6ia4dms1/Q_srl.v


// original source:
// https://github.com/nachiket/tdfc/blob/master/verilog/queues/Q_srl_oreg3_prefull_SIMPLE.v


// Copyright (c) 1999 The Regents of the University of California
// Copyright (c) 2010 The Regents of the University of Pennsylvania
// Copyright (c) 2011 Department of Electrical and Electronic Engineering, Imperial College London
// Copyright (c) 2020 Xilinx
//
// Permission to use, copy, modify, and distribute this software and
// its documentation for any purpose, without fee, and without a
// written agreement is hereby granted, provided that the above copyright
// notice and this paragraph and the following two paragraphs appear in
// all copies.
//
// IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR
// DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
// LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION,
// EVEN IF THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
// THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
// INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
// AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE PROVIDED HEREUNDER IS ON
// AN "AS IS" BASIS, AND THE UNIVERSITY OF CALIFORNIA HAS NO OBLIGATIONS TO
// PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
//

// Q_srl_oreg3_prefull_SIMPLE.v
//
//  - In-page queue with parameterizable depth, bit width
//  - Stream I/O is triple (data, valid, back-pressure),
//      with EOS concatenated into the data
//  - Flow control for input & output is combinationally decoupled
//  - 2 <= depth <= 256
//      * (depth >= 2)  is required to decouple I/O flow control,
//          where empty => no produce,  full => no consume,
//          and depth 1 would ping-pong between the two at half rate
//      * (depth <= 256) can be modified
//           by changing ''synthesis loop_limit X'' below
//          and changing ''addrwidth'' or its log computation
//  - 1 <= width
//  - Queue storage is in SRL16E, up to depth 16 per LUT per bit-slice,
//      plus output register (for fast output)
//  - Queue addressing is done by ''addr'' up-down counter
//  - Queue fullness is checked by comparator (addr==depth)
//  - Queue fullness                           is pre-computed for next cycle
//  - Queue input back-pressure                is pre-computed for next cycle
//  - Queue output valid (state!=state__empty) is pre-computed for next cycle
//      (necessary since SRL data output reg requires non-boolean state)
//  - FSM has 3 states (empty, one, more)
//  - When empty, continue to emit most recently emitted value (for debugging)
//
//  - Queue slots used      = / (state==state_empty) ? 0
//                            | (state==state_one)   ? 1
//                            \ (state==state_more)  ? addr+2
//  - Queue slots used     <=  depth
//  - Queue slots remaining =  depth - used
//                          = / (state==state_empty) ? depth
//                            | (state==state_one)   ? depth-1
//                            \ (state==state_more)  ? depth-2-addr
//
//  - Synplify 7.1 / 8.0
//  - Eylon Caspi,  9/11/03, 8/18/04, 3/29/05


`ifdef  Q_srl
`else
`define Q_srl


module Q_srl (clock, reset, i_d, i_v, i_r, o_d, o_v, o_r, count, maxcount);

   parameter depth = 16;   // - greatest #items in queue  (2 <= depth <= 256)
   parameter width = 16;   // - width of data (i_d, o_d)

   localparam countwidth = $clog2(depth + 1);
   localparam addrwidth = $clog2(depth);

   input     clock;
   input     reset;

   input  [width-1:0] i_d;	// - input  stream data (concat data + eos)
   input              i_v;	// - input  stream valid
   output             i_r;	// - input  stream ready
   wire               i_b;  // - input  stream back-pressure

   output [width-1:0] o_d;	// - output stream data (concat data + eos)
   output             o_v;	// - output stream valid
   input              o_r;	// - output stream ready
   wire               o_b;	// - output stream back-pressure

   output [countwidth-1:0] count;  // - output number of elems in queue
   output [countwidth-1:0] maxcount;  // - maximum observed count since reset

   reg [countwidth-1:0] maxcount_reg;  // - maximum count seen until now
   reg    [addrwidth-1:0] addr, addr_, a_;		// - SRL16 address
							//     for data output
   reg 			  shift_en_;			// - SRL16 shift enable
   reg    [width-1:0] 	  srl [depth-2:0];		// - SRL16 memory
   reg 			  shift_en_o_;			// - SRLO  shift enable
   reg    [width-1:0] 	  srlo_, srlo			// - SRLO  output reg
			  /* synthesis syn_allow_retiming=0 */ ;

   parameter state_empty = 2'd0;    // - state empty : o_v=0 o_d=UNDEFINED
   parameter state_one   = 2'd1;    // - state one   : o_v=1 o_d=srlo
   parameter state_more  = 2'd2;    // - state more  : o_v=1 o_d=srlo
				    //     #items in srl = addr+2

   reg [1:0] state, state_;	    // - state register

   wire      addr_full_;	    // - true iff addr==depth-2 on NEXT cycle
   reg       addr_full; 	    // - true iff addr==depth-2
   wire      addr_zero_;	    // - true iff addr==0
   wire      o_v_reg_;		    // - true iff state_empty   on NEXT cycle
   reg       o_v_reg  		    // - true iff state_empty
	     /* synthesis syn_allow_retiming=0 */ ;
   wire      i_b_reg_;		    // - true iff !full         on NEXT cycle
   reg       i_b_reg  		    // - true iff !full
	     /* synthesis syn_allow_retiming=0 */ ;

   assign addr_full_ = (state_==state_more) && (addr_==depth-2);
						// - queue full
   assign addr_zero_ = (addr==0);		// - queue contains 2 (or 1,0)
   assign o_v_reg_   = (state_!=state_empty);	// - output valid if non-empty
   assign i_b_reg_   = addr_full_;		// - input bp if full
   assign o_d = srlo;				// - output data from queue
   assign o_v = o_v_reg;			// - output valid if non-empty
   assign i_b = i_b_reg;			// - input bp if full
   assign maxcount = maxcount_reg;

   assign i_r = !i_b;
   assign o_b = !o_r;

   assign count = (state==state_more ? addr+2 : (state==state_one ? 1 : 0));

   // - ''always'' block with both FFs and SRL16 does not work,
   //      since FFs need reset but SRL16 does not

   always @(posedge clock) begin	// - seq always: FFs
      if (reset) begin
	 state     <= state_empty;
	 addr      <= 0;
         addr_full <= 0;
	 o_v_reg   <= 0;

	 i_b_reg   <= 0;
	 maxcount_reg <= 0;

      end
      else begin
	 state     <= state_;
	 addr      <= addr_;
         addr_full <= addr_full_;
	 o_v_reg   <= o_v_reg_;
	 i_b_reg   <= i_b_reg_;
	 maxcount_reg <= (count > maxcount_reg ? count : maxcount_reg);
      end
   end // always @ (posedge clock)

   always @(posedge clock) begin	// - seq always: srlo
      // - infer enabled output reg at end of shift chain
      // - input first element from i_d, all subsequent elements from SRL16
      if (reset) begin
	 srlo <= 0;
      end
      else begin
	 if (shift_en_o_) begin
	    srlo <= srlo_;
	 end
      end
   end // always @ (posedge clock)

   always @(posedge clock) begin			// - seq always: srl
      // - infer enabled SRL16E from shifting srl array
      // - no reset capability;  srl[] contents undefined on reset
      if (shift_en_) begin
	 // synthesis loop_limit 256
	 for (a_=depth-2; a_>0; a_=a_-1) begin
	    srl[a_] = srl[a_-1];
	 end
	 srl[0] <= i_d;
      end
   end // always @ (posedge clock or negedge reset)

   always @* begin					// - combi always
        srlo_       <=  'bx;
        shift_en_o_ <= 1'bx;
        shift_en_   <= 1'bx;
        addr_       <=  'bx;
        state_      <= 2'bx;
      case (state)

	state_empty: begin		    // - (empty, will not produce)
	      if (i_v) begin		    // - empty & i_v => consume
		 srlo_       <= i_d;
		 shift_en_o_ <= 1;
		 shift_en_   <= 1'bx;
		 addr_       <= 0;
		 state_      <= state_one;
	      end
	      else	begin		    // - empty & !i_v => idle
		 srlo_       <= 'bx;
		 shift_en_o_ <= 0;
		 shift_en_   <= 1'bx;
		 addr_       <= 0;
		 state_      <= state_empty;
	      end
	end

	state_one: begin		    // - (contains one)
	      if (i_v && o_b) begin	    // - one & i_v & o_b => consume
		 srlo_       <= 'bx;
		 shift_en_o_ <= 0;
		 shift_en_   <= 1;
		 addr_       <= 0;
		 state_      <= state_more;
	      end
	      else if (i_v && !o_b) begin   // - one & i_v & !o_b => cons+prod
		 srlo_       <= i_d;
		 shift_en_o_ <= 1;
		 shift_en_   <= 1;
		 addr_       <= 0;
		 state_      <= state_one;
	      end
	      else if (!i_v && o_b) begin   // - one & !i_v & o_b => idle
		 srlo_       <= 'bx;
		 shift_en_o_ <= 0;
		 shift_en_   <= 1'bx;
		 addr_       <= 0;
		 state_      <= state_one;
	      end
	      else if (!i_v && !o_b) begin  // - one & !i_v & !o_b => produce
		 srlo_       <= 'bx;
		 shift_en_o_ <= 0;
		 shift_en_   <= 1'bx;
		 addr_       <= 0;
		 state_      <= state_empty;
	      end
	end // case: state_one

	state_more: begin		    // - (contains more than one)
	   if (addr_full || (depth==2)) begin
					    // - (full, will not consume)
					    // - (full here if depth==2)
	      if (o_b) begin		    // - full & o_b => idle
		 srlo_       <= 'bx;
		 shift_en_o_ <= 0;
		 shift_en_   <= 0;
		 addr_       <= addr;
		 state_      <= state_more;
	      end
	      else begin		    // - full & !o_b => produce
		 srlo_       <= srl[addr];
		 shift_en_o_ <= 1;
		 shift_en_   <= 0;
//		 addr_       <= addr-1;
//		 state_      <= state_more;
		 addr_       <= addr_zero_ ? 0         : addr-1;
		 state_      <= addr_zero_ ? state_one : state_more;
	      end
	   end
	   else begin			    // - (mid: neither empty nor full)
	      if (i_v && o_b) begin	    // - mid & i_v & o_b => consume
		 srlo_       <= 'bx;
		 shift_en_o_ <= 0;
		 shift_en_   <= 1;
		 addr_       <= addr+1;
		 state_      <= state_more;
	      end
	      else if (i_v && !o_b) begin   // - mid & i_v & !o_b => cons+prod
		 srlo_       <= srl[addr];
		 shift_en_o_ <= 1;
		 shift_en_   <= 1;
		 addr_       <= addr;
		 state_      <= state_more;
	      end
	      else if (!i_v && o_b) begin   // - mid & !i_v & o_b => idle
		 srlo_       <= 'bx;
		 shift_en_o_ <= 0;
		 shift_en_   <= 0;
		 addr_       <= addr;
		 state_      <= state_more;
	      end
	      else if (!i_v && !o_b) begin  // - mid & !i_v & !o_b => produce
		 srlo_       <= srl[addr];
		 shift_en_o_ <= 1;
		 shift_en_   <= 0;
		 addr_       <= addr_zero_ ? 0         : addr-1;
		 state_      <= addr_zero_ ? state_one : state_more;
	      end
	   end // else: !if(addr_full)
	end // case: state_more

	default: begin
		 srlo_       <=  'bx;
		 shift_en_o_ <= 1'bx;
		 shift_en_   <= 1'bx;
		 addr_       <=  'bx;
		 state_      <= 2'bx;
	end // case: default

      endcase // case(state)
   end // always @ *

endmodule // Q_srl


`endif  // `ifdef  Q_srl
//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/vivado_stitch_proj_w5fn6zuu/finn_vivado_stitch_proj.gen/sources_1/bd/finn_design/ip/finn_design_StreamingFIFO_rtl_12_0/synth/finn_design_StreamingFIFO_rtl_12_0.v


// (c) Copyright 1995-2026 Xilinx, Inc. All rights reserved.
// 
// This file contains confidential and proprietary information
// of Xilinx, Inc. and is protected under U.S. and
// international copyright and other intellectual property
// laws.
// 
// DISCLAIMER
// This disclaimer is not a license and does not grant any
// rights to the materials distributed herewith. Except as
// otherwise provided in a valid license issued to you by
// Xilinx, and to the maximum extent permitted by applicable
// law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
// WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
// AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
// BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
// INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
// (2) Xilinx shall not be liable (whether in contract or tort,
// including negligence, or under any other theory of
// liability) for any loss or damage of any kind or nature
// related to, arising under or in connection with these
// materials, including for any direct, or any indirect,
// special, incidental, or consequential loss or damage
// (including loss of data, profits, goodwill, or any type of
// loss or damage suffered as a result of any action brought
// by a third party) even if such damage or loss was
// reasonably foreseeable or Xilinx had been advised of the
// possibility of the same.
// 
// CRITICAL APPLICATIONS
// Xilinx products are not designed or intended to be fail-
// safe, or for use in any application requiring fail-safe
// performance, such as life-support or safety devices or
// systems, Class III medical devices, nuclear facilities,
// applications related to the deployment of airbags, or any
// other applications that could lead to death, personal
// injury, or severe property or environmental damage
// (individually and collectively, "Critical
// Applications"). Customer assumes the sole risk and
// liability of any use of Xilinx products in Critical
// Applications, subject only to applicable laws and
// regulations governing limitations on product liability.
// 
// THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
// PART OF THIS FILE AT ALL TIMES.
// 
// DO NOT MODIFY THIS FILE.


// IP VLNV: xilinx.com:module_ref:StreamingFIFO_rtl_12:1.0
// IP Revision: 1

(* X_CORE_INFO = "StreamingFIFO_rtl_12,Vivado 2022.2" *)
(* CHECK_LICENSE_TYPE = "finn_design_StreamingFIFO_rtl_12_0,StreamingFIFO_rtl_12,{}" *)
(* CORE_GENERATION_INFO = "finn_design_StreamingFIFO_rtl_12_0,StreamingFIFO_rtl_12,{x_ipProduct=Vivado 2022.2,x_ipVendor=xilinx.com,x_ipLibrary=module_ref,x_ipName=StreamingFIFO_rtl_12,x_ipVersion=1.0,x_ipCoreRevision=1,x_ipLanguage=VERILOG,x_ipSimLanguage=MIXED}" *)
(* IP_DEFINITION_SOURCE = "module_ref" *)
(* DowngradeIPIdentifiedWarnings = "yes" *)
module finn_design_StreamingFIFO_rtl_12_0 (
  ap_clk,
  ap_rst_n,
  count,
  maxcount,
  in0_V_TREADY,
  in0_V_TVALID,
  in0_V_TDATA,
  out_V_TREADY,
  out_V_TVALID,
  out_V_TDATA
);

(* X_INTERFACE_PARAMETER = "XIL_INTERFACENAME ap_clk, ASSOCIATED_RESET ap_rst_n, ASSOCIATED_BUSIF in0_V:out_V, FREQ_HZ 100000000, FREQ_TOLERANCE_HZ 0, PHASE 0.0, CLK_DOMAIN finn_design_ap_clk_0, INSERT_VIP 0" *)
(* X_INTERFACE_INFO = "xilinx.com:signal:clock:1.0 ap_clk CLK" *)
input wire ap_clk;
(* X_INTERFACE_PARAMETER = "XIL_INTERFACENAME ap_rst_n, POLARITY ACTIVE_LOW, INSERT_VIP 0" *)
(* X_INTERFACE_INFO = "xilinx.com:signal:reset:1.0 ap_rst_n RST" *)
input wire ap_rst_n;
output wire [5 : 0] count;
output wire [5 : 0] maxcount;
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 in0_V TREADY" *)
output wire in0_V_TREADY;
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 in0_V TVALID" *)
input wire in0_V_TVALID;
(* X_INTERFACE_PARAMETER = "XIL_INTERFACENAME in0_V, TDATA_NUM_BYTES 16, TDEST_WIDTH 0, TID_WIDTH 0, TUSER_WIDTH 0, HAS_TREADY 1, HAS_TSTRB 0, HAS_TKEEP 0, HAS_TLAST 0, FREQ_HZ 100000000, PHASE 0.0, CLK_DOMAIN finn_design_ap_clk_0, LAYERED_METADATA undef, INSERT_VIP 0" *)
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 in0_V TDATA" *)
input wire [127 : 0] in0_V_TDATA;
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 out_V TREADY" *)
input wire out_V_TREADY;
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 out_V TVALID" *)
output wire out_V_TVALID;
(* X_INTERFACE_PARAMETER = "XIL_INTERFACENAME out_V, TDATA_NUM_BYTES 16, TDEST_WIDTH 0, TID_WIDTH 0, TUSER_WIDTH 0, HAS_TREADY 1, HAS_TSTRB 0, HAS_TKEEP 0, HAS_TLAST 0, FREQ_HZ 100000000, PHASE 0.0, CLK_DOMAIN finn_design_ap_clk_0, LAYERED_METADATA undef, INSERT_VIP 0" *)
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 out_V TDATA" *)
output wire [127 : 0] out_V_TDATA;

  StreamingFIFO_rtl_12 inst (
    .ap_clk(ap_clk),
    .ap_rst_n(ap_rst_n),
    .count(count),
    .maxcount(maxcount),
    .in0_V_TREADY(in0_V_TREADY),
    .in0_V_TVALID(in0_V_TVALID),
    .in0_V_TDATA(in0_V_TDATA),
    .out_V_TREADY(out_V_TREADY),
    .out_V_TVALID(out_V_TVALID),
    .out_V_TDATA(out_V_TDATA)
  );
endmodule
//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/vivado_stitch_proj_w5fn6zuu/finn_vivado_stitch_proj.gen/sources_1/bd/finn_design/ipshared/fb57/hdl/verilog/MVAU_hls_1_mux_1448_4_1_1.v


// ==============================================================
// Vitis HLS - High-Level Synthesis from C, C++ and OpenCL v2022.2 (64-bit)
// Tool Version Limit: 2019.12
// Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.
// ==============================================================

`timescale 1ns/1ps

module MVAU_hls_1_mux_1448_4_1_1 #(
parameter
    ID                = 0,
    NUM_STAGE         = 1,
    din0_WIDTH       = 32,
    din1_WIDTH       = 32,
    din2_WIDTH       = 32,
    din3_WIDTH       = 32,
    din4_WIDTH       = 32,
    din5_WIDTH       = 32,
    din6_WIDTH       = 32,
    din7_WIDTH       = 32,
    din8_WIDTH       = 32,
    din9_WIDTH       = 32,
    din10_WIDTH       = 32,
    din11_WIDTH       = 32,
    din12_WIDTH       = 32,
    din13_WIDTH       = 32,
    din14_WIDTH       = 32,
    din15_WIDTH       = 32,
    din16_WIDTH       = 32,
    din17_WIDTH       = 32,
    din18_WIDTH       = 32,
    din19_WIDTH       = 32,
    din20_WIDTH       = 32,
    din21_WIDTH       = 32,
    din22_WIDTH       = 32,
    din23_WIDTH       = 32,
    din24_WIDTH       = 32,
    din25_WIDTH       = 32,
    din26_WIDTH       = 32,
    din27_WIDTH       = 32,
    din28_WIDTH       = 32,
    din29_WIDTH       = 32,
    din30_WIDTH       = 32,
    din31_WIDTH       = 32,
    din32_WIDTH       = 32,
    din33_WIDTH       = 32,
    din34_WIDTH       = 32,
    din35_WIDTH       = 32,
    din36_WIDTH       = 32,
    din37_WIDTH       = 32,
    din38_WIDTH       = 32,
    din39_WIDTH       = 32,
    din40_WIDTH       = 32,
    din41_WIDTH       = 32,
    din42_WIDTH       = 32,
    din43_WIDTH       = 32,
    din44_WIDTH       = 32,
    din45_WIDTH       = 32,
    din46_WIDTH       = 32,
    din47_WIDTH       = 32,
    din48_WIDTH       = 32,
    din49_WIDTH       = 32,
    din50_WIDTH       = 32,
    din51_WIDTH       = 32,
    din52_WIDTH       = 32,
    din53_WIDTH       = 32,
    din54_WIDTH       = 32,
    din55_WIDTH       = 32,
    din56_WIDTH       = 32,
    din57_WIDTH       = 32,
    din58_WIDTH       = 32,
    din59_WIDTH       = 32,
    din60_WIDTH       = 32,
    din61_WIDTH       = 32,
    din62_WIDTH       = 32,
    din63_WIDTH       = 32,
    din64_WIDTH       = 32,
    din65_WIDTH       = 32,
    din66_WIDTH       = 32,
    din67_WIDTH       = 32,
    din68_WIDTH       = 32,
    din69_WIDTH       = 32,
    din70_WIDTH       = 32,
    din71_WIDTH       = 32,
    din72_WIDTH       = 32,
    din73_WIDTH       = 32,
    din74_WIDTH       = 32,
    din75_WIDTH       = 32,
    din76_WIDTH       = 32,
    din77_WIDTH       = 32,
    din78_WIDTH       = 32,
    din79_WIDTH       = 32,
    din80_WIDTH       = 32,
    din81_WIDTH       = 32,
    din82_WIDTH       = 32,
    din83_WIDTH       = 32,
    din84_WIDTH       = 32,
    din85_WIDTH       = 32,
    din86_WIDTH       = 32,
    din87_WIDTH       = 32,
    din88_WIDTH       = 32,
    din89_WIDTH       = 32,
    din90_WIDTH       = 32,
    din91_WIDTH       = 32,
    din92_WIDTH       = 32,
    din93_WIDTH       = 32,
    din94_WIDTH       = 32,
    din95_WIDTH       = 32,
    din96_WIDTH       = 32,
    din97_WIDTH       = 32,
    din98_WIDTH       = 32,
    din99_WIDTH       = 32,
    din100_WIDTH       = 32,
    din101_WIDTH       = 32,
    din102_WIDTH       = 32,
    din103_WIDTH       = 32,
    din104_WIDTH       = 32,
    din105_WIDTH       = 32,
    din106_WIDTH       = 32,
    din107_WIDTH       = 32,
    din108_WIDTH       = 32,
    din109_WIDTH       = 32,
    din110_WIDTH       = 32,
    din111_WIDTH       = 32,
    din112_WIDTH       = 32,
    din113_WIDTH       = 32,
    din114_WIDTH       = 32,
    din115_WIDTH       = 32,
    din116_WIDTH       = 32,
    din117_WIDTH       = 32,
    din118_WIDTH       = 32,
    din119_WIDTH       = 32,
    din120_WIDTH       = 32,
    din121_WIDTH       = 32,
    din122_WIDTH       = 32,
    din123_WIDTH       = 32,
    din124_WIDTH       = 32,
    din125_WIDTH       = 32,
    din126_WIDTH       = 32,
    din127_WIDTH       = 32,
    din128_WIDTH       = 32,
    din129_WIDTH       = 32,
    din130_WIDTH       = 32,
    din131_WIDTH       = 32,
    din132_WIDTH       = 32,
    din133_WIDTH       = 32,
    din134_WIDTH       = 32,
    din135_WIDTH       = 32,
    din136_WIDTH       = 32,
    din137_WIDTH       = 32,
    din138_WIDTH       = 32,
    din139_WIDTH       = 32,
    din140_WIDTH       = 32,
    din141_WIDTH       = 32,
    din142_WIDTH       = 32,
    din143_WIDTH       = 32,
    din144_WIDTH         = 32,
    dout_WIDTH            = 32
)(
    input  [3 : 0]     din0,
    input  [3 : 0]     din1,
    input  [3 : 0]     din2,
    input  [3 : 0]     din3,
    input  [3 : 0]     din4,
    input  [3 : 0]     din5,
    input  [3 : 0]     din6,
    input  [3 : 0]     din7,
    input  [3 : 0]     din8,
    input  [3 : 0]     din9,
    input  [3 : 0]     din10,
    input  [3 : 0]     din11,
    input  [3 : 0]     din12,
    input  [3 : 0]     din13,
    input  [3 : 0]     din14,
    input  [3 : 0]     din15,
    input  [3 : 0]     din16,
    input  [3 : 0]     din17,
    input  [3 : 0]     din18,
    input  [3 : 0]     din19,
    input  [3 : 0]     din20,
    input  [3 : 0]     din21,
    input  [3 : 0]     din22,
    input  [3 : 0]     din23,
    input  [3 : 0]     din24,
    input  [3 : 0]     din25,
    input  [3 : 0]     din26,
    input  [3 : 0]     din27,
    input  [3 : 0]     din28,
    input  [3 : 0]     din29,
    input  [3 : 0]     din30,
    input  [3 : 0]     din31,
    input  [3 : 0]     din32,
    input  [3 : 0]     din33,
    input  [3 : 0]     din34,
    input  [3 : 0]     din35,
    input  [3 : 0]     din36,
    input  [3 : 0]     din37,
    input  [3 : 0]     din38,
    input  [3 : 0]     din39,
    input  [3 : 0]     din40,
    input  [3 : 0]     din41,
    input  [3 : 0]     din42,
    input  [3 : 0]     din43,
    input  [3 : 0]     din44,
    input  [3 : 0]     din45,
    input  [3 : 0]     din46,
    input  [3 : 0]     din47,
    input  [3 : 0]     din48,
    input  [3 : 0]     din49,
    input  [3 : 0]     din50,
    input  [3 : 0]     din51,
    input  [3 : 0]     din52,
    input  [3 : 0]     din53,
    input  [3 : 0]     din54,
    input  [3 : 0]     din55,
    input  [3 : 0]     din56,
    input  [3 : 0]     din57,
    input  [3 : 0]     din58,
    input  [3 : 0]     din59,
    input  [3 : 0]     din60,
    input  [3 : 0]     din61,
    input  [3 : 0]     din62,
    input  [3 : 0]     din63,
    input  [3 : 0]     din64,
    input  [3 : 0]     din65,
    input  [3 : 0]     din66,
    input  [3 : 0]     din67,
    input  [3 : 0]     din68,
    input  [3 : 0]     din69,
    input  [3 : 0]     din70,
    input  [3 : 0]     din71,
    input  [3 : 0]     din72,
    input  [3 : 0]     din73,
    input  [3 : 0]     din74,
    input  [3 : 0]     din75,
    input  [3 : 0]     din76,
    input  [3 : 0]     din77,
    input  [3 : 0]     din78,
    input  [3 : 0]     din79,
    input  [3 : 0]     din80,
    input  [3 : 0]     din81,
    input  [3 : 0]     din82,
    input  [3 : 0]     din83,
    input  [3 : 0]     din84,
    input  [3 : 0]     din85,
    input  [3 : 0]     din86,
    input  [3 : 0]     din87,
    input  [3 : 0]     din88,
    input  [3 : 0]     din89,
    input  [3 : 0]     din90,
    input  [3 : 0]     din91,
    input  [3 : 0]     din92,
    input  [3 : 0]     din93,
    input  [3 : 0]     din94,
    input  [3 : 0]     din95,
    input  [3 : 0]     din96,
    input  [3 : 0]     din97,
    input  [3 : 0]     din98,
    input  [3 : 0]     din99,
    input  [3 : 0]     din100,
    input  [3 : 0]     din101,
    input  [3 : 0]     din102,
    input  [3 : 0]     din103,
    input  [3 : 0]     din104,
    input  [3 : 0]     din105,
    input  [3 : 0]     din106,
    input  [3 : 0]     din107,
    input  [3 : 0]     din108,
    input  [3 : 0]     din109,
    input  [3 : 0]     din110,
    input  [3 : 0]     din111,
    input  [3 : 0]     din112,
    input  [3 : 0]     din113,
    input  [3 : 0]     din114,
    input  [3 : 0]     din115,
    input  [3 : 0]     din116,
    input  [3 : 0]     din117,
    input  [3 : 0]     din118,
    input  [3 : 0]     din119,
    input  [3 : 0]     din120,
    input  [3 : 0]     din121,
    input  [3 : 0]     din122,
    input  [3 : 0]     din123,
    input  [3 : 0]     din124,
    input  [3 : 0]     din125,
    input  [3 : 0]     din126,
    input  [3 : 0]     din127,
    input  [3 : 0]     din128,
    input  [3 : 0]     din129,
    input  [3 : 0]     din130,
    input  [3 : 0]     din131,
    input  [3 : 0]     din132,
    input  [3 : 0]     din133,
    input  [3 : 0]     din134,
    input  [3 : 0]     din135,
    input  [3 : 0]     din136,
    input  [3 : 0]     din137,
    input  [3 : 0]     din138,
    input  [3 : 0]     din139,
    input  [3 : 0]     din140,
    input  [3 : 0]     din141,
    input  [3 : 0]     din142,
    input  [3 : 0]     din143,
    input  [7 : 0]    din144,
    output [3 : 0]   dout);

// puts internal signals
wire [7 : 0]     sel;
// level 1 signals
wire [3 : 0]         mux_1_0;
wire [3 : 0]         mux_1_1;
wire [3 : 0]         mux_1_2;
wire [3 : 0]         mux_1_3;
wire [3 : 0]         mux_1_4;
wire [3 : 0]         mux_1_5;
wire [3 : 0]         mux_1_6;
wire [3 : 0]         mux_1_7;
wire [3 : 0]         mux_1_8;
wire [3 : 0]         mux_1_9;
wire [3 : 0]         mux_1_10;
wire [3 : 0]         mux_1_11;
wire [3 : 0]         mux_1_12;
wire [3 : 0]         mux_1_13;
wire [3 : 0]         mux_1_14;
wire [3 : 0]         mux_1_15;
wire [3 : 0]         mux_1_16;
wire [3 : 0]         mux_1_17;
wire [3 : 0]         mux_1_18;
wire [3 : 0]         mux_1_19;
wire [3 : 0]         mux_1_20;
wire [3 : 0]         mux_1_21;
wire [3 : 0]         mux_1_22;
wire [3 : 0]         mux_1_23;
wire [3 : 0]         mux_1_24;
wire [3 : 0]         mux_1_25;
wire [3 : 0]         mux_1_26;
wire [3 : 0]         mux_1_27;
wire [3 : 0]         mux_1_28;
wire [3 : 0]         mux_1_29;
wire [3 : 0]         mux_1_30;
wire [3 : 0]         mux_1_31;
wire [3 : 0]         mux_1_32;
wire [3 : 0]         mux_1_33;
wire [3 : 0]         mux_1_34;
wire [3 : 0]         mux_1_35;
wire [3 : 0]         mux_1_36;
wire [3 : 0]         mux_1_37;
wire [3 : 0]         mux_1_38;
wire [3 : 0]         mux_1_39;
wire [3 : 0]         mux_1_40;
wire [3 : 0]         mux_1_41;
wire [3 : 0]         mux_1_42;
wire [3 : 0]         mux_1_43;
wire [3 : 0]         mux_1_44;
wire [3 : 0]         mux_1_45;
wire [3 : 0]         mux_1_46;
wire [3 : 0]         mux_1_47;
wire [3 : 0]         mux_1_48;
wire [3 : 0]         mux_1_49;
wire [3 : 0]         mux_1_50;
wire [3 : 0]         mux_1_51;
wire [3 : 0]         mux_1_52;
wire [3 : 0]         mux_1_53;
wire [3 : 0]         mux_1_54;
wire [3 : 0]         mux_1_55;
wire [3 : 0]         mux_1_56;
wire [3 : 0]         mux_1_57;
wire [3 : 0]         mux_1_58;
wire [3 : 0]         mux_1_59;
wire [3 : 0]         mux_1_60;
wire [3 : 0]         mux_1_61;
wire [3 : 0]         mux_1_62;
wire [3 : 0]         mux_1_63;
wire [3 : 0]         mux_1_64;
wire [3 : 0]         mux_1_65;
wire [3 : 0]         mux_1_66;
wire [3 : 0]         mux_1_67;
wire [3 : 0]         mux_1_68;
wire [3 : 0]         mux_1_69;
wire [3 : 0]         mux_1_70;
wire [3 : 0]         mux_1_71;
// level 2 signals
wire [3 : 0]         mux_2_0;
wire [3 : 0]         mux_2_1;
wire [3 : 0]         mux_2_2;
wire [3 : 0]         mux_2_3;
wire [3 : 0]         mux_2_4;
wire [3 : 0]         mux_2_5;
wire [3 : 0]         mux_2_6;
wire [3 : 0]         mux_2_7;
wire [3 : 0]         mux_2_8;
wire [3 : 0]         mux_2_9;
wire [3 : 0]         mux_2_10;
wire [3 : 0]         mux_2_11;
wire [3 : 0]         mux_2_12;
wire [3 : 0]         mux_2_13;
wire [3 : 0]         mux_2_14;
wire [3 : 0]         mux_2_15;
wire [3 : 0]         mux_2_16;
wire [3 : 0]         mux_2_17;
wire [3 : 0]         mux_2_18;
wire [3 : 0]         mux_2_19;
wire [3 : 0]         mux_2_20;
wire [3 : 0]         mux_2_21;
wire [3 : 0]         mux_2_22;
wire [3 : 0]         mux_2_23;
wire [3 : 0]         mux_2_24;
wire [3 : 0]         mux_2_25;
wire [3 : 0]         mux_2_26;
wire [3 : 0]         mux_2_27;
wire [3 : 0]         mux_2_28;
wire [3 : 0]         mux_2_29;
wire [3 : 0]         mux_2_30;
wire [3 : 0]         mux_2_31;
wire [3 : 0]         mux_2_32;
wire [3 : 0]         mux_2_33;
wire [3 : 0]         mux_2_34;
wire [3 : 0]         mux_2_35;
// level 3 signals
wire [3 : 0]         mux_3_0;
wire [3 : 0]         mux_3_1;
wire [3 : 0]         mux_3_2;
wire [3 : 0]         mux_3_3;
wire [3 : 0]         mux_3_4;
wire [3 : 0]         mux_3_5;
wire [3 : 0]         mux_3_6;
wire [3 : 0]         mux_3_7;
wire [3 : 0]         mux_3_8;
wire [3 : 0]         mux_3_9;
wire [3 : 0]         mux_3_10;
wire [3 : 0]         mux_3_11;
wire [3 : 0]         mux_3_12;
wire [3 : 0]         mux_3_13;
wire [3 : 0]         mux_3_14;
wire [3 : 0]         mux_3_15;
wire [3 : 0]         mux_3_16;
wire [3 : 0]         mux_3_17;
// level 4 signals
wire [3 : 0]         mux_4_0;
wire [3 : 0]         mux_4_1;
wire [3 : 0]         mux_4_2;
wire [3 : 0]         mux_4_3;
wire [3 : 0]         mux_4_4;
wire [3 : 0]         mux_4_5;
wire [3 : 0]         mux_4_6;
wire [3 : 0]         mux_4_7;
wire [3 : 0]         mux_4_8;
// level 5 signals
wire [3 : 0]         mux_5_0;
wire [3 : 0]         mux_5_1;
wire [3 : 0]         mux_5_2;
wire [3 : 0]         mux_5_3;
wire [3 : 0]         mux_5_4;
// level 6 signals
wire [3 : 0]         mux_6_0;
wire [3 : 0]         mux_6_1;
wire [3 : 0]         mux_6_2;
// level 7 signals
wire [3 : 0]         mux_7_0;
wire [3 : 0]         mux_7_1;
// level 8 signals
wire [3 : 0]         mux_8_0;

assign sel = din144;

// Generate level 1 logic
assign mux_1_0 = (sel[0] == 0)? din0 : din1;
assign mux_1_1 = (sel[0] == 0)? din2 : din3;
assign mux_1_2 = (sel[0] == 0)? din4 : din5;
assign mux_1_3 = (sel[0] == 0)? din6 : din7;
assign mux_1_4 = (sel[0] == 0)? din8 : din9;
assign mux_1_5 = (sel[0] == 0)? din10 : din11;
assign mux_1_6 = (sel[0] == 0)? din12 : din13;
assign mux_1_7 = (sel[0] == 0)? din14 : din15;
assign mux_1_8 = (sel[0] == 0)? din16 : din17;
assign mux_1_9 = (sel[0] == 0)? din18 : din19;
assign mux_1_10 = (sel[0] == 0)? din20 : din21;
assign mux_1_11 = (sel[0] == 0)? din22 : din23;
assign mux_1_12 = (sel[0] == 0)? din24 : din25;
assign mux_1_13 = (sel[0] == 0)? din26 : din27;
assign mux_1_14 = (sel[0] == 0)? din28 : din29;
assign mux_1_15 = (sel[0] == 0)? din30 : din31;
assign mux_1_16 = (sel[0] == 0)? din32 : din33;
assign mux_1_17 = (sel[0] == 0)? din34 : din35;
assign mux_1_18 = (sel[0] == 0)? din36 : din37;
assign mux_1_19 = (sel[0] == 0)? din38 : din39;
assign mux_1_20 = (sel[0] == 0)? din40 : din41;
assign mux_1_21 = (sel[0] == 0)? din42 : din43;
assign mux_1_22 = (sel[0] == 0)? din44 : din45;
assign mux_1_23 = (sel[0] == 0)? din46 : din47;
assign mux_1_24 = (sel[0] == 0)? din48 : din49;
assign mux_1_25 = (sel[0] == 0)? din50 : din51;
assign mux_1_26 = (sel[0] == 0)? din52 : din53;
assign mux_1_27 = (sel[0] == 0)? din54 : din55;
assign mux_1_28 = (sel[0] == 0)? din56 : din57;
assign mux_1_29 = (sel[0] == 0)? din58 : din59;
assign mux_1_30 = (sel[0] == 0)? din60 : din61;
assign mux_1_31 = (sel[0] == 0)? din62 : din63;
assign mux_1_32 = (sel[0] == 0)? din64 : din65;
assign mux_1_33 = (sel[0] == 0)? din66 : din67;
assign mux_1_34 = (sel[0] == 0)? din68 : din69;
assign mux_1_35 = (sel[0] == 0)? din70 : din71;
assign mux_1_36 = (sel[0] == 0)? din72 : din73;
assign mux_1_37 = (sel[0] == 0)? din74 : din75;
assign mux_1_38 = (sel[0] == 0)? din76 : din77;
assign mux_1_39 = (sel[0] == 0)? din78 : din79;
assign mux_1_40 = (sel[0] == 0)? din80 : din81;
assign mux_1_41 = (sel[0] == 0)? din82 : din83;
assign mux_1_42 = (sel[0] == 0)? din84 : din85;
assign mux_1_43 = (sel[0] == 0)? din86 : din87;
assign mux_1_44 = (sel[0] == 0)? din88 : din89;
assign mux_1_45 = (sel[0] == 0)? din90 : din91;
assign mux_1_46 = (sel[0] == 0)? din92 : din93;
assign mux_1_47 = (sel[0] == 0)? din94 : din95;
assign mux_1_48 = (sel[0] == 0)? din96 : din97;
assign mux_1_49 = (sel[0] == 0)? din98 : din99;
assign mux_1_50 = (sel[0] == 0)? din100 : din101;
assign mux_1_51 = (sel[0] == 0)? din102 : din103;
assign mux_1_52 = (sel[0] == 0)? din104 : din105;
assign mux_1_53 = (sel[0] == 0)? din106 : din107;
assign mux_1_54 = (sel[0] == 0)? din108 : din109;
assign mux_1_55 = (sel[0] == 0)? din110 : din111;
assign mux_1_56 = (sel[0] == 0)? din112 : din113;
assign mux_1_57 = (sel[0] == 0)? din114 : din115;
assign mux_1_58 = (sel[0] == 0)? din116 : din117;
assign mux_1_59 = (sel[0] == 0)? din118 : din119;
assign mux_1_60 = (sel[0] == 0)? din120 : din121;
assign mux_1_61 = (sel[0] == 0)? din122 : din123;
assign mux_1_62 = (sel[0] == 0)? din124 : din125;
assign mux_1_63 = (sel[0] == 0)? din126 : din127;
assign mux_1_64 = (sel[0] == 0)? din128 : din129;
assign mux_1_65 = (sel[0] == 0)? din130 : din131;
assign mux_1_66 = (sel[0] == 0)? din132 : din133;
assign mux_1_67 = (sel[0] == 0)? din134 : din135;
assign mux_1_68 = (sel[0] == 0)? din136 : din137;
assign mux_1_69 = (sel[0] == 0)? din138 : din139;
assign mux_1_70 = (sel[0] == 0)? din140 : din141;
assign mux_1_71 = (sel[0] == 0)? din142 : din143;

// Generate level 2 logic
assign mux_2_0 = (sel[1] == 0)? mux_1_0 : mux_1_1;
assign mux_2_1 = (sel[1] == 0)? mux_1_2 : mux_1_3;
assign mux_2_2 = (sel[1] == 0)? mux_1_4 : mux_1_5;
assign mux_2_3 = (sel[1] == 0)? mux_1_6 : mux_1_7;
assign mux_2_4 = (sel[1] == 0)? mux_1_8 : mux_1_9;
assign mux_2_5 = (sel[1] == 0)? mux_1_10 : mux_1_11;
assign mux_2_6 = (sel[1] == 0)? mux_1_12 : mux_1_13;
assign mux_2_7 = (sel[1] == 0)? mux_1_14 : mux_1_15;
assign mux_2_8 = (sel[1] == 0)? mux_1_16 : mux_1_17;
assign mux_2_9 = (sel[1] == 0)? mux_1_18 : mux_1_19;
assign mux_2_10 = (sel[1] == 0)? mux_1_20 : mux_1_21;
assign mux_2_11 = (sel[1] == 0)? mux_1_22 : mux_1_23;
assign mux_2_12 = (sel[1] == 0)? mux_1_24 : mux_1_25;
assign mux_2_13 = (sel[1] == 0)? mux_1_26 : mux_1_27;
assign mux_2_14 = (sel[1] == 0)? mux_1_28 : mux_1_29;
assign mux_2_15 = (sel[1] == 0)? mux_1_30 : mux_1_31;
assign mux_2_16 = (sel[1] == 0)? mux_1_32 : mux_1_33;
assign mux_2_17 = (sel[1] == 0)? mux_1_34 : mux_1_35;
assign mux_2_18 = (sel[1] == 0)? mux_1_36 : mux_1_37;
assign mux_2_19 = (sel[1] == 0)? mux_1_38 : mux_1_39;
assign mux_2_20 = (sel[1] == 0)? mux_1_40 : mux_1_41;
assign mux_2_21 = (sel[1] == 0)? mux_1_42 : mux_1_43;
assign mux_2_22 = (sel[1] == 0)? mux_1_44 : mux_1_45;
assign mux_2_23 = (sel[1] == 0)? mux_1_46 : mux_1_47;
assign mux_2_24 = (sel[1] == 0)? mux_1_48 : mux_1_49;
assign mux_2_25 = (sel[1] == 0)? mux_1_50 : mux_1_51;
assign mux_2_26 = (sel[1] == 0)? mux_1_52 : mux_1_53;
assign mux_2_27 = (sel[1] == 0)? mux_1_54 : mux_1_55;
assign mux_2_28 = (sel[1] == 0)? mux_1_56 : mux_1_57;
assign mux_2_29 = (sel[1] == 0)? mux_1_58 : mux_1_59;
assign mux_2_30 = (sel[1] == 0)? mux_1_60 : mux_1_61;
assign mux_2_31 = (sel[1] == 0)? mux_1_62 : mux_1_63;
assign mux_2_32 = (sel[1] == 0)? mux_1_64 : mux_1_65;
assign mux_2_33 = (sel[1] == 0)? mux_1_66 : mux_1_67;
assign mux_2_34 = (sel[1] == 0)? mux_1_68 : mux_1_69;
assign mux_2_35 = (sel[1] == 0)? mux_1_70 : mux_1_71;

// Generate level 3 logic
assign mux_3_0 = (sel[2] == 0)? mux_2_0 : mux_2_1;
assign mux_3_1 = (sel[2] == 0)? mux_2_2 : mux_2_3;
assign mux_3_2 = (sel[2] == 0)? mux_2_4 : mux_2_5;
assign mux_3_3 = (sel[2] == 0)? mux_2_6 : mux_2_7;
assign mux_3_4 = (sel[2] == 0)? mux_2_8 : mux_2_9;
assign mux_3_5 = (sel[2] == 0)? mux_2_10 : mux_2_11;
assign mux_3_6 = (sel[2] == 0)? mux_2_12 : mux_2_13;
assign mux_3_7 = (sel[2] == 0)? mux_2_14 : mux_2_15;
assign mux_3_8 = (sel[2] == 0)? mux_2_16 : mux_2_17;
assign mux_3_9 = (sel[2] == 0)? mux_2_18 : mux_2_19;
assign mux_3_10 = (sel[2] == 0)? mux_2_20 : mux_2_21;
assign mux_3_11 = (sel[2] == 0)? mux_2_22 : mux_2_23;
assign mux_3_12 = (sel[2] == 0)? mux_2_24 : mux_2_25;
assign mux_3_13 = (sel[2] == 0)? mux_2_26 : mux_2_27;
assign mux_3_14 = (sel[2] == 0)? mux_2_28 : mux_2_29;
assign mux_3_15 = (sel[2] == 0)? mux_2_30 : mux_2_31;
assign mux_3_16 = (sel[2] == 0)? mux_2_32 : mux_2_33;
assign mux_3_17 = (sel[2] == 0)? mux_2_34 : mux_2_35;

// Generate level 4 logic
assign mux_4_0 = (sel[3] == 0)? mux_3_0 : mux_3_1;
assign mux_4_1 = (sel[3] == 0)? mux_3_2 : mux_3_3;
assign mux_4_2 = (sel[3] == 0)? mux_3_4 : mux_3_5;
assign mux_4_3 = (sel[3] == 0)? mux_3_6 : mux_3_7;
assign mux_4_4 = (sel[3] == 0)? mux_3_8 : mux_3_9;
assign mux_4_5 = (sel[3] == 0)? mux_3_10 : mux_3_11;
assign mux_4_6 = (sel[3] == 0)? mux_3_12 : mux_3_13;
assign mux_4_7 = (sel[3] == 0)? mux_3_14 : mux_3_15;
assign mux_4_8 = (sel[3] == 0)? mux_3_16 : mux_3_17;

// Generate level 5 logic
assign mux_5_0 = (sel[4] == 0)? mux_4_0 : mux_4_1;
assign mux_5_1 = (sel[4] == 0)? mux_4_2 : mux_4_3;
assign mux_5_2 = (sel[4] == 0)? mux_4_4 : mux_4_5;
assign mux_5_3 = (sel[4] == 0)? mux_4_6 : mux_4_7;
assign mux_5_4 = mux_4_8;

// Generate level 6 logic
assign mux_6_0 = (sel[5] == 0)? mux_5_0 : mux_5_1;
assign mux_6_1 = (sel[5] == 0)? mux_5_2 : mux_5_3;
assign mux_6_2 = mux_5_4;

// Generate level 7 logic
assign mux_7_0 = (sel[6] == 0)? mux_6_0 : mux_6_1;
assign mux_7_1 = mux_6_2;

// Generate level 8 logic
assign mux_8_0 = (sel[7] == 0)? mux_7_0 : mux_7_1;

// output logic
assign dout = mux_8_0;

endmodule
//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/vivado_stitch_proj_w5fn6zuu/finn_vivado_stitch_proj.gen/sources_1/bd/finn_design/ipshared/18e4/hdl/verilog/MVAU_hls_0.v


// ==============================================================
// RTL generated by Vitis HLS - High-Level Synthesis from C, C++ and OpenCL v2022.2 (64-bit)
// Version: 2022.2
// Copyright (C) Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.
// 
// ===========================================================

`timescale 1 ns / 1 ps 

(* CORE_GENERATION_INFO="MVAU_hls_0_MVAU_hls_0,hls_ip_2022_2,{HLS_INPUT_TYPE=cxx,HLS_INPUT_FLOAT=0,HLS_INPUT_FIXED=0,HLS_INPUT_PART=xc7z010-clg400-1,HLS_INPUT_CLOCK=10.000000,HLS_INPUT_ARCH=others,HLS_SYN_CLOCK=7.591000,HLS_SYN_LAT=338698,HLS_SYN_TPT=none,HLS_SYN_MEM=0,HLS_SYN_DSP=0,HLS_SYN_FF=673,HLS_SYN_LUT=993,HLS_VERSION=2022_2}" *)

module MVAU_hls_0 (
        ap_clk,
        ap_rst_n,
        in0_V_TDATA,
        in0_V_TVALID,
        in0_V_TREADY,
        weights_V_TDATA,
        weights_V_TVALID,
        weights_V_TREADY,
        out_V_TDATA,
        out_V_TVALID,
        out_V_TREADY
);

parameter    ap_ST_fsm_state1 = 4'd1;
parameter    ap_ST_fsm_state2 = 4'd2;
parameter    ap_ST_fsm_state3 = 4'd4;
parameter    ap_ST_fsm_state4 = 4'd8;

input   ap_clk;
input   ap_rst_n;
input  [7:0] in0_V_TDATA;
input   in0_V_TVALID;
output   in0_V_TREADY;
input  [7:0] weights_V_TDATA;
input   weights_V_TVALID;
output   weights_V_TREADY;
output  [7:0] out_V_TDATA;
output   out_V_TVALID;
input   out_V_TREADY;

 reg    ap_rst_n_inv;
wire    grp_Matrix_Vector_Activate_Stream_Batch_fu_60_ap_start;
wire    grp_Matrix_Vector_Activate_Stream_Batch_fu_60_ap_done;
wire    grp_Matrix_Vector_Activate_Stream_Batch_fu_60_ap_idle;
wire    grp_Matrix_Vector_Activate_Stream_Batch_fu_60_ap_ready;
wire    grp_Matrix_Vector_Activate_Stream_Batch_fu_60_out_V_TREADY;
wire    grp_Matrix_Vector_Activate_Stream_Batch_fu_60_in0_V_TREADY;
wire   [7:0] grp_Matrix_Vector_Activate_Stream_Batch_fu_60_out_V_TDATA;
wire    grp_Matrix_Vector_Activate_Stream_Batch_fu_60_out_V_TVALID;
wire    grp_Matrix_Vector_Activate_Stream_Batch_fu_60_weights_V_TREADY;
reg    grp_Matrix_Vector_Activate_Stream_Batch_fu_60_ap_start_reg;
(* fsm_encoding = "none" *) reg   [3:0] ap_CS_fsm;
wire    ap_CS_fsm_state2;
wire    ap_CS_fsm_state3;
reg   [3:0] ap_NS_fsm;
wire    ap_ST_fsm_state1_blk;
wire    ap_ST_fsm_state2_blk;
reg    ap_ST_fsm_state3_blk;
reg    ap_ST_fsm_state4_blk;
wire    regslice_both_out_V_U_apdone_blk;
wire    ap_CS_fsm_state4;
wire    regslice_both_in0_V_U_apdone_blk;
wire   [7:0] in0_V_TDATA_int_regslice;
wire    in0_V_TVALID_int_regslice;
reg    in0_V_TREADY_int_regslice;
wire    regslice_both_in0_V_U_ack_in;
wire    regslice_both_weights_V_U_apdone_blk;
wire   [7:0] weights_V_TDATA_int_regslice;
wire    weights_V_TVALID_int_regslice;
reg    weights_V_TREADY_int_regslice;
wire    regslice_both_weights_V_U_ack_in;
wire    out_V_TREADY_int_regslice;
wire    regslice_both_out_V_U_vld_out;
wire    ap_ce_reg;

// power-on initialization
initial begin
#0 grp_Matrix_Vector_Activate_Stream_Batch_fu_60_ap_start_reg = 1'b0;
#0 ap_CS_fsm = 4'd1;
end

MVAU_hls_0_Matrix_Vector_Activate_Stream_Batch grp_Matrix_Vector_Activate_Stream_Batch_fu_60(
    .ap_clk(ap_clk),
    .ap_rst(ap_rst_n_inv),
    .ap_start(grp_Matrix_Vector_Activate_Stream_Batch_fu_60_ap_start),
    .ap_done(grp_Matrix_Vector_Activate_Stream_Batch_fu_60_ap_done),
    .ap_idle(grp_Matrix_Vector_Activate_Stream_Batch_fu_60_ap_idle),
    .ap_ready(grp_Matrix_Vector_Activate_Stream_Batch_fu_60_ap_ready),
    .in0_V_TVALID(in0_V_TVALID_int_regslice),
    .weights_V_TVALID(weights_V_TVALID_int_regslice),
    .out_V_TREADY(grp_Matrix_Vector_Activate_Stream_Batch_fu_60_out_V_TREADY),
    .in0_V_TDATA(in0_V_TDATA_int_regslice),
    .in0_V_TREADY(grp_Matrix_Vector_Activate_Stream_Batch_fu_60_in0_V_TREADY),
    .out_V_TDATA(grp_Matrix_Vector_Activate_Stream_Batch_fu_60_out_V_TDATA),
    .out_V_TVALID(grp_Matrix_Vector_Activate_Stream_Batch_fu_60_out_V_TVALID),
    .weights_V_TDATA(weights_V_TDATA_int_regslice),
    .weights_V_TREADY(grp_Matrix_Vector_Activate_Stream_Batch_fu_60_weights_V_TREADY)
);

MVAU_hls_0_regslice_both #(
    .DataWidth( 8 ))
regslice_both_in0_V_U(
    .ap_clk(ap_clk),
    .ap_rst(ap_rst_n_inv),
    .data_in(in0_V_TDATA),
    .vld_in(in0_V_TVALID),
    .ack_in(regslice_both_in0_V_U_ack_in),
    .data_out(in0_V_TDATA_int_regslice),
    .vld_out(in0_V_TVALID_int_regslice),
    .ack_out(in0_V_TREADY_int_regslice),
    .apdone_blk(regslice_both_in0_V_U_apdone_blk)
);

MVAU_hls_0_regslice_both #(
    .DataWidth( 8 ))
regslice_both_weights_V_U(
    .ap_clk(ap_clk),
    .ap_rst(ap_rst_n_inv),
    .data_in(weights_V_TDATA),
    .vld_in(weights_V_TVALID),
    .ack_in(regslice_both_weights_V_U_ack_in),
    .data_out(weights_V_TDATA_int_regslice),
    .vld_out(weights_V_TVALID_int_regslice),
    .ack_out(weights_V_TREADY_int_regslice),
    .apdone_blk(regslice_both_weights_V_U_apdone_blk)
);

MVAU_hls_0_regslice_both #(
    .DataWidth( 8 ))
regslice_both_out_V_U(
    .ap_clk(ap_clk),
    .ap_rst(ap_rst_n_inv),
    .data_in(grp_Matrix_Vector_Activate_Stream_Batch_fu_60_out_V_TDATA),
    .vld_in(grp_Matrix_Vector_Activate_Stream_Batch_fu_60_out_V_TVALID),
    .ack_in(out_V_TREADY_int_regslice),
    .data_out(out_V_TDATA),
    .vld_out(regslice_both_out_V_U_vld_out),
    .ack_out(out_V_TREADY),
    .apdone_blk(regslice_both_out_V_U_apdone_blk)
);

always @ (posedge ap_clk) begin
    if (ap_rst_n_inv == 1'b1) begin
        ap_CS_fsm <= ap_ST_fsm_state1;
    end else begin
        ap_CS_fsm <= ap_NS_fsm;
    end
end

always @ (posedge ap_clk) begin
    if (ap_rst_n_inv == 1'b1) begin
        grp_Matrix_Vector_Activate_Stream_Batch_fu_60_ap_start_reg <= 1'b0;
    end else begin
        if ((1'b1 == ap_CS_fsm_state2)) begin
            grp_Matrix_Vector_Activate_Stream_Batch_fu_60_ap_start_reg <= 1'b1;
        end else if ((grp_Matrix_Vector_Activate_Stream_Batch_fu_60_ap_ready == 1'b1)) begin
            grp_Matrix_Vector_Activate_Stream_Batch_fu_60_ap_start_reg <= 1'b0;
        end
    end
end

assign ap_ST_fsm_state1_blk = 1'b0;

assign ap_ST_fsm_state2_blk = 1'b0;

always @ (*) begin
    if ((grp_Matrix_Vector_Activate_Stream_Batch_fu_60_ap_done == 1'b0)) begin
        ap_ST_fsm_state3_blk = 1'b1;
    end else begin
        ap_ST_fsm_state3_blk = 1'b0;
    end
end

always @ (*) begin
    if ((regslice_both_out_V_U_apdone_blk == 1'b1)) begin
        ap_ST_fsm_state4_blk = 1'b1;
    end else begin
        ap_ST_fsm_state4_blk = 1'b0;
    end
end

always @ (*) begin
    if ((1'b1 == ap_CS_fsm_state3)) begin
        in0_V_TREADY_int_regslice = grp_Matrix_Vector_Activate_Stream_Batch_fu_60_in0_V_TREADY;
    end else begin
        in0_V_TREADY_int_regslice = 1'b0;
    end
end

always @ (*) begin
    if ((1'b1 == ap_CS_fsm_state3)) begin
        weights_V_TREADY_int_regslice = grp_Matrix_Vector_Activate_Stream_Batch_fu_60_weights_V_TREADY;
    end else begin
        weights_V_TREADY_int_regslice = 1'b0;
    end
end

always @ (*) begin
    case (ap_CS_fsm)
        ap_ST_fsm_state1 : begin
            ap_NS_fsm = ap_ST_fsm_state2;
        end
        ap_ST_fsm_state2 : begin
            ap_NS_fsm = ap_ST_fsm_state3;
        end
        ap_ST_fsm_state3 : begin
            if (((grp_Matrix_Vector_Activate_Stream_Batch_fu_60_ap_done == 1'b1) & (1'b1 == ap_CS_fsm_state3))) begin
                ap_NS_fsm = ap_ST_fsm_state4;
            end else begin
                ap_NS_fsm = ap_ST_fsm_state3;
            end
        end
        ap_ST_fsm_state4 : begin
            if (((1'b1 == ap_CS_fsm_state4) & (regslice_both_out_V_U_apdone_blk == 1'b0))) begin
                ap_NS_fsm = ap_ST_fsm_state1;
            end else begin
                ap_NS_fsm = ap_ST_fsm_state4;
            end
        end
        default : begin
            ap_NS_fsm = 'bx;
        end
    endcase
end

assign ap_CS_fsm_state2 = ap_CS_fsm[32'd1];

assign ap_CS_fsm_state3 = ap_CS_fsm[32'd2];

assign ap_CS_fsm_state4 = ap_CS_fsm[32'd3];

always @ (*) begin
    ap_rst_n_inv = ~ap_rst_n;
end

assign grp_Matrix_Vector_Activate_Stream_Batch_fu_60_ap_start = grp_Matrix_Vector_Activate_Stream_Batch_fu_60_ap_start_reg;

assign grp_Matrix_Vector_Activate_Stream_Batch_fu_60_out_V_TREADY = (out_V_TREADY_int_regslice & ap_CS_fsm_state3);

assign in0_V_TREADY = regslice_both_in0_V_U_ack_in;

assign out_V_TVALID = regslice_both_out_V_U_vld_out;

assign weights_V_TREADY = regslice_both_weights_V_U_ack_in;

endmodule //MVAU_hls_0
//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/vivado_stitch_proj_w5fn6zuu/finn_vivado_stitch_proj.gen/sources_1/bd/finn_design/ip/finn_design_MVAU_hls_1_0/synth/finn_design_MVAU_hls_1_0.v


// (c) Copyright 1995-2026 Xilinx, Inc. All rights reserved.
// 
// This file contains confidential and proprietary information
// of Xilinx, Inc. and is protected under U.S. and
// international copyright and other intellectual property
// laws.
// 
// DISCLAIMER
// This disclaimer is not a license and does not grant any
// rights to the materials distributed herewith. Except as
// otherwise provided in a valid license issued to you by
// Xilinx, and to the maximum extent permitted by applicable
// law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
// WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
// AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
// BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
// INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
// (2) Xilinx shall not be liable (whether in contract or tort,
// including negligence, or under any other theory of
// liability) for any loss or damage of any kind or nature
// related to, arising under or in connection with these
// materials, including for any direct, or any indirect,
// special, incidental, or consequential loss or damage
// (including loss of data, profits, goodwill, or any type of
// loss or damage suffered as a result of any action brought
// by a third party) even if such damage or loss was
// reasonably foreseeable or Xilinx had been advised of the
// possibility of the same.
// 
// CRITICAL APPLICATIONS
// Xilinx products are not designed or intended to be fail-
// safe, or for use in any application requiring fail-safe
// performance, such as life-support or safety devices or
// systems, Class III medical devices, nuclear facilities,
// applications related to the deployment of airbags, or any
// other applications that could lead to death, personal
// injury, or severe property or environmental damage
// (individually and collectively, "Critical
// Applications"). Customer assumes the sole risk and
// liability of any use of Xilinx products in Critical
// Applications, subject only to applicable laws and
// regulations governing limitations on product liability.
// 
// THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
// PART OF THIS FILE AT ALL TIMES.
// 
// DO NOT MODIFY THIS FILE.


// IP VLNV: xilinx.com:hls:MVAU_hls_1:1.0
// IP Revision: 2114489082

(* X_CORE_INFO = "MVAU_hls_1,Vivado 2022.2" *)
(* CHECK_LICENSE_TYPE = "finn_design_MVAU_hls_1_0,MVAU_hls_1,{}" *)
(* CORE_GENERATION_INFO = "finn_design_MVAU_hls_1_0,MVAU_hls_1,{x_ipProduct=Vivado 2022.2,x_ipVendor=xilinx.com,x_ipLibrary=hls,x_ipName=MVAU_hls_1,x_ipVersion=1.0,x_ipCoreRevision=2114489082,x_ipLanguage=VERILOG,x_ipSimLanguage=MIXED}" *)
(* IP_DEFINITION_SOURCE = "HLS" *)
(* DowngradeIPIdentifiedWarnings = "yes" *)
module finn_design_MVAU_hls_1_0 (
  ap_clk,
  ap_rst_n,
  in0_V_TVALID,
  in0_V_TREADY,
  in0_V_TDATA,
  weights_V_TVALID,
  weights_V_TREADY,
  weights_V_TDATA,
  out_V_TVALID,
  out_V_TREADY,
  out_V_TDATA
);

(* X_INTERFACE_PARAMETER = "XIL_INTERFACENAME ap_clk, ASSOCIATED_BUSIF in0_V:weights_V:out_V, ASSOCIATED_RESET ap_rst_n, FREQ_HZ 100000000, FREQ_TOLERANCE_HZ 0, PHASE 0.0, CLK_DOMAIN finn_design_ap_clk_0, INSERT_VIP 0" *)
(* X_INTERFACE_INFO = "xilinx.com:signal:clock:1.0 ap_clk CLK" *)
input wire ap_clk;
(* X_INTERFACE_PARAMETER = "XIL_INTERFACENAME ap_rst_n, POLARITY ACTIVE_LOW, INSERT_VIP 0" *)
(* X_INTERFACE_INFO = "xilinx.com:signal:reset:1.0 ap_rst_n RST" *)
input wire ap_rst_n;
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 in0_V TVALID" *)
input wire in0_V_TVALID;
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 in0_V TREADY" *)
output wire in0_V_TREADY;
(* X_INTERFACE_PARAMETER = "XIL_INTERFACENAME in0_V, TDATA_NUM_BYTES 1, TUSER_WIDTH 0, TDEST_WIDTH 0, TID_WIDTH 0, HAS_TREADY 1, HAS_TSTRB 0, HAS_TKEEP 0, HAS_TLAST 0, FREQ_HZ 100000000, PHASE 0.0, CLK_DOMAIN finn_design_ap_clk_0, INSERT_VIP 0" *)
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 in0_V TDATA" *)
input wire [7 : 0] in0_V_TDATA;
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 weights_V TVALID" *)
input wire weights_V_TVALID;
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 weights_V TREADY" *)
output wire weights_V_TREADY;
(* X_INTERFACE_PARAMETER = "XIL_INTERFACENAME weights_V, TDATA_NUM_BYTES 1, TUSER_WIDTH 0, TDEST_WIDTH 0, TID_WIDTH 0, HAS_TREADY 1, HAS_TSTRB 0, HAS_TKEEP 0, HAS_TLAST 0, FREQ_HZ 100000000, PHASE 0.0, CLK_DOMAIN finn_design_ap_clk_0, INSERT_VIP 0" *)
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 weights_V TDATA" *)
input wire [7 : 0] weights_V_TDATA;
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 out_V TVALID" *)
output wire out_V_TVALID;
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 out_V TREADY" *)
input wire out_V_TREADY;
(* X_INTERFACE_PARAMETER = "XIL_INTERFACENAME out_V, TDATA_NUM_BYTES 1, TUSER_WIDTH 0, TDEST_WIDTH 0, TID_WIDTH 0, HAS_TREADY 1, HAS_TSTRB 0, HAS_TKEEP 0, HAS_TLAST 0, FREQ_HZ 100000000, PHASE 0.0, CLK_DOMAIN finn_design_ap_clk_0, INSERT_VIP 0" *)
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 out_V TDATA" *)
output wire [7 : 0] out_V_TDATA;

(* SDX_KERNEL = "true" *)
(* SDX_KERNEL_TYPE = "hls" *)
(* SDX_KERNEL_SYNTH_INST = "inst" *)
  MVAU_hls_1 inst (
    .ap_clk(ap_clk),
    .ap_rst_n(ap_rst_n),
    .in0_V_TVALID(in0_V_TVALID),
    .in0_V_TREADY(in0_V_TREADY),
    .in0_V_TDATA(in0_V_TDATA),
    .weights_V_TVALID(weights_V_TVALID),
    .weights_V_TREADY(weights_V_TREADY),
    .weights_V_TDATA(weights_V_TDATA),
    .out_V_TVALID(out_V_TVALID),
    .out_V_TREADY(out_V_TREADY),
    .out_V_TDATA(out_V_TDATA)
  );
endmodule
//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/vivado_stitch_proj_w5fn6zuu/finn_vivado_stitch_proj.gen/sources_1/bd/finn_design/ip/finn_design_StreamingFIFO_rtl_4_0/synth/finn_design_StreamingFIFO_rtl_4_0.v


// (c) Copyright 1995-2026 Xilinx, Inc. All rights reserved.
// 
// This file contains confidential and proprietary information
// of Xilinx, Inc. and is protected under U.S. and
// international copyright and other intellectual property
// laws.
// 
// DISCLAIMER
// This disclaimer is not a license and does not grant any
// rights to the materials distributed herewith. Except as
// otherwise provided in a valid license issued to you by
// Xilinx, and to the maximum extent permitted by applicable
// law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
// WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
// AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
// BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
// INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
// (2) Xilinx shall not be liable (whether in contract or tort,
// including negligence, or under any other theory of
// liability) for any loss or damage of any kind or nature
// related to, arising under or in connection with these
// materials, including for any direct, or any indirect,
// special, incidental, or consequential loss or damage
// (including loss of data, profits, goodwill, or any type of
// loss or damage suffered as a result of any action brought
// by a third party) even if such damage or loss was
// reasonably foreseeable or Xilinx had been advised of the
// possibility of the same.
// 
// CRITICAL APPLICATIONS
// Xilinx products are not designed or intended to be fail-
// safe, or for use in any application requiring fail-safe
// performance, such as life-support or safety devices or
// systems, Class III medical devices, nuclear facilities,
// applications related to the deployment of airbags, or any
// other applications that could lead to death, personal
// injury, or severe property or environmental damage
// (individually and collectively, "Critical
// Applications"). Customer assumes the sole risk and
// liability of any use of Xilinx products in Critical
// Applications, subject only to applicable laws and
// regulations governing limitations on product liability.
// 
// THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
// PART OF THIS FILE AT ALL TIMES.
// 
// DO NOT MODIFY THIS FILE.


// IP VLNV: xilinx.com:module_ref:StreamingFIFO_rtl_4:1.0
// IP Revision: 1

(* X_CORE_INFO = "StreamingFIFO_rtl_4,Vivado 2022.2" *)
(* CHECK_LICENSE_TYPE = "finn_design_StreamingFIFO_rtl_4_0,StreamingFIFO_rtl_4,{}" *)
(* CORE_GENERATION_INFO = "finn_design_StreamingFIFO_rtl_4_0,StreamingFIFO_rtl_4,{x_ipProduct=Vivado 2022.2,x_ipVendor=xilinx.com,x_ipLibrary=module_ref,x_ipName=StreamingFIFO_rtl_4,x_ipVersion=1.0,x_ipCoreRevision=1,x_ipLanguage=VERILOG,x_ipSimLanguage=MIXED}" *)
(* IP_DEFINITION_SOURCE = "module_ref" *)
(* DowngradeIPIdentifiedWarnings = "yes" *)
module finn_design_StreamingFIFO_rtl_4_0 (
  ap_clk,
  ap_rst_n,
  count,
  maxcount,
  in0_V_TREADY,
  in0_V_TVALID,
  in0_V_TDATA,
  out_V_TREADY,
  out_V_TVALID,
  out_V_TDATA
);

(* X_INTERFACE_PARAMETER = "XIL_INTERFACENAME ap_clk, ASSOCIATED_RESET ap_rst_n, ASSOCIATED_BUSIF in0_V:out_V, FREQ_HZ 100000000, FREQ_TOLERANCE_HZ 0, PHASE 0.0, CLK_DOMAIN finn_design_ap_clk_0, INSERT_VIP 0" *)
(* X_INTERFACE_INFO = "xilinx.com:signal:clock:1.0 ap_clk CLK" *)
input wire ap_clk;
(* X_INTERFACE_PARAMETER = "XIL_INTERFACENAME ap_rst_n, POLARITY ACTIVE_LOW, INSERT_VIP 0" *)
(* X_INTERFACE_INFO = "xilinx.com:signal:reset:1.0 ap_rst_n RST" *)
input wire ap_rst_n;
output wire [13 : 0] count;
output wire [13 : 0] maxcount;
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 in0_V TREADY" *)
output wire in0_V_TREADY;
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 in0_V TVALID" *)
input wire in0_V_TVALID;
(* X_INTERFACE_PARAMETER = "XIL_INTERFACENAME in0_V, TDATA_NUM_BYTES 1, TDEST_WIDTH 0, TID_WIDTH 0, TUSER_WIDTH 0, HAS_TREADY 1, HAS_TSTRB 0, HAS_TKEEP 0, HAS_TLAST 0, FREQ_HZ 100000000, PHASE 0.0, CLK_DOMAIN finn_design_ap_clk_0, LAYERED_METADATA undef, INSERT_VIP 0" *)
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 in0_V TDATA" *)
input wire [7 : 0] in0_V_TDATA;
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 out_V TREADY" *)
input wire out_V_TREADY;
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 out_V TVALID" *)
output wire out_V_TVALID;
(* X_INTERFACE_PARAMETER = "XIL_INTERFACENAME out_V, TDATA_NUM_BYTES 1, TDEST_WIDTH 0, TID_WIDTH 0, TUSER_WIDTH 0, HAS_TREADY 1, HAS_TSTRB 0, HAS_TKEEP 0, HAS_TLAST 0, FREQ_HZ 100000000, PHASE 0.0, CLK_DOMAIN finn_design_ap_clk_0, LAYERED_METADATA undef, INSERT_VIP 0" *)
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 out_V TDATA" *)
output wire [7 : 0] out_V_TDATA;

  StreamingFIFO_rtl_4 inst (
    .ap_clk(ap_clk),
    .ap_rst_n(ap_rst_n),
    .count(count),
    .maxcount(maxcount),
    .in0_V_TREADY(in0_V_TREADY),
    .in0_V_TVALID(in0_V_TVALID),
    .in0_V_TDATA(in0_V_TDATA),
    .out_V_TREADY(out_V_TREADY),
    .out_V_TVALID(out_V_TVALID),
    .out_V_TDATA(out_V_TDATA)
  );
endmodule
//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/vivado_stitch_proj_w5fn6zuu/finn_vivado_stitch_proj.gen/sources_1/bd/finn_design/ipshared/18e4/hdl/verilog/MVAU_hls_0_Matrix_Vector_Activate_Stream_Batch_p_ZL7threshs_13_ROM_AUTO_1R.v


// ==============================================================
// Vitis HLS - High-Level Synthesis from C, C++ and OpenCL v2022.2 (64-bit)
// Version: 2022.2
// Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.
// ==============================================================
`timescale 1 ns / 1 ps
module MVAU_hls_0_Matrix_Vector_Activate_Stream_Batch_p_ZL7threshs_13_ROM_AUTO_1R (
    address0, ce0, q0, 
    reset, clk);

parameter DataWidth = 12;
parameter AddressWidth = 4;
parameter AddressRange = 16;
 
input[AddressWidth-1:0] address0;
input ce0;
output reg[DataWidth-1:0] q0;

input reset;
input clk;

 
reg [DataWidth-1:0] rom0[0:AddressRange-1];


initial begin
     
    $readmemh("/home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/code_gen_ipgen_MVAU_hls_0_z2r2fzak/project_MVAU_hls_0/sol1/impl/ip/hdl/verilog/MVAU_hls_0_Matrix_Vector_Activate_Stream_Batch_p_ZL7threshs_13_ROM_AUTO_1R.dat", rom0);
end

  
always @(posedge clk) 
begin 
    if (ce0) 
    begin
        q0 <= rom0[address0];
    end
end


endmodule

//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/code_gen_ipgen_StreamingFIFO_rtl_8_nl6qclbk/Q_srl.v


// original source:
// https://github.com/nachiket/tdfc/blob/master/verilog/queues/Q_srl_oreg3_prefull_SIMPLE.v


// Copyright (c) 1999 The Regents of the University of California
// Copyright (c) 2010 The Regents of the University of Pennsylvania
// Copyright (c) 2011 Department of Electrical and Electronic Engineering, Imperial College London
// Copyright (c) 2020 Xilinx
//
// Permission to use, copy, modify, and distribute this software and
// its documentation for any purpose, without fee, and without a
// written agreement is hereby granted, provided that the above copyright
// notice and this paragraph and the following two paragraphs appear in
// all copies.
//
// IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR
// DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
// LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION,
// EVEN IF THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
// THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
// INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
// AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE PROVIDED HEREUNDER IS ON
// AN "AS IS" BASIS, AND THE UNIVERSITY OF CALIFORNIA HAS NO OBLIGATIONS TO
// PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
//

// Q_srl_oreg3_prefull_SIMPLE.v
//
//  - In-page queue with parameterizable depth, bit width
//  - Stream I/O is triple (data, valid, back-pressure),
//      with EOS concatenated into the data
//  - Flow control for input & output is combinationally decoupled
//  - 2 <= depth <= 256
//      * (depth >= 2)  is required to decouple I/O flow control,
//          where empty => no produce,  full => no consume,
//          and depth 1 would ping-pong between the two at half rate
//      * (depth <= 256) can be modified
//           by changing ''synthesis loop_limit X'' below
//          and changing ''addrwidth'' or its log computation
//  - 1 <= width
//  - Queue storage is in SRL16E, up to depth 16 per LUT per bit-slice,
//      plus output register (for fast output)
//  - Queue addressing is done by ''addr'' up-down counter
//  - Queue fullness is checked by comparator (addr==depth)
//  - Queue fullness                           is pre-computed for next cycle
//  - Queue input back-pressure                is pre-computed for next cycle
//  - Queue output valid (state!=state__empty) is pre-computed for next cycle
//      (necessary since SRL data output reg requires non-boolean state)
//  - FSM has 3 states (empty, one, more)
//  - When empty, continue to emit most recently emitted value (for debugging)
//
//  - Queue slots used      = / (state==state_empty) ? 0
//                            | (state==state_one)   ? 1
//                            \ (state==state_more)  ? addr+2
//  - Queue slots used     <=  depth
//  - Queue slots remaining =  depth - used
//                          = / (state==state_empty) ? depth
//                            | (state==state_one)   ? depth-1
//                            \ (state==state_more)  ? depth-2-addr
//
//  - Synplify 7.1 / 8.0
//  - Eylon Caspi,  9/11/03, 8/18/04, 3/29/05


`ifdef  Q_srl
`else
`define Q_srl


module Q_srl (clock, reset, i_d, i_v, i_r, o_d, o_v, o_r, count, maxcount);

   parameter depth = 16;   // - greatest #items in queue  (2 <= depth <= 256)
   parameter width = 16;   // - width of data (i_d, o_d)

   localparam countwidth = $clog2(depth + 1);
   localparam addrwidth = $clog2(depth);

   input     clock;
   input     reset;

   input  [width-1:0] i_d;	// - input  stream data (concat data + eos)
   input              i_v;	// - input  stream valid
   output             i_r;	// - input  stream ready
   wire               i_b;  // - input  stream back-pressure

   output [width-1:0] o_d;	// - output stream data (concat data + eos)
   output             o_v;	// - output stream valid
   input              o_r;	// - output stream ready
   wire               o_b;	// - output stream back-pressure

   output [countwidth-1:0] count;  // - output number of elems in queue
   output [countwidth-1:0] maxcount;  // - maximum observed count since reset

   reg [countwidth-1:0] maxcount_reg;  // - maximum count seen until now
   reg    [addrwidth-1:0] addr, addr_, a_;		// - SRL16 address
							//     for data output
   reg 			  shift_en_;			// - SRL16 shift enable
   reg    [width-1:0] 	  srl [depth-2:0];		// - SRL16 memory
   reg 			  shift_en_o_;			// - SRLO  shift enable
   reg    [width-1:0] 	  srlo_, srlo			// - SRLO  output reg
			  /* synthesis syn_allow_retiming=0 */ ;

   parameter state_empty = 2'd0;    // - state empty : o_v=0 o_d=UNDEFINED
   parameter state_one   = 2'd1;    // - state one   : o_v=1 o_d=srlo
   parameter state_more  = 2'd2;    // - state more  : o_v=1 o_d=srlo
				    //     #items in srl = addr+2

   reg [1:0] state, state_;	    // - state register

   wire      addr_full_;	    // - true iff addr==depth-2 on NEXT cycle
   reg       addr_full; 	    // - true iff addr==depth-2
   wire      addr_zero_;	    // - true iff addr==0
   wire      o_v_reg_;		    // - true iff state_empty   on NEXT cycle
   reg       o_v_reg  		    // - true iff state_empty
	     /* synthesis syn_allow_retiming=0 */ ;
   wire      i_b_reg_;		    // - true iff !full         on NEXT cycle
   reg       i_b_reg  		    // - true iff !full
	     /* synthesis syn_allow_retiming=0 */ ;

   assign addr_full_ = (state_==state_more) && (addr_==depth-2);
						// - queue full
   assign addr_zero_ = (addr==0);		// - queue contains 2 (or 1,0)
   assign o_v_reg_   = (state_!=state_empty);	// - output valid if non-empty
   assign i_b_reg_   = addr_full_;		// - input bp if full
   assign o_d = srlo;				// - output data from queue
   assign o_v = o_v_reg;			// - output valid if non-empty
   assign i_b = i_b_reg;			// - input bp if full
   assign maxcount = maxcount_reg;

   assign i_r = !i_b;
   assign o_b = !o_r;

   assign count = (state==state_more ? addr+2 : (state==state_one ? 1 : 0));

   // - ''always'' block with both FFs and SRL16 does not work,
   //      since FFs need reset but SRL16 does not

   always @(posedge clock) begin	// - seq always: FFs
      if (reset) begin
	 state     <= state_empty;
	 addr      <= 0;
         addr_full <= 0;
	 o_v_reg   <= 0;

	 i_b_reg   <= 0;
	 maxcount_reg <= 0;

      end
      else begin
	 state     <= state_;
	 addr      <= addr_;
         addr_full <= addr_full_;
	 o_v_reg   <= o_v_reg_;
	 i_b_reg   <= i_b_reg_;
	 maxcount_reg <= (count > maxcount_reg ? count : maxcount_reg);
      end
   end // always @ (posedge clock)

   always @(posedge clock) begin	// - seq always: srlo
      // - infer enabled output reg at end of shift chain
      // - input first element from i_d, all subsequent elements from SRL16
      if (reset) begin
	 srlo <= 0;
      end
      else begin
	 if (shift_en_o_) begin
	    srlo <= srlo_;
	 end
      end
   end // always @ (posedge clock)

   always @(posedge clock) begin			// - seq always: srl
      // - infer enabled SRL16E from shifting srl array
      // - no reset capability;  srl[] contents undefined on reset
      if (shift_en_) begin
	 // synthesis loop_limit 256
	 for (a_=depth-2; a_>0; a_=a_-1) begin
	    srl[a_] = srl[a_-1];
	 end
	 srl[0] <= i_d;
      end
   end // always @ (posedge clock or negedge reset)

   always @* begin					// - combi always
        srlo_       <=  'bx;
        shift_en_o_ <= 1'bx;
        shift_en_   <= 1'bx;
        addr_       <=  'bx;
        state_      <= 2'bx;
      case (state)

	state_empty: begin		    // - (empty, will not produce)
	      if (i_v) begin		    // - empty & i_v => consume
		 srlo_       <= i_d;
		 shift_en_o_ <= 1;
		 shift_en_   <= 1'bx;
		 addr_       <= 0;
		 state_      <= state_one;
	      end
	      else	begin		    // - empty & !i_v => idle
		 srlo_       <= 'bx;
		 shift_en_o_ <= 0;
		 shift_en_   <= 1'bx;
		 addr_       <= 0;
		 state_      <= state_empty;
	      end
	end

	state_one: begin		    // - (contains one)
	      if (i_v && o_b) begin	    // - one & i_v & o_b => consume
		 srlo_       <= 'bx;
		 shift_en_o_ <= 0;
		 shift_en_   <= 1;
		 addr_       <= 0;
		 state_      <= state_more;
	      end
	      else if (i_v && !o_b) begin   // - one & i_v & !o_b => cons+prod
		 srlo_       <= i_d;
		 shift_en_o_ <= 1;
		 shift_en_   <= 1;
		 addr_       <= 0;
		 state_      <= state_one;
	      end
	      else if (!i_v && o_b) begin   // - one & !i_v & o_b => idle
		 srlo_       <= 'bx;
		 shift_en_o_ <= 0;
		 shift_en_   <= 1'bx;
		 addr_       <= 0;
		 state_      <= state_one;
	      end
	      else if (!i_v && !o_b) begin  // - one & !i_v & !o_b => produce
		 srlo_       <= 'bx;
		 shift_en_o_ <= 0;
		 shift_en_   <= 1'bx;
		 addr_       <= 0;
		 state_      <= state_empty;
	      end
	end // case: state_one

	state_more: begin		    // - (contains more than one)
	   if (addr_full || (depth==2)) begin
					    // - (full, will not consume)
					    // - (full here if depth==2)
	      if (o_b) begin		    // - full & o_b => idle
		 srlo_       <= 'bx;
		 shift_en_o_ <= 0;
		 shift_en_   <= 0;
		 addr_       <= addr;
		 state_      <= state_more;
	      end
	      else begin		    // - full & !o_b => produce
		 srlo_       <= srl[addr];
		 shift_en_o_ <= 1;
		 shift_en_   <= 0;
//		 addr_       <= addr-1;
//		 state_      <= state_more;
		 addr_       <= addr_zero_ ? 0         : addr-1;
		 state_      <= addr_zero_ ? state_one : state_more;
	      end
	   end
	   else begin			    // - (mid: neither empty nor full)
	      if (i_v && o_b) begin	    // - mid & i_v & o_b => consume
		 srlo_       <= 'bx;
		 shift_en_o_ <= 0;
		 shift_en_   <= 1;
		 addr_       <= addr+1;
		 state_      <= state_more;
	      end
	      else if (i_v && !o_b) begin   // - mid & i_v & !o_b => cons+prod
		 srlo_       <= srl[addr];
		 shift_en_o_ <= 1;
		 shift_en_   <= 1;
		 addr_       <= addr;
		 state_      <= state_more;
	      end
	      else if (!i_v && o_b) begin   // - mid & !i_v & o_b => idle
		 srlo_       <= 'bx;
		 shift_en_o_ <= 0;
		 shift_en_   <= 0;
		 addr_       <= addr;
		 state_      <= state_more;
	      end
	      else if (!i_v && !o_b) begin  // - mid & !i_v & !o_b => produce
		 srlo_       <= srl[addr];
		 shift_en_o_ <= 1;
		 shift_en_   <= 0;
		 addr_       <= addr_zero_ ? 0         : addr-1;
		 state_      <= addr_zero_ ? state_one : state_more;
	      end
	   end // else: !if(addr_full)
	end // case: state_more

	default: begin
		 srlo_       <=  'bx;
		 shift_en_o_ <= 1'bx;
		 shift_en_   <= 1'bx;
		 addr_       <=  'bx;
		 state_      <= 2'bx;
	end // case: default

      endcase // case(state)
   end // always @ *

endmodule // Q_srl


`endif  // `ifdef  Q_srl
//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/code_gen_ipgen_StreamingFIFO_rtl_1_1vyz9xjq/Q_srl.v


// original source:
// https://github.com/nachiket/tdfc/blob/master/verilog/queues/Q_srl_oreg3_prefull_SIMPLE.v


// Copyright (c) 1999 The Regents of the University of California
// Copyright (c) 2010 The Regents of the University of Pennsylvania
// Copyright (c) 2011 Department of Electrical and Electronic Engineering, Imperial College London
// Copyright (c) 2020 Xilinx
//
// Permission to use, copy, modify, and distribute this software and
// its documentation for any purpose, without fee, and without a
// written agreement is hereby granted, provided that the above copyright
// notice and this paragraph and the following two paragraphs appear in
// all copies.
//
// IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR
// DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
// LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION,
// EVEN IF THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
// THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
// INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
// AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE PROVIDED HEREUNDER IS ON
// AN "AS IS" BASIS, AND THE UNIVERSITY OF CALIFORNIA HAS NO OBLIGATIONS TO
// PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
//

// Q_srl_oreg3_prefull_SIMPLE.v
//
//  - In-page queue with parameterizable depth, bit width
//  - Stream I/O is triple (data, valid, back-pressure),
//      with EOS concatenated into the data
//  - Flow control for input & output is combinationally decoupled
//  - 2 <= depth <= 256
//      * (depth >= 2)  is required to decouple I/O flow control,
//          where empty => no produce,  full => no consume,
//          and depth 1 would ping-pong between the two at half rate
//      * (depth <= 256) can be modified
//           by changing ''synthesis loop_limit X'' below
//          and changing ''addrwidth'' or its log computation
//  - 1 <= width
//  - Queue storage is in SRL16E, up to depth 16 per LUT per bit-slice,
//      plus output register (for fast output)
//  - Queue addressing is done by ''addr'' up-down counter
//  - Queue fullness is checked by comparator (addr==depth)
//  - Queue fullness                           is pre-computed for next cycle
//  - Queue input back-pressure                is pre-computed for next cycle
//  - Queue output valid (state!=state__empty) is pre-computed for next cycle
//      (necessary since SRL data output reg requires non-boolean state)
//  - FSM has 3 states (empty, one, more)
//  - When empty, continue to emit most recently emitted value (for debugging)
//
//  - Queue slots used      = / (state==state_empty) ? 0
//                            | (state==state_one)   ? 1
//                            \ (state==state_more)  ? addr+2
//  - Queue slots used     <=  depth
//  - Queue slots remaining =  depth - used
//                          = / (state==state_empty) ? depth
//                            | (state==state_one)   ? depth-1
//                            \ (state==state_more)  ? depth-2-addr
//
//  - Synplify 7.1 / 8.0
//  - Eylon Caspi,  9/11/03, 8/18/04, 3/29/05


`ifdef  Q_srl
`else
`define Q_srl


module Q_srl (clock, reset, i_d, i_v, i_r, o_d, o_v, o_r, count, maxcount);

   parameter depth = 16;   // - greatest #items in queue  (2 <= depth <= 256)
   parameter width = 16;   // - width of data (i_d, o_d)

   localparam countwidth = $clog2(depth + 1);
   localparam addrwidth = $clog2(depth);

   input     clock;
   input     reset;

   input  [width-1:0] i_d;	// - input  stream data (concat data + eos)
   input              i_v;	// - input  stream valid
   output             i_r;	// - input  stream ready
   wire               i_b;  // - input  stream back-pressure

   output [width-1:0] o_d;	// - output stream data (concat data + eos)
   output             o_v;	// - output stream valid
   input              o_r;	// - output stream ready
   wire               o_b;	// - output stream back-pressure

   output [countwidth-1:0] count;  // - output number of elems in queue
   output [countwidth-1:0] maxcount;  // - maximum observed count since reset

   reg [countwidth-1:0] maxcount_reg;  // - maximum count seen until now
   reg    [addrwidth-1:0] addr, addr_, a_;		// - SRL16 address
							//     for data output
   reg 			  shift_en_;			// - SRL16 shift enable
   reg    [width-1:0] 	  srl [depth-2:0];		// - SRL16 memory
   reg 			  shift_en_o_;			// - SRLO  shift enable
   reg    [width-1:0] 	  srlo_, srlo			// - SRLO  output reg
			  /* synthesis syn_allow_retiming=0 */ ;

   parameter state_empty = 2'd0;    // - state empty : o_v=0 o_d=UNDEFINED
   parameter state_one   = 2'd1;    // - state one   : o_v=1 o_d=srlo
   parameter state_more  = 2'd2;    // - state more  : o_v=1 o_d=srlo
				    //     #items in srl = addr+2

   reg [1:0] state, state_;	    // - state register

   wire      addr_full_;	    // - true iff addr==depth-2 on NEXT cycle
   reg       addr_full; 	    // - true iff addr==depth-2
   wire      addr_zero_;	    // - true iff addr==0
   wire      o_v_reg_;		    // - true iff state_empty   on NEXT cycle
   reg       o_v_reg  		    // - true iff state_empty
	     /* synthesis syn_allow_retiming=0 */ ;
   wire      i_b_reg_;		    // - true iff !full         on NEXT cycle
   reg       i_b_reg  		    // - true iff !full
	     /* synthesis syn_allow_retiming=0 */ ;

   assign addr_full_ = (state_==state_more) && (addr_==depth-2);
						// - queue full
   assign addr_zero_ = (addr==0);		// - queue contains 2 (or 1,0)
   assign o_v_reg_   = (state_!=state_empty);	// - output valid if non-empty
   assign i_b_reg_   = addr_full_;		// - input bp if full
   assign o_d = srlo;				// - output data from queue
   assign o_v = o_v_reg;			// - output valid if non-empty
   assign i_b = i_b_reg;			// - input bp if full
   assign maxcount = maxcount_reg;

   assign i_r = !i_b;
   assign o_b = !o_r;

   assign count = (state==state_more ? addr+2 : (state==state_one ? 1 : 0));

   // - ''always'' block with both FFs and SRL16 does not work,
   //      since FFs need reset but SRL16 does not

   always @(posedge clock) begin	// - seq always: FFs
      if (reset) begin
	 state     <= state_empty;
	 addr      <= 0;
         addr_full <= 0;
	 o_v_reg   <= 0;

	 i_b_reg   <= 0;
	 maxcount_reg <= 0;

      end
      else begin
	 state     <= state_;
	 addr      <= addr_;
         addr_full <= addr_full_;
	 o_v_reg   <= o_v_reg_;
	 i_b_reg   <= i_b_reg_;
	 maxcount_reg <= (count > maxcount_reg ? count : maxcount_reg);
      end
   end // always @ (posedge clock)

   always @(posedge clock) begin	// - seq always: srlo
      // - infer enabled output reg at end of shift chain
      // - input first element from i_d, all subsequent elements from SRL16
      if (reset) begin
	 srlo <= 0;
      end
      else begin
	 if (shift_en_o_) begin
	    srlo <= srlo_;
	 end
      end
   end // always @ (posedge clock)

   always @(posedge clock) begin			// - seq always: srl
      // - infer enabled SRL16E from shifting srl array
      // - no reset capability;  srl[] contents undefined on reset
      if (shift_en_) begin
	 // synthesis loop_limit 256
	 for (a_=depth-2; a_>0; a_=a_-1) begin
	    srl[a_] = srl[a_-1];
	 end
	 srl[0] <= i_d;
      end
   end // always @ (posedge clock or negedge reset)

   always @* begin					// - combi always
        srlo_       <=  'bx;
        shift_en_o_ <= 1'bx;
        shift_en_   <= 1'bx;
        addr_       <=  'bx;
        state_      <= 2'bx;
      case (state)

	state_empty: begin		    // - (empty, will not produce)
	      if (i_v) begin		    // - empty & i_v => consume
		 srlo_       <= i_d;
		 shift_en_o_ <= 1;
		 shift_en_   <= 1'bx;
		 addr_       <= 0;
		 state_      <= state_one;
	      end
	      else	begin		    // - empty & !i_v => idle
		 srlo_       <= 'bx;
		 shift_en_o_ <= 0;
		 shift_en_   <= 1'bx;
		 addr_       <= 0;
		 state_      <= state_empty;
	      end
	end

	state_one: begin		    // - (contains one)
	      if (i_v && o_b) begin	    // - one & i_v & o_b => consume
		 srlo_       <= 'bx;
		 shift_en_o_ <= 0;
		 shift_en_   <= 1;
		 addr_       <= 0;
		 state_      <= state_more;
	      end
	      else if (i_v && !o_b) begin   // - one & i_v & !o_b => cons+prod
		 srlo_       <= i_d;
		 shift_en_o_ <= 1;
		 shift_en_   <= 1;
		 addr_       <= 0;
		 state_      <= state_one;
	      end
	      else if (!i_v && o_b) begin   // - one & !i_v & o_b => idle
		 srlo_       <= 'bx;
		 shift_en_o_ <= 0;
		 shift_en_   <= 1'bx;
		 addr_       <= 0;
		 state_      <= state_one;
	      end
	      else if (!i_v && !o_b) begin  // - one & !i_v & !o_b => produce
		 srlo_       <= 'bx;
		 shift_en_o_ <= 0;
		 shift_en_   <= 1'bx;
		 addr_       <= 0;
		 state_      <= state_empty;
	      end
	end // case: state_one

	state_more: begin		    // - (contains more than one)
	   if (addr_full || (depth==2)) begin
					    // - (full, will not consume)
					    // - (full here if depth==2)
	      if (o_b) begin		    // - full & o_b => idle
		 srlo_       <= 'bx;
		 shift_en_o_ <= 0;
		 shift_en_   <= 0;
		 addr_       <= addr;
		 state_      <= state_more;
	      end
	      else begin		    // - full & !o_b => produce
		 srlo_       <= srl[addr];
		 shift_en_o_ <= 1;
		 shift_en_   <= 0;
//		 addr_       <= addr-1;
//		 state_      <= state_more;
		 addr_       <= addr_zero_ ? 0         : addr-1;
		 state_      <= addr_zero_ ? state_one : state_more;
	      end
	   end
	   else begin			    // - (mid: neither empty nor full)
	      if (i_v && o_b) begin	    // - mid & i_v & o_b => consume
		 srlo_       <= 'bx;
		 shift_en_o_ <= 0;
		 shift_en_   <= 1;
		 addr_       <= addr+1;
		 state_      <= state_more;
	      end
	      else if (i_v && !o_b) begin   // - mid & i_v & !o_b => cons+prod
		 srlo_       <= srl[addr];
		 shift_en_o_ <= 1;
		 shift_en_   <= 1;
		 addr_       <= addr;
		 state_      <= state_more;
	      end
	      else if (!i_v && o_b) begin   // - mid & !i_v & o_b => idle
		 srlo_       <= 'bx;
		 shift_en_o_ <= 0;
		 shift_en_   <= 0;
		 addr_       <= addr;
		 state_      <= state_more;
	      end
	      else if (!i_v && !o_b) begin  // - mid & !i_v & !o_b => produce
		 srlo_       <= srl[addr];
		 shift_en_o_ <= 1;
		 shift_en_   <= 0;
		 addr_       <= addr_zero_ ? 0         : addr-1;
		 state_      <= addr_zero_ ? state_one : state_more;
	      end
	   end // else: !if(addr_full)
	end // case: state_more

	default: begin
		 srlo_       <=  'bx;
		 shift_en_o_ <= 1'bx;
		 shift_en_   <= 1'bx;
		 addr_       <=  'bx;
		 state_      <= 2'bx;
	end // case: default

      endcase // case(state)
   end // always @ *

endmodule // Q_srl


`endif  // `ifdef  Q_srl
//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/code_gen_ipgen_StreamingDataWidthConverter_rtl_0_dwunb9n0/dwc.sv


/******************************************************************************
 * Copyright (C) 2023, Advanced Micro Devices, Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *  1. Redistributions of source code must retain the above copyright notice,
 *     this list of conditions and the following disclaimer.
 *
 *  2. Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *
 *  3. Neither the name of the copyright holder nor the names of its
 *     contributors may be used to endorse or promote products derived from
 *     this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION). HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * @brief	Stream Data Width Converter.
 * @author	Thomas B. Preuer <tpreusse@amd.com>
 *****************************************************************************/
module dwc #(
	int unsigned  IBITS,
	int unsigned  OBITS
)(
	//- Global Control ------------------
	input	logic  clk,
	input	logic  rst,

	//- AXI Stream - Input --------------
	output	logic  irdy,
	input	logic  ivld,
	input	logic [IBITS-1:0]  idat,

	//- AXI Stream - Output -------------
	input	logic  ordy,
	output	logic  ovld,
	output	logic [OBITS-1:0]  odat
);

	if(IBITS == OBITS) begin : genNoop
		assign	irdy = ordy;
		assign	ovld = ivld;
		assign	odat  = idat;
	end : genNoop
	else if(IBITS < OBITS) begin : genUp

		// Sanity Checking: integer upscaling
		initial begin
			if(OBITS % IBITS) begin
				$error("Output width %0d is not a multiple of input width %0d.", OBITS, IBITS);
				$finish;
			end
		end

		// Parallelizing Shift Register A and Sidestep Buffer B on Input Path
		localparam int unsigned  K = OBITS / IBITS;
		typedef logic [IBITS-1:0]  dat_t;
		dat_t       [K-1:0]  ADat = 'x;
		logic [$clog2(K):0]  ACnt = K-1;	// (empty) K-1, ..., 0, -1 (full/valid)
		dat_t  BDat = 'x;
		logic  BRdy =  1;
		always_ff @(posedge clk) begin
			if(rst) begin
				ADat <= 'x;
				ACnt <= K-1;
				BDat <= 'x;
				BRdy <=  1;
			end
			else begin
				automatic type(ACnt)  acnt = (ovld && ordy)? K-1 : ACnt;
				automatic logic  rdy = !ovld || ordy;
				if((ivld || !BRdy) && rdy) begin
					ADat <= { BRdy? idat : BDat, ADat[K-1:1] };
					acnt--;
				end
				ACnt <= acnt;

				if(BRdy)  BDat <= idat;
				BRdy <= rdy || (BRdy && !ivld);
			end
		end

		// Output Assignments
		assign  irdy = BRdy;
		assign	ovld = ACnt[$left(ACnt)];
		assign	odat  = ADat;

	end : genUp
	else begin : genDown

		// Sanity Checking: integer downscaling
		initial begin
			if(IBITS % OBITS) begin
				$error("Input width %0d is not a multiple of output width %0d.", IBITS, OBITS);
				$finish;
			end
		end

		// Serializing Shift Register A and Sidestep Buffer B on Output Path
		localparam int unsigned  K = IBITS / OBITS;
		typedef logic [OBITS-1:0]  dat_t;
		dat_t [      K-1:0]  ADat = 'x;
		logic [$clog2(K):0]  ACnt =  1;	// (full) -K+1, ..., -1, 0, 1 (empty/not valid)
		dat_t  BDat = 'x;
		logic  BRdy =  1;
		dat_t  CDat = 'x;
		logic  CVld =  0;
		always_ff @(posedge clk) begin
			if(rst) begin
				ADat <= 'x;
				ACnt <=  1;
				BDat <= 'x;
				BRdy <=  1;
				CDat <= 'x;
				CVld <=  0;
			end
			else begin
				automatic type(ACnt)  acnt = ACnt;
				automatic logic       ainc = 0;
				if(irdy) begin
					ADat <= idat;
					acnt = ivld? -K+1 : 1;
				end
				else if(BRdy) begin
					ADat <= { {OBITS{1'bx}}, ADat[K-1:1] };
					ainc = BRdy;
				end;
				ACnt <= acnt + ainc;

				if(BRdy)  BDat <= ADat[0];
				BRdy <= !CVld || ordy || (BRdy && !ACnt[$left(ACnt)] && ACnt[0]);

				if(!CVld || ordy)  CDat <= BRdy? ADat[0] : BDat;
				CVld <= (CVld && !ordy) || !BRdy || ACnt[$left(ACnt)] || !ACnt[0];
			end
		end

		// Output Assignments
		assign  irdy = BRdy && !ACnt[$left(ACnt)];
		assign	ovld = CVld;
		assign	odat  = CDat;

	end : genDown

endmodule : dwc
//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/vivado_stitch_proj_w5fn6zuu/finn_vivado_stitch_proj.gen/sources_1/bd/finn_design/ip/finn_design_StreamingFIFO_rtl_0_0/synth/finn_design_StreamingFIFO_rtl_0_0.v


// (c) Copyright 1995-2026 Xilinx, Inc. All rights reserved.
// 
// This file contains confidential and proprietary information
// of Xilinx, Inc. and is protected under U.S. and
// international copyright and other intellectual property
// laws.
// 
// DISCLAIMER
// This disclaimer is not a license and does not grant any
// rights to the materials distributed herewith. Except as
// otherwise provided in a valid license issued to you by
// Xilinx, and to the maximum extent permitted by applicable
// law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
// WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
// AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
// BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
// INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
// (2) Xilinx shall not be liable (whether in contract or tort,
// including negligence, or under any other theory of
// liability) for any loss or damage of any kind or nature
// related to, arising under or in connection with these
// materials, including for any direct, or any indirect,
// special, incidental, or consequential loss or damage
// (including loss of data, profits, goodwill, or any type of
// loss or damage suffered as a result of any action brought
// by a third party) even if such damage or loss was
// reasonably foreseeable or Xilinx had been advised of the
// possibility of the same.
// 
// CRITICAL APPLICATIONS
// Xilinx products are not designed or intended to be fail-
// safe, or for use in any application requiring fail-safe
// performance, such as life-support or safety devices or
// systems, Class III medical devices, nuclear facilities,
// applications related to the deployment of airbags, or any
// other applications that could lead to death, personal
// injury, or severe property or environmental damage
// (individually and collectively, "Critical
// Applications"). Customer assumes the sole risk and
// liability of any use of Xilinx products in Critical
// Applications, subject only to applicable laws and
// regulations governing limitations on product liability.
// 
// THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
// PART OF THIS FILE AT ALL TIMES.
// 
// DO NOT MODIFY THIS FILE.


// IP VLNV: xilinx.com:module_ref:StreamingFIFO_rtl_0:1.0
// IP Revision: 1

(* X_CORE_INFO = "StreamingFIFO_rtl_0,Vivado 2022.2" *)
(* CHECK_LICENSE_TYPE = "finn_design_StreamingFIFO_rtl_0_0,StreamingFIFO_rtl_0,{}" *)
(* CORE_GENERATION_INFO = "finn_design_StreamingFIFO_rtl_0_0,StreamingFIFO_rtl_0,{x_ipProduct=Vivado 2022.2,x_ipVendor=xilinx.com,x_ipLibrary=module_ref,x_ipName=StreamingFIFO_rtl_0,x_ipVersion=1.0,x_ipCoreRevision=1,x_ipLanguage=VERILOG,x_ipSimLanguage=MIXED}" *)
(* IP_DEFINITION_SOURCE = "module_ref" *)
(* DowngradeIPIdentifiedWarnings = "yes" *)
module finn_design_StreamingFIFO_rtl_0_0 (
  ap_clk,
  ap_rst_n,
  count,
  maxcount,
  in0_V_TREADY,
  in0_V_TVALID,
  in0_V_TDATA,
  out_V_TREADY,
  out_V_TVALID,
  out_V_TDATA
);

(* X_INTERFACE_PARAMETER = "XIL_INTERFACENAME ap_clk, ASSOCIATED_RESET ap_rst_n, ASSOCIATED_BUSIF in0_V:out_V, FREQ_HZ 100000000, FREQ_TOLERANCE_HZ 0, PHASE 0.0, CLK_DOMAIN finn_design_ap_clk_0, INSERT_VIP 0" *)
(* X_INTERFACE_INFO = "xilinx.com:signal:clock:1.0 ap_clk CLK" *)
input wire ap_clk;
(* X_INTERFACE_PARAMETER = "XIL_INTERFACENAME ap_rst_n, POLARITY ACTIVE_LOW, INSERT_VIP 0" *)
(* X_INTERFACE_INFO = "xilinx.com:signal:reset:1.0 ap_rst_n RST" *)
input wire ap_rst_n;
output wire [9 : 0] count;
output wire [9 : 0] maxcount;
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 in0_V TREADY" *)
output wire in0_V_TREADY;
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 in0_V TVALID" *)
input wire in0_V_TVALID;
(* X_INTERFACE_PARAMETER = "XIL_INTERFACENAME in0_V, TDATA_NUM_BYTES 3, TDEST_WIDTH 0, TID_WIDTH 0, TUSER_WIDTH 0, HAS_TREADY 1, HAS_TSTRB 0, HAS_TKEEP 0, HAS_TLAST 0, FREQ_HZ 100000000, PHASE 0.0, CLK_DOMAIN finn_design_ap_clk_0, LAYERED_METADATA undef, INSERT_VIP 0" *)
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 in0_V TDATA" *)
input wire [23 : 0] in0_V_TDATA;
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 out_V TREADY" *)
input wire out_V_TREADY;
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 out_V TVALID" *)
output wire out_V_TVALID;
(* X_INTERFACE_PARAMETER = "XIL_INTERFACENAME out_V, TDATA_NUM_BYTES 3, TDEST_WIDTH 0, TID_WIDTH 0, TUSER_WIDTH 0, HAS_TREADY 1, HAS_TSTRB 0, HAS_TKEEP 0, HAS_TLAST 0, FREQ_HZ 100000000, PHASE 0.0, CLK_DOMAIN finn_design_ap_clk_0, LAYERED_METADATA undef, INSERT_VIP 0" *)
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 out_V TDATA" *)
output wire [23 : 0] out_V_TDATA;

  StreamingFIFO_rtl_0 inst (
    .ap_clk(ap_clk),
    .ap_rst_n(ap_rst_n),
    .count(count),
    .maxcount(maxcount),
    .in0_V_TREADY(in0_V_TREADY),
    .in0_V_TVALID(in0_V_TVALID),
    .in0_V_TDATA(in0_V_TDATA),
    .out_V_TREADY(out_V_TREADY),
    .out_V_TVALID(out_V_TVALID),
    .out_V_TDATA(out_V_TDATA)
  );
endmodule
//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/vivado_stitch_proj_w5fn6zuu/finn_vivado_stitch_proj.gen/sources_1/bd/finn_design/ipshared/bcb1/hdl/memstream_axi.sv


/**
 * Copyright (c) 2023, Xilinx
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of FINN nor the names of its
 *   contributors may be used to endorse or promote products derived from
 *   this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * @author	Thomas B. Preuer <thomas.preusser@amd.com>
 */

module memstream_axi #(
	int unsigned  DEPTH,
	int unsigned  WIDTH,

	parameter  INIT_FILE = "",
	parameter  RAM_STYLE = "auto",

	localparam int unsigned  AXILITE_ADDR_WIDTH = $clog2(DEPTH * (2**$clog2((WIDTH+31)/32))) + 2
)(
	// Global Control
	input	logic  clk,
	input	logic  rst,

	// AXI-lite Write
	output	logic  awready,
	input	logic  awvalid,
	input	logic [2:0]  awprot,
	input	logic [AXILITE_ADDR_WIDTH-1:0]  awaddr,

	output	logic  wready,
	input	logic  wvalid,
	input	logic [31:0]  wdata,
	input	logic [ 3:0]  wstrb,

	input	logic  bready,
	output	logic  bvalid,
	output	logic [1:0]  bresp,

	// AXI-lite Read
	output	logic  arready,
	input	logic  arvalid,
	input	logic [2:0]  arprot,
	input	logic [AXILITE_ADDR_WIDTH-1:0]  araddr,

	input	logic  rready,
	output	logic  rvalid,
	output	logic [ 1:0]  rresp,
	output	logic [31:0]  rdata,

	// Continuous output stream
	input	logic  m_axis_0_tready,
	output	logic  m_axis_0_tvalid,
	output	logic [((WIDTH+7)/8)*8-1:0]  m_axis_0_tdata
);

	//-----------------------------------------------------------------------
	// AXI-lite to ap_memory Adapter
	uwire [31:0]  config_address;
	uwire  config_ce;
	uwire  config_we;
	uwire  config_rack;
	uwire [WIDTH-1:0]  config_d0;
	uwire [WIDTH-1:0]  config_q0;
	axi4lite_if #(
		.ADDR_WIDTH(AXILITE_ADDR_WIDTH),
		.DATA_WIDTH(32),
		.IP_DATA_WIDTH(WIDTH)
	) config_if (
		.aclk(clk), .aresetn(!rst),

		// Write Channels
		.awready, .awvalid, .awaddr, .awprot,
		.wready,  .wvalid,  .wdata,  .wstrb,
		.bready,  .bvalid,  .bresp,

		// Read Channels
		.arready, .arvalid, .araddr, .arprot,
		.rready,  .rvalid,  .rresp,  .rdata,

		// IP-side Interface
		.ip_en(config_ce),
		.ip_wen(config_we),
		.ip_addr(config_address),
		.ip_wdata(config_d0),
		.ip_rack(config_rack),
		.ip_rdata(config_q0)
	);

	//-----------------------------------------------------------------------
	// Streaming Memory Backend
	memstream #(
		.DEPTH(DEPTH),
		.WIDTH(WIDTH),
		.INIT_FILE(INIT_FILE),
		.RAM_STYLE(RAM_STYLE)
	) mem (
		.clk, .rst,

		.config_address,
		.config_ce,
		.config_we,
		.config_d0,
		.config_q0,
		.config_rack,

		.ordy(m_axis_0_tready),
		.ovld(m_axis_0_tvalid),
		.odat(m_axis_0_tdata[WIDTH-1:0])
	);
	if($bits(m_axis_0_tdata) > WIDTH) begin
		assign	m_axis_0_tdata[$left(m_axis_0_tdata):WIDTH] = '0;
	end

endmodule : memstream_axi
//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/vivado_stitch_proj_w5fn6zuu/finn_vivado_stitch_proj.gen/sources_1/bd/finn_design/ipshared/6bf6/hdl/verilog/StreamingMaxPool_hls_0_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8.v


// ==============================================================
// RTL generated by Vitis HLS - High-Level Synthesis from C, C++ and OpenCL v2022.2 (64-bit)
// Version: 2022.2
// Copyright (C) Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.
// 
// ===========================================================

`timescale 1 ns / 1 ps 

module StreamingMaxPool_hls_0_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8 (
        ap_clk,
        ap_rst,
        ap_start,
        ap_done,
        ap_idle,
        ap_ready,
        out_V_TREADY,
        buf_V_address0,
        buf_V_ce0,
        buf_V_we0,
        buf_V_d0,
        buf_V_q0,
        buf_V_1_address0,
        buf_V_1_ce0,
        buf_V_1_we0,
        buf_V_1_d0,
        buf_V_1_q0,
        buf_V_2_address0,
        buf_V_2_ce0,
        buf_V_2_we0,
        buf_V_2_d0,
        buf_V_2_q0,
        buf_V_3_address0,
        buf_V_3_ce0,
        buf_V_3_we0,
        buf_V_3_d0,
        buf_V_3_q0,
        buf_V_4_address0,
        buf_V_4_ce0,
        buf_V_4_we0,
        buf_V_4_d0,
        buf_V_4_q0,
        buf_V_5_address0,
        buf_V_5_ce0,
        buf_V_5_we0,
        buf_V_5_d0,
        buf_V_5_q0,
        buf_V_6_address0,
        buf_V_6_ce0,
        buf_V_6_we0,
        buf_V_6_d0,
        buf_V_6_q0,
        buf_V_7_address0,
        buf_V_7_ce0,
        buf_V_7_we0,
        buf_V_7_d0,
        buf_V_7_q0,
        buf_V_8_address0,
        buf_V_8_ce0,
        buf_V_8_we0,
        buf_V_8_d0,
        buf_V_8_q0,
        buf_V_9_address0,
        buf_V_9_ce0,
        buf_V_9_we0,
        buf_V_9_d0,
        buf_V_9_q0,
        buf_V_10_address0,
        buf_V_10_ce0,
        buf_V_10_we0,
        buf_V_10_d0,
        buf_V_10_q0,
        buf_V_11_address0,
        buf_V_11_ce0,
        buf_V_11_we0,
        buf_V_11_d0,
        buf_V_11_q0,
        buf_V_12_address0,
        buf_V_12_ce0,
        buf_V_12_we0,
        buf_V_12_d0,
        buf_V_12_q0,
        buf_V_13_address0,
        buf_V_13_ce0,
        buf_V_13_we0,
        buf_V_13_d0,
        buf_V_13_q0,
        buf_V_14_address0,
        buf_V_14_ce0,
        buf_V_14_we0,
        buf_V_14_d0,
        buf_V_14_q0,
        buf_V_15_address0,
        buf_V_15_ce0,
        buf_V_15_we0,
        buf_V_15_d0,
        buf_V_15_q0,
        out_V_TDATA,
        out_V_TVALID
);

parameter    ap_ST_iter0_fsm_state1 = 1'd1;
parameter    ap_ST_iter1_fsm_state2 = 2'd2;
parameter    ap_ST_iter1_fsm_state0 = 2'd1;

input   ap_clk;
input   ap_rst;
input   ap_start;
output   ap_done;
output   ap_idle;
output   ap_ready;
input   out_V_TREADY;
output  [3:0] buf_V_address0;
output   buf_V_ce0;
output   buf_V_we0;
output  [3:0] buf_V_d0;
input  [3:0] buf_V_q0;
output  [3:0] buf_V_1_address0;
output   buf_V_1_ce0;
output   buf_V_1_we0;
output  [3:0] buf_V_1_d0;
input  [3:0] buf_V_1_q0;
output  [3:0] buf_V_2_address0;
output   buf_V_2_ce0;
output   buf_V_2_we0;
output  [3:0] buf_V_2_d0;
input  [3:0] buf_V_2_q0;
output  [3:0] buf_V_3_address0;
output   buf_V_3_ce0;
output   buf_V_3_we0;
output  [3:0] buf_V_3_d0;
input  [3:0] buf_V_3_q0;
output  [3:0] buf_V_4_address0;
output   buf_V_4_ce0;
output   buf_V_4_we0;
output  [3:0] buf_V_4_d0;
input  [3:0] buf_V_4_q0;
output  [3:0] buf_V_5_address0;
output   buf_V_5_ce0;
output   buf_V_5_we0;
output  [3:0] buf_V_5_d0;
input  [3:0] buf_V_5_q0;
output  [3:0] buf_V_6_address0;
output   buf_V_6_ce0;
output   buf_V_6_we0;
output  [3:0] buf_V_6_d0;
input  [3:0] buf_V_6_q0;
output  [3:0] buf_V_7_address0;
output   buf_V_7_ce0;
output   buf_V_7_we0;
output  [3:0] buf_V_7_d0;
input  [3:0] buf_V_7_q0;
output  [3:0] buf_V_8_address0;
output   buf_V_8_ce0;
output   buf_V_8_we0;
output  [3:0] buf_V_8_d0;
input  [3:0] buf_V_8_q0;
output  [3:0] buf_V_9_address0;
output   buf_V_9_ce0;
output   buf_V_9_we0;
output  [3:0] buf_V_9_d0;
input  [3:0] buf_V_9_q0;
output  [3:0] buf_V_10_address0;
output   buf_V_10_ce0;
output   buf_V_10_we0;
output  [3:0] buf_V_10_d0;
input  [3:0] buf_V_10_q0;
output  [3:0] buf_V_11_address0;
output   buf_V_11_ce0;
output   buf_V_11_we0;
output  [3:0] buf_V_11_d0;
input  [3:0] buf_V_11_q0;
output  [3:0] buf_V_12_address0;
output   buf_V_12_ce0;
output   buf_V_12_we0;
output  [3:0] buf_V_12_d0;
input  [3:0] buf_V_12_q0;
output  [3:0] buf_V_13_address0;
output   buf_V_13_ce0;
output   buf_V_13_we0;
output  [3:0] buf_V_13_d0;
input  [3:0] buf_V_13_q0;
output  [3:0] buf_V_14_address0;
output   buf_V_14_ce0;
output   buf_V_14_we0;
output  [3:0] buf_V_14_d0;
input  [3:0] buf_V_14_q0;
output  [3:0] buf_V_15_address0;
output   buf_V_15_ce0;
output   buf_V_15_we0;
output  [3:0] buf_V_15_d0;
input  [3:0] buf_V_15_q0;
output  [63:0] out_V_TDATA;
output   out_V_TVALID;

reg ap_idle;
reg buf_V_ce0;
reg buf_V_we0;
reg buf_V_1_ce0;
reg buf_V_1_we0;
reg buf_V_2_ce0;
reg buf_V_2_we0;
reg buf_V_3_ce0;
reg buf_V_3_we0;
reg buf_V_4_ce0;
reg buf_V_4_we0;
reg buf_V_5_ce0;
reg buf_V_5_we0;
reg buf_V_6_ce0;
reg buf_V_6_we0;
reg buf_V_7_ce0;
reg buf_V_7_we0;
reg buf_V_8_ce0;
reg buf_V_8_we0;
reg buf_V_9_ce0;
reg buf_V_9_we0;
reg buf_V_10_ce0;
reg buf_V_10_we0;
reg buf_V_11_ce0;
reg buf_V_11_we0;
reg buf_V_12_ce0;
reg buf_V_12_we0;
reg buf_V_13_ce0;
reg buf_V_13_we0;
reg buf_V_14_ce0;
reg buf_V_14_we0;
reg buf_V_15_ce0;
reg buf_V_15_we0;
reg out_V_TVALID;

reg   [0:0] ap_CS_iter0_fsm;
wire    ap_CS_iter0_fsm_state1;
reg   [1:0] ap_CS_iter1_fsm;
wire    ap_CS_iter1_fsm_state0;
reg    ap_block_state1_pp0_stage0_iter0;
reg   [0:0] icmp_ln174_reg_396;
wire   [0:0] icmp_ln174_reg_396_pp0_iter0_reg;
reg    ap_block_state2_pp0_stage0_iter1;
reg    ap_block_state2_io;
wire    ap_CS_iter1_fsm_state2;
wire   [0:0] icmp_ln174_fu_315_p2;
reg    ap_condition_exit_pp0_iter0_stage0;
wire    ap_loop_exit_ready;
reg    ap_ready_int;
reg    out_V_TDATA_blk_n;
wire   [63:0] outpix_cast_fu_327_p1;
reg   [3:0] outpix_fu_72;
wire   [3:0] add_ln174_fu_321_p2;
wire    ap_loop_init;
reg   [3:0] ap_sig_allocacmp_outpix_1;
reg    ap_done_reg;
wire    ap_continue_int;
reg    ap_done_int;
reg    ap_loop_exit_ready_pp0_iter1_reg;
reg   [0:0] ap_NS_iter0_fsm;
reg   [1:0] ap_NS_iter1_fsm;
reg    ap_ST_iter0_fsm_state1_blk;
reg    ap_ST_iter1_fsm_state2_blk;
wire    ap_start_int;
reg    ap_condition_358;
wire    ap_ce_reg;

// power-on initialization
initial begin
#0 ap_CS_iter0_fsm = 1'd1;
#0 ap_CS_iter1_fsm = 2'd1;
#0 ap_done_reg = 1'b0;
end

StreamingMaxPool_hls_0_flow_control_loop_pipe_sequential_init flow_control_loop_pipe_sequential_init_U(
    .ap_clk(ap_clk),
    .ap_rst(ap_rst),
    .ap_start(ap_start),
    .ap_ready(ap_ready),
    .ap_done(ap_done),
    .ap_start_int(ap_start_int),
    .ap_loop_init(ap_loop_init),
    .ap_ready_int(ap_ready_int),
    .ap_loop_exit_ready(ap_condition_exit_pp0_iter0_stage0),
    .ap_loop_exit_done(ap_done_int),
    .ap_continue_int(ap_continue_int),
    .ap_done_int(ap_done_int)
);

always @ (posedge ap_clk) begin
    if (ap_rst == 1'b1) begin
        ap_CS_iter0_fsm <= ap_ST_iter0_fsm_state1;
    end else begin
        ap_CS_iter0_fsm <= ap_NS_iter0_fsm;
    end
end

always @ (posedge ap_clk) begin
    if (ap_rst == 1'b1) begin
        ap_CS_iter1_fsm <= ap_ST_iter1_fsm_state0;
    end else begin
        ap_CS_iter1_fsm <= ap_NS_iter1_fsm;
    end
end

always @ (posedge ap_clk) begin
    if (ap_rst == 1'b1) begin
        ap_done_reg <= 1'b0;
    end else begin
        if ((ap_continue_int == 1'b1)) begin
            ap_done_reg <= 1'b0;
        end else if ((~((1'b1 == ap_block_state2_io) | ((icmp_ln174_reg_396 == 1'd0) & (out_V_TREADY == 1'b0))) & (ap_loop_exit_ready_pp0_iter1_reg == 1'b1) & (1'b1 == ap_CS_iter1_fsm_state2))) begin
            ap_done_reg <= 1'b1;
        end
    end
end

always @ (posedge ap_clk) begin
    if ((~((1'b1 == ap_block_state2_io) | ((icmp_ln174_reg_396 == 1'd0) & (out_V_TREADY == 1'b0))) & (ap_loop_exit_ready == 1'b0) & (1'b1 == ap_CS_iter1_fsm_state2))) begin
        ap_loop_exit_ready_pp0_iter1_reg <= 1'b0;
    end else if ((~((ap_start_int == 1'b0) | ((1'b1 == ap_CS_iter1_fsm_state2) & ((1'b1 == ap_block_state2_io) | ((icmp_ln174_reg_396 == 1'd0) & (out_V_TREADY == 1'b0))))) & (1'b1 == ap_CS_iter0_fsm_state1))) begin
        ap_loop_exit_ready_pp0_iter1_reg <= ap_loop_exit_ready;
    end
end

always @ (posedge ap_clk) begin
    if ((1'b1 == ap_condition_358)) begin
        if ((icmp_ln174_fu_315_p2 == 1'd0)) begin
            outpix_fu_72 <= add_ln174_fu_321_p2;
        end else if ((ap_loop_init == 1'b1)) begin
            outpix_fu_72 <= 4'd0;
        end
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((1'b1 == ap_CS_iter1_fsm_state2) & ((1'b1 == ap_block_state2_io) | ((icmp_ln174_reg_396 == 1'd0) & (out_V_TREADY == 1'b0))))) & (1'b1 == ap_CS_iter0_fsm_state1))) begin
        icmp_ln174_reg_396 <= icmp_ln174_fu_315_p2;
    end
end

always @ (*) begin
    if ((ap_start_int == 1'b0)) begin
        ap_ST_iter0_fsm_state1_blk = 1'b1;
    end else begin
        ap_ST_iter0_fsm_state1_blk = 1'b0;
    end
end

always @ (*) begin
    if (((1'b1 == ap_block_state2_io) | ((icmp_ln174_reg_396 == 1'd0) & (out_V_TREADY == 1'b0)))) begin
        ap_ST_iter1_fsm_state2_blk = 1'b1;
    end else begin
        ap_ST_iter1_fsm_state2_blk = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((1'b1 == ap_CS_iter1_fsm_state2) & ((1'b1 == ap_block_state2_io) | ((icmp_ln174_reg_396 == 1'd0) & (out_V_TREADY == 1'b0))))) & (icmp_ln174_fu_315_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1))) begin
        ap_condition_exit_pp0_iter0_stage0 = 1'b1;
    end else begin
        ap_condition_exit_pp0_iter0_stage0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((1'b1 == ap_block_state2_io) | ((icmp_ln174_reg_396 == 1'd0) & (out_V_TREADY == 1'b0))) & (ap_loop_exit_ready_pp0_iter1_reg == 1'b1) & (1'b1 == ap_CS_iter1_fsm_state2))) begin
        ap_done_int = 1'b1;
    end else begin
        ap_done_int = ap_done_reg;
    end
end

always @ (*) begin
    if (((ap_start_int == 1'b0) & (1'b1 == ap_CS_iter1_fsm_state0) & (1'b1 == ap_CS_iter0_fsm_state1))) begin
        ap_idle = 1'b1;
    end else begin
        ap_idle = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((1'b1 == ap_CS_iter1_fsm_state2) & ((1'b1 == ap_block_state2_io) | ((icmp_ln174_reg_396 == 1'd0) & (out_V_TREADY == 1'b0))))) & (1'b1 == ap_CS_iter0_fsm_state1))) begin
        ap_ready_int = 1'b1;
    end else begin
        ap_ready_int = 1'b0;
    end
end

always @ (*) begin
    if (((1'b1 == ap_CS_iter0_fsm_state1) & (ap_loop_init == 1'b1))) begin
        ap_sig_allocacmp_outpix_1 = 4'd0;
    end else begin
        ap_sig_allocacmp_outpix_1 = outpix_fu_72;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((1'b1 == ap_CS_iter1_fsm_state2) & ((1'b1 == ap_block_state2_io) | ((icmp_ln174_reg_396 == 1'd0) & (out_V_TREADY == 1'b0))))) & (icmp_ln174_fu_315_p2 == 1'd0) & (1'b1 == ap_CS_iter0_fsm_state1))) begin
        buf_V_10_ce0 = 1'b1;
    end else begin
        buf_V_10_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((1'b1 == ap_CS_iter1_fsm_state2) & ((1'b1 == ap_block_state2_io) | ((icmp_ln174_reg_396 == 1'd0) & (out_V_TREADY == 1'b0))))) & (icmp_ln174_fu_315_p2 == 1'd0) & (1'b1 == ap_CS_iter0_fsm_state1))) begin
        buf_V_10_we0 = 1'b1;
    end else begin
        buf_V_10_we0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((1'b1 == ap_CS_iter1_fsm_state2) & ((1'b1 == ap_block_state2_io) | ((icmp_ln174_reg_396 == 1'd0) & (out_V_TREADY == 1'b0))))) & (icmp_ln174_fu_315_p2 == 1'd0) & (1'b1 == ap_CS_iter0_fsm_state1))) begin
        buf_V_11_ce0 = 1'b1;
    end else begin
        buf_V_11_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((1'b1 == ap_CS_iter1_fsm_state2) & ((1'b1 == ap_block_state2_io) | ((icmp_ln174_reg_396 == 1'd0) & (out_V_TREADY == 1'b0))))) & (icmp_ln174_fu_315_p2 == 1'd0) & (1'b1 == ap_CS_iter0_fsm_state1))) begin
        buf_V_11_we0 = 1'b1;
    end else begin
        buf_V_11_we0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((1'b1 == ap_CS_iter1_fsm_state2) & ((1'b1 == ap_block_state2_io) | ((icmp_ln174_reg_396 == 1'd0) & (out_V_TREADY == 1'b0))))) & (icmp_ln174_fu_315_p2 == 1'd0) & (1'b1 == ap_CS_iter0_fsm_state1))) begin
        buf_V_12_ce0 = 1'b1;
    end else begin
        buf_V_12_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((1'b1 == ap_CS_iter1_fsm_state2) & ((1'b1 == ap_block_state2_io) | ((icmp_ln174_reg_396 == 1'd0) & (out_V_TREADY == 1'b0))))) & (icmp_ln174_fu_315_p2 == 1'd0) & (1'b1 == ap_CS_iter0_fsm_state1))) begin
        buf_V_12_we0 = 1'b1;
    end else begin
        buf_V_12_we0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((1'b1 == ap_CS_iter1_fsm_state2) & ((1'b1 == ap_block_state2_io) | ((icmp_ln174_reg_396 == 1'd0) & (out_V_TREADY == 1'b0))))) & (icmp_ln174_fu_315_p2 == 1'd0) & (1'b1 == ap_CS_iter0_fsm_state1))) begin
        buf_V_13_ce0 = 1'b1;
    end else begin
        buf_V_13_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((1'b1 == ap_CS_iter1_fsm_state2) & ((1'b1 == ap_block_state2_io) | ((icmp_ln174_reg_396 == 1'd0) & (out_V_TREADY == 1'b0))))) & (icmp_ln174_fu_315_p2 == 1'd0) & (1'b1 == ap_CS_iter0_fsm_state1))) begin
        buf_V_13_we0 = 1'b1;
    end else begin
        buf_V_13_we0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((1'b1 == ap_CS_iter1_fsm_state2) & ((1'b1 == ap_block_state2_io) | ((icmp_ln174_reg_396 == 1'd0) & (out_V_TREADY == 1'b0))))) & (icmp_ln174_fu_315_p2 == 1'd0) & (1'b1 == ap_CS_iter0_fsm_state1))) begin
        buf_V_14_ce0 = 1'b1;
    end else begin
        buf_V_14_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((1'b1 == ap_CS_iter1_fsm_state2) & ((1'b1 == ap_block_state2_io) | ((icmp_ln174_reg_396 == 1'd0) & (out_V_TREADY == 1'b0))))) & (icmp_ln174_fu_315_p2 == 1'd0) & (1'b1 == ap_CS_iter0_fsm_state1))) begin
        buf_V_14_we0 = 1'b1;
    end else begin
        buf_V_14_we0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((1'b1 == ap_CS_iter1_fsm_state2) & ((1'b1 == ap_block_state2_io) | ((icmp_ln174_reg_396 == 1'd0) & (out_V_TREADY == 1'b0))))) & (icmp_ln174_fu_315_p2 == 1'd0) & (1'b1 == ap_CS_iter0_fsm_state1))) begin
        buf_V_15_ce0 = 1'b1;
    end else begin
        buf_V_15_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((1'b1 == ap_CS_iter1_fsm_state2) & ((1'b1 == ap_block_state2_io) | ((icmp_ln174_reg_396 == 1'd0) & (out_V_TREADY == 1'b0))))) & (icmp_ln174_fu_315_p2 == 1'd0) & (1'b1 == ap_CS_iter0_fsm_state1))) begin
        buf_V_15_we0 = 1'b1;
    end else begin
        buf_V_15_we0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((1'b1 == ap_CS_iter1_fsm_state2) & ((1'b1 == ap_block_state2_io) | ((icmp_ln174_reg_396 == 1'd0) & (out_V_TREADY == 1'b0))))) & (icmp_ln174_fu_315_p2 == 1'd0) & (1'b1 == ap_CS_iter0_fsm_state1))) begin
        buf_V_1_ce0 = 1'b1;
    end else begin
        buf_V_1_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((1'b1 == ap_CS_iter1_fsm_state2) & ((1'b1 == ap_block_state2_io) | ((icmp_ln174_reg_396 == 1'd0) & (out_V_TREADY == 1'b0))))) & (icmp_ln174_fu_315_p2 == 1'd0) & (1'b1 == ap_CS_iter0_fsm_state1))) begin
        buf_V_1_we0 = 1'b1;
    end else begin
        buf_V_1_we0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((1'b1 == ap_CS_iter1_fsm_state2) & ((1'b1 == ap_block_state2_io) | ((icmp_ln174_reg_396 == 1'd0) & (out_V_TREADY == 1'b0))))) & (icmp_ln174_fu_315_p2 == 1'd0) & (1'b1 == ap_CS_iter0_fsm_state1))) begin
        buf_V_2_ce0 = 1'b1;
    end else begin
        buf_V_2_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((1'b1 == ap_CS_iter1_fsm_state2) & ((1'b1 == ap_block_state2_io) | ((icmp_ln174_reg_396 == 1'd0) & (out_V_TREADY == 1'b0))))) & (icmp_ln174_fu_315_p2 == 1'd0) & (1'b1 == ap_CS_iter0_fsm_state1))) begin
        buf_V_2_we0 = 1'b1;
    end else begin
        buf_V_2_we0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((1'b1 == ap_CS_iter1_fsm_state2) & ((1'b1 == ap_block_state2_io) | ((icmp_ln174_reg_396 == 1'd0) & (out_V_TREADY == 1'b0))))) & (icmp_ln174_fu_315_p2 == 1'd0) & (1'b1 == ap_CS_iter0_fsm_state1))) begin
        buf_V_3_ce0 = 1'b1;
    end else begin
        buf_V_3_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((1'b1 == ap_CS_iter1_fsm_state2) & ((1'b1 == ap_block_state2_io) | ((icmp_ln174_reg_396 == 1'd0) & (out_V_TREADY == 1'b0))))) & (icmp_ln174_fu_315_p2 == 1'd0) & (1'b1 == ap_CS_iter0_fsm_state1))) begin
        buf_V_3_we0 = 1'b1;
    end else begin
        buf_V_3_we0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((1'b1 == ap_CS_iter1_fsm_state2) & ((1'b1 == ap_block_state2_io) | ((icmp_ln174_reg_396 == 1'd0) & (out_V_TREADY == 1'b0))))) & (icmp_ln174_fu_315_p2 == 1'd0) & (1'b1 == ap_CS_iter0_fsm_state1))) begin
        buf_V_4_ce0 = 1'b1;
    end else begin
        buf_V_4_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((1'b1 == ap_CS_iter1_fsm_state2) & ((1'b1 == ap_block_state2_io) | ((icmp_ln174_reg_396 == 1'd0) & (out_V_TREADY == 1'b0))))) & (icmp_ln174_fu_315_p2 == 1'd0) & (1'b1 == ap_CS_iter0_fsm_state1))) begin
        buf_V_4_we0 = 1'b1;
    end else begin
        buf_V_4_we0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((1'b1 == ap_CS_iter1_fsm_state2) & ((1'b1 == ap_block_state2_io) | ((icmp_ln174_reg_396 == 1'd0) & (out_V_TREADY == 1'b0))))) & (icmp_ln174_fu_315_p2 == 1'd0) & (1'b1 == ap_CS_iter0_fsm_state1))) begin
        buf_V_5_ce0 = 1'b1;
    end else begin
        buf_V_5_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((1'b1 == ap_CS_iter1_fsm_state2) & ((1'b1 == ap_block_state2_io) | ((icmp_ln174_reg_396 == 1'd0) & (out_V_TREADY == 1'b0))))) & (icmp_ln174_fu_315_p2 == 1'd0) & (1'b1 == ap_CS_iter0_fsm_state1))) begin
        buf_V_5_we0 = 1'b1;
    end else begin
        buf_V_5_we0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((1'b1 == ap_CS_iter1_fsm_state2) & ((1'b1 == ap_block_state2_io) | ((icmp_ln174_reg_396 == 1'd0) & (out_V_TREADY == 1'b0))))) & (icmp_ln174_fu_315_p2 == 1'd0) & (1'b1 == ap_CS_iter0_fsm_state1))) begin
        buf_V_6_ce0 = 1'b1;
    end else begin
        buf_V_6_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((1'b1 == ap_CS_iter1_fsm_state2) & ((1'b1 == ap_block_state2_io) | ((icmp_ln174_reg_396 == 1'd0) & (out_V_TREADY == 1'b0))))) & (icmp_ln174_fu_315_p2 == 1'd0) & (1'b1 == ap_CS_iter0_fsm_state1))) begin
        buf_V_6_we0 = 1'b1;
    end else begin
        buf_V_6_we0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((1'b1 == ap_CS_iter1_fsm_state2) & ((1'b1 == ap_block_state2_io) | ((icmp_ln174_reg_396 == 1'd0) & (out_V_TREADY == 1'b0))))) & (icmp_ln174_fu_315_p2 == 1'd0) & (1'b1 == ap_CS_iter0_fsm_state1))) begin
        buf_V_7_ce0 = 1'b1;
    end else begin
        buf_V_7_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((1'b1 == ap_CS_iter1_fsm_state2) & ((1'b1 == ap_block_state2_io) | ((icmp_ln174_reg_396 == 1'd0) & (out_V_TREADY == 1'b0))))) & (icmp_ln174_fu_315_p2 == 1'd0) & (1'b1 == ap_CS_iter0_fsm_state1))) begin
        buf_V_7_we0 = 1'b1;
    end else begin
        buf_V_7_we0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((1'b1 == ap_CS_iter1_fsm_state2) & ((1'b1 == ap_block_state2_io) | ((icmp_ln174_reg_396 == 1'd0) & (out_V_TREADY == 1'b0))))) & (icmp_ln174_fu_315_p2 == 1'd0) & (1'b1 == ap_CS_iter0_fsm_state1))) begin
        buf_V_8_ce0 = 1'b1;
    end else begin
        buf_V_8_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((1'b1 == ap_CS_iter1_fsm_state2) & ((1'b1 == ap_block_state2_io) | ((icmp_ln174_reg_396 == 1'd0) & (out_V_TREADY == 1'b0))))) & (icmp_ln174_fu_315_p2 == 1'd0) & (1'b1 == ap_CS_iter0_fsm_state1))) begin
        buf_V_8_we0 = 1'b1;
    end else begin
        buf_V_8_we0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((1'b1 == ap_CS_iter1_fsm_state2) & ((1'b1 == ap_block_state2_io) | ((icmp_ln174_reg_396 == 1'd0) & (out_V_TREADY == 1'b0))))) & (icmp_ln174_fu_315_p2 == 1'd0) & (1'b1 == ap_CS_iter0_fsm_state1))) begin
        buf_V_9_ce0 = 1'b1;
    end else begin
        buf_V_9_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((1'b1 == ap_CS_iter1_fsm_state2) & ((1'b1 == ap_block_state2_io) | ((icmp_ln174_reg_396 == 1'd0) & (out_V_TREADY == 1'b0))))) & (icmp_ln174_fu_315_p2 == 1'd0) & (1'b1 == ap_CS_iter0_fsm_state1))) begin
        buf_V_9_we0 = 1'b1;
    end else begin
        buf_V_9_we0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((1'b1 == ap_CS_iter1_fsm_state2) & ((1'b1 == ap_block_state2_io) | ((icmp_ln174_reg_396 == 1'd0) & (out_V_TREADY == 1'b0))))) & (icmp_ln174_fu_315_p2 == 1'd0) & (1'b1 == ap_CS_iter0_fsm_state1))) begin
        buf_V_ce0 = 1'b1;
    end else begin
        buf_V_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((1'b1 == ap_CS_iter1_fsm_state2) & ((1'b1 == ap_block_state2_io) | ((icmp_ln174_reg_396 == 1'd0) & (out_V_TREADY == 1'b0))))) & (icmp_ln174_fu_315_p2 == 1'd0) & (1'b1 == ap_CS_iter0_fsm_state1))) begin
        buf_V_we0 = 1'b1;
    end else begin
        buf_V_we0 = 1'b0;
    end
end

always @ (*) begin
    if (((icmp_ln174_reg_396 == 1'd0) & (1'b1 == ap_CS_iter1_fsm_state2))) begin
        out_V_TDATA_blk_n = out_V_TREADY;
    end else begin
        out_V_TDATA_blk_n = 1'b1;
    end
end

always @ (*) begin
    if ((~((1'b1 == ap_block_state2_io) | ((icmp_ln174_reg_396 == 1'd0) & (out_V_TREADY == 1'b0))) & (icmp_ln174_reg_396 == 1'd0) & (1'b1 == ap_CS_iter1_fsm_state2))) begin
        out_V_TVALID = 1'b1;
    end else begin
        out_V_TVALID = 1'b0;
    end
end

always @ (*) begin
    case (ap_CS_iter0_fsm)
        ap_ST_iter0_fsm_state1 : begin
            ap_NS_iter0_fsm = ap_ST_iter0_fsm_state1;
        end
        default : begin
            ap_NS_iter0_fsm = 'bx;
        end
    endcase
end

always @ (*) begin
    case (ap_CS_iter1_fsm)
        ap_ST_iter1_fsm_state2 : begin
            if ((~((1'b1 == ap_block_state2_io) | ((icmp_ln174_reg_396 == 1'd0) & (out_V_TREADY == 1'b0))) & ((1'b0 == ap_CS_iter0_fsm_state1) | ((ap_start_int == 1'b0) & (1'b1 == ap_CS_iter0_fsm_state1))))) begin
                ap_NS_iter1_fsm = ap_ST_iter1_fsm_state0;
            end else if (((~((1'b1 == ap_block_state2_io) | ((icmp_ln174_reg_396 == 1'd0) & (out_V_TREADY == 1'b0))) & (ap_start_int == 1'b1) & (1'b1 == ap_CS_iter0_fsm_state1)) | (~((1'b1 == ap_block_state2_io) | ((icmp_ln174_reg_396 == 1'd0) & (out_V_TREADY == 1'b0))) & (icmp_ln174_reg_396_pp0_iter0_reg == 1'd1) & (1'b1 == ap_CS_iter1_fsm_state2)))) begin
                ap_NS_iter1_fsm = ap_ST_iter1_fsm_state2;
            end else begin
                ap_NS_iter1_fsm = ap_ST_iter1_fsm_state2;
            end
        end
        ap_ST_iter1_fsm_state0 : begin
            if ((~((ap_start_int == 1'b0) | ((1'b1 == ap_CS_iter1_fsm_state2) & ((1'b1 == ap_block_state2_io) | ((icmp_ln174_reg_396 == 1'd0) & (out_V_TREADY == 1'b0))))) & (1'b1 == ap_CS_iter0_fsm_state1))) begin
                ap_NS_iter1_fsm = ap_ST_iter1_fsm_state2;
            end else begin
                ap_NS_iter1_fsm = ap_ST_iter1_fsm_state0;
            end
        end
        default : begin
            ap_NS_iter1_fsm = 'bx;
        end
    endcase
end

assign add_ln174_fu_321_p2 = (ap_sig_allocacmp_outpix_1 + 4'd1);

assign ap_CS_iter0_fsm_state1 = ap_CS_iter0_fsm[32'd0];

assign ap_CS_iter1_fsm_state0 = ap_CS_iter1_fsm[32'd0];

assign ap_CS_iter1_fsm_state2 = ap_CS_iter1_fsm[32'd1];

always @ (*) begin
    ap_block_state1_pp0_stage0_iter0 = (ap_start_int == 1'b0);
end

always @ (*) begin
    ap_block_state2_io = ((icmp_ln174_reg_396 == 1'd0) & (out_V_TREADY == 1'b0));
end

always @ (*) begin
    ap_block_state2_pp0_stage0_iter1 = ((icmp_ln174_reg_396 == 1'd0) & (out_V_TREADY == 1'b0));
end

always @ (*) begin
    ap_condition_358 = (~((ap_start_int == 1'b0) | ((1'b1 == ap_CS_iter1_fsm_state2) & ((1'b1 == ap_block_state2_io) | ((icmp_ln174_reg_396 == 1'd0) & (out_V_TREADY == 1'b0))))) & (1'b1 == ap_CS_iter0_fsm_state1));
end

assign ap_loop_exit_ready = ap_condition_exit_pp0_iter0_stage0;

assign buf_V_10_address0 = outpix_cast_fu_327_p1;

assign buf_V_10_d0 = 4'd0;

assign buf_V_11_address0 = outpix_cast_fu_327_p1;

assign buf_V_11_d0 = 4'd0;

assign buf_V_12_address0 = outpix_cast_fu_327_p1;

assign buf_V_12_d0 = 4'd0;

assign buf_V_13_address0 = outpix_cast_fu_327_p1;

assign buf_V_13_d0 = 4'd0;

assign buf_V_14_address0 = outpix_cast_fu_327_p1;

assign buf_V_14_d0 = 4'd0;

assign buf_V_15_address0 = outpix_cast_fu_327_p1;

assign buf_V_15_d0 = 4'd0;

assign buf_V_1_address0 = outpix_cast_fu_327_p1;

assign buf_V_1_d0 = 4'd0;

assign buf_V_2_address0 = outpix_cast_fu_327_p1;

assign buf_V_2_d0 = 4'd0;

assign buf_V_3_address0 = outpix_cast_fu_327_p1;

assign buf_V_3_d0 = 4'd0;

assign buf_V_4_address0 = outpix_cast_fu_327_p1;

assign buf_V_4_d0 = 4'd0;

assign buf_V_5_address0 = outpix_cast_fu_327_p1;

assign buf_V_5_d0 = 4'd0;

assign buf_V_6_address0 = outpix_cast_fu_327_p1;

assign buf_V_6_d0 = 4'd0;

assign buf_V_7_address0 = outpix_cast_fu_327_p1;

assign buf_V_7_d0 = 4'd0;

assign buf_V_8_address0 = outpix_cast_fu_327_p1;

assign buf_V_8_d0 = 4'd0;

assign buf_V_9_address0 = outpix_cast_fu_327_p1;

assign buf_V_9_d0 = 4'd0;

assign buf_V_address0 = outpix_cast_fu_327_p1;

assign buf_V_d0 = 4'd0;

assign icmp_ln174_fu_315_p2 = ((ap_sig_allocacmp_outpix_1 == 4'd14) ? 1'b1 : 1'b0);

assign icmp_ln174_reg_396_pp0_iter0_reg = icmp_ln174_reg_396;

assign out_V_TDATA = {{{{{{{{{{{{{{{{buf_V_15_q0}, {buf_V_14_q0}}, {buf_V_13_q0}}, {buf_V_12_q0}}, {buf_V_11_q0}}, {buf_V_10_q0}}, {buf_V_9_q0}}, {buf_V_8_q0}}, {buf_V_7_q0}}, {buf_V_6_q0}}, {buf_V_5_q0}}, {buf_V_4_q0}}, {buf_V_3_q0}}, {buf_V_2_q0}}, {buf_V_1_q0}}, {buf_V_q0}};

assign outpix_cast_fu_327_p1 = ap_sig_allocacmp_outpix_1;

endmodule //StreamingMaxPool_hls_0_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8
//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/code_gen_ipgen_StreamingFIFO_rtl_11_6ia4dms1/StreamingFIFO_rtl_11.v


/******************************************************************************
 * Copyright (C) 2024, Advanced Micro Devices, Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *  1. Redistributions of source code must retain the above copyright notice,
 *     this list of conditions and the following disclaimer.
 *
 *  2. Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *
 *  3. Neither the name of the copyright holder nor the names of its
 *     contributors may be used to endorse or promote products derived from
 *     this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION). HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *****************************************************************************/

module StreamingFIFO_rtl_11(
//- Global Control ------------------
(* X_INTERFACE_PARAMETER = "ASSOCIATED_BUSIF in0_V:out_V, ASSOCIATED_RESET = ap_rst_n" *)
(* X_INTERFACE_INFO = "xilinx.com:signal:clock:1.0 ap_clk CLK" *)
input   ap_clk,
(* X_INTERFACE_PARAMETER = "POLARITY ACTIVE_LOW" *)
input   ap_rst_n,

output [7:0] count,
output [7:0] maxcount,

//- AXI Stream - Input --------------
output   in0_V_TREADY,
input   in0_V_TVALID,
input  [127:0] in0_V_TDATA,

//- AXI Stream - Output --------------
input   out_V_TREADY,
output   out_V_TVALID,
output  [127:0] out_V_TDATA
);

Q_srl #(
.depth(196),
.width(128)
)
impl
(
 .clock(ap_clk),
 .reset(!ap_rst_n),
 .count(count),
 .maxcount(maxcount),
 .i_d(in0_V_TDATA),
 .i_v(in0_V_TVALID),
 .i_r(in0_V_TREADY),
 .o_d(out_V_TDATA),
 .o_v(out_V_TVALID),
 .o_r(out_V_TREADY)
);

endmodule
//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/vivado_stitch_proj_w5fn6zuu/finn_vivado_stitch_proj.gen/sources_1/bd/finn_design/ipshared/18e4/hdl/verilog/MVAU_hls_0_Matrix_Vector_Activate_Stream_Batch_p_ZL7threshs_2_ROM_AUTO_1R.v


// ==============================================================
// Vitis HLS - High-Level Synthesis from C, C++ and OpenCL v2022.2 (64-bit)
// Version: 2022.2
// Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.
// ==============================================================
`timescale 1 ns / 1 ps
module MVAU_hls_0_Matrix_Vector_Activate_Stream_Batch_p_ZL7threshs_2_ROM_AUTO_1R (
    address0, ce0, q0, 
    reset, clk);

parameter DataWidth = 12;
parameter AddressWidth = 4;
parameter AddressRange = 16;
 
input[AddressWidth-1:0] address0;
input ce0;
output reg[DataWidth-1:0] q0;

input reset;
input clk;

 
reg [DataWidth-1:0] rom0[0:AddressRange-1];


initial begin
     
    $readmemh("/home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/code_gen_ipgen_MVAU_hls_0_z2r2fzak/project_MVAU_hls_0/sol1/impl/ip/hdl/verilog/MVAU_hls_0_Matrix_Vector_Activate_Stream_Batch_p_ZL7threshs_2_ROM_AUTO_1R.dat", rom0);
end

  
always @(posedge clk) 
begin 
    if (ce0) 
    begin
        q0 <= rom0[address0];
    end
end


endmodule

//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/vivado_stitch_proj_w5fn6zuu/finn_vivado_stitch_proj.gen/sources_1/bd/finn_design/ip/finn_design_StreamingFIFO_rtl_10_0/synth/finn_design_StreamingFIFO_rtl_10_0.v


// (c) Copyright 1995-2026 Xilinx, Inc. All rights reserved.
// 
// This file contains confidential and proprietary information
// of Xilinx, Inc. and is protected under U.S. and
// international copyright and other intellectual property
// laws.
// 
// DISCLAIMER
// This disclaimer is not a license and does not grant any
// rights to the materials distributed herewith. Except as
// otherwise provided in a valid license issued to you by
// Xilinx, and to the maximum extent permitted by applicable
// law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
// WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
// AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
// BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
// INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
// (2) Xilinx shall not be liable (whether in contract or tort,
// including negligence, or under any other theory of
// liability) for any loss or damage of any kind or nature
// related to, arising under or in connection with these
// materials, including for any direct, or any indirect,
// special, incidental, or consequential loss or damage
// (including loss of data, profits, goodwill, or any type of
// loss or damage suffered as a result of any action brought
// by a third party) even if such damage or loss was
// reasonably foreseeable or Xilinx had been advised of the
// possibility of the same.
// 
// CRITICAL APPLICATIONS
// Xilinx products are not designed or intended to be fail-
// safe, or for use in any application requiring fail-safe
// performance, such as life-support or safety devices or
// systems, Class III medical devices, nuclear facilities,
// applications related to the deployment of airbags, or any
// other applications that could lead to death, personal
// injury, or severe property or environmental damage
// (individually and collectively, "Critical
// Applications"). Customer assumes the sole risk and
// liability of any use of Xilinx products in Critical
// Applications, subject only to applicable laws and
// regulations governing limitations on product liability.
// 
// THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
// PART OF THIS FILE AT ALL TIMES.
// 
// DO NOT MODIFY THIS FILE.


// IP VLNV: xilinx.com:module_ref:StreamingFIFO_rtl_10:1.0
// IP Revision: 1

(* X_CORE_INFO = "StreamingFIFO_rtl_10,Vivado 2022.2" *)
(* CHECK_LICENSE_TYPE = "finn_design_StreamingFIFO_rtl_10_0,StreamingFIFO_rtl_10,{}" *)
(* CORE_GENERATION_INFO = "finn_design_StreamingFIFO_rtl_10_0,StreamingFIFO_rtl_10,{x_ipProduct=Vivado 2022.2,x_ipVendor=xilinx.com,x_ipLibrary=module_ref,x_ipName=StreamingFIFO_rtl_10,x_ipVersion=1.0,x_ipCoreRevision=1,x_ipLanguage=VERILOG,x_ipSimLanguage=MIXED}" *)
(* IP_DEFINITION_SOURCE = "module_ref" *)
(* DowngradeIPIdentifiedWarnings = "yes" *)
module finn_design_StreamingFIFO_rtl_10_0 (
  ap_clk,
  ap_rst_n,
  count,
  maxcount,
  in0_V_TREADY,
  in0_V_TVALID,
  in0_V_TDATA,
  out_V_TREADY,
  out_V_TVALID,
  out_V_TDATA
);

(* X_INTERFACE_PARAMETER = "XIL_INTERFACENAME ap_clk, ASSOCIATED_RESET ap_rst_n, ASSOCIATED_BUSIF in0_V:out_V, FREQ_HZ 100000000, FREQ_TOLERANCE_HZ 0, PHASE 0.0, CLK_DOMAIN finn_design_ap_clk_0, INSERT_VIP 0" *)
(* X_INTERFACE_INFO = "xilinx.com:signal:clock:1.0 ap_clk CLK" *)
input wire ap_clk;
(* X_INTERFACE_PARAMETER = "XIL_INTERFACENAME ap_rst_n, POLARITY ACTIVE_LOW, INSERT_VIP 0" *)
(* X_INTERFACE_INFO = "xilinx.com:signal:reset:1.0 ap_rst_n RST" *)
input wire ap_rst_n;
output wire [12 : 0] count;
output wire [12 : 0] maxcount;
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 in0_V TREADY" *)
output wire in0_V_TREADY;
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 in0_V TVALID" *)
input wire in0_V_TVALID;
(* X_INTERFACE_PARAMETER = "XIL_INTERFACENAME in0_V, TDATA_NUM_BYTES 1, TDEST_WIDTH 0, TID_WIDTH 0, TUSER_WIDTH 0, HAS_TREADY 1, HAS_TSTRB 0, HAS_TKEEP 0, HAS_TLAST 0, FREQ_HZ 100000000, PHASE 0.0, CLK_DOMAIN finn_design_ap_clk_0, LAYERED_METADATA undef, INSERT_VIP 0" *)
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 in0_V TDATA" *)
input wire [7 : 0] in0_V_TDATA;
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 out_V TREADY" *)
input wire out_V_TREADY;
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 out_V TVALID" *)
output wire out_V_TVALID;
(* X_INTERFACE_PARAMETER = "XIL_INTERFACENAME out_V, TDATA_NUM_BYTES 1, TDEST_WIDTH 0, TID_WIDTH 0, TUSER_WIDTH 0, HAS_TREADY 1, HAS_TSTRB 0, HAS_TKEEP 0, HAS_TLAST 0, FREQ_HZ 100000000, PHASE 0.0, CLK_DOMAIN finn_design_ap_clk_0, LAYERED_METADATA undef, INSERT_VIP 0" *)
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 out_V TDATA" *)
output wire [7 : 0] out_V_TDATA;

  StreamingFIFO_rtl_10 inst (
    .ap_clk(ap_clk),
    .ap_rst_n(ap_rst_n),
    .count(count),
    .maxcount(maxcount),
    .in0_V_TREADY(in0_V_TREADY),
    .in0_V_TVALID(in0_V_TVALID),
    .in0_V_TDATA(in0_V_TDATA),
    .out_V_TREADY(out_V_TREADY),
    .out_V_TVALID(out_V_TVALID),
    .out_V_TDATA(out_V_TDATA)
  );
endmodule
//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/vivado_stitch_proj_w5fn6zuu/finn_vivado_stitch_proj.gen/sources_1/bd/finn_design/ipshared/fb57/hdl/verilog/MVAU_hls_1_Matrix_Vector_Activate_Stream_Batch_p_ZL7threshs_11_ROM_AUTO_1R.v


// ==============================================================
// Vitis HLS - High-Level Synthesis from C, C++ and OpenCL v2022.2 (64-bit)
// Version: 2022.2
// Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.
// ==============================================================
`timescale 1 ns / 1 ps
module MVAU_hls_1_Matrix_Vector_Activate_Stream_Batch_p_ZL7threshs_11_ROM_AUTO_1R (
    address0, ce0, q0, 
    reset, clk);

parameter DataWidth = 10;
parameter AddressWidth = 5;
parameter AddressRange = 32;
 
input[AddressWidth-1:0] address0;
input ce0;
output reg[DataWidth-1:0] q0;

input reset;
input clk;

 
reg [DataWidth-1:0] rom0[0:AddressRange-1];


initial begin
     
    $readmemh("/home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/code_gen_ipgen_MVAU_hls_1__774deg0/project_MVAU_hls_1/sol1/impl/ip/hdl/verilog/MVAU_hls_1_Matrix_Vector_Activate_Stream_Batch_p_ZL7threshs_11_ROM_AUTO_1R.dat", rom0);
end

  
always @(posedge clk) 
begin 
    if (ce0) 
    begin
        q0 <= rom0[address0];
    end
end


endmodule

//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/code_gen_ipgen_StreamingFIFO_rtl_0_08tq8umn/Q_srl.v


// original source:
// https://github.com/nachiket/tdfc/blob/master/verilog/queues/Q_srl_oreg3_prefull_SIMPLE.v


// Copyright (c) 1999 The Regents of the University of California
// Copyright (c) 2010 The Regents of the University of Pennsylvania
// Copyright (c) 2011 Department of Electrical and Electronic Engineering, Imperial College London
// Copyright (c) 2020 Xilinx
//
// Permission to use, copy, modify, and distribute this software and
// its documentation for any purpose, without fee, and without a
// written agreement is hereby granted, provided that the above copyright
// notice and this paragraph and the following two paragraphs appear in
// all copies.
//
// IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR
// DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
// LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION,
// EVEN IF THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
// THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
// INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
// AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE PROVIDED HEREUNDER IS ON
// AN "AS IS" BASIS, AND THE UNIVERSITY OF CALIFORNIA HAS NO OBLIGATIONS TO
// PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
//

// Q_srl_oreg3_prefull_SIMPLE.v
//
//  - In-page queue with parameterizable depth, bit width
//  - Stream I/O is triple (data, valid, back-pressure),
//      with EOS concatenated into the data
//  - Flow control for input & output is combinationally decoupled
//  - 2 <= depth <= 256
//      * (depth >= 2)  is required to decouple I/O flow control,
//          where empty => no produce,  full => no consume,
//          and depth 1 would ping-pong between the two at half rate
//      * (depth <= 256) can be modified
//           by changing ''synthesis loop_limit X'' below
//          and changing ''addrwidth'' or its log computation
//  - 1 <= width
//  - Queue storage is in SRL16E, up to depth 16 per LUT per bit-slice,
//      plus output register (for fast output)
//  - Queue addressing is done by ''addr'' up-down counter
//  - Queue fullness is checked by comparator (addr==depth)
//  - Queue fullness                           is pre-computed for next cycle
//  - Queue input back-pressure                is pre-computed for next cycle
//  - Queue output valid (state!=state__empty) is pre-computed for next cycle
//      (necessary since SRL data output reg requires non-boolean state)
//  - FSM has 3 states (empty, one, more)
//  - When empty, continue to emit most recently emitted value (for debugging)
//
//  - Queue slots used      = / (state==state_empty) ? 0
//                            | (state==state_one)   ? 1
//                            \ (state==state_more)  ? addr+2
//  - Queue slots used     <=  depth
//  - Queue slots remaining =  depth - used
//                          = / (state==state_empty) ? depth
//                            | (state==state_one)   ? depth-1
//                            \ (state==state_more)  ? depth-2-addr
//
//  - Synplify 7.1 / 8.0
//  - Eylon Caspi,  9/11/03, 8/18/04, 3/29/05


`ifdef  Q_srl
`else
`define Q_srl


module Q_srl (clock, reset, i_d, i_v, i_r, o_d, o_v, o_r, count, maxcount);

   parameter depth = 16;   // - greatest #items in queue  (2 <= depth <= 256)
   parameter width = 16;   // - width of data (i_d, o_d)

   localparam countwidth = $clog2(depth + 1);
   localparam addrwidth = $clog2(depth);

   input     clock;
   input     reset;

   input  [width-1:0] i_d;	// - input  stream data (concat data + eos)
   input              i_v;	// - input  stream valid
   output             i_r;	// - input  stream ready
   wire               i_b;  // - input  stream back-pressure

   output [width-1:0] o_d;	// - output stream data (concat data + eos)
   output             o_v;	// - output stream valid
   input              o_r;	// - output stream ready
   wire               o_b;	// - output stream back-pressure

   output [countwidth-1:0] count;  // - output number of elems in queue
   output [countwidth-1:0] maxcount;  // - maximum observed count since reset

   reg [countwidth-1:0] maxcount_reg;  // - maximum count seen until now
   reg    [addrwidth-1:0] addr, addr_, a_;		// - SRL16 address
							//     for data output
   reg 			  shift_en_;			// - SRL16 shift enable
   reg    [width-1:0] 	  srl [depth-2:0];		// - SRL16 memory
   reg 			  shift_en_o_;			// - SRLO  shift enable
   reg    [width-1:0] 	  srlo_, srlo			// - SRLO  output reg
			  /* synthesis syn_allow_retiming=0 */ ;

   parameter state_empty = 2'd0;    // - state empty : o_v=0 o_d=UNDEFINED
   parameter state_one   = 2'd1;    // - state one   : o_v=1 o_d=srlo
   parameter state_more  = 2'd2;    // - state more  : o_v=1 o_d=srlo
				    //     #items in srl = addr+2

   reg [1:0] state, state_;	    // - state register

   wire      addr_full_;	    // - true iff addr==depth-2 on NEXT cycle
   reg       addr_full; 	    // - true iff addr==depth-2
   wire      addr_zero_;	    // - true iff addr==0
   wire      o_v_reg_;		    // - true iff state_empty   on NEXT cycle
   reg       o_v_reg  		    // - true iff state_empty
	     /* synthesis syn_allow_retiming=0 */ ;
   wire      i_b_reg_;		    // - true iff !full         on NEXT cycle
   reg       i_b_reg  		    // - true iff !full
	     /* synthesis syn_allow_retiming=0 */ ;

   assign addr_full_ = (state_==state_more) && (addr_==depth-2);
						// - queue full
   assign addr_zero_ = (addr==0);		// - queue contains 2 (or 1,0)
   assign o_v_reg_   = (state_!=state_empty);	// - output valid if non-empty
   assign i_b_reg_   = addr_full_;		// - input bp if full
   assign o_d = srlo;				// - output data from queue
   assign o_v = o_v_reg;			// - output valid if non-empty
   assign i_b = i_b_reg;			// - input bp if full
   assign maxcount = maxcount_reg;

   assign i_r = !i_b;
   assign o_b = !o_r;

   assign count = (state==state_more ? addr+2 : (state==state_one ? 1 : 0));

   // - ''always'' block with both FFs and SRL16 does not work,
   //      since FFs need reset but SRL16 does not

   always @(posedge clock) begin	// - seq always: FFs
      if (reset) begin
	 state     <= state_empty;
	 addr      <= 0;
         addr_full <= 0;
	 o_v_reg   <= 0;

	 i_b_reg   <= 0;
	 maxcount_reg <= 0;

      end
      else begin
	 state     <= state_;
	 addr      <= addr_;
         addr_full <= addr_full_;
	 o_v_reg   <= o_v_reg_;
	 i_b_reg   <= i_b_reg_;
	 maxcount_reg <= (count > maxcount_reg ? count : maxcount_reg);
      end
   end // always @ (posedge clock)

   always @(posedge clock) begin	// - seq always: srlo
      // - infer enabled output reg at end of shift chain
      // - input first element from i_d, all subsequent elements from SRL16
      if (reset) begin
	 srlo <= 0;
      end
      else begin
	 if (shift_en_o_) begin
	    srlo <= srlo_;
	 end
      end
   end // always @ (posedge clock)

   always @(posedge clock) begin			// - seq always: srl
      // - infer enabled SRL16E from shifting srl array
      // - no reset capability;  srl[] contents undefined on reset
      if (shift_en_) begin
	 // synthesis loop_limit 256
	 for (a_=depth-2; a_>0; a_=a_-1) begin
	    srl[a_] = srl[a_-1];
	 end
	 srl[0] <= i_d;
      end
   end // always @ (posedge clock or negedge reset)

   always @* begin					// - combi always
        srlo_       <=  'bx;
        shift_en_o_ <= 1'bx;
        shift_en_   <= 1'bx;
        addr_       <=  'bx;
        state_      <= 2'bx;
      case (state)

	state_empty: begin		    // - (empty, will not produce)
	      if (i_v) begin		    // - empty & i_v => consume
		 srlo_       <= i_d;
		 shift_en_o_ <= 1;
		 shift_en_   <= 1'bx;
		 addr_       <= 0;
		 state_      <= state_one;
	      end
	      else	begin		    // - empty & !i_v => idle
		 srlo_       <= 'bx;
		 shift_en_o_ <= 0;
		 shift_en_   <= 1'bx;
		 addr_       <= 0;
		 state_      <= state_empty;
	      end
	end

	state_one: begin		    // - (contains one)
	      if (i_v && o_b) begin	    // - one & i_v & o_b => consume
		 srlo_       <= 'bx;
		 shift_en_o_ <= 0;
		 shift_en_   <= 1;
		 addr_       <= 0;
		 state_      <= state_more;
	      end
	      else if (i_v && !o_b) begin   // - one & i_v & !o_b => cons+prod
		 srlo_       <= i_d;
		 shift_en_o_ <= 1;
		 shift_en_   <= 1;
		 addr_       <= 0;
		 state_      <= state_one;
	      end
	      else if (!i_v && o_b) begin   // - one & !i_v & o_b => idle
		 srlo_       <= 'bx;
		 shift_en_o_ <= 0;
		 shift_en_   <= 1'bx;
		 addr_       <= 0;
		 state_      <= state_one;
	      end
	      else if (!i_v && !o_b) begin  // - one & !i_v & !o_b => produce
		 srlo_       <= 'bx;
		 shift_en_o_ <= 0;
		 shift_en_   <= 1'bx;
		 addr_       <= 0;
		 state_      <= state_empty;
	      end
	end // case: state_one

	state_more: begin		    // - (contains more than one)
	   if (addr_full || (depth==2)) begin
					    // - (full, will not consume)
					    // - (full here if depth==2)
	      if (o_b) begin		    // - full & o_b => idle
		 srlo_       <= 'bx;
		 shift_en_o_ <= 0;
		 shift_en_   <= 0;
		 addr_       <= addr;
		 state_      <= state_more;
	      end
	      else begin		    // - full & !o_b => produce
		 srlo_       <= srl[addr];
		 shift_en_o_ <= 1;
		 shift_en_   <= 0;
//		 addr_       <= addr-1;
//		 state_      <= state_more;
		 addr_       <= addr_zero_ ? 0         : addr-1;
		 state_      <= addr_zero_ ? state_one : state_more;
	      end
	   end
	   else begin			    // - (mid: neither empty nor full)
	      if (i_v && o_b) begin	    // - mid & i_v & o_b => consume
		 srlo_       <= 'bx;
		 shift_en_o_ <= 0;
		 shift_en_   <= 1;
		 addr_       <= addr+1;
		 state_      <= state_more;
	      end
	      else if (i_v && !o_b) begin   // - mid & i_v & !o_b => cons+prod
		 srlo_       <= srl[addr];
		 shift_en_o_ <= 1;
		 shift_en_   <= 1;
		 addr_       <= addr;
		 state_      <= state_more;
	      end
	      else if (!i_v && o_b) begin   // - mid & !i_v & o_b => idle
		 srlo_       <= 'bx;
		 shift_en_o_ <= 0;
		 shift_en_   <= 0;
		 addr_       <= addr;
		 state_      <= state_more;
	      end
	      else if (!i_v && !o_b) begin  // - mid & !i_v & !o_b => produce
		 srlo_       <= srl[addr];
		 shift_en_o_ <= 1;
		 shift_en_   <= 0;
		 addr_       <= addr_zero_ ? 0         : addr-1;
		 state_      <= addr_zero_ ? state_one : state_more;
	      end
	   end // else: !if(addr_full)
	end // case: state_more

	default: begin
		 srlo_       <=  'bx;
		 shift_en_o_ <= 1'bx;
		 shift_en_   <= 1'bx;
		 addr_       <=  'bx;
		 state_      <= 2'bx;
	end // case: default

      endcase // case(state)
   end // always @ *

endmodule // Q_srl


`endif  // `ifdef  Q_srl
//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/code_gen_ipgen_StreamingFIFO_rtl_4_aqxw_l15/Q_srl.v


// original source:
// https://github.com/nachiket/tdfc/blob/master/verilog/queues/Q_srl_oreg3_prefull_SIMPLE.v


// Copyright (c) 1999 The Regents of the University of California
// Copyright (c) 2010 The Regents of the University of Pennsylvania
// Copyright (c) 2011 Department of Electrical and Electronic Engineering, Imperial College London
// Copyright (c) 2020 Xilinx
//
// Permission to use, copy, modify, and distribute this software and
// its documentation for any purpose, without fee, and without a
// written agreement is hereby granted, provided that the above copyright
// notice and this paragraph and the following two paragraphs appear in
// all copies.
//
// IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR
// DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
// LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION,
// EVEN IF THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
// THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
// INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
// AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE PROVIDED HEREUNDER IS ON
// AN "AS IS" BASIS, AND THE UNIVERSITY OF CALIFORNIA HAS NO OBLIGATIONS TO
// PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
//

// Q_srl_oreg3_prefull_SIMPLE.v
//
//  - In-page queue with parameterizable depth, bit width
//  - Stream I/O is triple (data, valid, back-pressure),
//      with EOS concatenated into the data
//  - Flow control for input & output is combinationally decoupled
//  - 2 <= depth <= 256
//      * (depth >= 2)  is required to decouple I/O flow control,
//          where empty => no produce,  full => no consume,
//          and depth 1 would ping-pong between the two at half rate
//      * (depth <= 256) can be modified
//           by changing ''synthesis loop_limit X'' below
//          and changing ''addrwidth'' or its log computation
//  - 1 <= width
//  - Queue storage is in SRL16E, up to depth 16 per LUT per bit-slice,
//      plus output register (for fast output)
//  - Queue addressing is done by ''addr'' up-down counter
//  - Queue fullness is checked by comparator (addr==depth)
//  - Queue fullness                           is pre-computed for next cycle
//  - Queue input back-pressure                is pre-computed for next cycle
//  - Queue output valid (state!=state__empty) is pre-computed for next cycle
//      (necessary since SRL data output reg requires non-boolean state)
//  - FSM has 3 states (empty, one, more)
//  - When empty, continue to emit most recently emitted value (for debugging)
//
//  - Queue slots used      = / (state==state_empty) ? 0
//                            | (state==state_one)   ? 1
//                            \ (state==state_more)  ? addr+2
//  - Queue slots used     <=  depth
//  - Queue slots remaining =  depth - used
//                          = / (state==state_empty) ? depth
//                            | (state==state_one)   ? depth-1
//                            \ (state==state_more)  ? depth-2-addr
//
//  - Synplify 7.1 / 8.0
//  - Eylon Caspi,  9/11/03, 8/18/04, 3/29/05


`ifdef  Q_srl
`else
`define Q_srl


module Q_srl (clock, reset, i_d, i_v, i_r, o_d, o_v, o_r, count, maxcount);

   parameter depth = 16;   // - greatest #items in queue  (2 <= depth <= 256)
   parameter width = 16;   // - width of data (i_d, o_d)

   localparam countwidth = $clog2(depth + 1);
   localparam addrwidth = $clog2(depth);

   input     clock;
   input     reset;

   input  [width-1:0] i_d;	// - input  stream data (concat data + eos)
   input              i_v;	// - input  stream valid
   output             i_r;	// - input  stream ready
   wire               i_b;  // - input  stream back-pressure

   output [width-1:0] o_d;	// - output stream data (concat data + eos)
   output             o_v;	// - output stream valid
   input              o_r;	// - output stream ready
   wire               o_b;	// - output stream back-pressure

   output [countwidth-1:0] count;  // - output number of elems in queue
   output [countwidth-1:0] maxcount;  // - maximum observed count since reset

   reg [countwidth-1:0] maxcount_reg;  // - maximum count seen until now
   reg    [addrwidth-1:0] addr, addr_, a_;		// - SRL16 address
							//     for data output
   reg 			  shift_en_;			// - SRL16 shift enable
   reg    [width-1:0] 	  srl [depth-2:0];		// - SRL16 memory
   reg 			  shift_en_o_;			// - SRLO  shift enable
   reg    [width-1:0] 	  srlo_, srlo			// - SRLO  output reg
			  /* synthesis syn_allow_retiming=0 */ ;

   parameter state_empty = 2'd0;    // - state empty : o_v=0 o_d=UNDEFINED
   parameter state_one   = 2'd1;    // - state one   : o_v=1 o_d=srlo
   parameter state_more  = 2'd2;    // - state more  : o_v=1 o_d=srlo
				    //     #items in srl = addr+2

   reg [1:0] state, state_;	    // - state register

   wire      addr_full_;	    // - true iff addr==depth-2 on NEXT cycle
   reg       addr_full; 	    // - true iff addr==depth-2
   wire      addr_zero_;	    // - true iff addr==0
   wire      o_v_reg_;		    // - true iff state_empty   on NEXT cycle
   reg       o_v_reg  		    // - true iff state_empty
	     /* synthesis syn_allow_retiming=0 */ ;
   wire      i_b_reg_;		    // - true iff !full         on NEXT cycle
   reg       i_b_reg  		    // - true iff !full
	     /* synthesis syn_allow_retiming=0 */ ;

   assign addr_full_ = (state_==state_more) && (addr_==depth-2);
						// - queue full
   assign addr_zero_ = (addr==0);		// - queue contains 2 (or 1,0)
   assign o_v_reg_   = (state_!=state_empty);	// - output valid if non-empty
   assign i_b_reg_   = addr_full_;		// - input bp if full
   assign o_d = srlo;				// - output data from queue
   assign o_v = o_v_reg;			// - output valid if non-empty
   assign i_b = i_b_reg;			// - input bp if full
   assign maxcount = maxcount_reg;

   assign i_r = !i_b;
   assign o_b = !o_r;

   assign count = (state==state_more ? addr+2 : (state==state_one ? 1 : 0));

   // - ''always'' block with both FFs and SRL16 does not work,
   //      since FFs need reset but SRL16 does not

   always @(posedge clock) begin	// - seq always: FFs
      if (reset) begin
	 state     <= state_empty;
	 addr      <= 0;
         addr_full <= 0;
	 o_v_reg   <= 0;

	 i_b_reg   <= 0;
	 maxcount_reg <= 0;

      end
      else begin
	 state     <= state_;
	 addr      <= addr_;
         addr_full <= addr_full_;
	 o_v_reg   <= o_v_reg_;
	 i_b_reg   <= i_b_reg_;
	 maxcount_reg <= (count > maxcount_reg ? count : maxcount_reg);
      end
   end // always @ (posedge clock)

   always @(posedge clock) begin	// - seq always: srlo
      // - infer enabled output reg at end of shift chain
      // - input first element from i_d, all subsequent elements from SRL16
      if (reset) begin
	 srlo <= 0;
      end
      else begin
	 if (shift_en_o_) begin
	    srlo <= srlo_;
	 end
      end
   end // always @ (posedge clock)

   always @(posedge clock) begin			// - seq always: srl
      // - infer enabled SRL16E from shifting srl array
      // - no reset capability;  srl[] contents undefined on reset
      if (shift_en_) begin
	 // synthesis loop_limit 256
	 for (a_=depth-2; a_>0; a_=a_-1) begin
	    srl[a_] = srl[a_-1];
	 end
	 srl[0] <= i_d;
      end
   end // always @ (posedge clock or negedge reset)

   always @* begin					// - combi always
        srlo_       <=  'bx;
        shift_en_o_ <= 1'bx;
        shift_en_   <= 1'bx;
        addr_       <=  'bx;
        state_      <= 2'bx;
      case (state)

	state_empty: begin		    // - (empty, will not produce)
	      if (i_v) begin		    // - empty & i_v => consume
		 srlo_       <= i_d;
		 shift_en_o_ <= 1;
		 shift_en_   <= 1'bx;
		 addr_       <= 0;
		 state_      <= state_one;
	      end
	      else	begin		    // - empty & !i_v => idle
		 srlo_       <= 'bx;
		 shift_en_o_ <= 0;
		 shift_en_   <= 1'bx;
		 addr_       <= 0;
		 state_      <= state_empty;
	      end
	end

	state_one: begin		    // - (contains one)
	      if (i_v && o_b) begin	    // - one & i_v & o_b => consume
		 srlo_       <= 'bx;
		 shift_en_o_ <= 0;
		 shift_en_   <= 1;
		 addr_       <= 0;
		 state_      <= state_more;
	      end
	      else if (i_v && !o_b) begin   // - one & i_v & !o_b => cons+prod
		 srlo_       <= i_d;
		 shift_en_o_ <= 1;
		 shift_en_   <= 1;
		 addr_       <= 0;
		 state_      <= state_one;
	      end
	      else if (!i_v && o_b) begin   // - one & !i_v & o_b => idle
		 srlo_       <= 'bx;
		 shift_en_o_ <= 0;
		 shift_en_   <= 1'bx;
		 addr_       <= 0;
		 state_      <= state_one;
	      end
	      else if (!i_v && !o_b) begin  // - one & !i_v & !o_b => produce
		 srlo_       <= 'bx;
		 shift_en_o_ <= 0;
		 shift_en_   <= 1'bx;
		 addr_       <= 0;
		 state_      <= state_empty;
	      end
	end // case: state_one

	state_more: begin		    // - (contains more than one)
	   if (addr_full || (depth==2)) begin
					    // - (full, will not consume)
					    // - (full here if depth==2)
	      if (o_b) begin		    // - full & o_b => idle
		 srlo_       <= 'bx;
		 shift_en_o_ <= 0;
		 shift_en_   <= 0;
		 addr_       <= addr;
		 state_      <= state_more;
	      end
	      else begin		    // - full & !o_b => produce
		 srlo_       <= srl[addr];
		 shift_en_o_ <= 1;
		 shift_en_   <= 0;
//		 addr_       <= addr-1;
//		 state_      <= state_more;
		 addr_       <= addr_zero_ ? 0         : addr-1;
		 state_      <= addr_zero_ ? state_one : state_more;
	      end
	   end
	   else begin			    // - (mid: neither empty nor full)
	      if (i_v && o_b) begin	    // - mid & i_v & o_b => consume
		 srlo_       <= 'bx;
		 shift_en_o_ <= 0;
		 shift_en_   <= 1;
		 addr_       <= addr+1;
		 state_      <= state_more;
	      end
	      else if (i_v && !o_b) begin   // - mid & i_v & !o_b => cons+prod
		 srlo_       <= srl[addr];
		 shift_en_o_ <= 1;
		 shift_en_   <= 1;
		 addr_       <= addr;
		 state_      <= state_more;
	      end
	      else if (!i_v && o_b) begin   // - mid & !i_v & o_b => idle
		 srlo_       <= 'bx;
		 shift_en_o_ <= 0;
		 shift_en_   <= 0;
		 addr_       <= addr;
		 state_      <= state_more;
	      end
	      else if (!i_v && !o_b) begin  // - mid & !i_v & !o_b => produce
		 srlo_       <= srl[addr];
		 shift_en_o_ <= 1;
		 shift_en_   <= 0;
		 addr_       <= addr_zero_ ? 0         : addr-1;
		 state_      <= addr_zero_ ? state_one : state_more;
	      end
	   end // else: !if(addr_full)
	end // case: state_more

	default: begin
		 srlo_       <=  'bx;
		 shift_en_o_ <= 1'bx;
		 shift_en_   <= 1'bx;
		 addr_       <=  'bx;
		 state_      <= 2'bx;
	end // case: default

      endcase // case(state)
   end // always @ *

endmodule // Q_srl


`endif  // `ifdef  Q_srl
//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/vivado_stitch_proj_w5fn6zuu/finn_vivado_stitch_proj.gen/sources_1/bd/finn_design/ip/finn_design_FMPadding_rtl_1_0/synth/finn_design_FMPadding_rtl_1_0.v


// (c) Copyright 1995-2026 Xilinx, Inc. All rights reserved.
// 
// This file contains confidential and proprietary information
// of Xilinx, Inc. and is protected under U.S. and
// international copyright and other intellectual property
// laws.
// 
// DISCLAIMER
// This disclaimer is not a license and does not grant any
// rights to the materials distributed herewith. Except as
// otherwise provided in a valid license issued to you by
// Xilinx, and to the maximum extent permitted by applicable
// law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
// WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
// AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
// BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
// INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
// (2) Xilinx shall not be liable (whether in contract or tort,
// including negligence, or under any other theory of
// liability) for any loss or damage of any kind or nature
// related to, arising under or in connection with these
// materials, including for any direct, or any indirect,
// special, incidental, or consequential loss or damage
// (including loss of data, profits, goodwill, or any type of
// loss or damage suffered as a result of any action brought
// by a third party) even if such damage or loss was
// reasonably foreseeable or Xilinx had been advised of the
// possibility of the same.
// 
// CRITICAL APPLICATIONS
// Xilinx products are not designed or intended to be fail-
// safe, or for use in any application requiring fail-safe
// performance, such as life-support or safety devices or
// systems, Class III medical devices, nuclear facilities,
// applications related to the deployment of airbags, or any
// other applications that could lead to death, personal
// injury, or severe property or environmental damage
// (individually and collectively, "Critical
// Applications"). Customer assumes the sole risk and
// liability of any use of Xilinx products in Critical
// Applications, subject only to applicable laws and
// regulations governing limitations on product liability.
// 
// THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
// PART OF THIS FILE AT ALL TIMES.
// 
// DO NOT MODIFY THIS FILE.


// IP VLNV: xilinx.com:module_ref:FMPadding_rtl_1:1.0
// IP Revision: 1

(* X_CORE_INFO = "FMPadding_rtl_1,Vivado 2022.2" *)
(* CHECK_LICENSE_TYPE = "finn_design_FMPadding_rtl_1_0,FMPadding_rtl_1,{}" *)
(* CORE_GENERATION_INFO = "finn_design_FMPadding_rtl_1_0,FMPadding_rtl_1,{x_ipProduct=Vivado 2022.2,x_ipVendor=xilinx.com,x_ipLibrary=module_ref,x_ipName=FMPadding_rtl_1,x_ipVersion=1.0,x_ipCoreRevision=1,x_ipLanguage=VERILOG,x_ipSimLanguage=MIXED}" *)
(* IP_DEFINITION_SOURCE = "module_ref" *)
(* DowngradeIPIdentifiedWarnings = "yes" *)
module finn_design_FMPadding_rtl_1_0 (
  ap_clk,
  ap_rst_n,
  s_axilite_AWVALID,
  s_axilite_AWREADY,
  s_axilite_AWADDR,
  s_axilite_WVALID,
  s_axilite_WREADY,
  s_axilite_WDATA,
  s_axilite_WSTRB,
  s_axilite_BVALID,
  s_axilite_BREADY,
  s_axilite_BRESP,
  s_axilite_ARVALID,
  s_axilite_ARREADY,
  s_axilite_ARADDR,
  s_axilite_RVALID,
  s_axilite_RREADY,
  s_axilite_RDATA,
  s_axilite_RRESP,
  in0_V_TREADY,
  in0_V_TVALID,
  in0_V_TDATA,
  out_V_TREADY,
  out_V_TVALID,
  out_V_TDATA
);

(* X_INTERFACE_PARAMETER = "XIL_INTERFACENAME ap_clk, ASSOCIATED_RESET ap_rst_n, ASSOCIATED_BUSIF in0_V:out_V:s_axilite, FREQ_HZ 100000000, FREQ_TOLERANCE_HZ 0, PHASE 0.0, CLK_DOMAIN finn_design_ap_clk_0, INSERT_VIP 0" *)
(* X_INTERFACE_INFO = "xilinx.com:signal:clock:1.0 ap_clk CLK" *)
input wire ap_clk;
(* X_INTERFACE_PARAMETER = "XIL_INTERFACENAME ap_rst_n, POLARITY ACTIVE_LOW, INSERT_VIP 0" *)
(* X_INTERFACE_INFO = "xilinx.com:signal:reset:1.0 ap_rst_n RST" *)
input wire ap_rst_n;
(* X_INTERFACE_INFO = "xilinx.com:interface:aximm:1.0 s_axilite AWVALID" *)
input wire s_axilite_AWVALID;
(* X_INTERFACE_INFO = "xilinx.com:interface:aximm:1.0 s_axilite AWREADY" *)
output wire s_axilite_AWREADY;
(* X_INTERFACE_INFO = "xilinx.com:interface:aximm:1.0 s_axilite AWADDR" *)
input wire [4 : 0] s_axilite_AWADDR;
(* X_INTERFACE_INFO = "xilinx.com:interface:aximm:1.0 s_axilite WVALID" *)
input wire s_axilite_WVALID;
(* X_INTERFACE_INFO = "xilinx.com:interface:aximm:1.0 s_axilite WREADY" *)
output wire s_axilite_WREADY;
(* X_INTERFACE_INFO = "xilinx.com:interface:aximm:1.0 s_axilite WDATA" *)
input wire [31 : 0] s_axilite_WDATA;
(* X_INTERFACE_INFO = "xilinx.com:interface:aximm:1.0 s_axilite WSTRB" *)
input wire [3 : 0] s_axilite_WSTRB;
(* X_INTERFACE_INFO = "xilinx.com:interface:aximm:1.0 s_axilite BVALID" *)
output wire s_axilite_BVALID;
(* X_INTERFACE_INFO = "xilinx.com:interface:aximm:1.0 s_axilite BREADY" *)
input wire s_axilite_BREADY;
(* X_INTERFACE_INFO = "xilinx.com:interface:aximm:1.0 s_axilite BRESP" *)
output wire [1 : 0] s_axilite_BRESP;
(* X_INTERFACE_INFO = "xilinx.com:interface:aximm:1.0 s_axilite ARVALID" *)
input wire s_axilite_ARVALID;
(* X_INTERFACE_INFO = "xilinx.com:interface:aximm:1.0 s_axilite ARREADY" *)
output wire s_axilite_ARREADY;
(* X_INTERFACE_INFO = "xilinx.com:interface:aximm:1.0 s_axilite ARADDR" *)
input wire [4 : 0] s_axilite_ARADDR;
(* X_INTERFACE_INFO = "xilinx.com:interface:aximm:1.0 s_axilite RVALID" *)
output wire s_axilite_RVALID;
(* X_INTERFACE_INFO = "xilinx.com:interface:aximm:1.0 s_axilite RREADY" *)
input wire s_axilite_RREADY;
(* X_INTERFACE_INFO = "xilinx.com:interface:aximm:1.0 s_axilite RDATA" *)
output wire [31 : 0] s_axilite_RDATA;
(* X_INTERFACE_PARAMETER = "XIL_INTERFACENAME s_axilite, DATA_WIDTH 32, PROTOCOL AXI4LITE, FREQ_HZ 100000000, ID_WIDTH 0, ADDR_WIDTH 5, AWUSER_WIDTH 0, ARUSER_WIDTH 0, WUSER_WIDTH 0, RUSER_WIDTH 0, BUSER_WIDTH 0, READ_WRITE_MODE READ_WRITE, HAS_BURST 0, HAS_LOCK 0, HAS_PROT 0, HAS_CACHE 0, HAS_QOS 0, HAS_REGION 0, HAS_WSTRB 1, HAS_BRESP 1, HAS_RRESP 1, SUPPORTS_NARROW_BURST 0, NUM_READ_OUTSTANDING 1, NUM_WRITE_OUTSTANDING 1, MAX_BURST_LENGTH 1, PHASE 0.0, CLK_DOMAIN finn_design_ap_clk_0, NUM_READ_THREADS 1, NUM_WRITE_THREA\
DS 1, RUSER_BITS_PER_BYTE 0, WUSER_BITS_PER_BYTE 0, INSERT_VIP 0" *)
(* X_INTERFACE_INFO = "xilinx.com:interface:aximm:1.0 s_axilite RRESP" *)
output wire [1 : 0] s_axilite_RRESP;
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 in0_V TREADY" *)
output wire in0_V_TREADY;
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 in0_V TVALID" *)
input wire in0_V_TVALID;
(* X_INTERFACE_PARAMETER = "XIL_INTERFACENAME in0_V, TDATA_NUM_BYTES 8, TDEST_WIDTH 0, TID_WIDTH 0, TUSER_WIDTH 0, HAS_TREADY 1, HAS_TSTRB 0, HAS_TKEEP 0, HAS_TLAST 0, FREQ_HZ 100000000, PHASE 0.0, CLK_DOMAIN finn_design_ap_clk_0, LAYERED_METADATA undef, INSERT_VIP 0" *)
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 in0_V TDATA" *)
input wire [63 : 0] in0_V_TDATA;
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 out_V TREADY" *)
input wire out_V_TREADY;
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 out_V TVALID" *)
output wire out_V_TVALID;
(* X_INTERFACE_PARAMETER = "XIL_INTERFACENAME out_V, TDATA_NUM_BYTES 8, TDEST_WIDTH 0, TID_WIDTH 0, TUSER_WIDTH 0, HAS_TREADY 1, HAS_TSTRB 0, HAS_TKEEP 0, HAS_TLAST 0, FREQ_HZ 100000000, PHASE 0.0, CLK_DOMAIN finn_design_ap_clk_0, LAYERED_METADATA undef, INSERT_VIP 0" *)
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 out_V TDATA" *)
output wire [63 : 0] out_V_TDATA;

  FMPadding_rtl_1 inst (
    .ap_clk(ap_clk),
    .ap_rst_n(ap_rst_n),
    .s_axilite_AWVALID(s_axilite_AWVALID),
    .s_axilite_AWREADY(s_axilite_AWREADY),
    .s_axilite_AWADDR(s_axilite_AWADDR),
    .s_axilite_WVALID(s_axilite_WVALID),
    .s_axilite_WREADY(s_axilite_WREADY),
    .s_axilite_WDATA(s_axilite_WDATA),
    .s_axilite_WSTRB(s_axilite_WSTRB),
    .s_axilite_BVALID(s_axilite_BVALID),
    .s_axilite_BREADY(s_axilite_BREADY),
    .s_axilite_BRESP(s_axilite_BRESP),
    .s_axilite_ARVALID(s_axilite_ARVALID),
    .s_axilite_ARREADY(s_axilite_ARREADY),
    .s_axilite_ARADDR(s_axilite_ARADDR),
    .s_axilite_RVALID(s_axilite_RVALID),
    .s_axilite_RREADY(s_axilite_RREADY),
    .s_axilite_RDATA(s_axilite_RDATA),
    .s_axilite_RRESP(s_axilite_RRESP),
    .in0_V_TREADY(in0_V_TREADY),
    .in0_V_TVALID(in0_V_TVALID),
    .in0_V_TDATA(in0_V_TDATA),
    .out_V_TREADY(out_V_TREADY),
    .out_V_TVALID(out_V_TVALID),
    .out_V_TDATA(out_V_TDATA)
  );
endmodule
//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/vivado_stitch_proj_w5fn6zuu/finn_vivado_stitch_proj.gen/sources_1/bd/finn_design/ipshared/18e4/hdl/verilog/MVAU_hls_0_Matrix_Vector_Activate_Stream_Batch_p_ZL7threshs_11_ROM_AUTO_1R.v


// ==============================================================
// Vitis HLS - High-Level Synthesis from C, C++ and OpenCL v2022.2 (64-bit)
// Version: 2022.2
// Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.
// ==============================================================
`timescale 1 ns / 1 ps
module MVAU_hls_0_Matrix_Vector_Activate_Stream_Batch_p_ZL7threshs_11_ROM_AUTO_1R (
    address0, ce0, q0, 
    reset, clk);

parameter DataWidth = 12;
parameter AddressWidth = 4;
parameter AddressRange = 16;
 
input[AddressWidth-1:0] address0;
input ce0;
output reg[DataWidth-1:0] q0;

input reset;
input clk;

 
reg [DataWidth-1:0] rom0[0:AddressRange-1];


initial begin
     
    $readmemh("/home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/code_gen_ipgen_MVAU_hls_0_z2r2fzak/project_MVAU_hls_0/sol1/impl/ip/hdl/verilog/MVAU_hls_0_Matrix_Vector_Activate_Stream_Batch_p_ZL7threshs_11_ROM_AUTO_1R.dat", rom0);
end

  
always @(posedge clk) 
begin 
    if (ce0) 
    begin
        q0 <= rom0[address0];
    end
end


endmodule

//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/vivado_stitch_proj_w5fn6zuu/finn_vivado_stitch_proj.gen/sources_1/bd/finn_design/ip/finn_design_StreamingMaxPool_hls_0_0/synth/finn_design_StreamingMaxPool_hls_0_0.v


// (c) Copyright 1995-2026 Xilinx, Inc. All rights reserved.
// 
// This file contains confidential and proprietary information
// of Xilinx, Inc. and is protected under U.S. and
// international copyright and other intellectual property
// laws.
// 
// DISCLAIMER
// This disclaimer is not a license and does not grant any
// rights to the materials distributed herewith. Except as
// otherwise provided in a valid license issued to you by
// Xilinx, and to the maximum extent permitted by applicable
// law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
// WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
// AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
// BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
// INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
// (2) Xilinx shall not be liable (whether in contract or tort,
// including negligence, or under any other theory of
// liability) for any loss or damage of any kind or nature
// related to, arising under or in connection with these
// materials, including for any direct, or any indirect,
// special, incidental, or consequential loss or damage
// (including loss of data, profits, goodwill, or any type of
// loss or damage suffered as a result of any action brought
// by a third party) even if such damage or loss was
// reasonably foreseeable or Xilinx had been advised of the
// possibility of the same.
// 
// CRITICAL APPLICATIONS
// Xilinx products are not designed or intended to be fail-
// safe, or for use in any application requiring fail-safe
// performance, such as life-support or safety devices or
// systems, Class III medical devices, nuclear facilities,
// applications related to the deployment of airbags, or any
// other applications that could lead to death, personal
// injury, or severe property or environmental damage
// (individually and collectively, "Critical
// Applications"). Customer assumes the sole risk and
// liability of any use of Xilinx products in Critical
// Applications, subject only to applicable laws and
// regulations governing limitations on product liability.
// 
// THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
// PART OF THIS FILE AT ALL TIMES.
// 
// DO NOT MODIFY THIS FILE.


// IP VLNV: xilinx.com:hls:StreamingMaxPool_hls_0:1.0
// IP Revision: 2114489082

(* X_CORE_INFO = "StreamingMaxPool_hls_0,Vivado 2022.2" *)
(* CHECK_LICENSE_TYPE = "finn_design_StreamingMaxPool_hls_0_0,StreamingMaxPool_hls_0,{}" *)
(* CORE_GENERATION_INFO = "finn_design_StreamingMaxPool_hls_0_0,StreamingMaxPool_hls_0,{x_ipProduct=Vivado 2022.2,x_ipVendor=xilinx.com,x_ipLibrary=hls,x_ipName=StreamingMaxPool_hls_0,x_ipVersion=1.0,x_ipCoreRevision=2114489082,x_ipLanguage=VERILOG,x_ipSimLanguage=MIXED}" *)
(* IP_DEFINITION_SOURCE = "HLS" *)
(* DowngradeIPIdentifiedWarnings = "yes" *)
module finn_design_StreamingMaxPool_hls_0_0 (
  ap_clk,
  ap_rst_n,
  in0_V_TVALID,
  in0_V_TREADY,
  in0_V_TDATA,
  out_V_TVALID,
  out_V_TREADY,
  out_V_TDATA
);

(* X_INTERFACE_PARAMETER = "XIL_INTERFACENAME ap_clk, ASSOCIATED_BUSIF in0_V:out_V, ASSOCIATED_RESET ap_rst_n, FREQ_HZ 100000000, FREQ_TOLERANCE_HZ 0, PHASE 0.0, CLK_DOMAIN finn_design_ap_clk_0, INSERT_VIP 0" *)
(* X_INTERFACE_INFO = "xilinx.com:signal:clock:1.0 ap_clk CLK" *)
input wire ap_clk;
(* X_INTERFACE_PARAMETER = "XIL_INTERFACENAME ap_rst_n, POLARITY ACTIVE_LOW, INSERT_VIP 0" *)
(* X_INTERFACE_INFO = "xilinx.com:signal:reset:1.0 ap_rst_n RST" *)
input wire ap_rst_n;
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 in0_V TVALID" *)
input wire in0_V_TVALID;
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 in0_V TREADY" *)
output wire in0_V_TREADY;
(* X_INTERFACE_PARAMETER = "XIL_INTERFACENAME in0_V, TDATA_NUM_BYTES 8, TUSER_WIDTH 0, TDEST_WIDTH 0, TID_WIDTH 0, HAS_TREADY 1, HAS_TSTRB 0, HAS_TKEEP 0, HAS_TLAST 0, FREQ_HZ 100000000, PHASE 0.0, CLK_DOMAIN finn_design_ap_clk_0, INSERT_VIP 0" *)
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 in0_V TDATA" *)
input wire [63 : 0] in0_V_TDATA;
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 out_V TVALID" *)
output wire out_V_TVALID;
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 out_V TREADY" *)
input wire out_V_TREADY;
(* X_INTERFACE_PARAMETER = "XIL_INTERFACENAME out_V, TDATA_NUM_BYTES 8, TUSER_WIDTH 0, TDEST_WIDTH 0, TID_WIDTH 0, HAS_TREADY 1, HAS_TSTRB 0, HAS_TKEEP 0, HAS_TLAST 0, FREQ_HZ 100000000, PHASE 0.0, CLK_DOMAIN finn_design_ap_clk_0, INSERT_VIP 0" *)
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 out_V TDATA" *)
output wire [63 : 0] out_V_TDATA;

(* SDX_KERNEL = "true" *)
(* SDX_KERNEL_TYPE = "hls" *)
(* SDX_KERNEL_SYNTH_INST = "inst" *)
  StreamingMaxPool_hls_0 inst (
    .ap_clk(ap_clk),
    .ap_rst_n(ap_rst_n),
    .in0_V_TVALID(in0_V_TVALID),
    .in0_V_TREADY(in0_V_TREADY),
    .in0_V_TDATA(in0_V_TDATA),
    .out_V_TVALID(out_V_TVALID),
    .out_V_TREADY(out_V_TREADY),
    .out_V_TDATA(out_V_TDATA)
  );
endmodule
//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/code_gen_ipgen_StreamingFIFO_rtl_3_tnug1a14/StreamingFIFO_rtl_3.v


/******************************************************************************
 * Copyright (C) 2024, Advanced Micro Devices, Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *  1. Redistributions of source code must retain the above copyright notice,
 *     this list of conditions and the following disclaimer.
 *
 *  2. Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *
 *  3. Neither the name of the copyright holder nor the names of its
 *     contributors may be used to endorse or promote products derived from
 *     this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION). HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *****************************************************************************/

module StreamingFIFO_rtl_3(
//- Global Control ------------------
(* X_INTERFACE_PARAMETER = "ASSOCIATED_BUSIF in0_V:out_V, ASSOCIATED_RESET = ap_rst_n" *)
(* X_INTERFACE_INFO = "xilinx.com:signal:clock:1.0 ap_clk CLK" *)
input   ap_clk,
(* X_INTERFACE_PARAMETER = "POLARITY ACTIVE_LOW" *)
input   ap_rst_n,

output [14:0] count,
output [14:0] maxcount,

//- AXI Stream - Input --------------
output   in0_V_TREADY,
input   in0_V_TVALID,
input  [7:0] in0_V_TDATA,

//- AXI Stream - Output --------------
input   out_V_TREADY,
output   out_V_TVALID,
output  [7:0] out_V_TDATA
);

Q_srl #(
.depth(21168),
.width(8)
)
impl
(
 .clock(ap_clk),
 .reset(!ap_rst_n),
 .count(count),
 .maxcount(maxcount),
 .i_d(in0_V_TDATA),
 .i_v(in0_V_TVALID),
 .i_r(in0_V_TREADY),
 .o_d(out_V_TDATA),
 .o_v(out_V_TVALID),
 .o_r(out_V_TREADY)
);

endmodule
//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn-rtllib/mvu/mvu_vvu_8sx9_dsp58.sv


/******************************************************************************
 * Copyright (C) 2024, Advanced Micro Devices, Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *  1. Redistributions of source code must retain the above copyright notice,
 *     this list of conditions and the following disclaimer.
 *
 *  2. Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *
 *  3. Neither the name of the copyright holder nor the names of its
 *     contributors may be used to endorse or promote products derived from
 *     this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION). HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * @brief	Matrix/Vector Vector Unit (MVU/VVU) core compute kernel utilizing DSP58.
 *****************************************************************************/

module mvu_vvu_8sx9_dsp58 #(
	bit IS_MVU,
    int unsigned PE,
    int unsigned SIMD,
    int unsigned ACTIVATION_WIDTH,
    int unsigned WEIGHT_WIDTH,
	int unsigned ACCU_WIDTH,
    bit SIGNED_ACTIVATIONS = 0,
    int unsigned SEGMENTLEN = 0, // Default to 0 (which implies a single segment)
	bit FORCE_BEHAVIORAL = 0,

	localparam int unsigned ACTIVATION_ELEMENTS = (IS_MVU ? 1 : PE) * SIMD,
	localparam int unsigned WEIGHT_ELEMENTS = PE*SIMD
  )
  (
    // Global Control
	input   logic clk,
    input   logic rst,
    input   logic en,

	// Input
    input   logic last,
    input   logic zero, // ignore current inputs and force this partial product to zero
    input   logic [WEIGHT_ELEMENTS-1:0][WEIGHT_WIDTH-1:0] w, // weights
	input   logic [ACTIVATION_ELEMENTS-1:0][ACTIVATION_WIDTH-1:0] a, // activations

	// Ouput
	output  logic vld,
    output  logic [PE-1:0][ACCU_WIDTH-1:0] p
  );
	// for verilator always use behavioral code
	localparam bit  BEHAVIORAL =
`ifdef VERILATOR
		1 ||
`endif
		FORCE_BEHAVIORAL;

//-------------------- Declare global signals --------------------\\
	localparam int unsigned CHAINLEN = (SIMD+2)/3;
	localparam int unsigned SEGLEN = SEGMENTLEN == 0 ? CHAINLEN : SEGMENTLEN; // Additional constant to default a SEGMENTLEN of '0' to the DSP-chain length
	localparam int unsigned PE_ACTIVATION = IS_MVU ? 1 : PE;
	uwire [26:0] a_in_i [PE_ACTIVATION * CHAINLEN];
	uwire [23:0] b_in_i [PE][CHAINLEN];
	uwire [PE-1:0][CHAINLEN-1:0][57:0] pcout; // Array with packed dimension > 256 (with a loop-carried dependency) cannot be handled out-of-the-box with PyVerilator

//-------------------- Shift register for opmode select signal --------------------\\
	localparam int unsigned MAX_PIPELINE_STAGES = (CHAINLEN + SEGLEN-1)/SEGLEN; // >=1 (== number of pipeline registers + 1 (A/B inputs always have 1 register))
	logic L [0:1+MAX_PIPELINE_STAGES] = '{default: 0}; // After MAX_PIPELINE_STAGES (== number of pipeline stages for input data), we have 3 additional cycles latency (A/B reg, Mreg, Preg).
	// Thus, we add +2 (since OPMODE is buffered by 1 cycle in the DSP fabric)

	always_ff @(posedge clk) begin
		if(rst)     L <= '{default: 0};
		else if(en) begin
			L[1+MAX_PIPELINE_STAGES] <= last;
			L[0:MAX_PIPELINE_STAGES] <= L[1:1+MAX_PIPELINE_STAGES];
		end
	end
	assign vld = L[0];

//-------------------- Shift register for ZERO flag --------------------\\
	logic Z [0:MAX_PIPELINE_STAGES-2] = '{default:0}; // We need MAX_PIPELINE_STAGES-1 pipeline stages (note: INMODE is buffered inside DSP fabric)

	if (MAX_PIPELINE_STAGES > 1) begin : genZreg
		always_ff @(posedge clk) begin
			if (rst)      Z <= '{default: 0};
			else if(en) begin
				Z[0] <= zero;
				if (MAX_PIPELINE_STAGES > 2)  Z[1:MAX_PIPELINE_STAGES-2] <= Z[0:MAX_PIPELINE_STAGES-3];
			end
		end
	end;

//-------------------- Buffer for input activations --------------------\\
	localparam int unsigned PAD_BITS_ACT = 9 - ACTIVATION_WIDTH;
	for (genvar k=0; k<PE_ACTIVATION; k++) begin : genActPE
		for (genvar i=0; i<CHAINLEN; i++) begin : genActSIMD
			localparam int TOTAL_PREGS = i/SEGLEN;
			localparam int EXTERNAL_PREGS = TOTAL_PREGS>1 ? TOTAL_PREGS-1 : 0;
			localparam int LANES_OCCUPIED = i == CHAINLEN-1 ? SIMD - 3*i : 3;

			if (EXTERNAL_PREGS > 0) begin : genExternalPregAct
				logic [0:EXTERNAL_PREGS-1][LANES_OCCUPIED-1:0][ACTIVATION_WIDTH-1:0] A = '{ default : 0};
				always_ff @(posedge clk) begin
					if (rst)     A <= '{default: 0};
					else if(en) begin
						A[EXTERNAL_PREGS-1] <=
// synthesis translate_off
							zero ? '1 :
// synthesis translate_on
							a[SIMD*k + 3*i +: LANES_OCCUPIED];
						if (EXTERNAL_PREGS > 1)   A[0:EXTERNAL_PREGS-2] <= A[1:EXTERNAL_PREGS-1];
					end
				end
				for (genvar j=0; j<LANES_OCCUPIED; j++) begin : genAin
				assign a_in_i[CHAINLEN*k+i][9*j +: 9] = SIGNED_ACTIVATIONS ? PAD_BITS_ACT == 0 ? A[0][j] : { {PAD_BITS_ACT{A[0][j][ACTIVATION_WIDTH-1]}}, A[0][j] }
													  : PAD_BITS_ACT == 0 ? A[0][j] : { {PAD_BITS_ACT{1'b0}}, A[0][j] } ;
				end : genAin
				for (genvar j=LANES_OCCUPIED; j<3; j++) begin : genAinZero
					assign a_in_i[CHAINLEN*k+i][9*j +: 9] = 9'b0;
				end : genAinZero
			end : genExternalPregAct
			else begin : genInpDSPAct
				for (genvar j=0; j<LANES_OCCUPIED; j++) begin : genAin
					assign a_in_i[CHAINLEN*k+i][9*j +: 9] =
// synthesis translate_off
						zero ? '1 :
// synthesis translate_on
						SIGNED_ACTIVATIONS ? PAD_BITS_ACT == 0 ? a[SIMD*k+3*i+j] : { {PAD_BITS_ACT{a[SIMD*k+3*i+j][ACTIVATION_WIDTH-1]}}, a[SIMD*k+3*i+j] }
													: PAD_BITS_ACT == 0 ? a[SIMD*k+3*i+j] : { {PAD_BITS_ACT{1'b0}}, a[SIMD*k+3*i+j] } ;
				end : genAin
				for (genvar j=LANES_OCCUPIED; j<3; j++) begin : genAinZero
					assign a_in_i[CHAINLEN*k+i][9*j +: 9] = 9'b0;
				end : genAinZero
			end : genInpDSPAct
		end : genActSIMD
	end : genActPE

//-------------------- Buffer for weights --------------------\\
	localparam int unsigned PAD_BITS_WEIGHT = 8 - WEIGHT_WIDTH;

	for (genvar i=0; i<PE; i++) begin : genWeightPE
		for (genvar j=0; j<CHAINLEN; j++) begin : genWeightSIMD
			localparam int TOTAL_PREGS = j/SEGLEN;
			localparam int EXTERNAL_PREGS = TOTAL_PREGS>1 ? TOTAL_PREGS-1 : 0;
			localparam int LANES_OCCUPIED = j == CHAINLEN-1 ? SIMD - 3*j : 3;

			if (EXTERNAL_PREGS > 0) begin : genExternalPregWeight
				logic [0:PE-1][0:EXTERNAL_PREGS-1][LANES_OCCUPIED-1:0][WEIGHT_WIDTH-1:0] B = '{ default : 0};
				always_ff @(posedge clk) begin
					if (rst)    B <= '{default: 0};
					else if (en) begin
						B[i][EXTERNAL_PREGS-1] <=
// synthesis translate_off
							zero ? '1 :
// synthesis translate_on
							//w[i][3*j +: LANES_OCCUPIED];
							w[SIMD*i+3*j +: LANES_OCCUPIED];
						if (EXTERNAL_PREGS > 1) B[i][0:EXTERNAL_PREGS-2] <= B[i][1:EXTERNAL_PREGS-1];
					end
				end
				for (genvar k = 0 ; k < LANES_OCCUPIED ; k++) begin : genBin
					assign b_in_i[i][j][8*k +: 8] = PAD_BITS_WEIGHT == 0 ? B[i][0][k] : { {PAD_BITS_WEIGHT{B[i][0][k][WEIGHT_WIDTH-1]}}, B[i][0][k] };
				end : genBin
				for (genvar k=LANES_OCCUPIED; k<3; k++) begin : genBinZero
					assign b_in_i[i][j][8*k +: 8] = 8'b0;
				end : genBinZero
			end : genExternalPregWeight
			else begin : genInpDSPWeight
				for (genvar k = 0; k < LANES_OCCUPIED; k++) begin : genBin
					assign b_in_i[i][j][8*k +: 8] =
// synthesis translate_off
						zero ? '1 :
// synthesis translate_on
						PAD_BITS_WEIGHT == 0 ? w[SIMD*i+3*j+k] : { {PAD_BITS_WEIGHT{w[SIMD*i+3*j+k][WEIGHT_WIDTH-1]}}, w[SIMD*i+3*j+k] };
				end : genBin
				for (genvar k=LANES_OCCUPIED; k<3; k++) begin : genBinZero
					assign b_in_i[i][j][8*k +: 8] = 8'b0;
				end : genBinZero
			end : genInpDSPWeight
		end : genWeightSIMD
	end : genWeightPE

//-------------------- Instantiate PE x CHAINLEN DSPs --------------------\\
	for (genvar i=0; i<PE; i++) begin : genDSPPE
		for (genvar j=0; j<CHAINLEN; j++) begin : genDSPChain
			localparam int TOTAL_PREGS = j/SEGLEN;
			localparam int INTERNAL_PREGS = TOTAL_PREGS>0 ? 2 : 1; // 1 : 0
			localparam bit PREG = (j+1)%SEGLEN==0 || j == CHAINLEN-1;
			localparam bit FIRST = j == 0;
			localparam bit LAST = j == CHAINLEN-1;
			uwire [57:0] pp;

			if (LAST) begin : genPOUT
				assign p[i] = pp[ACCU_WIDTH-1:0];
			end

			// Note: Since the product B * AD is computed,
			//       rst can be only applied to AD and zero only to B
			//       with the same effect as zeroing both.
			if(BEHAVIORAL) begin : genBehav
				// Stage #1: Input A/B
				logic signed [33:0] Areg [INTERNAL_PREGS];
				always_ff @(posedge clk) begin
					if (rst)	Areg <= '{ default : 0};
					else if (en) begin
						Areg[0] <= { 7'bx, a_in_i[(IS_MVU ? 0 : CHAINLEN*i) + j] };
						if (INTERNAL_PREGS == 2) Areg[1] <= Areg[0];
					end
				end
				logic signed [23:0] Breg [INTERNAL_PREGS];
				always_ff @(posedge clk) begin
					if (rst)	Breg <= '{ default : 0};
					else if (en) begin
						Breg[0] <= b_in_i[i][j];
						if (INTERNAL_PREGS == 2) Breg[1] <= Breg[0];
					end
				end

				// Stage #2: Multiply-Accumulate
				logic signed [57:0] Mreg;
				logic InmodeZero = 0;
				always_ff @(posedge clk) begin
					if (rst)		InmodeZero <= 0;
					else if (en)	InmodeZero <= ( TOTAL_PREGS > 0 ? Z[TOTAL_PREGS-1] : zero );
				end
				always_ff @(posedge clk) begin
					if (rst)	Mreg <= 0;
					else if (en) begin
						automatic logic signed [57:0] m = 0;
						for (int k = 0; k < 3; k++) begin
							m = m + (InmodeZero ? 0 : $signed(Areg[INTERNAL_PREGS-1][9*k +: 9]) * $signed(Breg[INTERNAL_PREGS-1][8*k +: 8]));
						end
						Mreg <= m;
					end
				end

				// Stage #3: Accumulate
				logic signed [57:0] Preg;
				logic Opmode = 0;
				if (FIRST && !LAST) begin : genFirst
					if (PREG) begin : genPregBehav
						always_ff @(posedge clk) begin
							if (rst)		Preg <= 0;
							else if (en)	Preg <= Mreg;
						end
					end
					else	assign Preg = Mreg;
				end
				else if (FIRST && LAST) begin : genSingle
					always_ff @(posedge clk) begin
						if (rst)		Opmode <= 0;
						else if (en)	Opmode <= L[1];
					end
					always_ff @(posedge clk) begin
						if (rst) 		Preg <= 0;
						else if (en)	Preg <= (Opmode ? 0 : Preg) + Mreg;
					end
				end
				else if (!FIRST && LAST) begin : genLast
					always_ff @(posedge clk) begin
						if (rst)		Opmode <= 0;
						else if (en)	Opmode <= L[1];
					end
					always_ff @(posedge clk) begin
						if (rst) 		Preg <= 0;
						else if (en)	Preg <= (Opmode ? 0 : Preg) + Mreg + pcout[i][j-1];
					end
				end
				else begin : genMid
					if (PREG) begin : genPregBehav
						always_ff @(posedge clk) begin
							if (rst)		Preg <= 0;
							else if (en)	Preg <= Mreg + pcout[i][j-1];
						end
					end
					else	assign Preg = Mreg + pcout[i][j-1];
				end
				assign pp = Preg;
				assign pcout[i][j] = Preg;
			end : genBehav
`ifndef VERILATOR
			else begin: genDSP
				DSP58 #(
					// Feature Control Attributes: Data Path Selection
					.AMULTSEL("A"),                     // Selects A input to multiplier (A, AD)
					.A_INPUT("DIRECT"),                 // Selects A input source, "DIRECT" (A port) or "CASCADE" (ACIN port)
					.BMULTSEL("B"),                     // Selects B input to multiplier (AD, B)
					.B_INPUT("DIRECT"),                 // Selects B input source, "DIRECT" (B port) or "CASCADE" (BCIN port)
					.DSP_MODE("INT8"),                  // Configures DSP to a particular mode of operation. Set to INT24 for
														// legacy mode.
					.PREADDINSEL("A"),                  // Selects input to pre-adder (A, B)
					.RND(58'h000000000000000),          // Rounding Constant
					.USE_MULT("MULTIPLY"),              // Select multiplier usage (DYNAMIC, MULTIPLY, NONE)
					.USE_SIMD("ONE58"),                 // SIMD selection (FOUR12, ONE58, TWO24)
					.USE_WIDEXOR("FALSE"),              // Use the Wide XOR function (FALSE, TRUE)
					.XORSIMD("XOR24_34_58_116"),        // Mode of operation for the Wide XOR (XOR12_22, XOR24_34_58_116)
					// Pattern Detector Attributes: Pattern Detection Configuration
					.AUTORESET_PATDET("NO_RESET"),      // NO_RESET, RESET_MATCH, RESET_NOT_MATCH
					.AUTORESET_PRIORITY("RESET"),       // Priority of AUTORESET vs. CEP (CEP, RESET).
					.MASK(58'h0ffffffffffffff),         // 58-bit mask value for pattern detect (1=ignore)
					.PATTERN(58'h000000000000000),      // 58-bit pattern match for pattern detect
					.SEL_MASK("MASK"),                  // C, MASK, ROUNDING_MODE1, ROUNDING_MODE2
					.SEL_PATTERN("PATTERN"),            // Select pattern value (C, PATTERN)
					.USE_PATTERN_DETECT("NO_PATDET"),   // Enable pattern detect (NO_PATDET, PATDET)
					// Programmable Inversion Attributes: Specifies built-in programmable inversion on specific pins
					.IS_ALUMODE_INVERTED(4'b0000),      // Optional inversion for ALUMODE
					.IS_CARRYIN_INVERTED(1'b0),         // Optional inversion for CARRYIN
					.IS_CLK_INVERTED(1'b0),             // Optional inversion for CLK
					.IS_INMODE_INVERTED(5'b00000),      // Optional inversion for INMODE
					.IS_NEGATE_INVERTED(3'b000),        // Optional inversion for NEGATE
					.IS_OPMODE_INVERTED({ LAST ? 2'b01 : 2'b00 , // W: LAST ? (L[1] ? 0 : P) : 0
										FIRST ? 3'b000 : 3'b001, // Z: FIRST ? 0 : PCIN
										2'b01, // Y : M
										2'b01  // X: M
					}), // Optional inversion for OPMODE
					.IS_RSTALLCARRYIN_INVERTED(1'b0),   // Optional inversion for RSTALLCARRYIN
					.IS_RSTALUMODE_INVERTED(1'b0),      // Optional inversion for RSTALUMODE
					.IS_RSTA_INVERTED(1'b0),            // Optional inversion for RSTA
					.IS_RSTB_INVERTED(1'b0),            // Optional inversion for RSTB
					.IS_RSTCTRL_INVERTED(1'b0),         // Optional inversion for STCONJUGATE_A
					.IS_RSTC_INVERTED(1'b0),            // Optional inversion for RSTC
					.IS_RSTD_INVERTED(1'b0),            // Optional inversion for RSTD
					.IS_RSTINMODE_INVERTED(1'b0),       // Optional inversion for RSTINMODE
					.IS_RSTM_INVERTED(1'b0),            // Optional inversion for RSTM
					.IS_RSTP_INVERTED(1'b0),            // Optional inversion for RSTP
					// Register Control Attributes: Pipeline Register Configuration
					.ACASCREG(INTERNAL_PREGS),          // Number of pipeline stages between A/ACIN and ACOUT (0-2)
					.ADREG(0),                          // Pipeline stages for pre-adder (0-1)
					.ALUMODEREG(0),                     // Pipeline stages for ALUMODE (0-1)
					.AREG(INTERNAL_PREGS),              // Pipeline stages for A (0-2)
					.BCASCREG(INTERNAL_PREGS),          // Number of pipeline stages between B/BCIN and BCOUT (0-2)
					.BREG(INTERNAL_PREGS),              // Pipeline stages for B (0-2)
					.CARRYINREG(0),                     // Pipeline stages for CARRYIN (0-1)
					.CARRYINSELREG(0),                  // Pipeline stages for CARRYINSEL (0-1)
					.CREG(0),                           // Pipeline stages for C (0-1)
					.DREG(0),                           // Pipeline stages for D (0-1)
					.INMODEREG(1),                      // Pipeline stages for INMODE (0-1)
					.MREG(1),                           // Multiplier pipeline stages (0-1)
					.OPMODEREG(1),                      // Pipeline stages for OPMODE (0-1)
					.PREG(PREG),                        // Number of pipeline stages for P (0-1)
					.RESET_MODE("SYNC")                 // Selection of synchronous or asynchronous reset. (ASYNC, SYNC).
				)
				DSP58_inst (
					// Cascade outputs: Cascade Ports
					.ACOUT(),                           // 34-bit output: A port cascade
					.BCOUT(),                           // 24-bit output: B cascade
					.CARRYCASCOUT(),                    // 1-bit output: Cascade carry
					.MULTSIGNOUT(),                     // 1-bit output: Multiplier sign cascade
					.PCOUT(pcout[i][j]),                // 58-bit output: Cascade output
					// Control outputs: Control Inputs/Status Bits
					.OVERFLOW(),                        // 1-bit output: Overflow in add/acc
					.PATTERNBDETECT(),                  // 1-bit output: Pattern bar detect
					.PATTERNDETECT(),                   // 1-bit output: Pattern detect
					.UNDERFLOW(),                       // 1-bit output: Underflow in add/acc
					// Data outputs: Data Ports
					.CARRYOUT(),                        // 4-bit output: Carry
					.P(pp),                             // 58-bit output: Primary data
					.XOROUT(),                          // 8-bit output: XOR data
					// Cascade inputs: Cascade Ports
					.ACIN('x),                          // 34-bit input: A cascade data
					.BCIN('x),                          // 24-bit input: B cascade
					.CARRYCASCIN('x),                   // 1-bit input: Cascade carry
					.MULTSIGNIN('x),                    // 1-bit input: Multiplier sign cascade
					.PCIN(FIRST ? 'x : pcout[i][j-1]),  // 58-bit input: P cascade
					// Control inputs: Control Inputs/Status Bits
					.ALUMODE(4'h0),                     // 4-bit input: ALU control
					.CARRYINSEL('0),                    // 3-bit input: Carry select
					.CLK(clk),                          // 1-bit input: Clock
					.INMODE({
							INTERNAL_PREGS==2 ? 1'b0 : 1'b1,
							2'b00,
							TOTAL_PREGS > 0 ? Z[TOTAL_PREGS-1] : zero,
							INTERNAL_PREGS==2 ? 1'b0 : 1'b1
					}),                                 // 5-bit input: INMODE control
					.NEGATE('0),                        // 3-bit input: Negates the input of the multiplier
					.OPMODE({
							LAST ? {1'b0, L[1]} : 2'b00,
							7'b000_0000
					}), // 9-bit input: Operation mode
					// Data inputs: Data Ports
					.A({ 7'bx, a_in_i[(IS_MVU ? 0 : CHAINLEN*i) + j] }),            // 34-bit input: A data
					.B(b_in_i[i][j]),                   // 24-bit input: B data
					.C('x),                             // 58-bit input: C data
					.CARRYIN('0),                       // 1-bit input: Carry-in
					.D('x),                             // 27-bit input: D data
					// Reset/Clock Enable inputs: Reset/Clock Enable Inputs
					.ASYNC_RST('0),                     // 1-bit input: Asynchronous reset for all registers.
					.CEA1(en),                          // 1-bit input: Clock enable for 1st stage AREG
					.CEA2(INTERNAL_PREGS==2 ? en : '0), // 1-bit input: Clock enable for 2nd stage AREG
					.CEAD('0),                          // 1-bit input: Clock enable for ADREG
					.CEALUMODE('0),                     // 1-bit input: Clock enable for ALUMODE
					.CEB1(en),                          // 1-bit input: Clock enable for 1st stage BREG
					.CEB2(INTERNAL_PREGS==2 ? en : '0), // 1-bit input: Clock enable for 2nd stage BREG
					.CEC('0),                           // 1-bit input: Clock enable for CREG
					.CECARRYIN('0),                     // 1-bit input: Clock enable for CARRYINREG
					.CECTRL(en),                        // 1-bit input: Clock enable for OPMODEREG and CARRYINSELREG
					.CED('0),                           // 1-bit input: Clock enable for DREG
					.CEINMODE(en),                      // 1-bit input: Clock enable for INMODEREG
					.CEM(en),                           // 1-bit input: Clock enable for MREG
					.CEP(PREG && en),                   // 1-bit input: Clock enable for PREG
					.RSTA(rst),                         // 1-bit input: Reset for AREG
					.RSTALLCARRYIN('0),                 // 1-bit input: Reset for CARRYINREG
					.RSTALUMODE('0),                    // 1-bit input: Reset for ALUMODEREG
					.RSTB(rst),                         // 1-bit input: Reset for BREG
					.RSTC('0),                          // 1-bit input: Reset for CREG
					.RSTCTRL(rst),                      // 1-bit input: Reset for OPMODEREG and CARRYINSELREG
					.RSTD('0),                          // 1-bit input: Reset for DREG and ADREG
					.RSTINMODE(rst),                    // 1-bit input: Reset for INMODE register
					.RSTM(rst),                         // 1-bit input: Reset for MREG
					.RSTP(PREG && rst)                  // 1-bit input: Reset for PREG
				);
			end : genDSP
`endif
		end : genDSPChain
	end : genDSPPE

endmodule : mvu_vvu_8sx9_dsp58
//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/code_gen_ipgen_StreamingFIFO_rtl_14_df3tdjyd/Q_srl.v


// original source:
// https://github.com/nachiket/tdfc/blob/master/verilog/queues/Q_srl_oreg3_prefull_SIMPLE.v


// Copyright (c) 1999 The Regents of the University of California
// Copyright (c) 2010 The Regents of the University of Pennsylvania
// Copyright (c) 2011 Department of Electrical and Electronic Engineering, Imperial College London
// Copyright (c) 2020 Xilinx
//
// Permission to use, copy, modify, and distribute this software and
// its documentation for any purpose, without fee, and without a
// written agreement is hereby granted, provided that the above copyright
// notice and this paragraph and the following two paragraphs appear in
// all copies.
//
// IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR
// DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
// LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION,
// EVEN IF THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
// THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
// INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
// AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE PROVIDED HEREUNDER IS ON
// AN "AS IS" BASIS, AND THE UNIVERSITY OF CALIFORNIA HAS NO OBLIGATIONS TO
// PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
//

// Q_srl_oreg3_prefull_SIMPLE.v
//
//  - In-page queue with parameterizable depth, bit width
//  - Stream I/O is triple (data, valid, back-pressure),
//      with EOS concatenated into the data
//  - Flow control for input & output is combinationally decoupled
//  - 2 <= depth <= 256
//      * (depth >= 2)  is required to decouple I/O flow control,
//          where empty => no produce,  full => no consume,
//          and depth 1 would ping-pong between the two at half rate
//      * (depth <= 256) can be modified
//           by changing ''synthesis loop_limit X'' below
//          and changing ''addrwidth'' or its log computation
//  - 1 <= width
//  - Queue storage is in SRL16E, up to depth 16 per LUT per bit-slice,
//      plus output register (for fast output)
//  - Queue addressing is done by ''addr'' up-down counter
//  - Queue fullness is checked by comparator (addr==depth)
//  - Queue fullness                           is pre-computed for next cycle
//  - Queue input back-pressure                is pre-computed for next cycle
//  - Queue output valid (state!=state__empty) is pre-computed for next cycle
//      (necessary since SRL data output reg requires non-boolean state)
//  - FSM has 3 states (empty, one, more)
//  - When empty, continue to emit most recently emitted value (for debugging)
//
//  - Queue slots used      = / (state==state_empty) ? 0
//                            | (state==state_one)   ? 1
//                            \ (state==state_more)  ? addr+2
//  - Queue slots used     <=  depth
//  - Queue slots remaining =  depth - used
//                          = / (state==state_empty) ? depth
//                            | (state==state_one)   ? depth-1
//                            \ (state==state_more)  ? depth-2-addr
//
//  - Synplify 7.1 / 8.0
//  - Eylon Caspi,  9/11/03, 8/18/04, 3/29/05


`ifdef  Q_srl
`else
`define Q_srl


module Q_srl (clock, reset, i_d, i_v, i_r, o_d, o_v, o_r, count, maxcount);

   parameter depth = 16;   // - greatest #items in queue  (2 <= depth <= 256)
   parameter width = 16;   // - width of data (i_d, o_d)

   localparam countwidth = $clog2(depth + 1);
   localparam addrwidth = $clog2(depth);

   input     clock;
   input     reset;

   input  [width-1:0] i_d;	// - input  stream data (concat data + eos)
   input              i_v;	// - input  stream valid
   output             i_r;	// - input  stream ready
   wire               i_b;  // - input  stream back-pressure

   output [width-1:0] o_d;	// - output stream data (concat data + eos)
   output             o_v;	// - output stream valid
   input              o_r;	// - output stream ready
   wire               o_b;	// - output stream back-pressure

   output [countwidth-1:0] count;  // - output number of elems in queue
   output [countwidth-1:0] maxcount;  // - maximum observed count since reset

   reg [countwidth-1:0] maxcount_reg;  // - maximum count seen until now
   reg    [addrwidth-1:0] addr, addr_, a_;		// - SRL16 address
							//     for data output
   reg 			  shift_en_;			// - SRL16 shift enable
   reg    [width-1:0] 	  srl [depth-2:0];		// - SRL16 memory
   reg 			  shift_en_o_;			// - SRLO  shift enable
   reg    [width-1:0] 	  srlo_, srlo			// - SRLO  output reg
			  /* synthesis syn_allow_retiming=0 */ ;

   parameter state_empty = 2'd0;    // - state empty : o_v=0 o_d=UNDEFINED
   parameter state_one   = 2'd1;    // - state one   : o_v=1 o_d=srlo
   parameter state_more  = 2'd2;    // - state more  : o_v=1 o_d=srlo
				    //     #items in srl = addr+2

   reg [1:0] state, state_;	    // - state register

   wire      addr_full_;	    // - true iff addr==depth-2 on NEXT cycle
   reg       addr_full; 	    // - true iff addr==depth-2
   wire      addr_zero_;	    // - true iff addr==0
   wire      o_v_reg_;		    // - true iff state_empty   on NEXT cycle
   reg       o_v_reg  		    // - true iff state_empty
	     /* synthesis syn_allow_retiming=0 */ ;
   wire      i_b_reg_;		    // - true iff !full         on NEXT cycle
   reg       i_b_reg  		    // - true iff !full
	     /* synthesis syn_allow_retiming=0 */ ;

   assign addr_full_ = (state_==state_more) && (addr_==depth-2);
						// - queue full
   assign addr_zero_ = (addr==0);		// - queue contains 2 (or 1,0)
   assign o_v_reg_   = (state_!=state_empty);	// - output valid if non-empty
   assign i_b_reg_   = addr_full_;		// - input bp if full
   assign o_d = srlo;				// - output data from queue
   assign o_v = o_v_reg;			// - output valid if non-empty
   assign i_b = i_b_reg;			// - input bp if full
   assign maxcount = maxcount_reg;

   assign i_r = !i_b;
   assign o_b = !o_r;

   assign count = (state==state_more ? addr+2 : (state==state_one ? 1 : 0));

   // - ''always'' block with both FFs and SRL16 does not work,
   //      since FFs need reset but SRL16 does not

   always @(posedge clock) begin	// - seq always: FFs
      if (reset) begin
	 state     <= state_empty;
	 addr      <= 0;
         addr_full <= 0;
	 o_v_reg   <= 0;

	 i_b_reg   <= 0;
	 maxcount_reg <= 0;

      end
      else begin
	 state     <= state_;
	 addr      <= addr_;
         addr_full <= addr_full_;
	 o_v_reg   <= o_v_reg_;
	 i_b_reg   <= i_b_reg_;
	 maxcount_reg <= (count > maxcount_reg ? count : maxcount_reg);
      end
   end // always @ (posedge clock)

   always @(posedge clock) begin	// - seq always: srlo
      // - infer enabled output reg at end of shift chain
      // - input first element from i_d, all subsequent elements from SRL16
      if (reset) begin
	 srlo <= 0;
      end
      else begin
	 if (shift_en_o_) begin
	    srlo <= srlo_;
	 end
      end
   end // always @ (posedge clock)

   always @(posedge clock) begin			// - seq always: srl
      // - infer enabled SRL16E from shifting srl array
      // - no reset capability;  srl[] contents undefined on reset
      if (shift_en_) begin
	 // synthesis loop_limit 256
	 for (a_=depth-2; a_>0; a_=a_-1) begin
	    srl[a_] = srl[a_-1];
	 end
	 srl[0] <= i_d;
      end
   end // always @ (posedge clock or negedge reset)

   always @* begin					// - combi always
        srlo_       <=  'bx;
        shift_en_o_ <= 1'bx;
        shift_en_   <= 1'bx;
        addr_       <=  'bx;
        state_      <= 2'bx;
      case (state)

	state_empty: begin		    // - (empty, will not produce)
	      if (i_v) begin		    // - empty & i_v => consume
		 srlo_       <= i_d;
		 shift_en_o_ <= 1;
		 shift_en_   <= 1'bx;
		 addr_       <= 0;
		 state_      <= state_one;
	      end
	      else	begin		    // - empty & !i_v => idle
		 srlo_       <= 'bx;
		 shift_en_o_ <= 0;
		 shift_en_   <= 1'bx;
		 addr_       <= 0;
		 state_      <= state_empty;
	      end
	end

	state_one: begin		    // - (contains one)
	      if (i_v && o_b) begin	    // - one & i_v & o_b => consume
		 srlo_       <= 'bx;
		 shift_en_o_ <= 0;
		 shift_en_   <= 1;
		 addr_       <= 0;
		 state_      <= state_more;
	      end
	      else if (i_v && !o_b) begin   // - one & i_v & !o_b => cons+prod
		 srlo_       <= i_d;
		 shift_en_o_ <= 1;
		 shift_en_   <= 1;
		 addr_       <= 0;
		 state_      <= state_one;
	      end
	      else if (!i_v && o_b) begin   // - one & !i_v & o_b => idle
		 srlo_       <= 'bx;
		 shift_en_o_ <= 0;
		 shift_en_   <= 1'bx;
		 addr_       <= 0;
		 state_      <= state_one;
	      end
	      else if (!i_v && !o_b) begin  // - one & !i_v & !o_b => produce
		 srlo_       <= 'bx;
		 shift_en_o_ <= 0;
		 shift_en_   <= 1'bx;
		 addr_       <= 0;
		 state_      <= state_empty;
	      end
	end // case: state_one

	state_more: begin		    // - (contains more than one)
	   if (addr_full || (depth==2)) begin
					    // - (full, will not consume)
					    // - (full here if depth==2)
	      if (o_b) begin		    // - full & o_b => idle
		 srlo_       <= 'bx;
		 shift_en_o_ <= 0;
		 shift_en_   <= 0;
		 addr_       <= addr;
		 state_      <= state_more;
	      end
	      else begin		    // - full & !o_b => produce
		 srlo_       <= srl[addr];
		 shift_en_o_ <= 1;
		 shift_en_   <= 0;
//		 addr_       <= addr-1;
//		 state_      <= state_more;
		 addr_       <= addr_zero_ ? 0         : addr-1;
		 state_      <= addr_zero_ ? state_one : state_more;
	      end
	   end
	   else begin			    // - (mid: neither empty nor full)
	      if (i_v && o_b) begin	    // - mid & i_v & o_b => consume
		 srlo_       <= 'bx;
		 shift_en_o_ <= 0;
		 shift_en_   <= 1;
		 addr_       <= addr+1;
		 state_      <= state_more;
	      end
	      else if (i_v && !o_b) begin   // - mid & i_v & !o_b => cons+prod
		 srlo_       <= srl[addr];
		 shift_en_o_ <= 1;
		 shift_en_   <= 1;
		 addr_       <= addr;
		 state_      <= state_more;
	      end
	      else if (!i_v && o_b) begin   // - mid & !i_v & o_b => idle
		 srlo_       <= 'bx;
		 shift_en_o_ <= 0;
		 shift_en_   <= 0;
		 addr_       <= addr;
		 state_      <= state_more;
	      end
	      else if (!i_v && !o_b) begin  // - mid & !i_v & !o_b => produce
		 srlo_       <= srl[addr];
		 shift_en_o_ <= 1;
		 shift_en_   <= 0;
		 addr_       <= addr_zero_ ? 0         : addr-1;
		 state_      <= addr_zero_ ? state_one : state_more;
	      end
	   end // else: !if(addr_full)
	end // case: state_more

	default: begin
		 srlo_       <=  'bx;
		 shift_en_o_ <= 1'bx;
		 shift_en_   <= 1'bx;
		 addr_       <=  'bx;
		 state_      <= 2'bx;
	end // case: default

      endcase // case(state)
   end // always @ *

endmodule // Q_srl


`endif  // `ifdef  Q_srl
//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/code_gen_ipgen_StreamingFIFO_rtl_9_1gvd06yw/Q_srl.v


// original source:
// https://github.com/nachiket/tdfc/blob/master/verilog/queues/Q_srl_oreg3_prefull_SIMPLE.v


// Copyright (c) 1999 The Regents of the University of California
// Copyright (c) 2010 The Regents of the University of Pennsylvania
// Copyright (c) 2011 Department of Electrical and Electronic Engineering, Imperial College London
// Copyright (c) 2020 Xilinx
//
// Permission to use, copy, modify, and distribute this software and
// its documentation for any purpose, without fee, and without a
// written agreement is hereby granted, provided that the above copyright
// notice and this paragraph and the following two paragraphs appear in
// all copies.
//
// IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR
// DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
// LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION,
// EVEN IF THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
// THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
// INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
// AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE PROVIDED HEREUNDER IS ON
// AN "AS IS" BASIS, AND THE UNIVERSITY OF CALIFORNIA HAS NO OBLIGATIONS TO
// PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
//

// Q_srl_oreg3_prefull_SIMPLE.v
//
//  - In-page queue with parameterizable depth, bit width
//  - Stream I/O is triple (data, valid, back-pressure),
//      with EOS concatenated into the data
//  - Flow control for input & output is combinationally decoupled
//  - 2 <= depth <= 256
//      * (depth >= 2)  is required to decouple I/O flow control,
//          where empty => no produce,  full => no consume,
//          and depth 1 would ping-pong between the two at half rate
//      * (depth <= 256) can be modified
//           by changing ''synthesis loop_limit X'' below
//          and changing ''addrwidth'' or its log computation
//  - 1 <= width
//  - Queue storage is in SRL16E, up to depth 16 per LUT per bit-slice,
//      plus output register (for fast output)
//  - Queue addressing is done by ''addr'' up-down counter
//  - Queue fullness is checked by comparator (addr==depth)
//  - Queue fullness                           is pre-computed for next cycle
//  - Queue input back-pressure                is pre-computed for next cycle
//  - Queue output valid (state!=state__empty) is pre-computed for next cycle
//      (necessary since SRL data output reg requires non-boolean state)
//  - FSM has 3 states (empty, one, more)
//  - When empty, continue to emit most recently emitted value (for debugging)
//
//  - Queue slots used      = / (state==state_empty) ? 0
//                            | (state==state_one)   ? 1
//                            \ (state==state_more)  ? addr+2
//  - Queue slots used     <=  depth
//  - Queue slots remaining =  depth - used
//                          = / (state==state_empty) ? depth
//                            | (state==state_one)   ? depth-1
//                            \ (state==state_more)  ? depth-2-addr
//
//  - Synplify 7.1 / 8.0
//  - Eylon Caspi,  9/11/03, 8/18/04, 3/29/05


`ifdef  Q_srl
`else
`define Q_srl


module Q_srl (clock, reset, i_d, i_v, i_r, o_d, o_v, o_r, count, maxcount);

   parameter depth = 16;   // - greatest #items in queue  (2 <= depth <= 256)
   parameter width = 16;   // - width of data (i_d, o_d)

   localparam countwidth = $clog2(depth + 1);
   localparam addrwidth = $clog2(depth);

   input     clock;
   input     reset;

   input  [width-1:0] i_d;	// - input  stream data (concat data + eos)
   input              i_v;	// - input  stream valid
   output             i_r;	// - input  stream ready
   wire               i_b;  // - input  stream back-pressure

   output [width-1:0] o_d;	// - output stream data (concat data + eos)
   output             o_v;	// - output stream valid
   input              o_r;	// - output stream ready
   wire               o_b;	// - output stream back-pressure

   output [countwidth-1:0] count;  // - output number of elems in queue
   output [countwidth-1:0] maxcount;  // - maximum observed count since reset

   reg [countwidth-1:0] maxcount_reg;  // - maximum count seen until now
   reg    [addrwidth-1:0] addr, addr_, a_;		// - SRL16 address
							//     for data output
   reg 			  shift_en_;			// - SRL16 shift enable
   reg    [width-1:0] 	  srl [depth-2:0];		// - SRL16 memory
   reg 			  shift_en_o_;			// - SRLO  shift enable
   reg    [width-1:0] 	  srlo_, srlo			// - SRLO  output reg
			  /* synthesis syn_allow_retiming=0 */ ;

   parameter state_empty = 2'd0;    // - state empty : o_v=0 o_d=UNDEFINED
   parameter state_one   = 2'd1;    // - state one   : o_v=1 o_d=srlo
   parameter state_more  = 2'd2;    // - state more  : o_v=1 o_d=srlo
				    //     #items in srl = addr+2

   reg [1:0] state, state_;	    // - state register

   wire      addr_full_;	    // - true iff addr==depth-2 on NEXT cycle
   reg       addr_full; 	    // - true iff addr==depth-2
   wire      addr_zero_;	    // - true iff addr==0
   wire      o_v_reg_;		    // - true iff state_empty   on NEXT cycle
   reg       o_v_reg  		    // - true iff state_empty
	     /* synthesis syn_allow_retiming=0 */ ;
   wire      i_b_reg_;		    // - true iff !full         on NEXT cycle
   reg       i_b_reg  		    // - true iff !full
	     /* synthesis syn_allow_retiming=0 */ ;

   assign addr_full_ = (state_==state_more) && (addr_==depth-2);
						// - queue full
   assign addr_zero_ = (addr==0);		// - queue contains 2 (or 1,0)
   assign o_v_reg_   = (state_!=state_empty);	// - output valid if non-empty
   assign i_b_reg_   = addr_full_;		// - input bp if full
   assign o_d = srlo;				// - output data from queue
   assign o_v = o_v_reg;			// - output valid if non-empty
   assign i_b = i_b_reg;			// - input bp if full
   assign maxcount = maxcount_reg;

   assign i_r = !i_b;
   assign o_b = !o_r;

   assign count = (state==state_more ? addr+2 : (state==state_one ? 1 : 0));

   // - ''always'' block with both FFs and SRL16 does not work,
   //      since FFs need reset but SRL16 does not

   always @(posedge clock) begin	// - seq always: FFs
      if (reset) begin
	 state     <= state_empty;
	 addr      <= 0;
         addr_full <= 0;
	 o_v_reg   <= 0;

	 i_b_reg   <= 0;
	 maxcount_reg <= 0;

      end
      else begin
	 state     <= state_;
	 addr      <= addr_;
         addr_full <= addr_full_;
	 o_v_reg   <= o_v_reg_;
	 i_b_reg   <= i_b_reg_;
	 maxcount_reg <= (count > maxcount_reg ? count : maxcount_reg);
      end
   end // always @ (posedge clock)

   always @(posedge clock) begin	// - seq always: srlo
      // - infer enabled output reg at end of shift chain
      // - input first element from i_d, all subsequent elements from SRL16
      if (reset) begin
	 srlo <= 0;
      end
      else begin
	 if (shift_en_o_) begin
	    srlo <= srlo_;
	 end
      end
   end // always @ (posedge clock)

   always @(posedge clock) begin			// - seq always: srl
      // - infer enabled SRL16E from shifting srl array
      // - no reset capability;  srl[] contents undefined on reset
      if (shift_en_) begin
	 // synthesis loop_limit 256
	 for (a_=depth-2; a_>0; a_=a_-1) begin
	    srl[a_] = srl[a_-1];
	 end
	 srl[0] <= i_d;
      end
   end // always @ (posedge clock or negedge reset)

   always @* begin					// - combi always
        srlo_       <=  'bx;
        shift_en_o_ <= 1'bx;
        shift_en_   <= 1'bx;
        addr_       <=  'bx;
        state_      <= 2'bx;
      case (state)

	state_empty: begin		    // - (empty, will not produce)
	      if (i_v) begin		    // - empty & i_v => consume
		 srlo_       <= i_d;
		 shift_en_o_ <= 1;
		 shift_en_   <= 1'bx;
		 addr_       <= 0;
		 state_      <= state_one;
	      end
	      else	begin		    // - empty & !i_v => idle
		 srlo_       <= 'bx;
		 shift_en_o_ <= 0;
		 shift_en_   <= 1'bx;
		 addr_       <= 0;
		 state_      <= state_empty;
	      end
	end

	state_one: begin		    // - (contains one)
	      if (i_v && o_b) begin	    // - one & i_v & o_b => consume
		 srlo_       <= 'bx;
		 shift_en_o_ <= 0;
		 shift_en_   <= 1;
		 addr_       <= 0;
		 state_      <= state_more;
	      end
	      else if (i_v && !o_b) begin   // - one & i_v & !o_b => cons+prod
		 srlo_       <= i_d;
		 shift_en_o_ <= 1;
		 shift_en_   <= 1;
		 addr_       <= 0;
		 state_      <= state_one;
	      end
	      else if (!i_v && o_b) begin   // - one & !i_v & o_b => idle
		 srlo_       <= 'bx;
		 shift_en_o_ <= 0;
		 shift_en_   <= 1'bx;
		 addr_       <= 0;
		 state_      <= state_one;
	      end
	      else if (!i_v && !o_b) begin  // - one & !i_v & !o_b => produce
		 srlo_       <= 'bx;
		 shift_en_o_ <= 0;
		 shift_en_   <= 1'bx;
		 addr_       <= 0;
		 state_      <= state_empty;
	      end
	end // case: state_one

	state_more: begin		    // - (contains more than one)
	   if (addr_full || (depth==2)) begin
					    // - (full, will not consume)
					    // - (full here if depth==2)
	      if (o_b) begin		    // - full & o_b => idle
		 srlo_       <= 'bx;
		 shift_en_o_ <= 0;
		 shift_en_   <= 0;
		 addr_       <= addr;
		 state_      <= state_more;
	      end
	      else begin		    // - full & !o_b => produce
		 srlo_       <= srl[addr];
		 shift_en_o_ <= 1;
		 shift_en_   <= 0;
//		 addr_       <= addr-1;
//		 state_      <= state_more;
		 addr_       <= addr_zero_ ? 0         : addr-1;
		 state_      <= addr_zero_ ? state_one : state_more;
	      end
	   end
	   else begin			    // - (mid: neither empty nor full)
	      if (i_v && o_b) begin	    // - mid & i_v & o_b => consume
		 srlo_       <= 'bx;
		 shift_en_o_ <= 0;
		 shift_en_   <= 1;
		 addr_       <= addr+1;
		 state_      <= state_more;
	      end
	      else if (i_v && !o_b) begin   // - mid & i_v & !o_b => cons+prod
		 srlo_       <= srl[addr];
		 shift_en_o_ <= 1;
		 shift_en_   <= 1;
		 addr_       <= addr;
		 state_      <= state_more;
	      end
	      else if (!i_v && o_b) begin   // - mid & !i_v & o_b => idle
		 srlo_       <= 'bx;
		 shift_en_o_ <= 0;
		 shift_en_   <= 0;
		 addr_       <= addr;
		 state_      <= state_more;
	      end
	      else if (!i_v && !o_b) begin  // - mid & !i_v & !o_b => produce
		 srlo_       <= srl[addr];
		 shift_en_o_ <= 1;
		 shift_en_   <= 0;
		 addr_       <= addr_zero_ ? 0         : addr-1;
		 state_      <= addr_zero_ ? state_one : state_more;
	      end
	   end // else: !if(addr_full)
	end // case: state_more

	default: begin
		 srlo_       <=  'bx;
		 shift_en_o_ <= 1'bx;
		 shift_en_   <= 1'bx;
		 addr_       <=  'bx;
		 state_      <= 2'bx;
	end // case: default

      endcase // case(state)
   end // always @ *

endmodule // Q_srl


`endif  // `ifdef  Q_srl
//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/vivado_stitch_proj_w5fn6zuu/finn_vivado_stitch_proj.gen/sources_1/bd/finn_design/ip/finn_design_StreamingFIFO_rtl_11_0/synth/finn_design_StreamingFIFO_rtl_11_0.v


// (c) Copyright 1995-2026 Xilinx, Inc. All rights reserved.
// 
// This file contains confidential and proprietary information
// of Xilinx, Inc. and is protected under U.S. and
// international copyright and other intellectual property
// laws.
// 
// DISCLAIMER
// This disclaimer is not a license and does not grant any
// rights to the materials distributed herewith. Except as
// otherwise provided in a valid license issued to you by
// Xilinx, and to the maximum extent permitted by applicable
// law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
// WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
// AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
// BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
// INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
// (2) Xilinx shall not be liable (whether in contract or tort,
// including negligence, or under any other theory of
// liability) for any loss or damage of any kind or nature
// related to, arising under or in connection with these
// materials, including for any direct, or any indirect,
// special, incidental, or consequential loss or damage
// (including loss of data, profits, goodwill, or any type of
// loss or damage suffered as a result of any action brought
// by a third party) even if such damage or loss was
// reasonably foreseeable or Xilinx had been advised of the
// possibility of the same.
// 
// CRITICAL APPLICATIONS
// Xilinx products are not designed or intended to be fail-
// safe, or for use in any application requiring fail-safe
// performance, such as life-support or safety devices or
// systems, Class III medical devices, nuclear facilities,
// applications related to the deployment of airbags, or any
// other applications that could lead to death, personal
// injury, or severe property or environmental damage
// (individually and collectively, "Critical
// Applications"). Customer assumes the sole risk and
// liability of any use of Xilinx products in Critical
// Applications, subject only to applicable laws and
// regulations governing limitations on product liability.
// 
// THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
// PART OF THIS FILE AT ALL TIMES.
// 
// DO NOT MODIFY THIS FILE.


// IP VLNV: xilinx.com:module_ref:StreamingFIFO_rtl_11:1.0
// IP Revision: 1

(* X_CORE_INFO = "StreamingFIFO_rtl_11,Vivado 2022.2" *)
(* CHECK_LICENSE_TYPE = "finn_design_StreamingFIFO_rtl_11_0,StreamingFIFO_rtl_11,{}" *)
(* CORE_GENERATION_INFO = "finn_design_StreamingFIFO_rtl_11_0,StreamingFIFO_rtl_11,{x_ipProduct=Vivado 2022.2,x_ipVendor=xilinx.com,x_ipLibrary=module_ref,x_ipName=StreamingFIFO_rtl_11,x_ipVersion=1.0,x_ipCoreRevision=1,x_ipLanguage=VERILOG,x_ipSimLanguage=MIXED}" *)
(* IP_DEFINITION_SOURCE = "module_ref" *)
(* DowngradeIPIdentifiedWarnings = "yes" *)
module finn_design_StreamingFIFO_rtl_11_0 (
  ap_clk,
  ap_rst_n,
  count,
  maxcount,
  in0_V_TREADY,
  in0_V_TVALID,
  in0_V_TDATA,
  out_V_TREADY,
  out_V_TVALID,
  out_V_TDATA
);

(* X_INTERFACE_PARAMETER = "XIL_INTERFACENAME ap_clk, ASSOCIATED_RESET ap_rst_n, ASSOCIATED_BUSIF in0_V:out_V, FREQ_HZ 100000000, FREQ_TOLERANCE_HZ 0, PHASE 0.0, CLK_DOMAIN finn_design_ap_clk_0, INSERT_VIP 0" *)
(* X_INTERFACE_INFO = "xilinx.com:signal:clock:1.0 ap_clk CLK" *)
input wire ap_clk;
(* X_INTERFACE_PARAMETER = "XIL_INTERFACENAME ap_rst_n, POLARITY ACTIVE_LOW, INSERT_VIP 0" *)
(* X_INTERFACE_INFO = "xilinx.com:signal:reset:1.0 ap_rst_n RST" *)
input wire ap_rst_n;
output wire [7 : 0] count;
output wire [7 : 0] maxcount;
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 in0_V TREADY" *)
output wire in0_V_TREADY;
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 in0_V TVALID" *)
input wire in0_V_TVALID;
(* X_INTERFACE_PARAMETER = "XIL_INTERFACENAME in0_V, TDATA_NUM_BYTES 16, TDEST_WIDTH 0, TID_WIDTH 0, TUSER_WIDTH 0, HAS_TREADY 1, HAS_TSTRB 0, HAS_TKEEP 0, HAS_TLAST 0, FREQ_HZ 100000000, PHASE 0.0, CLK_DOMAIN finn_design_ap_clk_0, LAYERED_METADATA undef, INSERT_VIP 0" *)
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 in0_V TDATA" *)
input wire [127 : 0] in0_V_TDATA;
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 out_V TREADY" *)
input wire out_V_TREADY;
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 out_V TVALID" *)
output wire out_V_TVALID;
(* X_INTERFACE_PARAMETER = "XIL_INTERFACENAME out_V, TDATA_NUM_BYTES 16, TDEST_WIDTH 0, TID_WIDTH 0, TUSER_WIDTH 0, HAS_TREADY 1, HAS_TSTRB 0, HAS_TKEEP 0, HAS_TLAST 0, FREQ_HZ 100000000, PHASE 0.0, CLK_DOMAIN finn_design_ap_clk_0, LAYERED_METADATA undef, INSERT_VIP 0" *)
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 out_V TDATA" *)
output wire [127 : 0] out_V_TDATA;

  StreamingFIFO_rtl_11 inst (
    .ap_clk(ap_clk),
    .ap_rst_n(ap_rst_n),
    .count(count),
    .maxcount(maxcount),
    .in0_V_TREADY(in0_V_TREADY),
    .in0_V_TVALID(in0_V_TVALID),
    .in0_V_TDATA(in0_V_TDATA),
    .out_V_TREADY(out_V_TREADY),
    .out_V_TVALID(out_V_TVALID),
    .out_V_TDATA(out_V_TDATA)
  );
endmodule
//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/code_gen_ipgen_StreamingFIFO_rtl_8_nl6qclbk/StreamingFIFO_rtl_8.v


/******************************************************************************
 * Copyright (C) 2024, Advanced Micro Devices, Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *  1. Redistributions of source code must retain the above copyright notice,
 *     this list of conditions and the following disclaimer.
 *
 *  2. Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *
 *  3. Neither the name of the copyright holder nor the names of its
 *     contributors may be used to endorse or promote products derived from
 *     this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION). HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *****************************************************************************/

module StreamingFIFO_rtl_8(
//- Global Control ------------------
(* X_INTERFACE_PARAMETER = "ASSOCIATED_BUSIF in0_V:out_V, ASSOCIATED_RESET = ap_rst_n" *)
(* X_INTERFACE_INFO = "xilinx.com:signal:clock:1.0 ap_clk CLK" *)
input   ap_clk,
(* X_INTERFACE_PARAMETER = "POLARITY ACTIVE_LOW" *)
input   ap_rst_n,

output [12:0] count,
output [12:0] maxcount,

//- AXI Stream - Input --------------
output   in0_V_TREADY,
input   in0_V_TVALID,
input  [7:0] in0_V_TDATA,

//- AXI Stream - Output --------------
input   out_V_TREADY,
output   out_V_TVALID,
output  [7:0] out_V_TDATA
);

Q_srl #(
.depth(4096),
.width(8)
)
impl
(
 .clock(ap_clk),
 .reset(!ap_rst_n),
 .count(count),
 .maxcount(maxcount),
 .i_d(in0_V_TDATA),
 .i_v(in0_V_TVALID),
 .i_r(in0_V_TREADY),
 .o_d(out_V_TDATA),
 .o_v(out_V_TVALID),
 .o_r(out_V_TREADY)
);

endmodule
//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/vivado_stitch_proj_w5fn6zuu/finn_vivado_stitch_proj.gen/sources_1/bd/finn_design/ipshared/6bf6/hdl/verilog/StreamingMaxPool_hls_0.v


// ==============================================================
// RTL generated by Vitis HLS - High-Level Synthesis from C, C++ and OpenCL v2022.2 (64-bit)
// Version: 2022.2
// Copyright (C) Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.
// 
// ===========================================================

`timescale 1 ns / 1 ps 

(* CORE_GENERATION_INFO="StreamingMaxPool_hls_0_StreamingMaxPool_hls_0,hls_ip_2022_2,{HLS_INPUT_TYPE=cxx,HLS_INPUT_FLOAT=0,HLS_INPUT_FIXED=0,HLS_INPUT_PART=xc7z010-clg400-1,HLS_INPUT_CLOCK=10.000000,HLS_INPUT_ARCH=others,HLS_SYN_CLOCK=6.236000,HLS_SYN_LAT=3423,HLS_SYN_TPT=none,HLS_SYN_MEM=0,HLS_SYN_DSP=0,HLS_SYN_FF=258,HLS_SYN_LUT=2344,HLS_VERSION=2022_2}" *)

module StreamingMaxPool_hls_0 (
        ap_clk,
        ap_rst_n,
        in0_V_TDATA,
        in0_V_TVALID,
        in0_V_TREADY,
        out_V_TDATA,
        out_V_TVALID,
        out_V_TREADY
);

parameter    ap_ST_fsm_state1 = 4'd1;
parameter    ap_ST_fsm_state2 = 4'd2;
parameter    ap_ST_fsm_state3 = 4'd4;
parameter    ap_ST_fsm_state4 = 4'd8;

input   ap_clk;
input   ap_rst_n;
input  [63:0] in0_V_TDATA;
input   in0_V_TVALID;
output   in0_V_TREADY;
output  [63:0] out_V_TDATA;
output   out_V_TVALID;
input   out_V_TREADY;

 reg    ap_rst_n_inv;
wire    grp_StreamingMaxPool_Precision_28u_2u_16u_ap_uint_4_0_64_s_fu_28_ap_start;
wire    grp_StreamingMaxPool_Precision_28u_2u_16u_ap_uint_4_0_64_s_fu_28_ap_done;
wire    grp_StreamingMaxPool_Precision_28u_2u_16u_ap_uint_4_0_64_s_fu_28_ap_idle;
wire    grp_StreamingMaxPool_Precision_28u_2u_16u_ap_uint_4_0_64_s_fu_28_ap_ready;
wire    grp_StreamingMaxPool_Precision_28u_2u_16u_ap_uint_4_0_64_s_fu_28_in0_V_TREADY;
wire   [63:0] grp_StreamingMaxPool_Precision_28u_2u_16u_ap_uint_4_0_64_s_fu_28_out_V_TDATA;
wire    grp_StreamingMaxPool_Precision_28u_2u_16u_ap_uint_4_0_64_s_fu_28_out_V_TVALID;
wire    grp_StreamingMaxPool_Precision_28u_2u_16u_ap_uint_4_0_64_s_fu_28_out_V_TREADY;
reg    grp_StreamingMaxPool_Precision_28u_2u_16u_ap_uint_4_0_64_s_fu_28_ap_start_reg;
(* fsm_encoding = "none" *) reg   [3:0] ap_CS_fsm;
wire    ap_CS_fsm_state2;
wire    ap_CS_fsm_state3;
reg   [3:0] ap_NS_fsm;
wire    ap_ST_fsm_state1_blk;
wire    ap_ST_fsm_state2_blk;
reg    ap_ST_fsm_state3_blk;
reg    ap_ST_fsm_state4_blk;
wire    regslice_both_out_V_U_apdone_blk;
wire    ap_CS_fsm_state4;
wire    regslice_both_in0_V_U_apdone_blk;
wire   [63:0] in0_V_TDATA_int_regslice;
wire    in0_V_TVALID_int_regslice;
reg    in0_V_TREADY_int_regslice;
wire    regslice_both_in0_V_U_ack_in;
wire    out_V_TREADY_int_regslice;
wire    regslice_both_out_V_U_vld_out;
wire    ap_ce_reg;

// power-on initialization
initial begin
#0 grp_StreamingMaxPool_Precision_28u_2u_16u_ap_uint_4_0_64_s_fu_28_ap_start_reg = 1'b0;
#0 ap_CS_fsm = 4'd1;
end

StreamingMaxPool_hls_0_StreamingMaxPool_Precision_28u_2u_16u_ap_uint_4_0_64_s grp_StreamingMaxPool_Precision_28u_2u_16u_ap_uint_4_0_64_s_fu_28(
    .ap_clk(ap_clk),
    .ap_rst(ap_rst_n_inv),
    .ap_start(grp_StreamingMaxPool_Precision_28u_2u_16u_ap_uint_4_0_64_s_fu_28_ap_start),
    .ap_done(grp_StreamingMaxPool_Precision_28u_2u_16u_ap_uint_4_0_64_s_fu_28_ap_done),
    .ap_idle(grp_StreamingMaxPool_Precision_28u_2u_16u_ap_uint_4_0_64_s_fu_28_ap_idle),
    .ap_ready(grp_StreamingMaxPool_Precision_28u_2u_16u_ap_uint_4_0_64_s_fu_28_ap_ready),
    .in0_V_TDATA(in0_V_TDATA_int_regslice),
    .in0_V_TVALID(in0_V_TVALID_int_regslice),
    .in0_V_TREADY(grp_StreamingMaxPool_Precision_28u_2u_16u_ap_uint_4_0_64_s_fu_28_in0_V_TREADY),
    .out_V_TDATA(grp_StreamingMaxPool_Precision_28u_2u_16u_ap_uint_4_0_64_s_fu_28_out_V_TDATA),
    .out_V_TVALID(grp_StreamingMaxPool_Precision_28u_2u_16u_ap_uint_4_0_64_s_fu_28_out_V_TVALID),
    .out_V_TREADY(grp_StreamingMaxPool_Precision_28u_2u_16u_ap_uint_4_0_64_s_fu_28_out_V_TREADY)
);

StreamingMaxPool_hls_0_regslice_both #(
    .DataWidth( 64 ))
regslice_both_in0_V_U(
    .ap_clk(ap_clk),
    .ap_rst(ap_rst_n_inv),
    .data_in(in0_V_TDATA),
    .vld_in(in0_V_TVALID),
    .ack_in(regslice_both_in0_V_U_ack_in),
    .data_out(in0_V_TDATA_int_regslice),
    .vld_out(in0_V_TVALID_int_regslice),
    .ack_out(in0_V_TREADY_int_regslice),
    .apdone_blk(regslice_both_in0_V_U_apdone_blk)
);

StreamingMaxPool_hls_0_regslice_both #(
    .DataWidth( 64 ))
regslice_both_out_V_U(
    .ap_clk(ap_clk),
    .ap_rst(ap_rst_n_inv),
    .data_in(grp_StreamingMaxPool_Precision_28u_2u_16u_ap_uint_4_0_64_s_fu_28_out_V_TDATA),
    .vld_in(grp_StreamingMaxPool_Precision_28u_2u_16u_ap_uint_4_0_64_s_fu_28_out_V_TVALID),
    .ack_in(out_V_TREADY_int_regslice),
    .data_out(out_V_TDATA),
    .vld_out(regslice_both_out_V_U_vld_out),
    .ack_out(out_V_TREADY),
    .apdone_blk(regslice_both_out_V_U_apdone_blk)
);

always @ (posedge ap_clk) begin
    if (ap_rst_n_inv == 1'b1) begin
        ap_CS_fsm <= ap_ST_fsm_state1;
    end else begin
        ap_CS_fsm <= ap_NS_fsm;
    end
end

always @ (posedge ap_clk) begin
    if (ap_rst_n_inv == 1'b1) begin
        grp_StreamingMaxPool_Precision_28u_2u_16u_ap_uint_4_0_64_s_fu_28_ap_start_reg <= 1'b0;
    end else begin
        if ((1'b1 == ap_CS_fsm_state2)) begin
            grp_StreamingMaxPool_Precision_28u_2u_16u_ap_uint_4_0_64_s_fu_28_ap_start_reg <= 1'b1;
        end else if ((grp_StreamingMaxPool_Precision_28u_2u_16u_ap_uint_4_0_64_s_fu_28_ap_ready == 1'b1)) begin
            grp_StreamingMaxPool_Precision_28u_2u_16u_ap_uint_4_0_64_s_fu_28_ap_start_reg <= 1'b0;
        end
    end
end

assign ap_ST_fsm_state1_blk = 1'b0;

assign ap_ST_fsm_state2_blk = 1'b0;

always @ (*) begin
    if ((grp_StreamingMaxPool_Precision_28u_2u_16u_ap_uint_4_0_64_s_fu_28_ap_done == 1'b0)) begin
        ap_ST_fsm_state3_blk = 1'b1;
    end else begin
        ap_ST_fsm_state3_blk = 1'b0;
    end
end

always @ (*) begin
    if ((regslice_both_out_V_U_apdone_blk == 1'b1)) begin
        ap_ST_fsm_state4_blk = 1'b1;
    end else begin
        ap_ST_fsm_state4_blk = 1'b0;
    end
end

always @ (*) begin
    if ((1'b1 == ap_CS_fsm_state3)) begin
        in0_V_TREADY_int_regslice = grp_StreamingMaxPool_Precision_28u_2u_16u_ap_uint_4_0_64_s_fu_28_in0_V_TREADY;
    end else begin
        in0_V_TREADY_int_regslice = 1'b0;
    end
end

always @ (*) begin
    case (ap_CS_fsm)
        ap_ST_fsm_state1 : begin
            ap_NS_fsm = ap_ST_fsm_state2;
        end
        ap_ST_fsm_state2 : begin
            ap_NS_fsm = ap_ST_fsm_state3;
        end
        ap_ST_fsm_state3 : begin
            if (((grp_StreamingMaxPool_Precision_28u_2u_16u_ap_uint_4_0_64_s_fu_28_ap_done == 1'b1) & (1'b1 == ap_CS_fsm_state3))) begin
                ap_NS_fsm = ap_ST_fsm_state4;
            end else begin
                ap_NS_fsm = ap_ST_fsm_state3;
            end
        end
        ap_ST_fsm_state4 : begin
            if (((regslice_both_out_V_U_apdone_blk == 1'b0) & (1'b1 == ap_CS_fsm_state4))) begin
                ap_NS_fsm = ap_ST_fsm_state1;
            end else begin
                ap_NS_fsm = ap_ST_fsm_state4;
            end
        end
        default : begin
            ap_NS_fsm = 'bx;
        end
    endcase
end

assign ap_CS_fsm_state2 = ap_CS_fsm[32'd1];

assign ap_CS_fsm_state3 = ap_CS_fsm[32'd2];

assign ap_CS_fsm_state4 = ap_CS_fsm[32'd3];

always @ (*) begin
    ap_rst_n_inv = ~ap_rst_n;
end

assign grp_StreamingMaxPool_Precision_28u_2u_16u_ap_uint_4_0_64_s_fu_28_ap_start = grp_StreamingMaxPool_Precision_28u_2u_16u_ap_uint_4_0_64_s_fu_28_ap_start_reg;

assign grp_StreamingMaxPool_Precision_28u_2u_16u_ap_uint_4_0_64_s_fu_28_out_V_TREADY = (out_V_TREADY_int_regslice & ap_CS_fsm_state3);

assign in0_V_TREADY = regslice_both_in0_V_U_ack_in;

assign out_V_TVALID = regslice_both_out_V_U_vld_out;

endmodule //StreamingMaxPool_hls_0
//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/vivado_stitch_proj_w5fn6zuu/finn_vivado_stitch_proj.gen/sources_1/bd/finn_design/ipshared/fb57/hdl/verilog/MVAU_hls_1_hls_deadlock_idx1_monitor.v


`timescale 1 ns / 1 ps

module MVAU_hls_1_hls_deadlock_idx1_monitor ( // for module MVAU_hls_1_MVAU_hls_1_inst.grp_Matrix_Vector_Activate_Stream_Batch_fu_60
    input wire clock,
    input wire reset,
    input wire [2:0] axis_block_sigs,
    input wire [1:0] inst_idle_sigs,
    input wire [0:0] inst_block_sigs,
    output wire block
);

// signal declare
reg monitor_find_block;
wire sub_parallel_block;
wire all_sub_parallel_has_block;
wire all_sub_single_has_block;
wire cur_axis_has_block;
wire seq_is_axis_block;

assign block = monitor_find_block;
assign all_sub_parallel_has_block = 1'b0;
assign all_sub_single_has_block = 1'b0;
assign cur_axis_has_block = 1'b0 | axis_block_sigs[0] | axis_block_sigs[1] | axis_block_sigs[2];
assign seq_is_axis_block = all_sub_parallel_has_block | all_sub_single_has_block | cur_axis_has_block;

always @(posedge clock) begin
    if (reset == 1'b1)
        monitor_find_block <= 1'b0;
    else if (seq_is_axis_block == 1'b1)
        monitor_find_block <= 1'b1;
    else
        monitor_find_block <= 1'b0;
end


// instant sub module
endmodule
//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/vivado_stitch_proj_w5fn6zuu/finn_vivado_stitch_proj.gen/sources_1/bd/finn_design/ip/finn_design_StreamingFIFO_rtl_3_0/synth/finn_design_StreamingFIFO_rtl_3_0.v


// (c) Copyright 1995-2026 Xilinx, Inc. All rights reserved.
// 
// This file contains confidential and proprietary information
// of Xilinx, Inc. and is protected under U.S. and
// international copyright and other intellectual property
// laws.
// 
// DISCLAIMER
// This disclaimer is not a license and does not grant any
// rights to the materials distributed herewith. Except as
// otherwise provided in a valid license issued to you by
// Xilinx, and to the maximum extent permitted by applicable
// law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
// WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
// AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
// BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
// INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
// (2) Xilinx shall not be liable (whether in contract or tort,
// including negligence, or under any other theory of
// liability) for any loss or damage of any kind or nature
// related to, arising under or in connection with these
// materials, including for any direct, or any indirect,
// special, incidental, or consequential loss or damage
// (including loss of data, profits, goodwill, or any type of
// loss or damage suffered as a result of any action brought
// by a third party) even if such damage or loss was
// reasonably foreseeable or Xilinx had been advised of the
// possibility of the same.
// 
// CRITICAL APPLICATIONS
// Xilinx products are not designed or intended to be fail-
// safe, or for use in any application requiring fail-safe
// performance, such as life-support or safety devices or
// systems, Class III medical devices, nuclear facilities,
// applications related to the deployment of airbags, or any
// other applications that could lead to death, personal
// injury, or severe property or environmental damage
// (individually and collectively, "Critical
// Applications"). Customer assumes the sole risk and
// liability of any use of Xilinx products in Critical
// Applications, subject only to applicable laws and
// regulations governing limitations on product liability.
// 
// THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
// PART OF THIS FILE AT ALL TIMES.
// 
// DO NOT MODIFY THIS FILE.


// IP VLNV: xilinx.com:module_ref:StreamingFIFO_rtl_3:1.0
// IP Revision: 1

(* X_CORE_INFO = "StreamingFIFO_rtl_3,Vivado 2022.2" *)
(* CHECK_LICENSE_TYPE = "finn_design_StreamingFIFO_rtl_3_0,StreamingFIFO_rtl_3,{}" *)
(* CORE_GENERATION_INFO = "finn_design_StreamingFIFO_rtl_3_0,StreamingFIFO_rtl_3,{x_ipProduct=Vivado 2022.2,x_ipVendor=xilinx.com,x_ipLibrary=module_ref,x_ipName=StreamingFIFO_rtl_3,x_ipVersion=1.0,x_ipCoreRevision=1,x_ipLanguage=VERILOG,x_ipSimLanguage=MIXED}" *)
(* IP_DEFINITION_SOURCE = "module_ref" *)
(* DowngradeIPIdentifiedWarnings = "yes" *)
module finn_design_StreamingFIFO_rtl_3_0 (
  ap_clk,
  ap_rst_n,
  count,
  maxcount,
  in0_V_TREADY,
  in0_V_TVALID,
  in0_V_TDATA,
  out_V_TREADY,
  out_V_TVALID,
  out_V_TDATA
);

(* X_INTERFACE_PARAMETER = "XIL_INTERFACENAME ap_clk, ASSOCIATED_RESET ap_rst_n, ASSOCIATED_BUSIF in0_V:out_V, FREQ_HZ 100000000, FREQ_TOLERANCE_HZ 0, PHASE 0.0, CLK_DOMAIN finn_design_ap_clk_0, INSERT_VIP 0" *)
(* X_INTERFACE_INFO = "xilinx.com:signal:clock:1.0 ap_clk CLK" *)
input wire ap_clk;
(* X_INTERFACE_PARAMETER = "XIL_INTERFACENAME ap_rst_n, POLARITY ACTIVE_LOW, INSERT_VIP 0" *)
(* X_INTERFACE_INFO = "xilinx.com:signal:reset:1.0 ap_rst_n RST" *)
input wire ap_rst_n;
output wire [14 : 0] count;
output wire [14 : 0] maxcount;
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 in0_V TREADY" *)
output wire in0_V_TREADY;
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 in0_V TVALID" *)
input wire in0_V_TVALID;
(* X_INTERFACE_PARAMETER = "XIL_INTERFACENAME in0_V, TDATA_NUM_BYTES 1, TDEST_WIDTH 0, TID_WIDTH 0, TUSER_WIDTH 0, HAS_TREADY 1, HAS_TSTRB 0, HAS_TKEEP 0, HAS_TLAST 0, FREQ_HZ 100000000, PHASE 0.0, CLK_DOMAIN finn_design_ap_clk_0, LAYERED_METADATA undef, INSERT_VIP 0" *)
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 in0_V TDATA" *)
input wire [7 : 0] in0_V_TDATA;
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 out_V TREADY" *)
input wire out_V_TREADY;
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 out_V TVALID" *)
output wire out_V_TVALID;
(* X_INTERFACE_PARAMETER = "XIL_INTERFACENAME out_V, TDATA_NUM_BYTES 1, TDEST_WIDTH 0, TID_WIDTH 0, TUSER_WIDTH 0, HAS_TREADY 1, HAS_TSTRB 0, HAS_TKEEP 0, HAS_TLAST 0, FREQ_HZ 100000000, PHASE 0.0, CLK_DOMAIN finn_design_ap_clk_0, LAYERED_METADATA undef, INSERT_VIP 0" *)
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 out_V TDATA" *)
output wire [7 : 0] out_V_TDATA;

  StreamingFIFO_rtl_3 inst (
    .ap_clk(ap_clk),
    .ap_rst_n(ap_rst_n),
    .count(count),
    .maxcount(maxcount),
    .in0_V_TREADY(in0_V_TREADY),
    .in0_V_TVALID(in0_V_TVALID),
    .in0_V_TDATA(in0_V_TDATA),
    .out_V_TREADY(out_V_TREADY),
    .out_V_TVALID(out_V_TVALID),
    .out_V_TDATA(out_V_TDATA)
  );
endmodule
//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/vivado_stitch_proj_w5fn6zuu/finn_vivado_stitch_proj.gen/sources_1/bd/finn_design/ip/finn_design_StreamingDataWidthConverter_rtl_0_0/synth/finn_design_StreamingDataWidthConverter_rtl_0_0.v


// (c) Copyright 1995-2026 Xilinx, Inc. All rights reserved.
// 
// This file contains confidential and proprietary information
// of Xilinx, Inc. and is protected under U.S. and
// international copyright and other intellectual property
// laws.
// 
// DISCLAIMER
// This disclaimer is not a license and does not grant any
// rights to the materials distributed herewith. Except as
// otherwise provided in a valid license issued to you by
// Xilinx, and to the maximum extent permitted by applicable
// law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
// WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
// AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
// BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
// INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
// (2) Xilinx shall not be liable (whether in contract or tort,
// including negligence, or under any other theory of
// liability) for any loss or damage of any kind or nature
// related to, arising under or in connection with these
// materials, including for any direct, or any indirect,
// special, incidental, or consequential loss or damage
// (including loss of data, profits, goodwill, or any type of
// loss or damage suffered as a result of any action brought
// by a third party) even if such damage or loss was
// reasonably foreseeable or Xilinx had been advised of the
// possibility of the same.
// 
// CRITICAL APPLICATIONS
// Xilinx products are not designed or intended to be fail-
// safe, or for use in any application requiring fail-safe
// performance, such as life-support or safety devices or
// systems, Class III medical devices, nuclear facilities,
// applications related to the deployment of airbags, or any
// other applications that could lead to death, personal
// injury, or severe property or environmental damage
// (individually and collectively, "Critical
// Applications"). Customer assumes the sole risk and
// liability of any use of Xilinx products in Critical
// Applications, subject only to applicable laws and
// regulations governing limitations on product liability.
// 
// THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
// PART OF THIS FILE AT ALL TIMES.
// 
// DO NOT MODIFY THIS FILE.


// IP VLNV: xilinx.com:module_ref:StreamingDataWidthConverter_rtl_0:1.0
// IP Revision: 1

(* X_CORE_INFO = "StreamingDataWidthConverter_rtl_0,Vivado 2022.2" *)
(* CHECK_LICENSE_TYPE = "finn_design_StreamingDataWidthConverter_rtl_0_0,StreamingDataWidthConverter_rtl_0,{}" *)
(* CORE_GENERATION_INFO = "finn_design_StreamingDataWidthConverter_rtl_0_0,StreamingDataWidthConverter_rtl_0,{x_ipProduct=Vivado 2022.2,x_ipVendor=xilinx.com,x_ipLibrary=module_ref,x_ipName=StreamingDataWidthConverter_rtl_0,x_ipVersion=1.0,x_ipCoreRevision=1,x_ipLanguage=VERILOG,x_ipSimLanguage=MIXED,IBITS=24,OBITS=8,AXI_IBITS=24,AXI_OBITS=8}" *)
(* IP_DEFINITION_SOURCE = "module_ref" *)
(* DowngradeIPIdentifiedWarnings = "yes" *)
module finn_design_StreamingDataWidthConverter_rtl_0_0 (
  ap_clk,
  ap_rst_n,
  in0_V_TREADY,
  in0_V_TVALID,
  in0_V_TDATA,
  out_V_TREADY,
  out_V_TVALID,
  out_V_TDATA
);

(* X_INTERFACE_PARAMETER = "XIL_INTERFACENAME ap_clk, ASSOCIATED_RESET ap_rst_n, ASSOCIATED_BUSIF in0_V:out_V, FREQ_HZ 100000000, FREQ_TOLERANCE_HZ 0, PHASE 0.0, CLK_DOMAIN finn_design_ap_clk_0, INSERT_VIP 0" *)
(* X_INTERFACE_INFO = "xilinx.com:signal:clock:1.0 ap_clk CLK" *)
input wire ap_clk;
(* X_INTERFACE_PARAMETER = "XIL_INTERFACENAME ap_rst_n, POLARITY ACTIVE_LOW, INSERT_VIP 0" *)
(* X_INTERFACE_INFO = "xilinx.com:signal:reset:1.0 ap_rst_n RST" *)
input wire ap_rst_n;
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 in0_V TREADY" *)
output wire in0_V_TREADY;
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 in0_V TVALID" *)
input wire in0_V_TVALID;
(* X_INTERFACE_PARAMETER = "XIL_INTERFACENAME in0_V, TDATA_NUM_BYTES 3, TDEST_WIDTH 0, TID_WIDTH 0, TUSER_WIDTH 0, HAS_TREADY 1, HAS_TSTRB 0, HAS_TKEEP 0, HAS_TLAST 0, FREQ_HZ 100000000, PHASE 0.0, CLK_DOMAIN finn_design_ap_clk_0, LAYERED_METADATA undef, INSERT_VIP 0" *)
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 in0_V TDATA" *)
input wire [23 : 0] in0_V_TDATA;
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 out_V TREADY" *)
input wire out_V_TREADY;
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 out_V TVALID" *)
output wire out_V_TVALID;
(* X_INTERFACE_PARAMETER = "XIL_INTERFACENAME out_V, TDATA_NUM_BYTES 1, TDEST_WIDTH 0, TID_WIDTH 0, TUSER_WIDTH 0, HAS_TREADY 1, HAS_TSTRB 0, HAS_TKEEP 0, HAS_TLAST 0, FREQ_HZ 100000000, PHASE 0.0, CLK_DOMAIN finn_design_ap_clk_0, LAYERED_METADATA undef, INSERT_VIP 0" *)
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 out_V TDATA" *)
output wire [7 : 0] out_V_TDATA;

  StreamingDataWidthConverter_rtl_0 #(
    .IBITS(24),
    .OBITS(8),
    .AXI_IBITS(24),
    .AXI_OBITS(8)
  ) inst (
    .ap_clk(ap_clk),
    .ap_rst_n(ap_rst_n),
    .in0_V_TREADY(in0_V_TREADY),
    .in0_V_TVALID(in0_V_TVALID),
    .in0_V_TDATA(in0_V_TDATA),
    .out_V_TREADY(out_V_TREADY),
    .out_V_TVALID(out_V_TVALID),
    .out_V_TDATA(out_V_TDATA)
  );
endmodule
//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/code_gen_ipgen_StreamingDataWidthConverter_rtl_1_6qz_oquq/dwc_axi.sv


/******************************************************************************
 * Copyright (C) 2023, Advanced Micro Devices, Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *  1. Redistributions of source code must retain the above copyright notice,
 *     this list of conditions and the following disclaimer.
 *
 *  2. Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *
 *  3. Neither the name of the copyright holder nor the names of its
 *     contributors may be used to endorse or promote products derived from
 *     this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION). HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * @brief	AXI Stream Adapter for Data Width Converter.
 * @author	Thomas B. Preuer <tpreusse@amd.com>
 *****************************************************************************/
module dwc_axi #(
	int unsigned  IBITS,
	int unsigned  OBITS,

	localparam int unsigned  AXI_IBITS = (IBITS+7)/8 * 8,
	localparam int unsigned  AXI_OBITS = (OBITS+7)/8 * 8
)(
	//- Global Control ------------------
	input	logic  ap_clk,
	input	logic  ap_rst_n,

	//- AXI Stream - Input --------------
	output	logic  s_axis_tready,
	input	logic  s_axis_tvalid,
	input	logic [AXI_IBITS-1:0]  s_axis_tdata,

	//- AXI Stream - Output -------------
	input	logic  m_axis_tready,
	output	logic  m_axis_tvalid,
	output	logic [AXI_OBITS-1:0]  m_axis_tdata
);

	dwc #(.IBITS(IBITS), .OBITS(OBITS)) core (
		.clk(ap_clk), .rst(!ap_rst_n),
		.irdy(s_axis_tready), .ivld(s_axis_tvalid), .idat(s_axis_tdata[IBITS-1:0]),
		.ordy(m_axis_tready), .ovld(m_axis_tvalid), .odat(m_axis_tdata[OBITS-1:0])
	);
	if(OBITS < AXI_OBITS) begin
		assign	m_axis_tdata[AXI_OBITS-1:OBITS] = '0;
	end

endmodule : dwc_axi
//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/vivado_stitch_proj_w5fn6zuu/finn_vivado_stitch_proj.gen/sources_1/bd/finn_design/ipshared/bcb1/hdl/memstream.sv


/**
 * Copyright (c) 2023, Xilinx
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of FINN nor the names of its
 *   contributors may be used to endorse or promote products derived from
 *   this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * @author	Thomas B. Preuer <thomas.preusser@amd.com>
 */

module memstream #(
	int unsigned  DEPTH,
	int unsigned  WIDTH,

	parameter  INIT_FILE = "",
	parameter  RAM_STYLE = "auto"
)(
	input	logic  clk,
	input	logic  rst,

	// Configuration and readback interface - compatible with ap_memory
	input	logic  config_ce,
	input	logic  config_we,
	input	logic [31     :0]  config_address,
	input	logic [WIDTH-1:0]  config_d0,

	output	logic  config_rack,
	output	logic [WIDTH-1:0]  config_q0,

	// Continuous output stream
	input	logic  ordy,
	output	logic  ovld,
	output	logic [WIDTH-1:0]  odat
);

	typedef logic [$clog2(DEPTH)-1:0]  addr_t;
	typedef logic [WIDTH        -1:0]  data_t;

	uwire  en;       // Pipeline enable
	uwire  rollback; // Rollback stream reads if backpressure would block read back

	// Counter with pre-computed last indication for val == DEPTH-1
	typedef struct {
		addr_t  val;
		logic   lst;
	} ptr_t;

	// Counter history to facilitate pipeline rollback
	ptr_t  Ptr[3] = '{
		0: '{ val: 0, lst: DEPTH<2 },
		default: '{ default: 'x }
	};

	//-----------------------------------------------------------------------
	// Stage #0: Address & Op
	logic  Wr1 = 0;  // Write
	logic  Rb1 = 0;  // Read back
	logic  Rs1 = 0;  // Read stream
	data_t  Data1 = 'x;
	if(1) begin : blkStage1
		// Increment for wrapping DEPTH-1 back to zero
		localparam int unsigned  WRAP_INC = 2**$bits(addr_t) - DEPTH + 1;

		uwire ptr_t  ptr_eff = rollback? Ptr[2] : Ptr[0];
		uwire ptr_t  ptr_nxt;
		assign	ptr_nxt.val = ptr_eff.val + (config_ce? 0 : !ptr_eff.lst? 1 : WRAP_INC);
		assign	ptr_nxt.lst =
			DEPTH < 2?   1 :
			config_ce?   ptr_eff.lst :
			ptr_eff.lst? 0 :
			/* else */   ptr_eff.val == DEPTH-2;

		always_ff @(posedge clk) begin
			if(rst)      Ptr[0] <= '{ val: 0, lst: DEPTH<2 };
			else if(en)  Ptr[0] <= ptr_nxt;
		end

		// Issue next Memory Operation
		always_ff @(posedge clk) begin
			if(rst) begin
				Wr1 <= 0;
				Rb1 <= 0;
				Rs1 <= 0;
				Ptr[1] <= '{ default : 'x };
				Data1  <= 'x;
			end
			else if(en) begin
				Wr1 <= 0;
				Rb1 <= 0;
				Rs1 <= 0;
				if(config_ce) begin
					if(config_we)  Wr1 <= 1;
					else           Rb1 <= 1;
					Ptr[1] <= '{ val: config_address, lst: 'x };
					Data1  <= config_d0;
				end
				else begin
					Rs1 <= 1;
					Ptr[1] <= ptr_eff;
					Data1  <= 'x;
				end
			end
		end
	end : blkStage1

	//-----------------------------------------------------------------------
	// Stage #2: Memory Access
	logic   Rb2 = 0;
	logic   Rs2 = 0;
	data_t  Data2 = 'x;
	if(1) begin : blkStage2
		(* RAM_STYLE = RAM_STYLE *)
		data_t  Mem[DEPTH];

		// Optional Memory Initialization
		if(INIT_FILE != "")  initial $readmemh(INIT_FILE, Mem);

		// Execute Memory Operation
		uwire addr_t  addr = Ptr[1].val;
		always_ff @(posedge clk) begin
			if(en) begin
				if(Wr1)  Mem[addr] <= Data1;
				Data2 <= Mem[addr];
			end
		end

		// Copy Output Designation
		always_ff @(posedge clk) begin
			if(rst) begin
				Rb2 <= 0;
				Rs2 <= 0;
				Ptr[2] <= '{ default: 'x };
			end
			else if(en) begin
				Rb2 <= Rb1;
				Rs2 <= Rs1 && !rollback;
				Ptr[2] <= Ptr[1];
			end
		end
	end : blkStage2

	//-----------------------------------------------------------------------
	// Output Interfaces
	assign	config_rack = Rb2;
	assign	config_q0 = Data2;

	assign	ovld = Rs2;
	assign	odat = Data2;

	uwire  backpressure = Rs2 && !ordy;
	assign	rollback = backpressure && (Rb1 || config_ce);
	assign	en       = !backpressure || Rb1 || config_ce;

endmodule : memstream
//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/code_gen_ipgen_StreamingDataWidthConverter_rtl_2_8cmmvtlt/dwc.sv


/******************************************************************************
 * Copyright (C) 2023, Advanced Micro Devices, Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *  1. Redistributions of source code must retain the above copyright notice,
 *     this list of conditions and the following disclaimer.
 *
 *  2. Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *
 *  3. Neither the name of the copyright holder nor the names of its
 *     contributors may be used to endorse or promote products derived from
 *     this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION). HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * @brief	Stream Data Width Converter.
 * @author	Thomas B. Preuer <tpreusse@amd.com>
 *****************************************************************************/
module dwc #(
	int unsigned  IBITS,
	int unsigned  OBITS
)(
	//- Global Control ------------------
	input	logic  clk,
	input	logic  rst,

	//- AXI Stream - Input --------------
	output	logic  irdy,
	input	logic  ivld,
	input	logic [IBITS-1:0]  idat,

	//- AXI Stream - Output -------------
	input	logic  ordy,
	output	logic  ovld,
	output	logic [OBITS-1:0]  odat
);

	if(IBITS == OBITS) begin : genNoop
		assign	irdy = ordy;
		assign	ovld = ivld;
		assign	odat  = idat;
	end : genNoop
	else if(IBITS < OBITS) begin : genUp

		// Sanity Checking: integer upscaling
		initial begin
			if(OBITS % IBITS) begin
				$error("Output width %0d is not a multiple of input width %0d.", OBITS, IBITS);
				$finish;
			end
		end

		// Parallelizing Shift Register A and Sidestep Buffer B on Input Path
		localparam int unsigned  K = OBITS / IBITS;
		typedef logic [IBITS-1:0]  dat_t;
		dat_t       [K-1:0]  ADat = 'x;
		logic [$clog2(K):0]  ACnt = K-1;	// (empty) K-1, ..., 0, -1 (full/valid)
		dat_t  BDat = 'x;
		logic  BRdy =  1;
		always_ff @(posedge clk) begin
			if(rst) begin
				ADat <= 'x;
				ACnt <= K-1;
				BDat <= 'x;
				BRdy <=  1;
			end
			else begin
				automatic type(ACnt)  acnt = (ovld && ordy)? K-1 : ACnt;
				automatic logic  rdy = !ovld || ordy;
				if((ivld || !BRdy) && rdy) begin
					ADat <= { BRdy? idat : BDat, ADat[K-1:1] };
					acnt--;
				end
				ACnt <= acnt;

				if(BRdy)  BDat <= idat;
				BRdy <= rdy || (BRdy && !ivld);
			end
		end

		// Output Assignments
		assign  irdy = BRdy;
		assign	ovld = ACnt[$left(ACnt)];
		assign	odat  = ADat;

	end : genUp
	else begin : genDown

		// Sanity Checking: integer downscaling
		initial begin
			if(IBITS % OBITS) begin
				$error("Input width %0d is not a multiple of output width %0d.", IBITS, OBITS);
				$finish;
			end
		end

		// Serializing Shift Register A and Sidestep Buffer B on Output Path
		localparam int unsigned  K = IBITS / OBITS;
		typedef logic [OBITS-1:0]  dat_t;
		dat_t [      K-1:0]  ADat = 'x;
		logic [$clog2(K):0]  ACnt =  1;	// (full) -K+1, ..., -1, 0, 1 (empty/not valid)
		dat_t  BDat = 'x;
		logic  BRdy =  1;
		dat_t  CDat = 'x;
		logic  CVld =  0;
		always_ff @(posedge clk) begin
			if(rst) begin
				ADat <= 'x;
				ACnt <=  1;
				BDat <= 'x;
				BRdy <=  1;
				CDat <= 'x;
				CVld <=  0;
			end
			else begin
				automatic type(ACnt)  acnt = ACnt;
				automatic logic       ainc = 0;
				if(irdy) begin
					ADat <= idat;
					acnt = ivld? -K+1 : 1;
				end
				else if(BRdy) begin
					ADat <= { {OBITS{1'bx}}, ADat[K-1:1] };
					ainc = BRdy;
				end;
				ACnt <= acnt + ainc;

				if(BRdy)  BDat <= ADat[0];
				BRdy <= !CVld || ordy || (BRdy && !ACnt[$left(ACnt)] && ACnt[0]);

				if(!CVld || ordy)  CDat <= BRdy? ADat[0] : BDat;
				CVld <= (CVld && !ordy) || !BRdy || ACnt[$left(ACnt)] || !ACnt[0];
			end
		end

		// Output Assignments
		assign  irdy = BRdy && !ACnt[$left(ACnt)];
		assign	ovld = CVld;
		assign	odat  = CDat;

	end : genDown

endmodule : dwc
//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn-rtllib/mvu/replay_buffer.sv


/******************************************************************************
 * Copyright (C) 2022-2023, Advanced Micro Devices, Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *  1. Redistributions of source code must retain the above copyright notice,
 *     this list of conditions and the following disclaimer.
 *
 *  2. Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *
 *  3. Neither the name of the copyright holder nor the names of its
 *     contributors may be used to endorse or promote products derived from
 *     this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION). HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * @brief	Replay buffer for counted sequences on an AXI-lite stream.
 * @author	Thomas B. Preuer <thomas.preusser@amd.com>
 *****************************************************************************/

module replay_buffer #(
	int unsigned  LEN,	// Sequence length
	int unsigned  REP,	// Sequence replay count
	int unsigned  W 	// Data width
)(
	input	logic  clk,
	input	logic  rst,

	input	logic [W-1:0]  idat,
	input	logic  ivld,
	output	logic  irdy,

	output	logic [W-1:0]  odat,
	output	logic  olast,
	output	logic  ofin,
	output	logic  ovld,
	input	logic  ordy
);

	if(LEN == 0)  initial begin
		$error("%m: Illegal zero sequence LEN.");
		$finish;
	end
	if(REP == 0) initial begin
		$error("%m: Illegal zero REP count.");
		$finish;
	end

	// Track position in Sequence
	uwire  last_item;
	uwire  shift;
	if(LEN == 1)  assign  last_item = 1;
	else begin
		typedef logic [$clog2(LEN)-1:0]  count_t;
		count_t  Count = 0;
		logic    Last  = 0;
		always_ff @(posedge clk) begin
			if(rst) begin
				Count <= 0;
				Last  <= 0;
			end
			else if(shift) begin
				Count <= Count + (Last? 2**$clog2(LEN)-LEN+1 : 1);
				Last  <= (((LEN-2) & ~Count) == 0) && ((LEN&1) || !Last);
			end
		end
		assign	last_item = Last;
	end

	if(REP == 1) begin
		assign	shift = ivld && ordy;

		assign	irdy  = ordy;
		assign	odat  = idat;
		assign	olast = last_item;
		assign	ofin  = last_item;
		assign	ovld  = ivld;
	end
	else begin

		// Track Repetitions
		uwire  last_rep;
		if(1) begin : blkRep
			typedef logic [$clog2(REP)-1:0]  rep_t;
			rep_t  RepCnt = 0;
			logic  RepLst = 0;
			always_ff @(posedge clk) begin
				if(rst) begin
					RepCnt <= 0;
					RepLst <= 0;
				end
				else if(last_item && shift) begin
					RepCnt <= RepCnt + (RepLst? 2**$clog2(REP)-REP+1 : 1);
					RepLst <= (((REP-2) & ~RepCnt) == 0) && ((REP&1) || !RepLst);
				end
			end
			assign	last_rep = RepLst;
		end : blkRep

		localparam int unsigned  AWIDTH = LEN < 2? 1 : $clog2(LEN);
		typedef logic [AWIDTH  :0]  ptr_t;	// pointers with additional generational MSB
		typedef logic [W     -1:0]  data_t;

		// Output Registers
		data_t  ODat;
		logic   OVld =  0;
		logic   OLst = 'x;
		logic   OFin = 'x;
		assign	odat  = ODat;
		assign	olast = OLst;
		assign	ofin  = OFin;
		assign	ovld  = OVld;

		// Buffer Memory Management
		data_t  Mem[2**AWIDTH];
		ptr_t  WP = 0;	// Write Pointer
		ptr_t  RP = 0;	// Read Pointer
		ptr_t  FP = 0;	// Free Pointer

		// Operational Guards
		//	Occupancy:    WP-FP
		//	  WP-FP < 2**AWIDTH -> writing allowed
		//		- increments WP
		//	Availability: WP-RP
		//	  WP-RP > 0         -> reading allowed
		//		- increments RP, last in sequence rewinds to FP for non-final repetition
		//		- increments FP in last repetition
		assign	irdy = !((WP-FP) >> AWIDTH);

		uwire  wr = irdy && ivld;
		uwire  rd = !OVld || ordy;
		always_ff @(posedge clk) begin
			if(wr)  Mem[WP[AWIDTH-1:0]] <= idat;
			if(rd)  ODat <= Mem[RP[AWIDTH-1:0]];
		end

		uwire  vld = (RP != WP);
		assign	shift = rd && vld;
		always_ff @(posedge clk) begin
			if(rst) begin
				WP <= 0;
				RP <= 0;
				FP <= 0;

				OVld <=  0;
				OLst <= 'x;
				OFin <= 'x;
			end
			else begin
				if(wr)  WP <= WP + 1;
				if(rd) begin
					if(vld) begin
						automatic logic  rewind = last_item && !last_rep;
						RP <= RP + (rewind? 2**(AWIDTH+1)-LEN+1 : 1);
						FP <= FP + last_rep;
					end

					OVld <= vld;
					OLst <= last_item;
					OFin <= last_rep && last_item;
				end
			end
		end

	end

endmodule : replay_buffer
//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/vivado_stitch_proj_w5fn6zuu/finn_vivado_stitch_proj.gen/sources_1/bd/finn_design/ipshared/bcb1/hdl/memstream_axi_wrapper.v


/**
 * Copyright (c) 2023, Xilinx
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of FINN nor the names of its
 *   contributors may be used to endorse or promote products derived from
 *   this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * @author	Thomas B. Preuer <thomas.preusser@amd.com>
 */

module memstream_axi_wrapper #(
	parameter  DEPTH = 512,
	parameter  WIDTH = 32,

	parameter  INIT_FILE = "",
	parameter  RAM_STYLE = "auto",

	parameter  AXILITE_ADDR_WIDTH = $clog2(DEPTH * (2**$clog2((WIDTH+31)/32))) + 2
)(
	// Global Control
	(* X_INTERFACE_PARAMETER = "ASSOCIATED_BUSIF m_axis_0, ASSOCIATED_RESET ap_rst_n" *)
	(* X_INTERFACE_INFO = "xilinx.com:signal:clock:1.0 ap_clk CLK" *)
	input	ap_clk,
	(* X_INTERFACE_PARAMETER = "POLARITY ACTIVE_LOW" *)
	input	ap_rst_n,

	// AXI-lite Write
	output	awready,
	input	awvalid,
	input	[2:0]  awprot,
	input	[AXILITE_ADDR_WIDTH-1:0]  awaddr,

	output	wready,
	input	wvalid,
	input	[31:0]  wdata,
	input	[ 3:0]  wstrb,

	input	bready,
	output	bvalid,
	output	[1:0]  bresp,

	// AXI-lite Read
	output	arready,
	input	arvalid,
	input	[2:0]  arprot,
	input	[AXILITE_ADDR_WIDTH-1:0]  araddr,

	input	rready,
	output	rvalid,
	output	[ 1:0]  rresp,
	output	[31:0]  rdata,

	// Continuous output stream
	input	m_axis_0_tready,
	output	m_axis_0_tvalid,
	output	[((WIDTH+7)/8)*8-1:0]  m_axis_0_tdata
);

	localparam  INIT_FILTERED =
`ifdef SYNTHESIS
		RAM_STYLE == "ultra"? "" :
`endif
		INIT_FILE;

	memstream_axi #(
		.DEPTH(DEPTH), .WIDTH(WIDTH),
		.INIT_FILE(INIT_FILTERED),
		.RAM_STYLE(RAM_STYLE)
	) core (
		.clk(ap_clk), .rst(!ap_rst_n),

		// AXI-lite Write
		.awready(awready),
		.awvalid(awvalid),
		.awprot(awprot),
		.awaddr(awaddr),
		.wready(wready),
		.wvalid(wvalid),
		.wdata(wdata),
		.wstrb(wstrb),
		.bready(bready),
		.bvalid(bvalid),
		.bresp(bresp),

		// AXI-lite Read
		.arready(arready),
		.arvalid(arvalid),
		.arprot(arprot),
		.araddr(araddr),
		.rready(rready),
		.rvalid(rvalid),
		.rresp(rresp),
		.rdata(rdata),

		// Continuous output stream
		.m_axis_0_tready(m_axis_0_tready),
		.m_axis_0_tvalid(m_axis_0_tvalid),
		.m_axis_0_tdata(m_axis_0_tdata)
	);

endmodule : memstream_axi_wrapper
//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/vivado_stitch_proj_w5fn6zuu/finn_vivado_stitch_proj.gen/sources_1/bd/finn_design/ip/finn_design_MVAU_hls_0_wstrm_0/synth/finn_design_MVAU_hls_0_wstrm_0.v


// (c) Copyright 1995-2026 Xilinx, Inc. All rights reserved.
// 
// This file contains confidential and proprietary information
// of Xilinx, Inc. and is protected under U.S. and
// international copyright and other intellectual property
// laws.
// 
// DISCLAIMER
// This disclaimer is not a license and does not grant any
// rights to the materials distributed herewith. Except as
// otherwise provided in a valid license issued to you by
// Xilinx, and to the maximum extent permitted by applicable
// law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
// WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
// AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
// BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
// INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
// (2) Xilinx shall not be liable (whether in contract or tort,
// including negligence, or under any other theory of
// liability) for any loss or damage of any kind or nature
// related to, arising under or in connection with these
// materials, including for any direct, or any indirect,
// special, incidental, or consequential loss or damage
// (including loss of data, profits, goodwill, or any type of
// loss or damage suffered as a result of any action brought
// by a third party) even if such damage or loss was
// reasonably foreseeable or Xilinx had been advised of the
// possibility of the same.
// 
// CRITICAL APPLICATIONS
// Xilinx products are not designed or intended to be fail-
// safe, or for use in any application requiring fail-safe
// performance, such as life-support or safety devices or
// systems, Class III medical devices, nuclear facilities,
// applications related to the deployment of airbags, or any
// other applications that could lead to death, personal
// injury, or severe property or environmental damage
// (individually and collectively, "Critical
// Applications"). Customer assumes the sole risk and
// liability of any use of Xilinx products in Critical
// Applications, subject only to applicable laws and
// regulations governing limitations on product liability.
// 
// THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
// PART OF THIS FILE AT ALL TIMES.
// 
// DO NOT MODIFY THIS FILE.


// IP VLNV: amd.com:finn:memstream:1.0
// IP Revision: 5

(* X_CORE_INFO = "memstream_axi_wrapper,Vivado 2022.2" *)
(* CHECK_LICENSE_TYPE = "finn_design_MVAU_hls_0_wstrm_0,memstream_axi_wrapper,{}" *)
(* IP_DEFINITION_SOURCE = "package_project" *)
(* DowngradeIPIdentifiedWarnings = "yes" *)
module finn_design_MVAU_hls_0_wstrm_0 (
  ap_clk,
  ap_rst_n,
  awready,
  awvalid,
  awprot,
  awaddr,
  wready,
  wvalid,
  wdata,
  wstrb,
  bready,
  bvalid,
  bresp,
  arready,
  arvalid,
  arprot,
  araddr,
  rready,
  rvalid,
  rresp,
  rdata,
  m_axis_0_tready,
  m_axis_0_tvalid,
  m_axis_0_tdata
);

(* X_INTERFACE_PARAMETER = "XIL_INTERFACENAME ap_clk, ASSOCIATED_RESET ap_rst_n, ASSOCIATED_BUSIF m_axis_0:s_axilite, FREQ_TOLERANCE_HZ -1, FREQ_HZ 100000000, PHASE 0.0, CLK_DOMAIN finn_design_ap_clk_0, INSERT_VIP 0" *)
(* X_INTERFACE_INFO = "xilinx.com:signal:clock:1.0 ap_clk CLK" *)
input wire ap_clk;
(* X_INTERFACE_PARAMETER = "XIL_INTERFACENAME ap_rst_n, POLARITY ACTIVE_LOW, INSERT_VIP 0" *)
(* X_INTERFACE_INFO = "xilinx.com:signal:reset:1.0 ap_rst_n RST" *)
input wire ap_rst_n;
(* X_INTERFACE_INFO = "xilinx.com:interface:aximm:1.0 s_axilite AWREADY" *)
output wire awready;
(* X_INTERFACE_INFO = "xilinx.com:interface:aximm:1.0 s_axilite AWVALID" *)
input wire awvalid;
(* X_INTERFACE_INFO = "xilinx.com:interface:aximm:1.0 s_axilite AWPROT" *)
input wire [2 : 0] awprot;
(* X_INTERFACE_INFO = "xilinx.com:interface:aximm:1.0 s_axilite AWADDR" *)
input wire [10 : 0] awaddr;
(* X_INTERFACE_INFO = "xilinx.com:interface:aximm:1.0 s_axilite WREADY" *)
output wire wready;
(* X_INTERFACE_INFO = "xilinx.com:interface:aximm:1.0 s_axilite WVALID" *)
input wire wvalid;
(* X_INTERFACE_INFO = "xilinx.com:interface:aximm:1.0 s_axilite WDATA" *)
input wire [31 : 0] wdata;
(* X_INTERFACE_INFO = "xilinx.com:interface:aximm:1.0 s_axilite WSTRB" *)
input wire [3 : 0] wstrb;
(* X_INTERFACE_INFO = "xilinx.com:interface:aximm:1.0 s_axilite BREADY" *)
input wire bready;
(* X_INTERFACE_INFO = "xilinx.com:interface:aximm:1.0 s_axilite BVALID" *)
output wire bvalid;
(* X_INTERFACE_INFO = "xilinx.com:interface:aximm:1.0 s_axilite BRESP" *)
output wire [1 : 0] bresp;
(* X_INTERFACE_INFO = "xilinx.com:interface:aximm:1.0 s_axilite ARREADY" *)
output wire arready;
(* X_INTERFACE_INFO = "xilinx.com:interface:aximm:1.0 s_axilite ARVALID" *)
input wire arvalid;
(* X_INTERFACE_INFO = "xilinx.com:interface:aximm:1.0 s_axilite ARPROT" *)
input wire [2 : 0] arprot;
(* X_INTERFACE_INFO = "xilinx.com:interface:aximm:1.0 s_axilite ARADDR" *)
input wire [10 : 0] araddr;
(* X_INTERFACE_INFO = "xilinx.com:interface:aximm:1.0 s_axilite RREADY" *)
input wire rready;
(* X_INTERFACE_INFO = "xilinx.com:interface:aximm:1.0 s_axilite RVALID" *)
output wire rvalid;
(* X_INTERFACE_INFO = "xilinx.com:interface:aximm:1.0 s_axilite RRESP" *)
output wire [1 : 0] rresp;
(* X_INTERFACE_PARAMETER = "XIL_INTERFACENAME s_axilite, DATA_WIDTH 32, PROTOCOL AXI4LITE, FREQ_HZ 100000000, ID_WIDTH 0, ADDR_WIDTH 11, AWUSER_WIDTH 0, ARUSER_WIDTH 0, WUSER_WIDTH 0, RUSER_WIDTH 0, BUSER_WIDTH 0, READ_WRITE_MODE READ_WRITE, HAS_BURST 0, HAS_LOCK 0, HAS_PROT 1, HAS_CACHE 0, HAS_QOS 0, HAS_REGION 0, HAS_WSTRB 1, HAS_BRESP 1, HAS_RRESP 1, SUPPORTS_NARROW_BURST 0, NUM_READ_OUTSTANDING 1, NUM_WRITE_OUTSTANDING 1, MAX_BURST_LENGTH 1, PHASE 0.0, CLK_DOMAIN finn_design_ap_clk_0, NUM_READ_THREADS 1, NUM_WRITE_THRE\
ADS 1, RUSER_BITS_PER_BYTE 0, WUSER_BITS_PER_BYTE 0, INSERT_VIP 0" *)
(* X_INTERFACE_INFO = "xilinx.com:interface:aximm:1.0 s_axilite RDATA" *)
output wire [31 : 0] rdata;
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 m_axis_0 TREADY" *)
input wire m_axis_0_tready;
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 m_axis_0 TVALID" *)
output wire m_axis_0_tvalid;
(* X_INTERFACE_PARAMETER = "XIL_INTERFACENAME m_axis_0, TDATA_NUM_BYTES 1, TDEST_WIDTH 0, TID_WIDTH 0, TUSER_WIDTH 0, HAS_TREADY 1, HAS_TSTRB 0, HAS_TKEEP 0, HAS_TLAST 0, FREQ_HZ 100000000, PHASE 0.0, CLK_DOMAIN finn_design_ap_clk_0, LAYERED_METADATA undef, INSERT_VIP 0" *)
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 m_axis_0 TDATA" *)
output wire [7 : 0] m_axis_0_tdata;

  memstream_axi_wrapper #(
    .DEPTH(432),
    .WIDTH(8),
    .INIT_FILE("/home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/code_gen_ipgen_MVAU_hls_0_z2r2fzak/memblock.dat"),
    .RAM_STYLE("auto"),
    .AXILITE_ADDR_WIDTH(11)
  ) inst (
    .ap_clk(ap_clk),
    .ap_rst_n(ap_rst_n),
    .awready(awready),
    .awvalid(awvalid),
    .awprot(awprot),
    .awaddr(awaddr),
    .wready(wready),
    .wvalid(wvalid),
    .wdata(wdata),
    .wstrb(wstrb),
    .bready(bready),
    .bvalid(bvalid),
    .bresp(bresp),
    .arready(arready),
    .arvalid(arvalid),
    .arprot(arprot),
    .araddr(araddr),
    .rready(rready),
    .rvalid(rvalid),
    .rresp(rresp),
    .rdata(rdata),
    .m_axis_0_tready(m_axis_0_tready),
    .m_axis_0_tvalid(m_axis_0_tvalid),
    .m_axis_0_tdata(m_axis_0_tdata)
  );
endmodule
//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/vivado_stitch_proj_w5fn6zuu/finn_vivado_stitch_proj.gen/sources_1/bd/finn_design/ipshared/18e4/hdl/verilog/MVAU_hls_0_Matrix_Vector_Activate_Stream_Batch_p_ZL7threshs_6_ROM_AUTO_1R.v


// ==============================================================
// Vitis HLS - High-Level Synthesis from C, C++ and OpenCL v2022.2 (64-bit)
// Version: 2022.2
// Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.
// ==============================================================
`timescale 1 ns / 1 ps
module MVAU_hls_0_Matrix_Vector_Activate_Stream_Batch_p_ZL7threshs_6_ROM_AUTO_1R (
    address0, ce0, q0, 
    reset, clk);

parameter DataWidth = 13;
parameter AddressWidth = 4;
parameter AddressRange = 16;
 
input[AddressWidth-1:0] address0;
input ce0;
output reg[DataWidth-1:0] q0;

input reset;
input clk;

 
reg [DataWidth-1:0] rom0[0:AddressRange-1];


initial begin
     
    $readmemh("/home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/code_gen_ipgen_MVAU_hls_0_z2r2fzak/project_MVAU_hls_0/sol1/impl/ip/hdl/verilog/MVAU_hls_0_Matrix_Vector_Activate_Stream_Batch_p_ZL7threshs_6_ROM_AUTO_1R.dat", rom0);
end

  
always @(posedge clk) 
begin 
    if (ce0) 
    begin
        q0 <= rom0[address0];
    end
end


endmodule

//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/vivado_stitch_proj_w5fn6zuu/finn_vivado_stitch_proj.gen/sources_1/bd/finn_design/ipshared/fb57/hdl/verilog/MVAU_hls_1_Matrix_Vector_Activate_Stream_Batch_p_ZL7threshs_3_ROM_AUTO_1R.v


// ==============================================================
// Vitis HLS - High-Level Synthesis from C, C++ and OpenCL v2022.2 (64-bit)
// Version: 2022.2
// Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.
// ==============================================================
`timescale 1 ns / 1 ps
module MVAU_hls_1_Matrix_Vector_Activate_Stream_Batch_p_ZL7threshs_3_ROM_AUTO_1R (
    address0, ce0, q0, 
    reset, clk);

parameter DataWidth = 10;
parameter AddressWidth = 5;
parameter AddressRange = 32;
 
input[AddressWidth-1:0] address0;
input ce0;
output reg[DataWidth-1:0] q0;

input reset;
input clk;

 
reg [DataWidth-1:0] rom0[0:AddressRange-1];


initial begin
     
    $readmemh("/home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/code_gen_ipgen_MVAU_hls_1__774deg0/project_MVAU_hls_1/sol1/impl/ip/hdl/verilog/MVAU_hls_1_Matrix_Vector_Activate_Stream_Batch_p_ZL7threshs_3_ROM_AUTO_1R.dat", rom0);
end

  
always @(posedge clk) 
begin 
    if (ce0) 
    begin
        q0 <= rom0[address0];
    end
end


endmodule

//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/code_gen_ipgen_StreamingFIFO_rtl_3_tnug1a14/Q_srl.v


// original source:
// https://github.com/nachiket/tdfc/blob/master/verilog/queues/Q_srl_oreg3_prefull_SIMPLE.v


// Copyright (c) 1999 The Regents of the University of California
// Copyright (c) 2010 The Regents of the University of Pennsylvania
// Copyright (c) 2011 Department of Electrical and Electronic Engineering, Imperial College London
// Copyright (c) 2020 Xilinx
//
// Permission to use, copy, modify, and distribute this software and
// its documentation for any purpose, without fee, and without a
// written agreement is hereby granted, provided that the above copyright
// notice and this paragraph and the following two paragraphs appear in
// all copies.
//
// IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR
// DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
// LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION,
// EVEN IF THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
// THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
// INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
// AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE PROVIDED HEREUNDER IS ON
// AN "AS IS" BASIS, AND THE UNIVERSITY OF CALIFORNIA HAS NO OBLIGATIONS TO
// PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
//

// Q_srl_oreg3_prefull_SIMPLE.v
//
//  - In-page queue with parameterizable depth, bit width
//  - Stream I/O is triple (data, valid, back-pressure),
//      with EOS concatenated into the data
//  - Flow control for input & output is combinationally decoupled
//  - 2 <= depth <= 256
//      * (depth >= 2)  is required to decouple I/O flow control,
//          where empty => no produce,  full => no consume,
//          and depth 1 would ping-pong between the two at half rate
//      * (depth <= 256) can be modified
//           by changing ''synthesis loop_limit X'' below
//          and changing ''addrwidth'' or its log computation
//  - 1 <= width
//  - Queue storage is in SRL16E, up to depth 16 per LUT per bit-slice,
//      plus output register (for fast output)
//  - Queue addressing is done by ''addr'' up-down counter
//  - Queue fullness is checked by comparator (addr==depth)
//  - Queue fullness                           is pre-computed for next cycle
//  - Queue input back-pressure                is pre-computed for next cycle
//  - Queue output valid (state!=state__empty) is pre-computed for next cycle
//      (necessary since SRL data output reg requires non-boolean state)
//  - FSM has 3 states (empty, one, more)
//  - When empty, continue to emit most recently emitted value (for debugging)
//
//  - Queue slots used      = / (state==state_empty) ? 0
//                            | (state==state_one)   ? 1
//                            \ (state==state_more)  ? addr+2
//  - Queue slots used     <=  depth
//  - Queue slots remaining =  depth - used
//                          = / (state==state_empty) ? depth
//                            | (state==state_one)   ? depth-1
//                            \ (state==state_more)  ? depth-2-addr
//
//  - Synplify 7.1 / 8.0
//  - Eylon Caspi,  9/11/03, 8/18/04, 3/29/05


`ifdef  Q_srl
`else
`define Q_srl


module Q_srl (clock, reset, i_d, i_v, i_r, o_d, o_v, o_r, count, maxcount);

   parameter depth = 16;   // - greatest #items in queue  (2 <= depth <= 256)
   parameter width = 16;   // - width of data (i_d, o_d)

   localparam countwidth = $clog2(depth + 1);
   localparam addrwidth = $clog2(depth);

   input     clock;
   input     reset;

   input  [width-1:0] i_d;	// - input  stream data (concat data + eos)
   input              i_v;	// - input  stream valid
   output             i_r;	// - input  stream ready
   wire               i_b;  // - input  stream back-pressure

   output [width-1:0] o_d;	// - output stream data (concat data + eos)
   output             o_v;	// - output stream valid
   input              o_r;	// - output stream ready
   wire               o_b;	// - output stream back-pressure

   output [countwidth-1:0] count;  // - output number of elems in queue
   output [countwidth-1:0] maxcount;  // - maximum observed count since reset

   reg [countwidth-1:0] maxcount_reg;  // - maximum count seen until now
   reg    [addrwidth-1:0] addr, addr_, a_;		// - SRL16 address
							//     for data output
   reg 			  shift_en_;			// - SRL16 shift enable
   reg    [width-1:0] 	  srl [depth-2:0];		// - SRL16 memory
   reg 			  shift_en_o_;			// - SRLO  shift enable
   reg    [width-1:0] 	  srlo_, srlo			// - SRLO  output reg
			  /* synthesis syn_allow_retiming=0 */ ;

   parameter state_empty = 2'd0;    // - state empty : o_v=0 o_d=UNDEFINED
   parameter state_one   = 2'd1;    // - state one   : o_v=1 o_d=srlo
   parameter state_more  = 2'd2;    // - state more  : o_v=1 o_d=srlo
				    //     #items in srl = addr+2

   reg [1:0] state, state_;	    // - state register

   wire      addr_full_;	    // - true iff addr==depth-2 on NEXT cycle
   reg       addr_full; 	    // - true iff addr==depth-2
   wire      addr_zero_;	    // - true iff addr==0
   wire      o_v_reg_;		    // - true iff state_empty   on NEXT cycle
   reg       o_v_reg  		    // - true iff state_empty
	     /* synthesis syn_allow_retiming=0 */ ;
   wire      i_b_reg_;		    // - true iff !full         on NEXT cycle
   reg       i_b_reg  		    // - true iff !full
	     /* synthesis syn_allow_retiming=0 */ ;

   assign addr_full_ = (state_==state_more) && (addr_==depth-2);
						// - queue full
   assign addr_zero_ = (addr==0);		// - queue contains 2 (or 1,0)
   assign o_v_reg_   = (state_!=state_empty);	// - output valid if non-empty
   assign i_b_reg_   = addr_full_;		// - input bp if full
   assign o_d = srlo;				// - output data from queue
   assign o_v = o_v_reg;			// - output valid if non-empty
   assign i_b = i_b_reg;			// - input bp if full
   assign maxcount = maxcount_reg;

   assign i_r = !i_b;
   assign o_b = !o_r;

   assign count = (state==state_more ? addr+2 : (state==state_one ? 1 : 0));

   // - ''always'' block with both FFs and SRL16 does not work,
   //      since FFs need reset but SRL16 does not

   always @(posedge clock) begin	// - seq always: FFs
      if (reset) begin
	 state     <= state_empty;
	 addr      <= 0;
         addr_full <= 0;
	 o_v_reg   <= 0;

	 i_b_reg   <= 0;
	 maxcount_reg <= 0;

      end
      else begin
	 state     <= state_;
	 addr      <= addr_;
         addr_full <= addr_full_;
	 o_v_reg   <= o_v_reg_;
	 i_b_reg   <= i_b_reg_;
	 maxcount_reg <= (count > maxcount_reg ? count : maxcount_reg);
      end
   end // always @ (posedge clock)

   always @(posedge clock) begin	// - seq always: srlo
      // - infer enabled output reg at end of shift chain
      // - input first element from i_d, all subsequent elements from SRL16
      if (reset) begin
	 srlo <= 0;
      end
      else begin
	 if (shift_en_o_) begin
	    srlo <= srlo_;
	 end
      end
   end // always @ (posedge clock)

   always @(posedge clock) begin			// - seq always: srl
      // - infer enabled SRL16E from shifting srl array
      // - no reset capability;  srl[] contents undefined on reset
      if (shift_en_) begin
	 // synthesis loop_limit 256
	 for (a_=depth-2; a_>0; a_=a_-1) begin
	    srl[a_] = srl[a_-1];
	 end
	 srl[0] <= i_d;
      end
   end // always @ (posedge clock or negedge reset)

   always @* begin					// - combi always
        srlo_       <=  'bx;
        shift_en_o_ <= 1'bx;
        shift_en_   <= 1'bx;
        addr_       <=  'bx;
        state_      <= 2'bx;
      case (state)

	state_empty: begin		    // - (empty, will not produce)
	      if (i_v) begin		    // - empty & i_v => consume
		 srlo_       <= i_d;
		 shift_en_o_ <= 1;
		 shift_en_   <= 1'bx;
		 addr_       <= 0;
		 state_      <= state_one;
	      end
	      else	begin		    // - empty & !i_v => idle
		 srlo_       <= 'bx;
		 shift_en_o_ <= 0;
		 shift_en_   <= 1'bx;
		 addr_       <= 0;
		 state_      <= state_empty;
	      end
	end

	state_one: begin		    // - (contains one)
	      if (i_v && o_b) begin	    // - one & i_v & o_b => consume
		 srlo_       <= 'bx;
		 shift_en_o_ <= 0;
		 shift_en_   <= 1;
		 addr_       <= 0;
		 state_      <= state_more;
	      end
	      else if (i_v && !o_b) begin   // - one & i_v & !o_b => cons+prod
		 srlo_       <= i_d;
		 shift_en_o_ <= 1;
		 shift_en_   <= 1;
		 addr_       <= 0;
		 state_      <= state_one;
	      end
	      else if (!i_v && o_b) begin   // - one & !i_v & o_b => idle
		 srlo_       <= 'bx;
		 shift_en_o_ <= 0;
		 shift_en_   <= 1'bx;
		 addr_       <= 0;
		 state_      <= state_one;
	      end
	      else if (!i_v && !o_b) begin  // - one & !i_v & !o_b => produce
		 srlo_       <= 'bx;
		 shift_en_o_ <= 0;
		 shift_en_   <= 1'bx;
		 addr_       <= 0;
		 state_      <= state_empty;
	      end
	end // case: state_one

	state_more: begin		    // - (contains more than one)
	   if (addr_full || (depth==2)) begin
					    // - (full, will not consume)
					    // - (full here if depth==2)
	      if (o_b) begin		    // - full & o_b => idle
		 srlo_       <= 'bx;
		 shift_en_o_ <= 0;
		 shift_en_   <= 0;
		 addr_       <= addr;
		 state_      <= state_more;
	      end
	      else begin		    // - full & !o_b => produce
		 srlo_       <= srl[addr];
		 shift_en_o_ <= 1;
		 shift_en_   <= 0;
//		 addr_       <= addr-1;
//		 state_      <= state_more;
		 addr_       <= addr_zero_ ? 0         : addr-1;
		 state_      <= addr_zero_ ? state_one : state_more;
	      end
	   end
	   else begin			    // - (mid: neither empty nor full)
	      if (i_v && o_b) begin	    // - mid & i_v & o_b => consume
		 srlo_       <= 'bx;
		 shift_en_o_ <= 0;
		 shift_en_   <= 1;
		 addr_       <= addr+1;
		 state_      <= state_more;
	      end
	      else if (i_v && !o_b) begin   // - mid & i_v & !o_b => cons+prod
		 srlo_       <= srl[addr];
		 shift_en_o_ <= 1;
		 shift_en_   <= 1;
		 addr_       <= addr;
		 state_      <= state_more;
	      end
	      else if (!i_v && o_b) begin   // - mid & !i_v & o_b => idle
		 srlo_       <= 'bx;
		 shift_en_o_ <= 0;
		 shift_en_   <= 0;
		 addr_       <= addr;
		 state_      <= state_more;
	      end
	      else if (!i_v && !o_b) begin  // - mid & !i_v & !o_b => produce
		 srlo_       <= srl[addr];
		 shift_en_o_ <= 1;
		 shift_en_   <= 0;
		 addr_       <= addr_zero_ ? 0         : addr-1;
		 state_      <= addr_zero_ ? state_one : state_more;
	      end
	   end // else: !if(addr_full)
	end // case: state_more

	default: begin
		 srlo_       <=  'bx;
		 shift_en_o_ <= 1'bx;
		 shift_en_   <= 1'bx;
		 addr_       <=  'bx;
		 state_      <= 2'bx;
	end // case: default

      endcase // case(state)
   end // always @ *

endmodule // Q_srl


`endif  // `ifdef  Q_srl
//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/vivado_stitch_proj_w5fn6zuu/finn_vivado_stitch_proj.gen/sources_1/bd/finn_design/ipshared/fb57/hdl/verilog/MVAU_hls_1_Matrix_Vector_Activate_Stream_Batch_p_ZL7threshs_7_ROM_AUTO_1R.v


// ==============================================================
// Vitis HLS - High-Level Synthesis from C, C++ and OpenCL v2022.2 (64-bit)
// Version: 2022.2
// Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.
// ==============================================================
`timescale 1 ns / 1 ps
module MVAU_hls_1_Matrix_Vector_Activate_Stream_Batch_p_ZL7threshs_7_ROM_AUTO_1R (
    address0, ce0, q0, 
    reset, clk);

parameter DataWidth = 11;
parameter AddressWidth = 5;
parameter AddressRange = 32;
 
input[AddressWidth-1:0] address0;
input ce0;
output reg[DataWidth-1:0] q0;

input reset;
input clk;

 
reg [DataWidth-1:0] rom0[0:AddressRange-1];


initial begin
     
    $readmemh("/home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/code_gen_ipgen_MVAU_hls_1__774deg0/project_MVAU_hls_1/sol1/impl/ip/hdl/verilog/MVAU_hls_1_Matrix_Vector_Activate_Stream_Batch_p_ZL7threshs_7_ROM_AUTO_1R.dat", rom0);
end

  
always @(posedge clk) 
begin 
    if (ce0) 
    begin
        q0 <= rom0[address0];
    end
end


endmodule

//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/vivado_stitch_proj_w5fn6zuu/finn_vivado_stitch_proj.gen/sources_1/bd/finn_design/ipshared/4d6a/hdl/verilog/StreamingMaxPool_hls_1_hls_deadlock_idx1_monitor.v


`timescale 1 ns / 1 ps

module StreamingMaxPool_hls_1_hls_deadlock_idx1_monitor ( // for module StreamingMaxPool_hls_1_StreamingMaxPool_hls_1_inst.grp_StreamingMaxPool_Precision_14u_2u_32u_ap_uint_4_0_128_s_fu_28
    input wire clock,
    input wire reset,
    input wire [1:0] axis_block_sigs,
    input wire [3:0] inst_idle_sigs,
    input wire [0:0] inst_block_sigs,
    output wire block
);

// signal declare
reg monitor_find_block;
wire idx3_block;
wire idx2_block;
wire sub_parallel_block;
wire all_sub_parallel_has_block;
wire all_sub_single_has_block;
wire cur_axis_has_block;
wire seq_is_axis_block;

assign block = monitor_find_block;
assign idx3_block = axis_block_sigs[1];
assign idx2_block = axis_block_sigs[0];
assign all_sub_parallel_has_block = 1'b0;
assign all_sub_single_has_block = 1'b0 | (idx3_block & (axis_block_sigs[1])) | (idx2_block & (axis_block_sigs[0]));
assign cur_axis_has_block = 1'b0;
assign seq_is_axis_block = all_sub_parallel_has_block | all_sub_single_has_block | cur_axis_has_block;

always @(posedge clock) begin
    if (reset == 1'b1)
        monitor_find_block <= 1'b0;
    else if (seq_is_axis_block == 1'b1)
        monitor_find_block <= 1'b1;
    else
        monitor_find_block <= 1'b0;
end


// instant sub module
endmodule
//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/vivado_stitch_proj_w5fn6zuu/finn_vivado_stitch_proj.gen/sources_1/bd/finn_design/ip/finn_design_ConvolutionInputGenerator_rtl_1_0/synth/finn_design_ConvolutionInputGenerator_rtl_1_0.v


// (c) Copyright 1995-2026 Xilinx, Inc. All rights reserved.
// 
// This file contains confidential and proprietary information
// of Xilinx, Inc. and is protected under U.S. and
// international copyright and other intellectual property
// laws.
// 
// DISCLAIMER
// This disclaimer is not a license and does not grant any
// rights to the materials distributed herewith. Except as
// otherwise provided in a valid license issued to you by
// Xilinx, and to the maximum extent permitted by applicable
// law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
// WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
// AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
// BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
// INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
// (2) Xilinx shall not be liable (whether in contract or tort,
// including negligence, or under any other theory of
// liability) for any loss or damage of any kind or nature
// related to, arising under or in connection with these
// materials, including for any direct, or any indirect,
// special, incidental, or consequential loss or damage
// (including loss of data, profits, goodwill, or any type of
// loss or damage suffered as a result of any action brought
// by a third party) even if such damage or loss was
// reasonably foreseeable or Xilinx had been advised of the
// possibility of the same.
// 
// CRITICAL APPLICATIONS
// Xilinx products are not designed or intended to be fail-
// safe, or for use in any application requiring fail-safe
// performance, such as life-support or safety devices or
// systems, Class III medical devices, nuclear facilities,
// applications related to the deployment of airbags, or any
// other applications that could lead to death, personal
// injury, or severe property or environmental damage
// (individually and collectively, "Critical
// Applications"). Customer assumes the sole risk and
// liability of any use of Xilinx products in Critical
// Applications, subject only to applicable laws and
// regulations governing limitations on product liability.
// 
// THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
// PART OF THIS FILE AT ALL TIMES.
// 
// DO NOT MODIFY THIS FILE.


// IP VLNV: xilinx.com:module_ref:ConvolutionInputGenerator_rtl_1:1.0
// IP Revision: 1

(* X_CORE_INFO = "ConvolutionInputGenerator_rtl_1,Vivado 2022.2" *)
(* CHECK_LICENSE_TYPE = "finn_design_ConvolutionInputGenerator_rtl_1_0,ConvolutionInputGenerator_rtl_1,{}" *)
(* CORE_GENERATION_INFO = "finn_design_ConvolutionInputGenerator_rtl_1_0,ConvolutionInputGenerator_rtl_1,{x_ipProduct=Vivado 2022.2,x_ipVendor=xilinx.com,x_ipLibrary=module_ref,x_ipName=ConvolutionInputGenerator_rtl_1,x_ipVersion=1.0,x_ipCoreRevision=1,x_ipLanguage=VERILOG,x_ipSimLanguage=MIXED,BIT_WIDTH=4,SIMD=1,MMV_IN=1,MMV_OUT=1,IN_WIDTH_PADDED=8,OUT_WIDTH_PADDED=8,BUF_IN_WIDTH=4,BUF_OUT_WIDTH=4}" *)
(* IP_DEFINITION_SOURCE = "module_ref" *)
(* DowngradeIPIdentifiedWarnings = "yes" *)
module finn_design_ConvolutionInputGenerator_rtl_1_0 (
  ap_clk,
  ap_rst_n,
  in0_V_TDATA,
  in0_V_TVALID,
  in0_V_TREADY,
  out_V_TDATA,
  out_V_TVALID,
  out_V_TREADY
);

(* X_INTERFACE_PARAMETER = "XIL_INTERFACENAME ap_clk, ASSOCIATED_RESET ap_rst_n, ASSOCIATED_BUSIF in0_V:out_V, FREQ_HZ 100000000, FREQ_TOLERANCE_HZ 0, PHASE 0.0, CLK_DOMAIN finn_design_ap_clk_0, INSERT_VIP 0" *)
(* X_INTERFACE_INFO = "xilinx.com:signal:clock:1.0 ap_clk CLK" *)
input wire ap_clk;
(* X_INTERFACE_PARAMETER = "XIL_INTERFACENAME ap_rst_n, POLARITY ACTIVE_LOW, INSERT_VIP 0" *)
(* X_INTERFACE_INFO = "xilinx.com:signal:reset:1.0 ap_rst_n RST" *)
input wire ap_rst_n;
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 in0_V TDATA" *)
input wire [7 : 0] in0_V_TDATA;
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 in0_V TVALID" *)
input wire in0_V_TVALID;
(* X_INTERFACE_PARAMETER = "XIL_INTERFACENAME in0_V, TDATA_NUM_BYTES 1, TDEST_WIDTH 0, TID_WIDTH 0, TUSER_WIDTH 0, HAS_TREADY 1, HAS_TSTRB 0, HAS_TKEEP 0, HAS_TLAST 0, FREQ_HZ 100000000, PHASE 0.0, CLK_DOMAIN finn_design_ap_clk_0, LAYERED_METADATA undef, INSERT_VIP 0" *)
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 in0_V TREADY" *)
output wire in0_V_TREADY;
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 out_V TDATA" *)
output wire [7 : 0] out_V_TDATA;
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 out_V TVALID" *)
output wire out_V_TVALID;
(* X_INTERFACE_PARAMETER = "XIL_INTERFACENAME out_V, TDATA_NUM_BYTES 1, TDEST_WIDTH 0, TID_WIDTH 0, TUSER_WIDTH 0, HAS_TREADY 1, HAS_TSTRB 0, HAS_TKEEP 0, HAS_TLAST 0, FREQ_HZ 100000000, PHASE 0.0, CLK_DOMAIN finn_design_ap_clk_0, LAYERED_METADATA undef, INSERT_VIP 0" *)
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 out_V TREADY" *)
input wire out_V_TREADY;

  ConvolutionInputGenerator_rtl_1 #(
    .BIT_WIDTH(4),
    .SIMD(1),
    .MMV_IN(1),
    .MMV_OUT(1),
    .IN_WIDTH_PADDED(8),
    .OUT_WIDTH_PADDED(8),
    .BUF_IN_WIDTH(4),
    .BUF_OUT_WIDTH(4)
  ) inst (
    .ap_clk(ap_clk),
    .ap_rst_n(ap_rst_n),
    .in0_V_TDATA(in0_V_TDATA),
    .in0_V_TVALID(in0_V_TVALID),
    .in0_V_TREADY(in0_V_TREADY),
    .out_V_TDATA(out_V_TDATA),
    .out_V_TVALID(out_V_TVALID),
    .out_V_TREADY(out_V_TREADY)
  );
endmodule
//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/vivado_stitch_proj_w5fn6zuu/finn_vivado_stitch_proj.gen/sources_1/bd/finn_design/ip/finn_design_StreamingDataWidthConverter_rtl_2_0/synth/finn_design_StreamingDataWidthConverter_rtl_2_0.v


// (c) Copyright 1995-2026 Xilinx, Inc. All rights reserved.
// 
// This file contains confidential and proprietary information
// of Xilinx, Inc. and is protected under U.S. and
// international copyright and other intellectual property
// laws.
// 
// DISCLAIMER
// This disclaimer is not a license and does not grant any
// rights to the materials distributed herewith. Except as
// otherwise provided in a valid license issued to you by
// Xilinx, and to the maximum extent permitted by applicable
// law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
// WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
// AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
// BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
// INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
// (2) Xilinx shall not be liable (whether in contract or tort,
// including negligence, or under any other theory of
// liability) for any loss or damage of any kind or nature
// related to, arising under or in connection with these
// materials, including for any direct, or any indirect,
// special, incidental, or consequential loss or damage
// (including loss of data, profits, goodwill, or any type of
// loss or damage suffered as a result of any action brought
// by a third party) even if such damage or loss was
// reasonably foreseeable or Xilinx had been advised of the
// possibility of the same.
// 
// CRITICAL APPLICATIONS
// Xilinx products are not designed or intended to be fail-
// safe, or for use in any application requiring fail-safe
// performance, such as life-support or safety devices or
// systems, Class III medical devices, nuclear facilities,
// applications related to the deployment of airbags, or any
// other applications that could lead to death, personal
// injury, or severe property or environmental damage
// (individually and collectively, "Critical
// Applications"). Customer assumes the sole risk and
// liability of any use of Xilinx products in Critical
// Applications, subject only to applicable laws and
// regulations governing limitations on product liability.
// 
// THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
// PART OF THIS FILE AT ALL TIMES.
// 
// DO NOT MODIFY THIS FILE.


// IP VLNV: xilinx.com:module_ref:StreamingDataWidthConverter_rtl_2:1.0
// IP Revision: 1

(* X_CORE_INFO = "StreamingDataWidthConverter_rtl_2,Vivado 2022.2" *)
(* CHECK_LICENSE_TYPE = "finn_design_StreamingDataWidthConverter_rtl_2_0,StreamingDataWidthConverter_rtl_2,{}" *)
(* CORE_GENERATION_INFO = "finn_design_StreamingDataWidthConverter_rtl_2_0,StreamingDataWidthConverter_rtl_2,{x_ipProduct=Vivado 2022.2,x_ipVendor=xilinx.com,x_ipLibrary=module_ref,x_ipName=StreamingDataWidthConverter_rtl_2,x_ipVersion=1.0,x_ipCoreRevision=1,x_ipLanguage=VERILOG,x_ipSimLanguage=MIXED,IBITS=64,OBITS=4,AXI_IBITS=64,AXI_OBITS=8}" *)
(* IP_DEFINITION_SOURCE = "module_ref" *)
(* DowngradeIPIdentifiedWarnings = "yes" *)
module finn_design_StreamingDataWidthConverter_rtl_2_0 (
  ap_clk,
  ap_rst_n,
  in0_V_TREADY,
  in0_V_TVALID,
  in0_V_TDATA,
  out_V_TREADY,
  out_V_TVALID,
  out_V_TDATA
);

(* X_INTERFACE_PARAMETER = "XIL_INTERFACENAME ap_clk, ASSOCIATED_RESET ap_rst_n, ASSOCIATED_BUSIF in0_V:out_V, FREQ_HZ 100000000, FREQ_TOLERANCE_HZ 0, PHASE 0.0, CLK_DOMAIN finn_design_ap_clk_0, INSERT_VIP 0" *)
(* X_INTERFACE_INFO = "xilinx.com:signal:clock:1.0 ap_clk CLK" *)
input wire ap_clk;
(* X_INTERFACE_PARAMETER = "XIL_INTERFACENAME ap_rst_n, POLARITY ACTIVE_LOW, INSERT_VIP 0" *)
(* X_INTERFACE_INFO = "xilinx.com:signal:reset:1.0 ap_rst_n RST" *)
input wire ap_rst_n;
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 in0_V TREADY" *)
output wire in0_V_TREADY;
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 in0_V TVALID" *)
input wire in0_V_TVALID;
(* X_INTERFACE_PARAMETER = "XIL_INTERFACENAME in0_V, TDATA_NUM_BYTES 8, TDEST_WIDTH 0, TID_WIDTH 0, TUSER_WIDTH 0, HAS_TREADY 1, HAS_TSTRB 0, HAS_TKEEP 0, HAS_TLAST 0, FREQ_HZ 100000000, PHASE 0.0, CLK_DOMAIN finn_design_ap_clk_0, LAYERED_METADATA undef, INSERT_VIP 0" *)
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 in0_V TDATA" *)
input wire [63 : 0] in0_V_TDATA;
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 out_V TREADY" *)
input wire out_V_TREADY;
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 out_V TVALID" *)
output wire out_V_TVALID;
(* X_INTERFACE_PARAMETER = "XIL_INTERFACENAME out_V, TDATA_NUM_BYTES 1, TDEST_WIDTH 0, TID_WIDTH 0, TUSER_WIDTH 0, HAS_TREADY 1, HAS_TSTRB 0, HAS_TKEEP 0, HAS_TLAST 0, FREQ_HZ 100000000, PHASE 0.0, CLK_DOMAIN finn_design_ap_clk_0, LAYERED_METADATA undef, INSERT_VIP 0" *)
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 out_V TDATA" *)
output wire [7 : 0] out_V_TDATA;

  StreamingDataWidthConverter_rtl_2 #(
    .IBITS(64),
    .OBITS(4),
    .AXI_IBITS(64),
    .AXI_OBITS(8)
  ) inst (
    .ap_clk(ap_clk),
    .ap_rst_n(ap_rst_n),
    .in0_V_TREADY(in0_V_TREADY),
    .in0_V_TVALID(in0_V_TVALID),
    .in0_V_TDATA(in0_V_TDATA),
    .out_V_TREADY(out_V_TREADY),
    .out_V_TVALID(out_V_TVALID),
    .out_V_TDATA(out_V_TDATA)
  );
endmodule
//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/code_gen_ipgen_StreamingDataWidthConverter_rtl_4_w7r25d9z/dwc_axi.sv


/******************************************************************************
 * Copyright (C) 2023, Advanced Micro Devices, Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *  1. Redistributions of source code must retain the above copyright notice,
 *     this list of conditions and the following disclaimer.
 *
 *  2. Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *
 *  3. Neither the name of the copyright holder nor the names of its
 *     contributors may be used to endorse or promote products derived from
 *     this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION). HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * @brief	AXI Stream Adapter for Data Width Converter.
 * @author	Thomas B. Preuer <tpreusse@amd.com>
 *****************************************************************************/
module dwc_axi #(
	int unsigned  IBITS,
	int unsigned  OBITS,

	localparam int unsigned  AXI_IBITS = (IBITS+7)/8 * 8,
	localparam int unsigned  AXI_OBITS = (OBITS+7)/8 * 8
)(
	//- Global Control ------------------
	input	logic  ap_clk,
	input	logic  ap_rst_n,

	//- AXI Stream - Input --------------
	output	logic  s_axis_tready,
	input	logic  s_axis_tvalid,
	input	logic [AXI_IBITS-1:0]  s_axis_tdata,

	//- AXI Stream - Output -------------
	input	logic  m_axis_tready,
	output	logic  m_axis_tvalid,
	output	logic [AXI_OBITS-1:0]  m_axis_tdata
);

	dwc #(.IBITS(IBITS), .OBITS(OBITS)) core (
		.clk(ap_clk), .rst(!ap_rst_n),
		.irdy(s_axis_tready), .ivld(s_axis_tvalid), .idat(s_axis_tdata[IBITS-1:0]),
		.ordy(m_axis_tready), .ovld(m_axis_tvalid), .odat(m_axis_tdata[OBITS-1:0])
	);
	if(OBITS < AXI_OBITS) begin
		assign	m_axis_tdata[AXI_OBITS-1:OBITS] = '0;
	end

endmodule : dwc_axi
//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/vivado_stitch_proj_w5fn6zuu/finn_vivado_stitch_proj.gen/sources_1/bd/finn_design/ipshared/fb57/hdl/verilog/MVAU_hls_1_Matrix_Vector_Activate_Stream_Batch_p_ZL7threshs_10_ROM_AUTO_1R.v


// ==============================================================
// Vitis HLS - High-Level Synthesis from C, C++ and OpenCL v2022.2 (64-bit)
// Version: 2022.2
// Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.
// ==============================================================
`timescale 1 ns / 1 ps
module MVAU_hls_1_Matrix_Vector_Activate_Stream_Batch_p_ZL7threshs_10_ROM_AUTO_1R (
    address0, ce0, q0, 
    reset, clk);

parameter DataWidth = 10;
parameter AddressWidth = 5;
parameter AddressRange = 32;
 
input[AddressWidth-1:0] address0;
input ce0;
output reg[DataWidth-1:0] q0;

input reset;
input clk;

 
reg [DataWidth-1:0] rom0[0:AddressRange-1];


initial begin
     
    $readmemh("/home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/code_gen_ipgen_MVAU_hls_1__774deg0/project_MVAU_hls_1/sol1/impl/ip/hdl/verilog/MVAU_hls_1_Matrix_Vector_Activate_Stream_Batch_p_ZL7threshs_10_ROM_AUTO_1R.dat", rom0);
end

  
always @(posedge clk) 
begin 
    if (ce0) 
    begin
        q0 <= rom0[address0];
    end
end


endmodule

//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/code_gen_ipgen_StreamingFIFO_rtl_6_gcub_frn/Q_srl.v


// original source:
// https://github.com/nachiket/tdfc/blob/master/verilog/queues/Q_srl_oreg3_prefull_SIMPLE.v


// Copyright (c) 1999 The Regents of the University of California
// Copyright (c) 2010 The Regents of the University of Pennsylvania
// Copyright (c) 2011 Department of Electrical and Electronic Engineering, Imperial College London
// Copyright (c) 2020 Xilinx
//
// Permission to use, copy, modify, and distribute this software and
// its documentation for any purpose, without fee, and without a
// written agreement is hereby granted, provided that the above copyright
// notice and this paragraph and the following two paragraphs appear in
// all copies.
//
// IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR
// DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
// LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION,
// EVEN IF THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
// THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
// INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
// AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE PROVIDED HEREUNDER IS ON
// AN "AS IS" BASIS, AND THE UNIVERSITY OF CALIFORNIA HAS NO OBLIGATIONS TO
// PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
//

// Q_srl_oreg3_prefull_SIMPLE.v
//
//  - In-page queue with parameterizable depth, bit width
//  - Stream I/O is triple (data, valid, back-pressure),
//      with EOS concatenated into the data
//  - Flow control for input & output is combinationally decoupled
//  - 2 <= depth <= 256
//      * (depth >= 2)  is required to decouple I/O flow control,
//          where empty => no produce,  full => no consume,
//          and depth 1 would ping-pong between the two at half rate
//      * (depth <= 256) can be modified
//           by changing ''synthesis loop_limit X'' below
//          and changing ''addrwidth'' or its log computation
//  - 1 <= width
//  - Queue storage is in SRL16E, up to depth 16 per LUT per bit-slice,
//      plus output register (for fast output)
//  - Queue addressing is done by ''addr'' up-down counter
//  - Queue fullness is checked by comparator (addr==depth)
//  - Queue fullness                           is pre-computed for next cycle
//  - Queue input back-pressure                is pre-computed for next cycle
//  - Queue output valid (state!=state__empty) is pre-computed for next cycle
//      (necessary since SRL data output reg requires non-boolean state)
//  - FSM has 3 states (empty, one, more)
//  - When empty, continue to emit most recently emitted value (for debugging)
//
//  - Queue slots used      = / (state==state_empty) ? 0
//                            | (state==state_one)   ? 1
//                            \ (state==state_more)  ? addr+2
//  - Queue slots used     <=  depth
//  - Queue slots remaining =  depth - used
//                          = / (state==state_empty) ? depth
//                            | (state==state_one)   ? depth-1
//                            \ (state==state_more)  ? depth-2-addr
//
//  - Synplify 7.1 / 8.0
//  - Eylon Caspi,  9/11/03, 8/18/04, 3/29/05


`ifdef  Q_srl
`else
`define Q_srl


module Q_srl (clock, reset, i_d, i_v, i_r, o_d, o_v, o_r, count, maxcount);

   parameter depth = 16;   // - greatest #items in queue  (2 <= depth <= 256)
   parameter width = 16;   // - width of data (i_d, o_d)

   localparam countwidth = $clog2(depth + 1);
   localparam addrwidth = $clog2(depth);

   input     clock;
   input     reset;

   input  [width-1:0] i_d;	// - input  stream data (concat data + eos)
   input              i_v;	// - input  stream valid
   output             i_r;	// - input  stream ready
   wire               i_b;  // - input  stream back-pressure

   output [width-1:0] o_d;	// - output stream data (concat data + eos)
   output             o_v;	// - output stream valid
   input              o_r;	// - output stream ready
   wire               o_b;	// - output stream back-pressure

   output [countwidth-1:0] count;  // - output number of elems in queue
   output [countwidth-1:0] maxcount;  // - maximum observed count since reset

   reg [countwidth-1:0] maxcount_reg;  // - maximum count seen until now
   reg    [addrwidth-1:0] addr, addr_, a_;		// - SRL16 address
							//     for data output
   reg 			  shift_en_;			// - SRL16 shift enable
   reg    [width-1:0] 	  srl [depth-2:0];		// - SRL16 memory
   reg 			  shift_en_o_;			// - SRLO  shift enable
   reg    [width-1:0] 	  srlo_, srlo			// - SRLO  output reg
			  /* synthesis syn_allow_retiming=0 */ ;

   parameter state_empty = 2'd0;    // - state empty : o_v=0 o_d=UNDEFINED
   parameter state_one   = 2'd1;    // - state one   : o_v=1 o_d=srlo
   parameter state_more  = 2'd2;    // - state more  : o_v=1 o_d=srlo
				    //     #items in srl = addr+2

   reg [1:0] state, state_;	    // - state register

   wire      addr_full_;	    // - true iff addr==depth-2 on NEXT cycle
   reg       addr_full; 	    // - true iff addr==depth-2
   wire      addr_zero_;	    // - true iff addr==0
   wire      o_v_reg_;		    // - true iff state_empty   on NEXT cycle
   reg       o_v_reg  		    // - true iff state_empty
	     /* synthesis syn_allow_retiming=0 */ ;
   wire      i_b_reg_;		    // - true iff !full         on NEXT cycle
   reg       i_b_reg  		    // - true iff !full
	     /* synthesis syn_allow_retiming=0 */ ;

   assign addr_full_ = (state_==state_more) && (addr_==depth-2);
						// - queue full
   assign addr_zero_ = (addr==0);		// - queue contains 2 (or 1,0)
   assign o_v_reg_   = (state_!=state_empty);	// - output valid if non-empty
   assign i_b_reg_   = addr_full_;		// - input bp if full
   assign o_d = srlo;				// - output data from queue
   assign o_v = o_v_reg;			// - output valid if non-empty
   assign i_b = i_b_reg;			// - input bp if full
   assign maxcount = maxcount_reg;

   assign i_r = !i_b;
   assign o_b = !o_r;

   assign count = (state==state_more ? addr+2 : (state==state_one ? 1 : 0));

   // - ''always'' block with both FFs and SRL16 does not work,
   //      since FFs need reset but SRL16 does not

   always @(posedge clock) begin	// - seq always: FFs
      if (reset) begin
	 state     <= state_empty;
	 addr      <= 0;
         addr_full <= 0;
	 o_v_reg   <= 0;

	 i_b_reg   <= 0;
	 maxcount_reg <= 0;

      end
      else begin
	 state     <= state_;
	 addr      <= addr_;
         addr_full <= addr_full_;
	 o_v_reg   <= o_v_reg_;
	 i_b_reg   <= i_b_reg_;
	 maxcount_reg <= (count > maxcount_reg ? count : maxcount_reg);
      end
   end // always @ (posedge clock)

   always @(posedge clock) begin	// - seq always: srlo
      // - infer enabled output reg at end of shift chain
      // - input first element from i_d, all subsequent elements from SRL16
      if (reset) begin
	 srlo <= 0;
      end
      else begin
	 if (shift_en_o_) begin
	    srlo <= srlo_;
	 end
      end
   end // always @ (posedge clock)

   always @(posedge clock) begin			// - seq always: srl
      // - infer enabled SRL16E from shifting srl array
      // - no reset capability;  srl[] contents undefined on reset
      if (shift_en_) begin
	 // synthesis loop_limit 256
	 for (a_=depth-2; a_>0; a_=a_-1) begin
	    srl[a_] = srl[a_-1];
	 end
	 srl[0] <= i_d;
      end
   end // always @ (posedge clock or negedge reset)

   always @* begin					// - combi always
        srlo_       <=  'bx;
        shift_en_o_ <= 1'bx;
        shift_en_   <= 1'bx;
        addr_       <=  'bx;
        state_      <= 2'bx;
      case (state)

	state_empty: begin		    // - (empty, will not produce)
	      if (i_v) begin		    // - empty & i_v => consume
		 srlo_       <= i_d;
		 shift_en_o_ <= 1;
		 shift_en_   <= 1'bx;
		 addr_       <= 0;
		 state_      <= state_one;
	      end
	      else	begin		    // - empty & !i_v => idle
		 srlo_       <= 'bx;
		 shift_en_o_ <= 0;
		 shift_en_   <= 1'bx;
		 addr_       <= 0;
		 state_      <= state_empty;
	      end
	end

	state_one: begin		    // - (contains one)
	      if (i_v && o_b) begin	    // - one & i_v & o_b => consume
		 srlo_       <= 'bx;
		 shift_en_o_ <= 0;
		 shift_en_   <= 1;
		 addr_       <= 0;
		 state_      <= state_more;
	      end
	      else if (i_v && !o_b) begin   // - one & i_v & !o_b => cons+prod
		 srlo_       <= i_d;
		 shift_en_o_ <= 1;
		 shift_en_   <= 1;
		 addr_       <= 0;
		 state_      <= state_one;
	      end
	      else if (!i_v && o_b) begin   // - one & !i_v & o_b => idle
		 srlo_       <= 'bx;
		 shift_en_o_ <= 0;
		 shift_en_   <= 1'bx;
		 addr_       <= 0;
		 state_      <= state_one;
	      end
	      else if (!i_v && !o_b) begin  // - one & !i_v & !o_b => produce
		 srlo_       <= 'bx;
		 shift_en_o_ <= 0;
		 shift_en_   <= 1'bx;
		 addr_       <= 0;
		 state_      <= state_empty;
	      end
	end // case: state_one

	state_more: begin		    // - (contains more than one)
	   if (addr_full || (depth==2)) begin
					    // - (full, will not consume)
					    // - (full here if depth==2)
	      if (o_b) begin		    // - full & o_b => idle
		 srlo_       <= 'bx;
		 shift_en_o_ <= 0;
		 shift_en_   <= 0;
		 addr_       <= addr;
		 state_      <= state_more;
	      end
	      else begin		    // - full & !o_b => produce
		 srlo_       <= srl[addr];
		 shift_en_o_ <= 1;
		 shift_en_   <= 0;
//		 addr_       <= addr-1;
//		 state_      <= state_more;
		 addr_       <= addr_zero_ ? 0         : addr-1;
		 state_      <= addr_zero_ ? state_one : state_more;
	      end
	   end
	   else begin			    // - (mid: neither empty nor full)
	      if (i_v && o_b) begin	    // - mid & i_v & o_b => consume
		 srlo_       <= 'bx;
		 shift_en_o_ <= 0;
		 shift_en_   <= 1;
		 addr_       <= addr+1;
		 state_      <= state_more;
	      end
	      else if (i_v && !o_b) begin   // - mid & i_v & !o_b => cons+prod
		 srlo_       <= srl[addr];
		 shift_en_o_ <= 1;
		 shift_en_   <= 1;
		 addr_       <= addr;
		 state_      <= state_more;
	      end
	      else if (!i_v && o_b) begin   // - mid & !i_v & o_b => idle
		 srlo_       <= 'bx;
		 shift_en_o_ <= 0;
		 shift_en_   <= 0;
		 addr_       <= addr;
		 state_      <= state_more;
	      end
	      else if (!i_v && !o_b) begin  // - mid & !i_v & !o_b => produce
		 srlo_       <= srl[addr];
		 shift_en_o_ <= 1;
		 shift_en_   <= 0;
		 addr_       <= addr_zero_ ? 0         : addr-1;
		 state_      <= addr_zero_ ? state_one : state_more;
	      end
	   end // else: !if(addr_full)
	end // case: state_more

	default: begin
		 srlo_       <=  'bx;
		 shift_en_o_ <= 1'bx;
		 shift_en_   <= 1'bx;
		 addr_       <=  'bx;
		 state_      <= 2'bx;
	end // case: default

      endcase // case(state)
   end // always @ *

endmodule // Q_srl


`endif  // `ifdef  Q_srl
//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/vivado_stitch_proj_w5fn6zuu/finn_vivado_stitch_proj.gen/sources_1/bd/finn_design/ipshared/6bf6/hdl/verilog/StreamingMaxPool_hls_0_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1.v


// ==============================================================
// RTL generated by Vitis HLS - High-Level Synthesis from C, C++ and OpenCL v2022.2 (64-bit)
// Version: 2022.2
// Copyright (C) Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.
// 
// ===========================================================

`timescale 1 ns / 1 ps 

module StreamingMaxPool_hls_0_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1 (
        ap_clk,
        ap_rst,
        ap_start,
        ap_done,
        ap_idle,
        ap_ready,
        buf_V_address0,
        buf_V_ce0,
        buf_V_we0,
        buf_V_d0,
        buf_V_1_address0,
        buf_V_1_ce0,
        buf_V_1_we0,
        buf_V_1_d0,
        buf_V_2_address0,
        buf_V_2_ce0,
        buf_V_2_we0,
        buf_V_2_d0,
        buf_V_3_address0,
        buf_V_3_ce0,
        buf_V_3_we0,
        buf_V_3_d0,
        buf_V_4_address0,
        buf_V_4_ce0,
        buf_V_4_we0,
        buf_V_4_d0,
        buf_V_5_address0,
        buf_V_5_ce0,
        buf_V_5_we0,
        buf_V_5_d0,
        buf_V_6_address0,
        buf_V_6_ce0,
        buf_V_6_we0,
        buf_V_6_d0,
        buf_V_7_address0,
        buf_V_7_ce0,
        buf_V_7_we0,
        buf_V_7_d0,
        buf_V_8_address0,
        buf_V_8_ce0,
        buf_V_8_we0,
        buf_V_8_d0,
        buf_V_9_address0,
        buf_V_9_ce0,
        buf_V_9_we0,
        buf_V_9_d0,
        buf_V_10_address0,
        buf_V_10_ce0,
        buf_V_10_we0,
        buf_V_10_d0,
        buf_V_11_address0,
        buf_V_11_ce0,
        buf_V_11_we0,
        buf_V_11_d0,
        buf_V_12_address0,
        buf_V_12_ce0,
        buf_V_12_we0,
        buf_V_12_d0,
        buf_V_13_address0,
        buf_V_13_ce0,
        buf_V_13_we0,
        buf_V_13_d0,
        buf_V_14_address0,
        buf_V_14_ce0,
        buf_V_14_we0,
        buf_V_14_d0,
        buf_V_15_address0,
        buf_V_15_ce0,
        buf_V_15_we0,
        buf_V_15_d0
);

parameter    ap_ST_fsm_state1 = 1'd1;

input   ap_clk;
input   ap_rst;
input   ap_start;
output   ap_done;
output   ap_idle;
output   ap_ready;
output  [3:0] buf_V_address0;
output   buf_V_ce0;
output   buf_V_we0;
output  [3:0] buf_V_d0;
output  [3:0] buf_V_1_address0;
output   buf_V_1_ce0;
output   buf_V_1_we0;
output  [3:0] buf_V_1_d0;
output  [3:0] buf_V_2_address0;
output   buf_V_2_ce0;
output   buf_V_2_we0;
output  [3:0] buf_V_2_d0;
output  [3:0] buf_V_3_address0;
output   buf_V_3_ce0;
output   buf_V_3_we0;
output  [3:0] buf_V_3_d0;
output  [3:0] buf_V_4_address0;
output   buf_V_4_ce0;
output   buf_V_4_we0;
output  [3:0] buf_V_4_d0;
output  [3:0] buf_V_5_address0;
output   buf_V_5_ce0;
output   buf_V_5_we0;
output  [3:0] buf_V_5_d0;
output  [3:0] buf_V_6_address0;
output   buf_V_6_ce0;
output   buf_V_6_we0;
output  [3:0] buf_V_6_d0;
output  [3:0] buf_V_7_address0;
output   buf_V_7_ce0;
output   buf_V_7_we0;
output  [3:0] buf_V_7_d0;
output  [3:0] buf_V_8_address0;
output   buf_V_8_ce0;
output   buf_V_8_we0;
output  [3:0] buf_V_8_d0;
output  [3:0] buf_V_9_address0;
output   buf_V_9_ce0;
output   buf_V_9_we0;
output  [3:0] buf_V_9_d0;
output  [3:0] buf_V_10_address0;
output   buf_V_10_ce0;
output   buf_V_10_we0;
output  [3:0] buf_V_10_d0;
output  [3:0] buf_V_11_address0;
output   buf_V_11_ce0;
output   buf_V_11_we0;
output  [3:0] buf_V_11_d0;
output  [3:0] buf_V_12_address0;
output   buf_V_12_ce0;
output   buf_V_12_we0;
output  [3:0] buf_V_12_d0;
output  [3:0] buf_V_13_address0;
output   buf_V_13_ce0;
output   buf_V_13_we0;
output  [3:0] buf_V_13_d0;
output  [3:0] buf_V_14_address0;
output   buf_V_14_ce0;
output   buf_V_14_we0;
output  [3:0] buf_V_14_d0;
output  [3:0] buf_V_15_address0;
output   buf_V_15_ce0;
output   buf_V_15_we0;
output  [3:0] buf_V_15_d0;

reg ap_idle;
reg buf_V_ce0;
reg buf_V_we0;
reg buf_V_1_ce0;
reg buf_V_1_we0;
reg buf_V_2_ce0;
reg buf_V_2_we0;
reg buf_V_3_ce0;
reg buf_V_3_we0;
reg buf_V_4_ce0;
reg buf_V_4_we0;
reg buf_V_5_ce0;
reg buf_V_5_we0;
reg buf_V_6_ce0;
reg buf_V_6_we0;
reg buf_V_7_ce0;
reg buf_V_7_we0;
reg buf_V_8_ce0;
reg buf_V_8_we0;
reg buf_V_9_ce0;
reg buf_V_9_we0;
reg buf_V_10_ce0;
reg buf_V_10_we0;
reg buf_V_11_ce0;
reg buf_V_11_we0;
reg buf_V_12_ce0;
reg buf_V_12_we0;
reg buf_V_13_ce0;
reg buf_V_13_we0;
reg buf_V_14_ce0;
reg buf_V_14_we0;
reg buf_V_15_ce0;
reg buf_V_15_we0;

(* fsm_encoding = "none" *) reg   [0:0] ap_CS_fsm;
wire    ap_CS_fsm_state1;
reg    ap_block_state1_pp0_stage0_iter0;
wire   [0:0] icmp_ln147_fu_294_p2;
reg    ap_condition_exit_pp0_iter0_stage0;
wire    ap_loop_exit_ready;
reg    ap_ready_int;
wire   [63:0] i_cast_fu_306_p1;
reg   [3:0] i_fu_58;
wire   [3:0] add_ln147_fu_300_p2;
wire    ap_loop_init;
reg   [3:0] ap_sig_allocacmp_i_1;
reg    ap_done_reg;
wire    ap_continue_int;
reg    ap_done_int;
reg   [0:0] ap_NS_fsm;
reg    ap_ST_fsm_state1_blk;
wire    ap_start_int;
wire    ap_ce_reg;

// power-on initialization
initial begin
#0 ap_CS_fsm = 1'd1;
#0 ap_done_reg = 1'b0;
end

StreamingMaxPool_hls_0_flow_control_loop_pipe_sequential_init flow_control_loop_pipe_sequential_init_U(
    .ap_clk(ap_clk),
    .ap_rst(ap_rst),
    .ap_start(ap_start),
    .ap_ready(ap_ready),
    .ap_done(ap_done),
    .ap_start_int(ap_start_int),
    .ap_loop_init(ap_loop_init),
    .ap_ready_int(ap_ready_int),
    .ap_loop_exit_ready(ap_condition_exit_pp0_iter0_stage0),
    .ap_loop_exit_done(ap_done_int),
    .ap_continue_int(ap_continue_int),
    .ap_done_int(ap_done_int)
);

always @ (posedge ap_clk) begin
    if (ap_rst == 1'b1) begin
        ap_CS_fsm <= ap_ST_fsm_state1;
    end else begin
        ap_CS_fsm <= ap_NS_fsm;
    end
end

always @ (posedge ap_clk) begin
    if (ap_rst == 1'b1) begin
        ap_done_reg <= 1'b0;
    end else begin
        if ((ap_continue_int == 1'b1)) begin
            ap_done_reg <= 1'b0;
        end else if (((ap_loop_exit_ready == 1'b1) & (1'b1 == ap_CS_fsm_state1) & (ap_start_int == 1'b1))) begin
            ap_done_reg <= 1'b1;
        end
    end
end

always @ (posedge ap_clk) begin
    if (((1'b1 == ap_CS_fsm_state1) & (ap_start_int == 1'b1))) begin
        if ((icmp_ln147_fu_294_p2 == 1'd0)) begin
            i_fu_58 <= add_ln147_fu_300_p2;
        end else if ((ap_loop_init == 1'b1)) begin
            i_fu_58 <= 4'd0;
        end
    end
end

always @ (*) begin
    if ((ap_start_int == 1'b0)) begin
        ap_ST_fsm_state1_blk = 1'b1;
    end else begin
        ap_ST_fsm_state1_blk = 1'b0;
    end
end

always @ (*) begin
    if (((icmp_ln147_fu_294_p2 == 1'd1) & (1'b1 == ap_CS_fsm_state1) & (ap_start_int == 1'b1))) begin
        ap_condition_exit_pp0_iter0_stage0 = 1'b1;
    end else begin
        ap_condition_exit_pp0_iter0_stage0 = 1'b0;
    end
end

always @ (*) begin
    if (((ap_loop_exit_ready == 1'b1) & (1'b1 == ap_CS_fsm_state1) & (ap_start_int == 1'b1))) begin
        ap_done_int = 1'b1;
    end else begin
        ap_done_int = ap_done_reg;
    end
end

always @ (*) begin
    if (((1'b1 == ap_CS_fsm_state1) & (ap_start_int == 1'b0))) begin
        ap_idle = 1'b1;
    end else begin
        ap_idle = 1'b0;
    end
end

always @ (*) begin
    if (((1'b1 == ap_CS_fsm_state1) & (ap_start_int == 1'b1))) begin
        ap_ready_int = 1'b1;
    end else begin
        ap_ready_int = 1'b0;
    end
end

always @ (*) begin
    if (((1'b1 == ap_CS_fsm_state1) & (ap_loop_init == 1'b1))) begin
        ap_sig_allocacmp_i_1 = 4'd0;
    end else begin
        ap_sig_allocacmp_i_1 = i_fu_58;
    end
end

always @ (*) begin
    if (((1'b1 == ap_CS_fsm_state1) & (ap_start_int == 1'b1))) begin
        buf_V_10_ce0 = 1'b1;
    end else begin
        buf_V_10_ce0 = 1'b0;
    end
end

always @ (*) begin
    if (((icmp_ln147_fu_294_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state1) & (ap_start_int == 1'b1))) begin
        buf_V_10_we0 = 1'b1;
    end else begin
        buf_V_10_we0 = 1'b0;
    end
end

always @ (*) begin
    if (((1'b1 == ap_CS_fsm_state1) & (ap_start_int == 1'b1))) begin
        buf_V_11_ce0 = 1'b1;
    end else begin
        buf_V_11_ce0 = 1'b0;
    end
end

always @ (*) begin
    if (((icmp_ln147_fu_294_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state1) & (ap_start_int == 1'b1))) begin
        buf_V_11_we0 = 1'b1;
    end else begin
        buf_V_11_we0 = 1'b0;
    end
end

always @ (*) begin
    if (((1'b1 == ap_CS_fsm_state1) & (ap_start_int == 1'b1))) begin
        buf_V_12_ce0 = 1'b1;
    end else begin
        buf_V_12_ce0 = 1'b0;
    end
end

always @ (*) begin
    if (((icmp_ln147_fu_294_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state1) & (ap_start_int == 1'b1))) begin
        buf_V_12_we0 = 1'b1;
    end else begin
        buf_V_12_we0 = 1'b0;
    end
end

always @ (*) begin
    if (((1'b1 == ap_CS_fsm_state1) & (ap_start_int == 1'b1))) begin
        buf_V_13_ce0 = 1'b1;
    end else begin
        buf_V_13_ce0 = 1'b0;
    end
end

always @ (*) begin
    if (((icmp_ln147_fu_294_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state1) & (ap_start_int == 1'b1))) begin
        buf_V_13_we0 = 1'b1;
    end else begin
        buf_V_13_we0 = 1'b0;
    end
end

always @ (*) begin
    if (((1'b1 == ap_CS_fsm_state1) & (ap_start_int == 1'b1))) begin
        buf_V_14_ce0 = 1'b1;
    end else begin
        buf_V_14_ce0 = 1'b0;
    end
end

always @ (*) begin
    if (((icmp_ln147_fu_294_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state1) & (ap_start_int == 1'b1))) begin
        buf_V_14_we0 = 1'b1;
    end else begin
        buf_V_14_we0 = 1'b0;
    end
end

always @ (*) begin
    if (((1'b1 == ap_CS_fsm_state1) & (ap_start_int == 1'b1))) begin
        buf_V_15_ce0 = 1'b1;
    end else begin
        buf_V_15_ce0 = 1'b0;
    end
end

always @ (*) begin
    if (((icmp_ln147_fu_294_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state1) & (ap_start_int == 1'b1))) begin
        buf_V_15_we0 = 1'b1;
    end else begin
        buf_V_15_we0 = 1'b0;
    end
end

always @ (*) begin
    if (((1'b1 == ap_CS_fsm_state1) & (ap_start_int == 1'b1))) begin
        buf_V_1_ce0 = 1'b1;
    end else begin
        buf_V_1_ce0 = 1'b0;
    end
end

always @ (*) begin
    if (((icmp_ln147_fu_294_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state1) & (ap_start_int == 1'b1))) begin
        buf_V_1_we0 = 1'b1;
    end else begin
        buf_V_1_we0 = 1'b0;
    end
end

always @ (*) begin
    if (((1'b1 == ap_CS_fsm_state1) & (ap_start_int == 1'b1))) begin
        buf_V_2_ce0 = 1'b1;
    end else begin
        buf_V_2_ce0 = 1'b0;
    end
end

always @ (*) begin
    if (((icmp_ln147_fu_294_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state1) & (ap_start_int == 1'b1))) begin
        buf_V_2_we0 = 1'b1;
    end else begin
        buf_V_2_we0 = 1'b0;
    end
end

always @ (*) begin
    if (((1'b1 == ap_CS_fsm_state1) & (ap_start_int == 1'b1))) begin
        buf_V_3_ce0 = 1'b1;
    end else begin
        buf_V_3_ce0 = 1'b0;
    end
end

always @ (*) begin
    if (((icmp_ln147_fu_294_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state1) & (ap_start_int == 1'b1))) begin
        buf_V_3_we0 = 1'b1;
    end else begin
        buf_V_3_we0 = 1'b0;
    end
end

always @ (*) begin
    if (((1'b1 == ap_CS_fsm_state1) & (ap_start_int == 1'b1))) begin
        buf_V_4_ce0 = 1'b1;
    end else begin
        buf_V_4_ce0 = 1'b0;
    end
end

always @ (*) begin
    if (((icmp_ln147_fu_294_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state1) & (ap_start_int == 1'b1))) begin
        buf_V_4_we0 = 1'b1;
    end else begin
        buf_V_4_we0 = 1'b0;
    end
end

always @ (*) begin
    if (((1'b1 == ap_CS_fsm_state1) & (ap_start_int == 1'b1))) begin
        buf_V_5_ce0 = 1'b1;
    end else begin
        buf_V_5_ce0 = 1'b0;
    end
end

always @ (*) begin
    if (((icmp_ln147_fu_294_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state1) & (ap_start_int == 1'b1))) begin
        buf_V_5_we0 = 1'b1;
    end else begin
        buf_V_5_we0 = 1'b0;
    end
end

always @ (*) begin
    if (((1'b1 == ap_CS_fsm_state1) & (ap_start_int == 1'b1))) begin
        buf_V_6_ce0 = 1'b1;
    end else begin
        buf_V_6_ce0 = 1'b0;
    end
end

always @ (*) begin
    if (((icmp_ln147_fu_294_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state1) & (ap_start_int == 1'b1))) begin
        buf_V_6_we0 = 1'b1;
    end else begin
        buf_V_6_we0 = 1'b0;
    end
end

always @ (*) begin
    if (((1'b1 == ap_CS_fsm_state1) & (ap_start_int == 1'b1))) begin
        buf_V_7_ce0 = 1'b1;
    end else begin
        buf_V_7_ce0 = 1'b0;
    end
end

always @ (*) begin
    if (((icmp_ln147_fu_294_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state1) & (ap_start_int == 1'b1))) begin
        buf_V_7_we0 = 1'b1;
    end else begin
        buf_V_7_we0 = 1'b0;
    end
end

always @ (*) begin
    if (((1'b1 == ap_CS_fsm_state1) & (ap_start_int == 1'b1))) begin
        buf_V_8_ce0 = 1'b1;
    end else begin
        buf_V_8_ce0 = 1'b0;
    end
end

always @ (*) begin
    if (((icmp_ln147_fu_294_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state1) & (ap_start_int == 1'b1))) begin
        buf_V_8_we0 = 1'b1;
    end else begin
        buf_V_8_we0 = 1'b0;
    end
end

always @ (*) begin
    if (((1'b1 == ap_CS_fsm_state1) & (ap_start_int == 1'b1))) begin
        buf_V_9_ce0 = 1'b1;
    end else begin
        buf_V_9_ce0 = 1'b0;
    end
end

always @ (*) begin
    if (((icmp_ln147_fu_294_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state1) & (ap_start_int == 1'b1))) begin
        buf_V_9_we0 = 1'b1;
    end else begin
        buf_V_9_we0 = 1'b0;
    end
end

always @ (*) begin
    if (((1'b1 == ap_CS_fsm_state1) & (ap_start_int == 1'b1))) begin
        buf_V_ce0 = 1'b1;
    end else begin
        buf_V_ce0 = 1'b0;
    end
end

always @ (*) begin
    if (((icmp_ln147_fu_294_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state1) & (ap_start_int == 1'b1))) begin
        buf_V_we0 = 1'b1;
    end else begin
        buf_V_we0 = 1'b0;
    end
end

always @ (*) begin
    case (ap_CS_fsm)
        ap_ST_fsm_state1 : begin
            ap_NS_fsm = ap_ST_fsm_state1;
        end
        default : begin
            ap_NS_fsm = 'bx;
        end
    endcase
end

assign add_ln147_fu_300_p2 = (ap_sig_allocacmp_i_1 + 4'd1);

assign ap_CS_fsm_state1 = ap_CS_fsm[32'd0];

always @ (*) begin
    ap_block_state1_pp0_stage0_iter0 = (ap_start_int == 1'b0);
end

assign ap_loop_exit_ready = ap_condition_exit_pp0_iter0_stage0;

assign buf_V_10_address0 = i_cast_fu_306_p1;

assign buf_V_10_d0 = 4'd0;

assign buf_V_11_address0 = i_cast_fu_306_p1;

assign buf_V_11_d0 = 4'd0;

assign buf_V_12_address0 = i_cast_fu_306_p1;

assign buf_V_12_d0 = 4'd0;

assign buf_V_13_address0 = i_cast_fu_306_p1;

assign buf_V_13_d0 = 4'd0;

assign buf_V_14_address0 = i_cast_fu_306_p1;

assign buf_V_14_d0 = 4'd0;

assign buf_V_15_address0 = i_cast_fu_306_p1;

assign buf_V_15_d0 = 4'd0;

assign buf_V_1_address0 = i_cast_fu_306_p1;

assign buf_V_1_d0 = 4'd0;

assign buf_V_2_address0 = i_cast_fu_306_p1;

assign buf_V_2_d0 = 4'd0;

assign buf_V_3_address0 = i_cast_fu_306_p1;

assign buf_V_3_d0 = 4'd0;

assign buf_V_4_address0 = i_cast_fu_306_p1;

assign buf_V_4_d0 = 4'd0;

assign buf_V_5_address0 = i_cast_fu_306_p1;

assign buf_V_5_d0 = 4'd0;

assign buf_V_6_address0 = i_cast_fu_306_p1;

assign buf_V_6_d0 = 4'd0;

assign buf_V_7_address0 = i_cast_fu_306_p1;

assign buf_V_7_d0 = 4'd0;

assign buf_V_8_address0 = i_cast_fu_306_p1;

assign buf_V_8_d0 = 4'd0;

assign buf_V_9_address0 = i_cast_fu_306_p1;

assign buf_V_9_d0 = 4'd0;

assign buf_V_address0 = i_cast_fu_306_p1;

assign buf_V_d0 = 4'd0;

assign i_cast_fu_306_p1 = ap_sig_allocacmp_i_1;

assign icmp_ln147_fu_294_p2 = ((ap_sig_allocacmp_i_1 == 4'd14) ? 1'b1 : 1'b0);

endmodule //StreamingMaxPool_hls_0_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1
//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/code_gen_ipgen_ConvolutionInputGenerator_rtl_1_6arfz_kp/swg_common.sv


/******************************************************************************
 * Copyright (C) 2022-2023, Advanced Micro Devices, Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *  1. Redistributions of source code must retain the above copyright notice,
 *     this list of conditions and the following disclaimer.
 *
 *  2. Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *
 *  3. Neither the name of the copyright holder nor the names of its
 *     contributors may be used to endorse or promote products derived from
 *     this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION). HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *****************************************************************************/


// loop controller used for both, "default" and "parallel", implementation styles
module swg_controller
import swg::*; #(
    int unsigned  LOOP_H_ITERATIONS,
    int unsigned  LOOP_W_ITERATIONS,
    int unsigned  LOOP_KH_ITERATIONS,
    int unsigned  LOOP_KW_ITERATIONS,
    int unsigned  LOOP_SIMD_ITERATIONS,

    int unsigned  INCR_BITWIDTH,

    bit IS_DEPTHWISE,

    int HEAD_INCR_SIMD,
    int HEAD_INCR_KW,
    int HEAD_INCR_KH,
    int HEAD_INCR_W,
    int HEAD_INCR_H,
    int TAIL_INCR_W,
    int TAIL_INCR_H,
    int TAIL_INCR_LAST,

    state_e INNERMOST_STATE
)(
    input   logic  clk,
    input   logic  rst_n,

    input   logic  advance,
    output  logic [INCR_BITWIDTH-1:0]  addr_incr,
    output  logic [INCR_BITWIDTH-1:0]  tail_incr
);

    // state and counters
    state_e  State = INNERMOST_STATE;
    state_e  state_next;

    logic signed [$clog2(LOOP_H_ITERATIONS   +2)+1-1:0]  Counter_loop_h    = LOOP_H_ITERATIONS;
    logic signed [$clog2(LOOP_W_ITERATIONS   +2)+1-1:0]  Counter_loop_w    = LOOP_W_ITERATIONS;
    logic signed [$clog2(LOOP_KH_ITERATIONS  +2)+1-1:0]  Counter_loop_kh   = LOOP_KH_ITERATIONS;
    logic signed [$clog2(LOOP_KW_ITERATIONS  +2)+1-1:0]  Counter_loop_kw   = LOOP_KW_ITERATIONS;
    logic signed [$clog2(LOOP_SIMD_ITERATIONS+2)+1-1:0]  Counter_loop_simd = LOOP_SIMD_ITERATIONS;

    // combinational logic for addr_incr generation
    always_comb begin : blkHead
        unique case (State)
            STATE_START     : addr_incr = 0;
            STATE_LOOP_SIMD : addr_incr = HEAD_INCR_SIMD;
            STATE_LOOP_KW   : addr_incr = HEAD_INCR_KW;
            STATE_LOOP_KH   : addr_incr = HEAD_INCR_KH;
            STATE_LOOP_W    : addr_incr = HEAD_INCR_W;
            STATE_LOOP_H    : addr_incr = HEAD_INCR_H;
        endcase
    end

    // combinational logic for tail_incr generation
    uwire  tail_incr_inner_condition = IS_DEPTHWISE? (Counter_loop_kh >= 0) : 0;
    assign tail_incr =
        tail_incr_inner_condition? 1 :
        Counter_loop_w >= 0?       TAIL_INCR_W :
        Counter_loop_h >= 0?       TAIL_INCR_H :
        /* else */                 TAIL_INCR_LAST;

    // combinational next state logic
    always_comb begin : blkState
        state_next = State;
        if(State != INNERMOST_STATE)  state_next = INNERMOST_STATE;
        else begin
            if(Counter_loop_simd < 0) begin
                state_next =
                    (Counter_loop_kw >= 0)? STATE_LOOP_KW :
                    (Counter_loop_kh >= 0)? STATE_LOOP_KH :
                    (Counter_loop_w  >= 0)? STATE_LOOP_W :
                    (Counter_loop_h  >= 0)? STATE_LOOP_H :
                    /* else */              STATE_START;
            end
        end
    end : blkState

    // sequential logic
    always_ff @ (posedge clk) begin
        if(!rst_n) begin
            State <= INNERMOST_STATE;
            Counter_loop_h    <= LOOP_H_ITERATIONS;
            Counter_loop_w    <= LOOP_W_ITERATIONS;
            Counter_loop_kh   <= LOOP_KH_ITERATIONS;
            Counter_loop_kw   <= LOOP_KW_ITERATIONS;
            Counter_loop_simd <= LOOP_SIMD_ITERATIONS;
        end
        else if(advance) begin
            State <= state_next;
            if (State == INNERMOST_STATE) begin
                if(Counter_loop_simd >= 0)  Counter_loop_simd <= Counter_loop_simd-1;
                else begin
                    Counter_loop_simd <= LOOP_SIMD_ITERATIONS;
                    if(Counter_loop_kw >= 0)  Counter_loop_kw <= Counter_loop_kw-1;
                    else begin
                        Counter_loop_kw <= LOOP_KW_ITERATIONS;
                        if(Counter_loop_kh >= 0)  Counter_loop_kh <= Counter_loop_kh-1;
                        else begin
                            Counter_loop_kh <= LOOP_KH_ITERATIONS;
                            if(Counter_loop_w >= 0)  Counter_loop_w <= Counter_loop_w-1;
                            else begin
                                Counter_loop_w <= LOOP_W_ITERATIONS;
                                if(Counter_loop_h >= 0)  Counter_loop_h <= Counter_loop_h-1;
                                else  Counter_loop_h <= LOOP_H_ITERATIONS;
                            end
                        end
                    end
                end
            end
        end
    end

endmodule :  swg_controller

// buffer used in "default" implementation style
module swg_cyclic_buffer_addressable #(
    int unsigned  WIDTH,
    int unsigned  DEPTH,
    parameter RAM_STYLE = "auto"
)(
    input   logic  clk,

    input   logic  write_enable,
    input   logic [$clog2(DEPTH)-1:0] write_addr,
    input   logic [WIDTH-1:0]  data_in,

    input   logic  read_enable,
    input   logic [$clog2(DEPTH)-1:0]  read_addr, // absolute (!) read address of cyclic buffer
    output  logic [WIDTH-1:0]  data_out
);

    (*ram_style=RAM_STYLE*) logic [WIDTH-1:0] Ram[DEPTH];
    logic [WIDTH-1:0]  Out = 'x;
    always_ff @(posedge clk) begin
        if (read_enable)  Out <= Ram[read_addr];
        if (write_enable) Ram[write_addr] <= data_in;
    end
    assign  data_out = Out;

endmodule : swg_cyclic_buffer_addressable

// buffer used in "parallel" implementation style
module swg_reg_buffer
#(
    int unsigned WIDTH = 1,
    int unsigned DEPTH = 1
)
(
    input logic clk,
    input logic shift_enable,
    input logic [WIDTH-1:0] shift_in,
    output logic [WIDTH-1:0] shift_out,
    output logic [WIDTH*DEPTH-1:0] data_out
);

logic [WIDTH-1:0] Data [DEPTH-1:0];

assign shift_out = Data[DEPTH-1];

for (genvar e=0; e<DEPTH; e++)
    assign data_out[e*WIDTH +: WIDTH] = Data[e];

always @ (posedge clk) begin
    if (shift_enable) begin
        if (DEPTH > 1) Data[DEPTH-1:1] <= Data[DEPTH-2:0];
        Data[0] <= shift_in;
    end
end
endmodule : swg_reg_buffer

// buffer used in "parallel" implementation style
module swg_ram_buffer
#(
    int unsigned WIDTH,
    int unsigned DEPTH,
    parameter RAM_STYLE = "auto"
)
(
    input logic clk,
    input logic rst_n,
    input logic shift_enable,
    input logic [WIDTH-1:0] shift_in,
    output logic [WIDTH-1:0] shift_out
);

logic [WIDTH-1:0] Out_reg;
assign shift_out = Out_reg;

logic [$clog2(DEPTH)-1:0] Addr_w = 0;
logic [$clog2(DEPTH)-1:0] Addr_r = 0;

(*ram_style=RAM_STYLE*) logic [WIDTH-1:0] Ram [DEPTH-1:0];

always_ff @(posedge clk) begin
    if (rst_n == 1'b0) begin
        Addr_w <= 0;
        Addr_r <= 1;
    end else begin
        if (shift_enable) begin
            Ram[Addr_w] <= shift_in;
            Out_reg <= Ram[Addr_r];

            if (Addr_w == DEPTH-1)
                Addr_w <= 0;
            else
                Addr_w <= Addr_w + 1;

            if (Addr_r == DEPTH-1)
                Addr_r <= 0;
            else
                Addr_r <= Addr_r + 1;
        end
    end
end
endmodule : swg_ram_buffer
//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/vivado_stitch_proj_w5fn6zuu/finn_vivado_stitch_proj.gen/sources_1/bd/finn_design/ipshared/fb57/hdl/verilog/MVAU_hls_1_mac_muladd_4ns_4s_14s_14_4_1.v


// ==============================================================
// Vitis HLS - High-Level Synthesis from C, C++ and OpenCL v2022.2 (64-bit)
// Tool Version Limit: 2019.12
// Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.
// ==============================================================
`timescale 1 ns / 1 ps

(* use_dsp = "yes" *) module MVAU_hls_1_mac_muladd_4ns_4s_14s_14_4_1_DSP48_0(
    input clk,
    input rst,
    input ce,
    input  [4 - 1:0] in0,
    input  [4 - 1:0] in1,
    input  [14 - 1:0] in2,
    output [14 - 1:0]  dout);

wire signed [25 - 1:0]     a;
wire signed [18 - 1:0]     b;
wire signed [48 - 1:0]     c;
wire signed [43 - 1:0]     m;
wire signed [48 - 1:0]     p;
reg  signed [43 - 1:0]     m_reg;
reg  signed [25 - 1:0]     a_reg;
reg  signed [18 - 1:0]     b_reg;
reg  signed [48 - 1:0]     p_reg;

assign a  = $unsigned(in0);
assign b  = $signed(in1);
assign c  = $signed(in2);

assign m  = a_reg * b_reg;
assign p  = m_reg + c;

always @(posedge clk) begin
    if (ce) begin
        m_reg  <= m;
        a_reg  <= a;
        b_reg  <= b;
        p_reg  <= p;
    end
end

assign dout = p_reg;

endmodule
`timescale 1 ns / 1 ps
module MVAU_hls_1_mac_muladd_4ns_4s_14s_14_4_1(
    clk,
    reset,
    ce,
    din0,
    din1,
    din2,
    dout);

parameter ID = 32'd1;
parameter NUM_STAGE = 32'd1;
parameter din0_WIDTH = 32'd1;
parameter din1_WIDTH = 32'd1;
parameter din2_WIDTH = 32'd1;
parameter dout_WIDTH = 32'd1;
input clk;
input reset;
input ce;
input[din0_WIDTH - 1:0] din0;
input[din1_WIDTH - 1:0] din1;
input[din2_WIDTH - 1:0] din2;
output[dout_WIDTH - 1:0] dout;



MVAU_hls_1_mac_muladd_4ns_4s_14s_14_4_1_DSP48_0 MVAU_hls_1_mac_muladd_4ns_4s_14s_14_4_1_DSP48_0_U(
    .clk( clk ),
    .rst( reset ),
    .ce( ce ),
    .in0( din0 ),
    .in1( din1 ),
    .in2( din2 ),
    .dout( dout ));

endmodule

//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/vivado_stitch_proj_w5fn6zuu/finn_vivado_stitch_proj.gen/sources_1/bd/finn_design/ipshared/fb57/hdl/verilog/MVAU_hls_1.v


// ==============================================================
// RTL generated by Vitis HLS - High-Level Synthesis from C, C++ and OpenCL v2022.2 (64-bit)
// Version: 2022.2
// Copyright (C) Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.
// 
// ===========================================================

`timescale 1 ns / 1 ps 

(* CORE_GENERATION_INFO="MVAU_hls_1_MVAU_hls_1,hls_ip_2022_2,{HLS_INPUT_TYPE=cxx,HLS_INPUT_FLOAT=0,HLS_INPUT_FIXED=0,HLS_INPUT_PART=xc7z010-clg400-1,HLS_INPUT_CLOCK=10.000000,HLS_INPUT_ARCH=others,HLS_SYN_CLOCK=7.591000,HLS_SYN_LAT=903178,HLS_SYN_TPT=none,HLS_SYN_MEM=0,HLS_SYN_DSP=0,HLS_SYN_FF=999,HLS_SYN_LUT=1671,HLS_VERSION=2022_2}" *)

module MVAU_hls_1 (
        ap_clk,
        ap_rst_n,
        in0_V_TDATA,
        in0_V_TVALID,
        in0_V_TREADY,
        weights_V_TDATA,
        weights_V_TVALID,
        weights_V_TREADY,
        out_V_TDATA,
        out_V_TVALID,
        out_V_TREADY
);

parameter    ap_ST_fsm_state1 = 4'd1;
parameter    ap_ST_fsm_state2 = 4'd2;
parameter    ap_ST_fsm_state3 = 4'd4;
parameter    ap_ST_fsm_state4 = 4'd8;

input   ap_clk;
input   ap_rst_n;
input  [7:0] in0_V_TDATA;
input   in0_V_TVALID;
output   in0_V_TREADY;
input  [7:0] weights_V_TDATA;
input   weights_V_TVALID;
output   weights_V_TREADY;
output  [7:0] out_V_TDATA;
output   out_V_TVALID;
input   out_V_TREADY;

 reg    ap_rst_n_inv;
wire    grp_Matrix_Vector_Activate_Stream_Batch_fu_60_ap_start;
wire    grp_Matrix_Vector_Activate_Stream_Batch_fu_60_ap_done;
wire    grp_Matrix_Vector_Activate_Stream_Batch_fu_60_ap_idle;
wire    grp_Matrix_Vector_Activate_Stream_Batch_fu_60_ap_ready;
wire    grp_Matrix_Vector_Activate_Stream_Batch_fu_60_out_V_TREADY;
wire    grp_Matrix_Vector_Activate_Stream_Batch_fu_60_in0_V_TREADY;
wire   [7:0] grp_Matrix_Vector_Activate_Stream_Batch_fu_60_out_V_TDATA;
wire    grp_Matrix_Vector_Activate_Stream_Batch_fu_60_out_V_TVALID;
wire    grp_Matrix_Vector_Activate_Stream_Batch_fu_60_weights_V_TREADY;
reg    grp_Matrix_Vector_Activate_Stream_Batch_fu_60_ap_start_reg;
(* fsm_encoding = "none" *) reg   [3:0] ap_CS_fsm;
wire    ap_CS_fsm_state2;
wire    ap_CS_fsm_state3;
reg   [3:0] ap_NS_fsm;
wire    ap_ST_fsm_state1_blk;
wire    ap_ST_fsm_state2_blk;
reg    ap_ST_fsm_state3_blk;
reg    ap_ST_fsm_state4_blk;
wire    regslice_both_out_V_U_apdone_blk;
wire    ap_CS_fsm_state4;
wire    regslice_both_in0_V_U_apdone_blk;
wire   [7:0] in0_V_TDATA_int_regslice;
wire    in0_V_TVALID_int_regslice;
reg    in0_V_TREADY_int_regslice;
wire    regslice_both_in0_V_U_ack_in;
wire    regslice_both_weights_V_U_apdone_blk;
wire   [7:0] weights_V_TDATA_int_regslice;
wire    weights_V_TVALID_int_regslice;
reg    weights_V_TREADY_int_regslice;
wire    regslice_both_weights_V_U_ack_in;
wire    out_V_TREADY_int_regslice;
wire    regslice_both_out_V_U_vld_out;
wire    ap_ce_reg;

// power-on initialization
initial begin
#0 grp_Matrix_Vector_Activate_Stream_Batch_fu_60_ap_start_reg = 1'b0;
#0 ap_CS_fsm = 4'd1;
end

MVAU_hls_1_Matrix_Vector_Activate_Stream_Batch grp_Matrix_Vector_Activate_Stream_Batch_fu_60(
    .ap_clk(ap_clk),
    .ap_rst(ap_rst_n_inv),
    .ap_start(grp_Matrix_Vector_Activate_Stream_Batch_fu_60_ap_start),
    .ap_done(grp_Matrix_Vector_Activate_Stream_Batch_fu_60_ap_done),
    .ap_idle(grp_Matrix_Vector_Activate_Stream_Batch_fu_60_ap_idle),
    .ap_ready(grp_Matrix_Vector_Activate_Stream_Batch_fu_60_ap_ready),
    .in0_V_TVALID(in0_V_TVALID_int_regslice),
    .weights_V_TVALID(weights_V_TVALID_int_regslice),
    .out_V_TREADY(grp_Matrix_Vector_Activate_Stream_Batch_fu_60_out_V_TREADY),
    .in0_V_TDATA(in0_V_TDATA_int_regslice),
    .in0_V_TREADY(grp_Matrix_Vector_Activate_Stream_Batch_fu_60_in0_V_TREADY),
    .out_V_TDATA(grp_Matrix_Vector_Activate_Stream_Batch_fu_60_out_V_TDATA),
    .out_V_TVALID(grp_Matrix_Vector_Activate_Stream_Batch_fu_60_out_V_TVALID),
    .weights_V_TDATA(weights_V_TDATA_int_regslice),
    .weights_V_TREADY(grp_Matrix_Vector_Activate_Stream_Batch_fu_60_weights_V_TREADY)
);

MVAU_hls_1_regslice_both #(
    .DataWidth( 8 ))
regslice_both_in0_V_U(
    .ap_clk(ap_clk),
    .ap_rst(ap_rst_n_inv),
    .data_in(in0_V_TDATA),
    .vld_in(in0_V_TVALID),
    .ack_in(regslice_both_in0_V_U_ack_in),
    .data_out(in0_V_TDATA_int_regslice),
    .vld_out(in0_V_TVALID_int_regslice),
    .ack_out(in0_V_TREADY_int_regslice),
    .apdone_blk(regslice_both_in0_V_U_apdone_blk)
);

MVAU_hls_1_regslice_both #(
    .DataWidth( 8 ))
regslice_both_weights_V_U(
    .ap_clk(ap_clk),
    .ap_rst(ap_rst_n_inv),
    .data_in(weights_V_TDATA),
    .vld_in(weights_V_TVALID),
    .ack_in(regslice_both_weights_V_U_ack_in),
    .data_out(weights_V_TDATA_int_regslice),
    .vld_out(weights_V_TVALID_int_regslice),
    .ack_out(weights_V_TREADY_int_regslice),
    .apdone_blk(regslice_both_weights_V_U_apdone_blk)
);

MVAU_hls_1_regslice_both #(
    .DataWidth( 8 ))
regslice_both_out_V_U(
    .ap_clk(ap_clk),
    .ap_rst(ap_rst_n_inv),
    .data_in(grp_Matrix_Vector_Activate_Stream_Batch_fu_60_out_V_TDATA),
    .vld_in(grp_Matrix_Vector_Activate_Stream_Batch_fu_60_out_V_TVALID),
    .ack_in(out_V_TREADY_int_regslice),
    .data_out(out_V_TDATA),
    .vld_out(regslice_both_out_V_U_vld_out),
    .ack_out(out_V_TREADY),
    .apdone_blk(regslice_both_out_V_U_apdone_blk)
);

always @ (posedge ap_clk) begin
    if (ap_rst_n_inv == 1'b1) begin
        ap_CS_fsm <= ap_ST_fsm_state1;
    end else begin
        ap_CS_fsm <= ap_NS_fsm;
    end
end

always @ (posedge ap_clk) begin
    if (ap_rst_n_inv == 1'b1) begin
        grp_Matrix_Vector_Activate_Stream_Batch_fu_60_ap_start_reg <= 1'b0;
    end else begin
        if ((1'b1 == ap_CS_fsm_state2)) begin
            grp_Matrix_Vector_Activate_Stream_Batch_fu_60_ap_start_reg <= 1'b1;
        end else if ((grp_Matrix_Vector_Activate_Stream_Batch_fu_60_ap_ready == 1'b1)) begin
            grp_Matrix_Vector_Activate_Stream_Batch_fu_60_ap_start_reg <= 1'b0;
        end
    end
end

assign ap_ST_fsm_state1_blk = 1'b0;

assign ap_ST_fsm_state2_blk = 1'b0;

always @ (*) begin
    if ((grp_Matrix_Vector_Activate_Stream_Batch_fu_60_ap_done == 1'b0)) begin
        ap_ST_fsm_state3_blk = 1'b1;
    end else begin
        ap_ST_fsm_state3_blk = 1'b0;
    end
end

always @ (*) begin
    if ((regslice_both_out_V_U_apdone_blk == 1'b1)) begin
        ap_ST_fsm_state4_blk = 1'b1;
    end else begin
        ap_ST_fsm_state4_blk = 1'b0;
    end
end

always @ (*) begin
    if ((1'b1 == ap_CS_fsm_state3)) begin
        in0_V_TREADY_int_regslice = grp_Matrix_Vector_Activate_Stream_Batch_fu_60_in0_V_TREADY;
    end else begin
        in0_V_TREADY_int_regslice = 1'b0;
    end
end

always @ (*) begin
    if ((1'b1 == ap_CS_fsm_state3)) begin
        weights_V_TREADY_int_regslice = grp_Matrix_Vector_Activate_Stream_Batch_fu_60_weights_V_TREADY;
    end else begin
        weights_V_TREADY_int_regslice = 1'b0;
    end
end

always @ (*) begin
    case (ap_CS_fsm)
        ap_ST_fsm_state1 : begin
            ap_NS_fsm = ap_ST_fsm_state2;
        end
        ap_ST_fsm_state2 : begin
            ap_NS_fsm = ap_ST_fsm_state3;
        end
        ap_ST_fsm_state3 : begin
            if (((grp_Matrix_Vector_Activate_Stream_Batch_fu_60_ap_done == 1'b1) & (1'b1 == ap_CS_fsm_state3))) begin
                ap_NS_fsm = ap_ST_fsm_state4;
            end else begin
                ap_NS_fsm = ap_ST_fsm_state3;
            end
        end
        ap_ST_fsm_state4 : begin
            if (((1'b1 == ap_CS_fsm_state4) & (regslice_both_out_V_U_apdone_blk == 1'b0))) begin
                ap_NS_fsm = ap_ST_fsm_state1;
            end else begin
                ap_NS_fsm = ap_ST_fsm_state4;
            end
        end
        default : begin
            ap_NS_fsm = 'bx;
        end
    endcase
end

assign ap_CS_fsm_state2 = ap_CS_fsm[32'd1];

assign ap_CS_fsm_state3 = ap_CS_fsm[32'd2];

assign ap_CS_fsm_state4 = ap_CS_fsm[32'd3];

always @ (*) begin
    ap_rst_n_inv = ~ap_rst_n;
end

assign grp_Matrix_Vector_Activate_Stream_Batch_fu_60_ap_start = grp_Matrix_Vector_Activate_Stream_Batch_fu_60_ap_start_reg;

assign grp_Matrix_Vector_Activate_Stream_Batch_fu_60_out_V_TREADY = (out_V_TREADY_int_regslice & ap_CS_fsm_state3);

assign in0_V_TREADY = regslice_both_in0_V_U_ack_in;

assign out_V_TVALID = regslice_both_out_V_U_vld_out;

assign weights_V_TREADY = regslice_both_weights_V_U_ack_in;

endmodule //MVAU_hls_1
//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/vivado_stitch_proj_w5fn6zuu/finn_vivado_stitch_proj.gen/sources_1/bd/finn_design/ipshared/18e4/hdl/verilog/MVAU_hls_0_Matrix_Vector_Activate_Stream_Batch_p_ZL7threshs_3_ROM_AUTO_1R.v


// ==============================================================
// Vitis HLS - High-Level Synthesis from C, C++ and OpenCL v2022.2 (64-bit)
// Version: 2022.2
// Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.
// ==============================================================
`timescale 1 ns / 1 ps
module MVAU_hls_0_Matrix_Vector_Activate_Stream_Batch_p_ZL7threshs_3_ROM_AUTO_1R (
    address0, ce0, q0, 
    reset, clk);

parameter DataWidth = 13;
parameter AddressWidth = 4;
parameter AddressRange = 16;
 
input[AddressWidth-1:0] address0;
input ce0;
output reg[DataWidth-1:0] q0;

input reset;
input clk;

 
reg [DataWidth-1:0] rom0[0:AddressRange-1];


initial begin
     
    $readmemh("/home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/code_gen_ipgen_MVAU_hls_0_z2r2fzak/project_MVAU_hls_0/sol1/impl/ip/hdl/verilog/MVAU_hls_0_Matrix_Vector_Activate_Stream_Batch_p_ZL7threshs_3_ROM_AUTO_1R.dat", rom0);
end

  
always @(posedge clk) 
begin 
    if (ce0) 
    begin
        q0 <= rom0[address0];
    end
end


endmodule

//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/vivado_stitch_proj_w5fn6zuu/finn_vivado_stitch_proj.gen/sources_1/bd/finn_design/ipshared/bcb1/hdl/axilite_if.v


/*
 Copyright (c) 2020, Xilinx
 All rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:

 * Redistributions of source code must retain the above copyright notice, this
   list of conditions and the following disclaimer.

 * Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.

 * Neither the name of FINN nor the names of its
   contributors may be used to endorse or promote products derived from
   this software without specific prior written permission.

 THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

module axi4lite_if
#(
    parameter ADDR_WIDTH = 32,
    parameter DATA_WIDTH = 32,//AXI4 spec requires this to be strictly 32 or 64
    parameter IP_DATA_WIDTH = 64//can be any power-of-2 multiple of DATA_WIDTH
)
(
//system signals
input aclk,
input aresetn,//active low, asynchronous assertion and synchronous deassertion

//Write channels
//write address
output reg                  awready,
input                       awvalid,
input [ADDR_WIDTH-1:0]      awaddr,
input [2:0]                 awprot,
//write data
output reg                  wready,
input                       wvalid,
input [DATA_WIDTH-1:0]      wdata,
input [(DATA_WIDTH/8)-1:0]  wstrb,
//burst response
input                       bready,
output reg                  bvalid,
output reg [1:0]            bresp,//NOTE: 00 = OKAY, 10 = SLVERR (write error)

//Read channels
//read address
output reg                  arready,
input                       arvalid,
input [ADDR_WIDTH-1:0]      araddr,
input [2:0]                 arprot,
//read data
input                       rready,
output reg                  rvalid,
output reg [1:0]            rresp,//NOTE: 00 = OKAY, 10 = SLVERR (read error)
output reg [DATA_WIDTH-1:0] rdata,

//IP-side interface
output reg                  ip_en,
output reg                  ip_wen,
output reg [ADDR_WIDTH-1:0] ip_addr,
output [IP_DATA_WIDTH-1:0]  ip_wdata,
input                       ip_rack,
input [IP_DATA_WIDTH-1:0]      ip_rdata
);

localparam RESP_OKAY = 2'b00;
localparam RESP_SLVERR = 2'b10;
//get ceil(log2(ceil(IP_DATA_WIDTH/DATA_WIDTH)))
localparam NFOLDS_LOG = $clog2((IP_DATA_WIDTH + DATA_WIDTH - 1) / DATA_WIDTH);

reg                      internal_ren;
reg                      internal_wen;
reg                      internal_wack;
reg [ADDR_WIDTH-1:0]     internal_raddr;
reg [ADDR_WIDTH-1:0]     internal_waddr;
reg [DATA_WIDTH-1:0]     internal_wdata;
wire [DATA_WIDTH-1:0]    internal_rdata;
reg                      internal_error = 0;

//check DATA_WIDTH
initial begin
    if(DATA_WIDTH != 32 & DATA_WIDTH != 64) begin
        $display("AXI4Lite DATA_WIDTH must be 32 or 64");
        $finish;
    end
end

//transaction state machine
localparam  STATE_IDLE  = 0,
            STATE_READ  = 1,
            STATE_WRITE = 2;

reg [1:0] state;

always @(posedge aclk or negedge aresetn)
    if(~aresetn)
        state <= STATE_IDLE;
    else case(state)
        STATE_IDLE:
            if(awvalid & wvalid)
                state <= STATE_WRITE;
            else if(arvalid)
                state <= STATE_READ;
        STATE_READ:
            if(rvalid & rready)
                state <= STATE_IDLE;
        STATE_WRITE:
            if(bvalid & bready)
                state <= STATE_IDLE;
        default: state <= STATE_IDLE;
    endcase

//write-related internal signals
always @(*) begin
    internal_waddr = awaddr >> $clog2(DATA_WIDTH/8);
    internal_wdata = wdata;
    internal_wen = (state == STATE_IDLE) & awvalid & wvalid;
end

always @(posedge aclk) begin
    awready <= internal_wen;
    wready <= internal_wen;
end

//read-related internal signals
always @(*) begin
    internal_raddr = araddr >> $clog2(DATA_WIDTH/8);
    internal_ren = (state == STATE_IDLE) & ~internal_wen & arvalid;
end

always @(posedge aclk)
    arready <= internal_ren;

wire write_to_last_fold;

always @(posedge aclk) begin
    ip_wen <= write_to_last_fold;
    ip_en <= internal_ren | write_to_last_fold;
    if(internal_ren | write_to_last_fold)
        ip_addr <= internal_ren ? (internal_raddr >> NFOLDS_LOG) : (internal_waddr >> NFOLDS_LOG);
    internal_wack <= internal_wen;
end

genvar i;
reg [(1<<NFOLDS_LOG)*DATA_WIDTH-1:0] ip_wdata_wide;
generate
if(NFOLDS_LOG == 0) begin: no_fold
    assign write_to_last_fold = internal_wen;
    assign internal_rdata = ip_rdata;
    always @(posedge aclk)
        ip_wdata_wide <= internal_wdata;
end else begin: fold
    reg [NFOLDS_LOG-1:0] internal_rfold;
    assign write_to_last_fold = internal_wen & (internal_waddr[NFOLDS_LOG-1:0] == {(NFOLDS_LOG){1'b1}});
    assign internal_rdata = ip_rdata >> (internal_rfold*DATA_WIDTH);
    always @(posedge aclk)
        if(internal_ren)
            internal_rfold <= internal_raddr[NFOLDS_LOG-1:0];
    for(i=0; i<(1<<NFOLDS_LOG); i = i+1) begin: gen_wdata
        always @(posedge aclk)
            if(internal_waddr[NFOLDS_LOG-1:0] == i)
                ip_wdata_wide[(i+1)*DATA_WIDTH-1:i*DATA_WIDTH] <= internal_wdata;
    end
end
endgenerate
assign ip_wdata = ip_wdata_wide[IP_DATA_WIDTH-1:0];

//write response on AXI4L bus
always @(posedge aclk or negedge aresetn)
    if(~aresetn) begin
        bvalid <= 0;//AXI4 spec requires BVALID pulled LOW during reset
        bresp <= RESP_OKAY;
    end else if(internal_wack) begin
        bvalid <= 1;
        bresp <= internal_error ? RESP_SLVERR : RESP_OKAY;
    end else if(bready) begin
        bvalid <= 0;
        bresp <= RESP_OKAY;
    end

//read response on AXI4L bus
always @(posedge aclk or negedge aresetn)
    if(~aresetn) begin
        rvalid <= 0;//AXI4 spec requires RVALID pulled LOW during reset
        rdata <= 0;
        rresp <= RESP_OKAY;
    end else if(ip_rack) begin
        rvalid <= 1;
        rdata <= internal_rdata;
        rresp <= internal_error ? RESP_SLVERR : RESP_OKAY;
    end else if(rready) begin
        rvalid <= 0;
        rdata <= 0;
        rresp <= RESP_OKAY;
    end

endmodule
//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/code_gen_ipgen_StreamingDataWidthConverter_rtl_3_aheji69x/dwc.sv


/******************************************************************************
 * Copyright (C) 2023, Advanced Micro Devices, Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *  1. Redistributions of source code must retain the above copyright notice,
 *     this list of conditions and the following disclaimer.
 *
 *  2. Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *
 *  3. Neither the name of the copyright holder nor the names of its
 *     contributors may be used to endorse or promote products derived from
 *     this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION). HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * @brief	Stream Data Width Converter.
 * @author	Thomas B. Preuer <tpreusse@amd.com>
 *****************************************************************************/
module dwc #(
	int unsigned  IBITS,
	int unsigned  OBITS
)(
	//- Global Control ------------------
	input	logic  clk,
	input	logic  rst,

	//- AXI Stream - Input --------------
	output	logic  irdy,
	input	logic  ivld,
	input	logic [IBITS-1:0]  idat,

	//- AXI Stream - Output -------------
	input	logic  ordy,
	output	logic  ovld,
	output	logic [OBITS-1:0]  odat
);

	if(IBITS == OBITS) begin : genNoop
		assign	irdy = ordy;
		assign	ovld = ivld;
		assign	odat  = idat;
	end : genNoop
	else if(IBITS < OBITS) begin : genUp

		// Sanity Checking: integer upscaling
		initial begin
			if(OBITS % IBITS) begin
				$error("Output width %0d is not a multiple of input width %0d.", OBITS, IBITS);
				$finish;
			end
		end

		// Parallelizing Shift Register A and Sidestep Buffer B on Input Path
		localparam int unsigned  K = OBITS / IBITS;
		typedef logic [IBITS-1:0]  dat_t;
		dat_t       [K-1:0]  ADat = 'x;
		logic [$clog2(K):0]  ACnt = K-1;	// (empty) K-1, ..., 0, -1 (full/valid)
		dat_t  BDat = 'x;
		logic  BRdy =  1;
		always_ff @(posedge clk) begin
			if(rst) begin
				ADat <= 'x;
				ACnt <= K-1;
				BDat <= 'x;
				BRdy <=  1;
			end
			else begin
				automatic type(ACnt)  acnt = (ovld && ordy)? K-1 : ACnt;
				automatic logic  rdy = !ovld || ordy;
				if((ivld || !BRdy) && rdy) begin
					ADat <= { BRdy? idat : BDat, ADat[K-1:1] };
					acnt--;
				end
				ACnt <= acnt;

				if(BRdy)  BDat <= idat;
				BRdy <= rdy || (BRdy && !ivld);
			end
		end

		// Output Assignments
		assign  irdy = BRdy;
		assign	ovld = ACnt[$left(ACnt)];
		assign	odat  = ADat;

	end : genUp
	else begin : genDown

		// Sanity Checking: integer downscaling
		initial begin
			if(IBITS % OBITS) begin
				$error("Input width %0d is not a multiple of output width %0d.", IBITS, OBITS);
				$finish;
			end
		end

		// Serializing Shift Register A and Sidestep Buffer B on Output Path
		localparam int unsigned  K = IBITS / OBITS;
		typedef logic [OBITS-1:0]  dat_t;
		dat_t [      K-1:0]  ADat = 'x;
		logic [$clog2(K):0]  ACnt =  1;	// (full) -K+1, ..., -1, 0, 1 (empty/not valid)
		dat_t  BDat = 'x;
		logic  BRdy =  1;
		dat_t  CDat = 'x;
		logic  CVld =  0;
		always_ff @(posedge clk) begin
			if(rst) begin
				ADat <= 'x;
				ACnt <=  1;
				BDat <= 'x;
				BRdy <=  1;
				CDat <= 'x;
				CVld <=  0;
			end
			else begin
				automatic type(ACnt)  acnt = ACnt;
				automatic logic       ainc = 0;
				if(irdy) begin
					ADat <= idat;
					acnt = ivld? -K+1 : 1;
				end
				else if(BRdy) begin
					ADat <= { {OBITS{1'bx}}, ADat[K-1:1] };
					ainc = BRdy;
				end;
				ACnt <= acnt + ainc;

				if(BRdy)  BDat <= ADat[0];
				BRdy <= !CVld || ordy || (BRdy && !ACnt[$left(ACnt)] && ACnt[0]);

				if(!CVld || ordy)  CDat <= BRdy? ADat[0] : BDat;
				CVld <= (CVld && !ordy) || !BRdy || ACnt[$left(ACnt)] || !ACnt[0];
			end
		end

		// Output Assignments
		assign  irdy = BRdy && !ACnt[$left(ACnt)];
		assign	ovld = CVld;
		assign	odat  = CDat;

	end : genDown

endmodule : dwc
//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/vivado_stitch_proj_w5fn6zuu/finn_vivado_stitch_proj.gen/sources_1/bd/finn_design/ipshared/6bf6/hdl/verilog/StreamingMaxPool_hls_0_hls_deadlock_idx0_monitor.v


`timescale 1 ns / 1 ps

module StreamingMaxPool_hls_0_hls_deadlock_idx0_monitor ( // for module StreamingMaxPool_hls_0_StreamingMaxPool_hls_0_inst
    input wire clock,
    input wire reset,
    input wire [1:0] axis_block_sigs,
    input wire [3:0] inst_idle_sigs,
    input wire [0:0] inst_block_sigs,
    output wire block
);

// signal declare
reg monitor_find_block;
wire idx1_block;
wire sub_parallel_block;
wire all_sub_parallel_has_block;
wire all_sub_single_has_block;
wire cur_axis_has_block;
wire seq_is_axis_block;

assign block = monitor_find_block;
assign all_sub_parallel_has_block = 1'b0;
assign all_sub_single_has_block = 1'b0 | (idx1_block & (axis_block_sigs[1] | axis_block_sigs[0]));
assign cur_axis_has_block = 1'b0;
assign seq_is_axis_block = all_sub_parallel_has_block | all_sub_single_has_block | cur_axis_has_block;

always @(posedge clock) begin
    if (reset == 1'b1)
        monitor_find_block <= 1'b0;
    else if (seq_is_axis_block == 1'b1)
        monitor_find_block <= 1'b1;
    else
        monitor_find_block <= 1'b0;
end


// instant sub module
 StreamingMaxPool_hls_0_hls_deadlock_idx1_monitor StreamingMaxPool_hls_0_hls_deadlock_idx1_monitor_U (
    .clock(clock),
    .reset(reset),
    .axis_block_sigs(axis_block_sigs),
    .inst_idle_sigs(inst_idle_sigs),
    .inst_block_sigs(inst_block_sigs),
    .block(idx1_block)
);

endmodule
//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/code_gen_ipgen_StreamingDataWidthConverter_rtl_4_w7r25d9z/StreamingDataWidthConverter_rtl_4.v


/******************************************************************************
 * Copyright (C) 2023, Advanced Micro Devices, Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *  1. Redistributions of source code must retain the above copyright notice,
 *     this list of conditions and the following disclaimer.
 *
 *  2. Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *
 *  3. Neither the name of the copyright holder nor the names of its
 *     contributors may be used to endorse or promote products derived from
 *     this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION). HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *****************************************************************************/

module StreamingDataWidthConverter_rtl_4 #(
	parameter  IBITS = 128,
	parameter  OBITS = 4,

	parameter  AXI_IBITS = (IBITS+7)/8 * 8,
	parameter  AXI_OBITS = (OBITS+7)/8 * 8
)(
	//- Global Control ------------------
	(* X_INTERFACE_INFO = "xilinx.com:signal:clock:1.0 ap_clk CLK" *)
	(* X_INTERFACE_PARAMETER = "ASSOCIATED_BUSIF in0_V:out_V, ASSOCIATED_RESET ap_rst_n" *)
	input	ap_clk,
	(* X_INTERFACE_PARAMETER = "POLARITY ACTIVE_LOW" *)
	input	ap_rst_n,

	//- AXI Stream - Input --------------
	output	in0_V_TREADY,
	input	in0_V_TVALID,
	input	[AXI_IBITS-1:0]  in0_V_TDATA,

	//- AXI Stream - Output -------------
	input	out_V_TREADY,
	output	out_V_TVALID,
	output	[AXI_OBITS-1:0]  out_V_TDATA
);

	dwc_axi #(
		.IBITS(IBITS),
		.OBITS(OBITS)
	) impl (
		.ap_clk(ap_clk),
		.ap_rst_n(ap_rst_n),
		.s_axis_tready(in0_V_TREADY),
		.s_axis_tvalid(in0_V_TVALID),
		.s_axis_tdata(in0_V_TDATA),
		.m_axis_tready(out_V_TREADY),
		.m_axis_tvalid(out_V_TVALID),
		.m_axis_tdata(out_V_TDATA)
	);

endmodule
//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/code_gen_ipgen_ConvolutionInputGenerator_rtl_1_6arfz_kp/ConvolutionInputGenerator_rtl_1_wrapper.v


/******************************************************************************
 * Copyright (C) 2022, Advanced Micro Devices, Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *  1. Redistributions of source code must retain the above copyright notice,
 *     this list of conditions and the following disclaimer.
 *
 *  2. Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *
 *  3. Neither the name of the copyright holder nor the names of its
 *     contributors may be used to endorse or promote products derived from
 *     this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION). HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *****************************************************************************/

module ConvolutionInputGenerator_rtl_1 (
	(* X_INTERFACE_PARAMETER = "ASSOCIATED_BUSIF in0_V:out_V, ASSOCIATED_RESET ap_rst_n" *)
	(* X_INTERFACE_INFO = "xilinx.com:signal:clock:1.0 ap_clk CLK" *)
	input  ap_clk,
	(* X_INTERFACE_PARAMETER = "POLARITY ACTIVE_LOW" *)
	input  ap_rst_n,
	input  [IN_WIDTH_PADDED-1:0] in0_V_TDATA,
	input  in0_V_TVALID,
	output in0_V_TREADY,
	output [OUT_WIDTH_PADDED-1:0] out_V_TDATA,
	output out_V_TVALID,
	input  out_V_TREADY
);

// top-level parameters (set via code-generation)
parameter BIT_WIDTH = 4;
parameter SIMD = 1;
parameter MMV_IN = 1;
parameter MMV_OUT = 1;
parameter IN_WIDTH_PADDED = 8;
parameter OUT_WIDTH_PADDED = 8;

// derived constants
parameter BUF_IN_WIDTH = BIT_WIDTH * SIMD * MMV_IN;
parameter BUF_OUT_WIDTH = BIT_WIDTH * SIMD * MMV_OUT;

ConvolutionInputGenerator_rtl_1_impl #(
	.BIT_WIDTH(BIT_WIDTH),
	.SIMD(SIMD),
	.MMV_IN(MMV_IN),
	.MMV_OUT(MMV_OUT)
) impl (
	.ap_clk(ap_clk),
	.ap_rst_n(ap_rst_n),
	.in0_V_V_TDATA(in0_V_TDATA[BUF_IN_WIDTH-1:0]),
	.in0_V_V_TVALID(in0_V_TVALID),
	.in0_V_V_TREADY(in0_V_TREADY),
	.out_V_V_TDATA(out_V_TDATA[BUF_OUT_WIDTH-1:0]),
	.out_V_V_TVALID(out_V_TVALID),
	.out_V_V_TREADY(out_V_TREADY)
);

endmodule : ConvolutionInputGenerator_rtl_1
//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/vivado_stitch_proj_w5fn6zuu/finn_vivado_stitch_proj.gen/sources_1/bd/finn_design/ipshared/fb57/hdl/verilog/MVAU_hls_1_hls_deadlock_idx0_monitor.v


`timescale 1 ns / 1 ps

module MVAU_hls_1_hls_deadlock_idx0_monitor ( // for module MVAU_hls_1_MVAU_hls_1_inst
    input wire clock,
    input wire reset,
    input wire [2:0] axis_block_sigs,
    input wire [1:0] inst_idle_sigs,
    input wire [0:0] inst_block_sigs,
    output wire block
);

// signal declare
reg monitor_find_block;
wire idx1_block;
wire sub_parallel_block;
wire all_sub_parallel_has_block;
wire all_sub_single_has_block;
wire cur_axis_has_block;
wire seq_is_axis_block;

assign block = monitor_find_block;
assign all_sub_parallel_has_block = 1'b0;
assign all_sub_single_has_block = 1'b0 | (idx1_block & (axis_block_sigs[0] | axis_block_sigs[1] | axis_block_sigs[2]));
assign cur_axis_has_block = 1'b0;
assign seq_is_axis_block = all_sub_parallel_has_block | all_sub_single_has_block | cur_axis_has_block;

always @(posedge clock) begin
    if (reset == 1'b1)
        monitor_find_block <= 1'b0;
    else if (seq_is_axis_block == 1'b1)
        monitor_find_block <= 1'b1;
    else
        monitor_find_block <= 1'b0;
end


// instant sub module
 MVAU_hls_1_hls_deadlock_idx1_monitor MVAU_hls_1_hls_deadlock_idx1_monitor_U (
    .clock(clock),
    .reset(reset),
    .axis_block_sigs(axis_block_sigs),
    .inst_idle_sigs(inst_idle_sigs),
    .inst_block_sigs(inst_block_sigs),
    .block(idx1_block)
);

endmodule
//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/code_gen_ipgen_StreamingFIFO_rtl_13_tpblmmir/StreamingFIFO_rtl_13.v


/******************************************************************************
 * Copyright (C) 2024, Advanced Micro Devices, Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *  1. Redistributions of source code must retain the above copyright notice,
 *     this list of conditions and the following disclaimer.
 *
 *  2. Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *
 *  3. Neither the name of the copyright holder nor the names of its
 *     contributors may be used to endorse or promote products derived from
 *     this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION). HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *****************************************************************************/

module StreamingFIFO_rtl_13(
//- Global Control ------------------
(* X_INTERFACE_PARAMETER = "ASSOCIATED_BUSIF in0_V:out_V, ASSOCIATED_RESET = ap_rst_n" *)
(* X_INTERFACE_INFO = "xilinx.com:signal:clock:1.0 ap_clk CLK" *)
input   ap_clk,
(* X_INTERFACE_PARAMETER = "POLARITY ACTIVE_LOW" *)
input   ap_rst_n,

output [10:0] count,
output [10:0] maxcount,

//- AXI Stream - Input --------------
output   in0_V_TREADY,
input   in0_V_TVALID,
input  [7:0] in0_V_TDATA,

//- AXI Stream - Output --------------
input   out_V_TREADY,
output   out_V_TVALID,
output  [7:0] out_V_TDATA
);

Q_srl #(
.depth(1568),
.width(8)
)
impl
(
 .clock(ap_clk),
 .reset(!ap_rst_n),
 .count(count),
 .maxcount(maxcount),
 .i_d(in0_V_TDATA),
 .i_v(in0_V_TVALID),
 .i_r(in0_V_TREADY),
 .o_d(out_V_TDATA),
 .o_v(out_V_TVALID),
 .o_r(out_V_TREADY)
);

endmodule
//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/code_gen_ipgen_StreamingFIFO_rtl_7_etz5w7xz/Q_srl.v


// original source:
// https://github.com/nachiket/tdfc/blob/master/verilog/queues/Q_srl_oreg3_prefull_SIMPLE.v


// Copyright (c) 1999 The Regents of the University of California
// Copyright (c) 2010 The Regents of the University of Pennsylvania
// Copyright (c) 2011 Department of Electrical and Electronic Engineering, Imperial College London
// Copyright (c) 2020 Xilinx
//
// Permission to use, copy, modify, and distribute this software and
// its documentation for any purpose, without fee, and without a
// written agreement is hereby granted, provided that the above copyright
// notice and this paragraph and the following two paragraphs appear in
// all copies.
//
// IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR
// DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
// LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION,
// EVEN IF THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
// THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
// INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
// AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE PROVIDED HEREUNDER IS ON
// AN "AS IS" BASIS, AND THE UNIVERSITY OF CALIFORNIA HAS NO OBLIGATIONS TO
// PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
//

// Q_srl_oreg3_prefull_SIMPLE.v
//
//  - In-page queue with parameterizable depth, bit width
//  - Stream I/O is triple (data, valid, back-pressure),
//      with EOS concatenated into the data
//  - Flow control for input & output is combinationally decoupled
//  - 2 <= depth <= 256
//      * (depth >= 2)  is required to decouple I/O flow control,
//          where empty => no produce,  full => no consume,
//          and depth 1 would ping-pong between the two at half rate
//      * (depth <= 256) can be modified
//           by changing ''synthesis loop_limit X'' below
//          and changing ''addrwidth'' or its log computation
//  - 1 <= width
//  - Queue storage is in SRL16E, up to depth 16 per LUT per bit-slice,
//      plus output register (for fast output)
//  - Queue addressing is done by ''addr'' up-down counter
//  - Queue fullness is checked by comparator (addr==depth)
//  - Queue fullness                           is pre-computed for next cycle
//  - Queue input back-pressure                is pre-computed for next cycle
//  - Queue output valid (state!=state__empty) is pre-computed for next cycle
//      (necessary since SRL data output reg requires non-boolean state)
//  - FSM has 3 states (empty, one, more)
//  - When empty, continue to emit most recently emitted value (for debugging)
//
//  - Queue slots used      = / (state==state_empty) ? 0
//                            | (state==state_one)   ? 1
//                            \ (state==state_more)  ? addr+2
//  - Queue slots used     <=  depth
//  - Queue slots remaining =  depth - used
//                          = / (state==state_empty) ? depth
//                            | (state==state_one)   ? depth-1
//                            \ (state==state_more)  ? depth-2-addr
//
//  - Synplify 7.1 / 8.0
//  - Eylon Caspi,  9/11/03, 8/18/04, 3/29/05


`ifdef  Q_srl
`else
`define Q_srl


module Q_srl (clock, reset, i_d, i_v, i_r, o_d, o_v, o_r, count, maxcount);

   parameter depth = 16;   // - greatest #items in queue  (2 <= depth <= 256)
   parameter width = 16;   // - width of data (i_d, o_d)

   localparam countwidth = $clog2(depth + 1);
   localparam addrwidth = $clog2(depth);

   input     clock;
   input     reset;

   input  [width-1:0] i_d;	// - input  stream data (concat data + eos)
   input              i_v;	// - input  stream valid
   output             i_r;	// - input  stream ready
   wire               i_b;  // - input  stream back-pressure

   output [width-1:0] o_d;	// - output stream data (concat data + eos)
   output             o_v;	// - output stream valid
   input              o_r;	// - output stream ready
   wire               o_b;	// - output stream back-pressure

   output [countwidth-1:0] count;  // - output number of elems in queue
   output [countwidth-1:0] maxcount;  // - maximum observed count since reset

   reg [countwidth-1:0] maxcount_reg;  // - maximum count seen until now
   reg    [addrwidth-1:0] addr, addr_, a_;		// - SRL16 address
							//     for data output
   reg 			  shift_en_;			// - SRL16 shift enable
   reg    [width-1:0] 	  srl [depth-2:0];		// - SRL16 memory
   reg 			  shift_en_o_;			// - SRLO  shift enable
   reg    [width-1:0] 	  srlo_, srlo			// - SRLO  output reg
			  /* synthesis syn_allow_retiming=0 */ ;

   parameter state_empty = 2'd0;    // - state empty : o_v=0 o_d=UNDEFINED
   parameter state_one   = 2'd1;    // - state one   : o_v=1 o_d=srlo
   parameter state_more  = 2'd2;    // - state more  : o_v=1 o_d=srlo
				    //     #items in srl = addr+2

   reg [1:0] state, state_;	    // - state register

   wire      addr_full_;	    // - true iff addr==depth-2 on NEXT cycle
   reg       addr_full; 	    // - true iff addr==depth-2
   wire      addr_zero_;	    // - true iff addr==0
   wire      o_v_reg_;		    // - true iff state_empty   on NEXT cycle
   reg       o_v_reg  		    // - true iff state_empty
	     /* synthesis syn_allow_retiming=0 */ ;
   wire      i_b_reg_;		    // - true iff !full         on NEXT cycle
   reg       i_b_reg  		    // - true iff !full
	     /* synthesis syn_allow_retiming=0 */ ;

   assign addr_full_ = (state_==state_more) && (addr_==depth-2);
						// - queue full
   assign addr_zero_ = (addr==0);		// - queue contains 2 (or 1,0)
   assign o_v_reg_   = (state_!=state_empty);	// - output valid if non-empty
   assign i_b_reg_   = addr_full_;		// - input bp if full
   assign o_d = srlo;				// - output data from queue
   assign o_v = o_v_reg;			// - output valid if non-empty
   assign i_b = i_b_reg;			// - input bp if full
   assign maxcount = maxcount_reg;

   assign i_r = !i_b;
   assign o_b = !o_r;

   assign count = (state==state_more ? addr+2 : (state==state_one ? 1 : 0));

   // - ''always'' block with both FFs and SRL16 does not work,
   //      since FFs need reset but SRL16 does not

   always @(posedge clock) begin	// - seq always: FFs
      if (reset) begin
	 state     <= state_empty;
	 addr      <= 0;
         addr_full <= 0;
	 o_v_reg   <= 0;

	 i_b_reg   <= 0;
	 maxcount_reg <= 0;

      end
      else begin
	 state     <= state_;
	 addr      <= addr_;
         addr_full <= addr_full_;
	 o_v_reg   <= o_v_reg_;
	 i_b_reg   <= i_b_reg_;
	 maxcount_reg <= (count > maxcount_reg ? count : maxcount_reg);
      end
   end // always @ (posedge clock)

   always @(posedge clock) begin	// - seq always: srlo
      // - infer enabled output reg at end of shift chain
      // - input first element from i_d, all subsequent elements from SRL16
      if (reset) begin
	 srlo <= 0;
      end
      else begin
	 if (shift_en_o_) begin
	    srlo <= srlo_;
	 end
      end
   end // always @ (posedge clock)

   always @(posedge clock) begin			// - seq always: srl
      // - infer enabled SRL16E from shifting srl array
      // - no reset capability;  srl[] contents undefined on reset
      if (shift_en_) begin
	 // synthesis loop_limit 256
	 for (a_=depth-2; a_>0; a_=a_-1) begin
	    srl[a_] = srl[a_-1];
	 end
	 srl[0] <= i_d;
      end
   end // always @ (posedge clock or negedge reset)

   always @* begin					// - combi always
        srlo_       <=  'bx;
        shift_en_o_ <= 1'bx;
        shift_en_   <= 1'bx;
        addr_       <=  'bx;
        state_      <= 2'bx;
      case (state)

	state_empty: begin		    // - (empty, will not produce)
	      if (i_v) begin		    // - empty & i_v => consume
		 srlo_       <= i_d;
		 shift_en_o_ <= 1;
		 shift_en_   <= 1'bx;
		 addr_       <= 0;
		 state_      <= state_one;
	      end
	      else	begin		    // - empty & !i_v => idle
		 srlo_       <= 'bx;
		 shift_en_o_ <= 0;
		 shift_en_   <= 1'bx;
		 addr_       <= 0;
		 state_      <= state_empty;
	      end
	end

	state_one: begin		    // - (contains one)
	      if (i_v && o_b) begin	    // - one & i_v & o_b => consume
		 srlo_       <= 'bx;
		 shift_en_o_ <= 0;
		 shift_en_   <= 1;
		 addr_       <= 0;
		 state_      <= state_more;
	      end
	      else if (i_v && !o_b) begin   // - one & i_v & !o_b => cons+prod
		 srlo_       <= i_d;
		 shift_en_o_ <= 1;
		 shift_en_   <= 1;
		 addr_       <= 0;
		 state_      <= state_one;
	      end
	      else if (!i_v && o_b) begin   // - one & !i_v & o_b => idle
		 srlo_       <= 'bx;
		 shift_en_o_ <= 0;
		 shift_en_   <= 1'bx;
		 addr_       <= 0;
		 state_      <= state_one;
	      end
	      else if (!i_v && !o_b) begin  // - one & !i_v & !o_b => produce
		 srlo_       <= 'bx;
		 shift_en_o_ <= 0;
		 shift_en_   <= 1'bx;
		 addr_       <= 0;
		 state_      <= state_empty;
	      end
	end // case: state_one

	state_more: begin		    // - (contains more than one)
	   if (addr_full || (depth==2)) begin
					    // - (full, will not consume)
					    // - (full here if depth==2)
	      if (o_b) begin		    // - full & o_b => idle
		 srlo_       <= 'bx;
		 shift_en_o_ <= 0;
		 shift_en_   <= 0;
		 addr_       <= addr;
		 state_      <= state_more;
	      end
	      else begin		    // - full & !o_b => produce
		 srlo_       <= srl[addr];
		 shift_en_o_ <= 1;
		 shift_en_   <= 0;
//		 addr_       <= addr-1;
//		 state_      <= state_more;
		 addr_       <= addr_zero_ ? 0         : addr-1;
		 state_      <= addr_zero_ ? state_one : state_more;
	      end
	   end
	   else begin			    // - (mid: neither empty nor full)
	      if (i_v && o_b) begin	    // - mid & i_v & o_b => consume
		 srlo_       <= 'bx;
		 shift_en_o_ <= 0;
		 shift_en_   <= 1;
		 addr_       <= addr+1;
		 state_      <= state_more;
	      end
	      else if (i_v && !o_b) begin   // - mid & i_v & !o_b => cons+prod
		 srlo_       <= srl[addr];
		 shift_en_o_ <= 1;
		 shift_en_   <= 1;
		 addr_       <= addr;
		 state_      <= state_more;
	      end
	      else if (!i_v && o_b) begin   // - mid & !i_v & o_b => idle
		 srlo_       <= 'bx;
		 shift_en_o_ <= 0;
		 shift_en_   <= 0;
		 addr_       <= addr;
		 state_      <= state_more;
	      end
	      else if (!i_v && !o_b) begin  // - mid & !i_v & !o_b => produce
		 srlo_       <= srl[addr];
		 shift_en_o_ <= 1;
		 shift_en_   <= 0;
		 addr_       <= addr_zero_ ? 0         : addr-1;
		 state_      <= addr_zero_ ? state_one : state_more;
	      end
	   end // else: !if(addr_full)
	end // case: state_more

	default: begin
		 srlo_       <=  'bx;
		 shift_en_o_ <= 1'bx;
		 shift_en_   <= 1'bx;
		 addr_       <=  'bx;
		 state_      <= 2'bx;
	end // case: default

      endcase // case(state)
   end // always @ *

endmodule // Q_srl


`endif  // `ifdef  Q_srl
//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/code_gen_ipgen_StreamingDataWidthConverter_rtl_3_aheji69x/dwc_axi.sv


/******************************************************************************
 * Copyright (C) 2023, Advanced Micro Devices, Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *  1. Redistributions of source code must retain the above copyright notice,
 *     this list of conditions and the following disclaimer.
 *
 *  2. Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *
 *  3. Neither the name of the copyright holder nor the names of its
 *     contributors may be used to endorse or promote products derived from
 *     this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION). HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * @brief	AXI Stream Adapter for Data Width Converter.
 * @author	Thomas B. Preuer <tpreusse@amd.com>
 *****************************************************************************/
module dwc_axi #(
	int unsigned  IBITS,
	int unsigned  OBITS,

	localparam int unsigned  AXI_IBITS = (IBITS+7)/8 * 8,
	localparam int unsigned  AXI_OBITS = (OBITS+7)/8 * 8
)(
	//- Global Control ------------------
	input	logic  ap_clk,
	input	logic  ap_rst_n,

	//- AXI Stream - Input --------------
	output	logic  s_axis_tready,
	input	logic  s_axis_tvalid,
	input	logic [AXI_IBITS-1:0]  s_axis_tdata,

	//- AXI Stream - Output -------------
	input	logic  m_axis_tready,
	output	logic  m_axis_tvalid,
	output	logic [AXI_OBITS-1:0]  m_axis_tdata
);

	dwc #(.IBITS(IBITS), .OBITS(OBITS)) core (
		.clk(ap_clk), .rst(!ap_rst_n),
		.irdy(s_axis_tready), .ivld(s_axis_tvalid), .idat(s_axis_tdata[IBITS-1:0]),
		.ordy(m_axis_tready), .ovld(m_axis_tvalid), .odat(m_axis_tdata[OBITS-1:0])
	);
	if(OBITS < AXI_OBITS) begin
		assign	m_axis_tdata[AXI_OBITS-1:OBITS] = '0;
	end

endmodule : dwc_axi
//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/vivado_stitch_proj_w5fn6zuu/finn_vivado_stitch_proj.gen/sources_1/bd/finn_design/ipshared/fb57/hdl/verilog/MVAU_hls_1_Matrix_Vector_Activate_Stream_Batch_p_ZL7threshs_6_ROM_AUTO_1R.v


// ==============================================================
// Vitis HLS - High-Level Synthesis from C, C++ and OpenCL v2022.2 (64-bit)
// Version: 2022.2
// Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.
// ==============================================================
`timescale 1 ns / 1 ps
module MVAU_hls_1_Matrix_Vector_Activate_Stream_Batch_p_ZL7threshs_6_ROM_AUTO_1R (
    address0, ce0, q0, 
    reset, clk);

parameter DataWidth = 11;
parameter AddressWidth = 5;
parameter AddressRange = 32;
 
input[AddressWidth-1:0] address0;
input ce0;
output reg[DataWidth-1:0] q0;

input reset;
input clk;

 
reg [DataWidth-1:0] rom0[0:AddressRange-1];


initial begin
     
    $readmemh("/home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/code_gen_ipgen_MVAU_hls_1__774deg0/project_MVAU_hls_1/sol1/impl/ip/hdl/verilog/MVAU_hls_1_Matrix_Vector_Activate_Stream_Batch_p_ZL7threshs_6_ROM_AUTO_1R.dat", rom0);
end

  
always @(posedge clk) 
begin 
    if (ce0) 
    begin
        q0 <= rom0[address0];
    end
end


endmodule

//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/code_gen_ipgen_StreamingDataWidthConverter_rtl_2_8cmmvtlt/StreamingDataWidthConverter_rtl_2.v


/******************************************************************************
 * Copyright (C) 2023, Advanced Micro Devices, Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *  1. Redistributions of source code must retain the above copyright notice,
 *     this list of conditions and the following disclaimer.
 *
 *  2. Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *
 *  3. Neither the name of the copyright holder nor the names of its
 *     contributors may be used to endorse or promote products derived from
 *     this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION). HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *****************************************************************************/

module StreamingDataWidthConverter_rtl_2 #(
	parameter  IBITS = 64,
	parameter  OBITS = 4,

	parameter  AXI_IBITS = (IBITS+7)/8 * 8,
	parameter  AXI_OBITS = (OBITS+7)/8 * 8
)(
	//- Global Control ------------------
	(* X_INTERFACE_INFO = "xilinx.com:signal:clock:1.0 ap_clk CLK" *)
	(* X_INTERFACE_PARAMETER = "ASSOCIATED_BUSIF in0_V:out_V, ASSOCIATED_RESET ap_rst_n" *)
	input	ap_clk,
	(* X_INTERFACE_PARAMETER = "POLARITY ACTIVE_LOW" *)
	input	ap_rst_n,

	//- AXI Stream - Input --------------
	output	in0_V_TREADY,
	input	in0_V_TVALID,
	input	[AXI_IBITS-1:0]  in0_V_TDATA,

	//- AXI Stream - Output -------------
	input	out_V_TREADY,
	output	out_V_TVALID,
	output	[AXI_OBITS-1:0]  out_V_TDATA
);

	dwc_axi #(
		.IBITS(IBITS),
		.OBITS(OBITS)
	) impl (
		.ap_clk(ap_clk),
		.ap_rst_n(ap_rst_n),
		.s_axis_tready(in0_V_TREADY),
		.s_axis_tvalid(in0_V_TVALID),
		.s_axis_tdata(in0_V_TDATA),
		.m_axis_tready(out_V_TREADY),
		.m_axis_tvalid(out_V_TVALID),
		.m_axis_tdata(out_V_TDATA)
	);

endmodule
//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/vivado_stitch_proj_w5fn6zuu/finn_vivado_stitch_proj.gen/sources_1/bd/finn_design/ip/finn_design_StreamingFIFO_rtl_5_0/synth/finn_design_StreamingFIFO_rtl_5_0.v


// (c) Copyright 1995-2026 Xilinx, Inc. All rights reserved.
// 
// This file contains confidential and proprietary information
// of Xilinx, Inc. and is protected under U.S. and
// international copyright and other intellectual property
// laws.
// 
// DISCLAIMER
// This disclaimer is not a license and does not grant any
// rights to the materials distributed herewith. Except as
// otherwise provided in a valid license issued to you by
// Xilinx, and to the maximum extent permitted by applicable
// law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
// WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
// AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
// BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
// INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
// (2) Xilinx shall not be liable (whether in contract or tort,
// including negligence, or under any other theory of
// liability) for any loss or damage of any kind or nature
// related to, arising under or in connection with these
// materials, including for any direct, or any indirect,
// special, incidental, or consequential loss or damage
// (including loss of data, profits, goodwill, or any type of
// loss or damage suffered as a result of any action brought
// by a third party) even if such damage or loss was
// reasonably foreseeable or Xilinx had been advised of the
// possibility of the same.
// 
// CRITICAL APPLICATIONS
// Xilinx products are not designed or intended to be fail-
// safe, or for use in any application requiring fail-safe
// performance, such as life-support or safety devices or
// systems, Class III medical devices, nuclear facilities,
// applications related to the deployment of airbags, or any
// other applications that could lead to death, personal
// injury, or severe property or environmental damage
// (individually and collectively, "Critical
// Applications"). Customer assumes the sole risk and
// liability of any use of Xilinx products in Critical
// Applications, subject only to applicable laws and
// regulations governing limitations on product liability.
// 
// THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
// PART OF THIS FILE AT ALL TIMES.
// 
// DO NOT MODIFY THIS FILE.


// IP VLNV: xilinx.com:module_ref:StreamingFIFO_rtl_5:1.0
// IP Revision: 1

(* X_CORE_INFO = "StreamingFIFO_rtl_5,Vivado 2022.2" *)
(* CHECK_LICENSE_TYPE = "finn_design_StreamingFIFO_rtl_5_0,StreamingFIFO_rtl_5,{}" *)
(* CORE_GENERATION_INFO = "finn_design_StreamingFIFO_rtl_5_0,StreamingFIFO_rtl_5,{x_ipProduct=Vivado 2022.2,x_ipVendor=xilinx.com,x_ipLibrary=module_ref,x_ipName=StreamingFIFO_rtl_5,x_ipVersion=1.0,x_ipCoreRevision=1,x_ipLanguage=VERILOG,x_ipSimLanguage=MIXED}" *)
(* IP_DEFINITION_SOURCE = "module_ref" *)
(* DowngradeIPIdentifiedWarnings = "yes" *)
module finn_design_StreamingFIFO_rtl_5_0 (
  ap_clk,
  ap_rst_n,
  count,
  maxcount,
  in0_V_TREADY,
  in0_V_TVALID,
  in0_V_TDATA,
  out_V_TREADY,
  out_V_TVALID,
  out_V_TDATA
);

(* X_INTERFACE_PARAMETER = "XIL_INTERFACENAME ap_clk, ASSOCIATED_RESET ap_rst_n, ASSOCIATED_BUSIF in0_V:out_V, FREQ_HZ 100000000, FREQ_TOLERANCE_HZ 0, PHASE 0.0, CLK_DOMAIN finn_design_ap_clk_0, INSERT_VIP 0" *)
(* X_INTERFACE_INFO = "xilinx.com:signal:clock:1.0 ap_clk CLK" *)
input wire ap_clk;
(* X_INTERFACE_PARAMETER = "XIL_INTERFACENAME ap_rst_n, POLARITY ACTIVE_LOW, INSERT_VIP 0" *)
(* X_INTERFACE_INFO = "xilinx.com:signal:reset:1.0 ap_rst_n RST" *)
input wire ap_rst_n;
output wire [9 : 0] count;
output wire [9 : 0] maxcount;
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 in0_V TREADY" *)
output wire in0_V_TREADY;
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 in0_V TVALID" *)
input wire in0_V_TVALID;
(* X_INTERFACE_PARAMETER = "XIL_INTERFACENAME in0_V, TDATA_NUM_BYTES 8, TDEST_WIDTH 0, TID_WIDTH 0, TUSER_WIDTH 0, HAS_TREADY 1, HAS_TSTRB 0, HAS_TKEEP 0, HAS_TLAST 0, FREQ_HZ 100000000, PHASE 0.0, CLK_DOMAIN finn_design_ap_clk_0, LAYERED_METADATA undef, INSERT_VIP 0" *)
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 in0_V TDATA" *)
input wire [63 : 0] in0_V_TDATA;
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 out_V TREADY" *)
input wire out_V_TREADY;
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 out_V TVALID" *)
output wire out_V_TVALID;
(* X_INTERFACE_PARAMETER = "XIL_INTERFACENAME out_V, TDATA_NUM_BYTES 8, TDEST_WIDTH 0, TID_WIDTH 0, TUSER_WIDTH 0, HAS_TREADY 1, HAS_TSTRB 0, HAS_TKEEP 0, HAS_TLAST 0, FREQ_HZ 100000000, PHASE 0.0, CLK_DOMAIN finn_design_ap_clk_0, LAYERED_METADATA undef, INSERT_VIP 0" *)
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 out_V TDATA" *)
output wire [63 : 0] out_V_TDATA;

  StreamingFIFO_rtl_5 inst (
    .ap_clk(ap_clk),
    .ap_rst_n(ap_rst_n),
    .count(count),
    .maxcount(maxcount),
    .in0_V_TREADY(in0_V_TREADY),
    .in0_V_TVALID(in0_V_TVALID),
    .in0_V_TDATA(in0_V_TDATA),
    .out_V_TREADY(out_V_TREADY),
    .out_V_TVALID(out_V_TVALID),
    .out_V_TDATA(out_V_TDATA)
  );
endmodule
//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/code_gen_ipgen_StreamingFIFO_rtl_9_1gvd06yw/StreamingFIFO_rtl_9.v


/******************************************************************************
 * Copyright (C) 2024, Advanced Micro Devices, Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *  1. Redistributions of source code must retain the above copyright notice,
 *     this list of conditions and the following disclaimer.
 *
 *  2. Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *
 *  3. Neither the name of the copyright holder nor the names of its
 *     contributors may be used to endorse or promote products derived from
 *     this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION). HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *****************************************************************************/

module StreamingFIFO_rtl_9(
//- Global Control ------------------
(* X_INTERFACE_PARAMETER = "ASSOCIATED_BUSIF in0_V:out_V, ASSOCIATED_RESET = ap_rst_n" *)
(* X_INTERFACE_INFO = "xilinx.com:signal:clock:1.0 ap_clk CLK" *)
input   ap_clk,
(* X_INTERFACE_PARAMETER = "POLARITY ACTIVE_LOW" *)
input   ap_rst_n,

output [14:0] count,
output [14:0] maxcount,

//- AXI Stream - Input --------------
output   in0_V_TREADY,
input   in0_V_TVALID,
input  [7:0] in0_V_TDATA,

//- AXI Stream - Output --------------
input   out_V_TREADY,
output   out_V_TVALID,
output  [7:0] out_V_TDATA
);

Q_srl #(
.depth(28224),
.width(8)
)
impl
(
 .clock(ap_clk),
 .reset(!ap_rst_n),
 .count(count),
 .maxcount(maxcount),
 .i_d(in0_V_TDATA),
 .i_v(in0_V_TVALID),
 .i_r(in0_V_TREADY),
 .o_d(out_V_TDATA),
 .o_v(out_V_TVALID),
 .o_r(out_V_TREADY)
);

endmodule
//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/vivado_stitch_proj_w5fn6zuu/finn_vivado_stitch_proj.gen/sources_1/bd/finn_design/ip/finn_design_StreamingFIFO_rtl_9_0/synth/finn_design_StreamingFIFO_rtl_9_0.v


// (c) Copyright 1995-2026 Xilinx, Inc. All rights reserved.
// 
// This file contains confidential and proprietary information
// of Xilinx, Inc. and is protected under U.S. and
// international copyright and other intellectual property
// laws.
// 
// DISCLAIMER
// This disclaimer is not a license and does not grant any
// rights to the materials distributed herewith. Except as
// otherwise provided in a valid license issued to you by
// Xilinx, and to the maximum extent permitted by applicable
// law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
// WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
// AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
// BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
// INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
// (2) Xilinx shall not be liable (whether in contract or tort,
// including negligence, or under any other theory of
// liability) for any loss or damage of any kind or nature
// related to, arising under or in connection with these
// materials, including for any direct, or any indirect,
// special, incidental, or consequential loss or damage
// (including loss of data, profits, goodwill, or any type of
// loss or damage suffered as a result of any action brought
// by a third party) even if such damage or loss was
// reasonably foreseeable or Xilinx had been advised of the
// possibility of the same.
// 
// CRITICAL APPLICATIONS
// Xilinx products are not designed or intended to be fail-
// safe, or for use in any application requiring fail-safe
// performance, such as life-support or safety devices or
// systems, Class III medical devices, nuclear facilities,
// applications related to the deployment of airbags, or any
// other applications that could lead to death, personal
// injury, or severe property or environmental damage
// (individually and collectively, "Critical
// Applications"). Customer assumes the sole risk and
// liability of any use of Xilinx products in Critical
// Applications, subject only to applicable laws and
// regulations governing limitations on product liability.
// 
// THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
// PART OF THIS FILE AT ALL TIMES.
// 
// DO NOT MODIFY THIS FILE.


// IP VLNV: xilinx.com:module_ref:StreamingFIFO_rtl_9:1.0
// IP Revision: 1

(* X_CORE_INFO = "StreamingFIFO_rtl_9,Vivado 2022.2" *)
(* CHECK_LICENSE_TYPE = "finn_design_StreamingFIFO_rtl_9_0,StreamingFIFO_rtl_9,{}" *)
(* CORE_GENERATION_INFO = "finn_design_StreamingFIFO_rtl_9_0,StreamingFIFO_rtl_9,{x_ipProduct=Vivado 2022.2,x_ipVendor=xilinx.com,x_ipLibrary=module_ref,x_ipName=StreamingFIFO_rtl_9,x_ipVersion=1.0,x_ipCoreRevision=1,x_ipLanguage=VERILOG,x_ipSimLanguage=MIXED}" *)
(* IP_DEFINITION_SOURCE = "module_ref" *)
(* DowngradeIPIdentifiedWarnings = "yes" *)
module finn_design_StreamingFIFO_rtl_9_0 (
  ap_clk,
  ap_rst_n,
  count,
  maxcount,
  in0_V_TREADY,
  in0_V_TVALID,
  in0_V_TDATA,
  out_V_TREADY,
  out_V_TVALID,
  out_V_TDATA
);

(* X_INTERFACE_PARAMETER = "XIL_INTERFACENAME ap_clk, ASSOCIATED_RESET ap_rst_n, ASSOCIATED_BUSIF in0_V:out_V, FREQ_HZ 100000000, FREQ_TOLERANCE_HZ 0, PHASE 0.0, CLK_DOMAIN finn_design_ap_clk_0, INSERT_VIP 0" *)
(* X_INTERFACE_INFO = "xilinx.com:signal:clock:1.0 ap_clk CLK" *)
input wire ap_clk;
(* X_INTERFACE_PARAMETER = "XIL_INTERFACENAME ap_rst_n, POLARITY ACTIVE_LOW, INSERT_VIP 0" *)
(* X_INTERFACE_INFO = "xilinx.com:signal:reset:1.0 ap_rst_n RST" *)
input wire ap_rst_n;
output wire [14 : 0] count;
output wire [14 : 0] maxcount;
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 in0_V TREADY" *)
output wire in0_V_TREADY;
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 in0_V TVALID" *)
input wire in0_V_TVALID;
(* X_INTERFACE_PARAMETER = "XIL_INTERFACENAME in0_V, TDATA_NUM_BYTES 1, TDEST_WIDTH 0, TID_WIDTH 0, TUSER_WIDTH 0, HAS_TREADY 1, HAS_TSTRB 0, HAS_TKEEP 0, HAS_TLAST 0, FREQ_HZ 100000000, PHASE 0.0, CLK_DOMAIN finn_design_ap_clk_0, LAYERED_METADATA undef, INSERT_VIP 0" *)
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 in0_V TDATA" *)
input wire [7 : 0] in0_V_TDATA;
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 out_V TREADY" *)
input wire out_V_TREADY;
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 out_V TVALID" *)
output wire out_V_TVALID;
(* X_INTERFACE_PARAMETER = "XIL_INTERFACENAME out_V, TDATA_NUM_BYTES 1, TDEST_WIDTH 0, TID_WIDTH 0, TUSER_WIDTH 0, HAS_TREADY 1, HAS_TSTRB 0, HAS_TKEEP 0, HAS_TLAST 0, FREQ_HZ 100000000, PHASE 0.0, CLK_DOMAIN finn_design_ap_clk_0, LAYERED_METADATA undef, INSERT_VIP 0" *)
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 out_V TDATA" *)
output wire [7 : 0] out_V_TDATA;

  StreamingFIFO_rtl_9 inst (
    .ap_clk(ap_clk),
    .ap_rst_n(ap_rst_n),
    .count(count),
    .maxcount(maxcount),
    .in0_V_TREADY(in0_V_TREADY),
    .in0_V_TVALID(in0_V_TVALID),
    .in0_V_TDATA(in0_V_TDATA),
    .out_V_TREADY(out_V_TREADY),
    .out_V_TVALID(out_V_TVALID),
    .out_V_TDATA(out_V_TDATA)
  );
endmodule
//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/vivado_stitch_proj_w5fn6zuu/finn_vivado_stitch_proj.gen/sources_1/bd/finn_design/ipshared/18e4/hdl/verilog/MVAU_hls_0_hls_deadlock_idx0_monitor.v


`timescale 1 ns / 1 ps

module MVAU_hls_0_hls_deadlock_idx0_monitor ( // for module MVAU_hls_0_MVAU_hls_0_inst
    input wire clock,
    input wire reset,
    input wire [2:0] axis_block_sigs,
    input wire [1:0] inst_idle_sigs,
    input wire [0:0] inst_block_sigs,
    output wire block
);

// signal declare
reg monitor_find_block;
wire idx1_block;
wire sub_parallel_block;
wire all_sub_parallel_has_block;
wire all_sub_single_has_block;
wire cur_axis_has_block;
wire seq_is_axis_block;

assign block = monitor_find_block;
assign all_sub_parallel_has_block = 1'b0;
assign all_sub_single_has_block = 1'b0 | (idx1_block & (axis_block_sigs[0] | axis_block_sigs[1] | axis_block_sigs[2]));
assign cur_axis_has_block = 1'b0;
assign seq_is_axis_block = all_sub_parallel_has_block | all_sub_single_has_block | cur_axis_has_block;

always @(posedge clock) begin
    if (reset == 1'b1)
        monitor_find_block <= 1'b0;
    else if (seq_is_axis_block == 1'b1)
        monitor_find_block <= 1'b1;
    else
        monitor_find_block <= 1'b0;
end


// instant sub module
 MVAU_hls_0_hls_deadlock_idx1_monitor MVAU_hls_0_hls_deadlock_idx1_monitor_U (
    .clock(clock),
    .reset(reset),
    .axis_block_sigs(axis_block_sigs),
    .inst_idle_sigs(inst_idle_sigs),
    .inst_block_sigs(inst_block_sigs),
    .block(idx1_block)
);

endmodule
//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/code_gen_ipgen_FMPadding_rtl_1_bx8daa0b/FMPadding_rtl_1.v


/******************************************************************************
 * Copyright (C) 2022, Advanced Micro Devices, Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *  1. Redistributions of source code must retain the above copyright notice,
 *     this list of conditions and the following disclaimer.
 *
 *  2. Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *
 *  3. Neither the name of the copyright holder nor the names of its
 *     contributors may be used to endorse or promote products derived from
 *     this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION). HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *****************************************************************************/

module FMPadding_rtl_1(
//- Global Control ------------------
(* X_INTERFACE_PARAMETER = "ASSOCIATED_BUSIF in0_V:out_V:s_axilite, ASSOCIATED_RESET = ap_rst_n" *)
(* X_INTERFACE_INFO = "xilinx.com:signal:clock:1.0 ap_clk CLK" *)
input   ap_clk,
(* X_INTERFACE_PARAMETER = "POLARITY ACTIVE_LOW" *)
input   ap_rst_n,

//- AXI Lite ------------------------
// Writing
input	       s_axilite_AWVALID,
output	       s_axilite_AWREADY,
input	[4:0]  s_axilite_AWADDR,

input	        s_axilite_WVALID,
output	        s_axilite_WREADY,
input	[31:0]  s_axilite_WDATA,
input	[ 3:0]  s_axilite_WSTRB,

output	       s_axilite_BVALID,
input	       s_axilite_BREADY,
output	[1:0]  s_axilite_BRESP,

// Reading
input	       s_axilite_ARVALID,
output	       s_axilite_ARREADY,
input	[4:0]  s_axilite_ARADDR,

output	        s_axilite_RVALID,
input	        s_axilite_RREADY,
output	[31:0]  s_axilite_RDATA,
output	[ 1:0]  s_axilite_RRESP,

//- AXI Stream - Input --------------
output	in0_V_TREADY,
input	in0_V_TVALID,
input	[64-1:0]  in0_V_TDATA,

//- AXI Stream - Output -------------
input	out_V_TREADY,
output	out_V_TVALID,
output	[64-1:0]  out_V_TDATA
);


fmpadding_axi #(
.XCOUNTER_BITS(5),
.YCOUNTER_BITS(5),
.NUM_CHANNELS(16),
.SIMD(16),
.ELEM_BITS(4),
.INIT_XON(1),
.INIT_XOFF(15),
.INIT_XEND(15),
.INIT_YON(1),
.INIT_YOFF(15),
.INIT_YEND(15)
)
impl
(
 .ap_clk(ap_clk),
 .ap_rst_n(ap_rst_n),
 .s_axilite_AWVALID(s_axilite_AWVALID),
 .s_axilite_AWREADY(s_axilite_AWREADY),
 .s_axilite_AWADDR(s_axilite_AWADDR),
 .s_axilite_WVALID(s_axilite_WVALID),
 .s_axilite_WREADY(s_axilite_WREADY),
 .s_axilite_WDATA(s_axilite_WDATA),
 .s_axilite_WSTRB(s_axilite_WSTRB),
 .s_axilite_BVALID(s_axilite_BVALID),
 .s_axilite_BREADY(s_axilite_BREADY),
 .s_axilite_BRESP(s_axilite_BRESP),
 .s_axilite_ARVALID(s_axilite_ARVALID),
 .s_axilite_ARREADY(s_axilite_ARREADY),
 .s_axilite_ARADDR(s_axilite_ARADDR),
 .s_axilite_RVALID(s_axilite_RVALID),
 .s_axilite_RREADY(s_axilite_RREADY),
 .s_axilite_RDATA(s_axilite_RDATA),
 .s_axilite_RRESP(s_axilite_RRESP),
 .s_axis_tready(in0_V_TREADY),
 .s_axis_tvalid(in0_V_TVALID),
 .s_axis_tdata(in0_V_TDATA),
 .m_axis_tready(out_V_TREADY),
 .m_axis_tvalid(out_V_TVALID),
 .m_axis_tdata(out_V_TDATA)
);

endmodule
//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/code_gen_ipgen_StreamingFIFO_rtl_0_08tq8umn/StreamingFIFO_rtl_0.v


/******************************************************************************
 * Copyright (C) 2024, Advanced Micro Devices, Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *  1. Redistributions of source code must retain the above copyright notice,
 *     this list of conditions and the following disclaimer.
 *
 *  2. Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *
 *  3. Neither the name of the copyright holder nor the names of its
 *     contributors may be used to endorse or promote products derived from
 *     this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION). HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *****************************************************************************/

module StreamingFIFO_rtl_0(
//- Global Control ------------------
(* X_INTERFACE_PARAMETER = "ASSOCIATED_BUSIF in0_V:out_V, ASSOCIATED_RESET = ap_rst_n" *)
(* X_INTERFACE_INFO = "xilinx.com:signal:clock:1.0 ap_clk CLK" *)
input   ap_clk,
(* X_INTERFACE_PARAMETER = "POLARITY ACTIVE_LOW" *)
input   ap_rst_n,

output [9:0] count,
output [9:0] maxcount,

//- AXI Stream - Input --------------
output   in0_V_TREADY,
input   in0_V_TVALID,
input  [23:0] in0_V_TDATA,

//- AXI Stream - Output --------------
input   out_V_TREADY,
output   out_V_TVALID,
output  [23:0] out_V_TDATA
);

Q_srl #(
.depth(784),
.width(24)
)
impl
(
 .clock(ap_clk),
 .reset(!ap_rst_n),
 .count(count),
 .maxcount(maxcount),
 .i_d(in0_V_TDATA),
 .i_v(in0_V_TVALID),
 .i_r(in0_V_TREADY),
 .o_d(out_V_TDATA),
 .o_v(out_V_TVALID),
 .o_r(out_V_TREADY)
);

endmodule
//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/vivado_stitch_proj_w5fn6zuu/finn_vivado_stitch_proj.gen/sources_1/bd/finn_design/ipshared/18e4/hdl/verilog/MVAU_hls_0_Matrix_Vector_Activate_Stream_Batch_p_ZL7threshs_10_ROM_AUTO_1R.v


// ==============================================================
// Vitis HLS - High-Level Synthesis from C, C++ and OpenCL v2022.2 (64-bit)
// Version: 2022.2
// Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.
// ==============================================================
`timescale 1 ns / 1 ps
module MVAU_hls_0_Matrix_Vector_Activate_Stream_Batch_p_ZL7threshs_10_ROM_AUTO_1R (
    address0, ce0, q0, 
    reset, clk);

parameter DataWidth = 12;
parameter AddressWidth = 4;
parameter AddressRange = 16;
 
input[AddressWidth-1:0] address0;
input ce0;
output reg[DataWidth-1:0] q0;

input reset;
input clk;

 
reg [DataWidth-1:0] rom0[0:AddressRange-1];


initial begin
     
    $readmemh("/home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/code_gen_ipgen_MVAU_hls_0_z2r2fzak/project_MVAU_hls_0/sol1/impl/ip/hdl/verilog/MVAU_hls_0_Matrix_Vector_Activate_Stream_Batch_p_ZL7threshs_10_ROM_AUTO_1R.dat", rom0);
end

  
always @(posedge clk) 
begin 
    if (ce0) 
    begin
        q0 <= rom0[address0];
    end
end


endmodule

//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/code_gen_ipgen_StreamingFIFO_rtl_10_7b54d5mo/StreamingFIFO_rtl_10.v


/******************************************************************************
 * Copyright (C) 2024, Advanced Micro Devices, Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *  1. Redistributions of source code must retain the above copyright notice,
 *     this list of conditions and the following disclaimer.
 *
 *  2. Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *
 *  3. Neither the name of the copyright holder nor the names of its
 *     contributors may be used to endorse or promote products derived from
 *     this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION). HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *****************************************************************************/

module StreamingFIFO_rtl_10(
//- Global Control ------------------
(* X_INTERFACE_PARAMETER = "ASSOCIATED_BUSIF in0_V:out_V, ASSOCIATED_RESET = ap_rst_n" *)
(* X_INTERFACE_INFO = "xilinx.com:signal:clock:1.0 ap_clk CLK" *)
input   ap_clk,
(* X_INTERFACE_PARAMETER = "POLARITY ACTIVE_LOW" *)
input   ap_rst_n,

output [12:0] count,
output [12:0] maxcount,

//- AXI Stream - Input --------------
output   in0_V_TREADY,
input   in0_V_TVALID,
input  [7:0] in0_V_TDATA,

//- AXI Stream - Output --------------
input   out_V_TREADY,
output   out_V_TVALID,
output  [7:0] out_V_TDATA
);

Q_srl #(
.depth(6272),
.width(8)
)
impl
(
 .clock(ap_clk),
 .reset(!ap_rst_n),
 .count(count),
 .maxcount(maxcount),
 .i_d(in0_V_TDATA),
 .i_v(in0_V_TVALID),
 .i_r(in0_V_TREADY),
 .o_d(out_V_TDATA),
 .o_v(out_V_TVALID),
 .o_r(out_V_TREADY)
);

endmodule
//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/vivado_stitch_proj_w5fn6zuu/finn_vivado_stitch_proj.gen/sources_1/bd/finn_design/hdl/finn_design_wrapper.v


//Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.
//--------------------------------------------------------------------------------
//Tool Version: Vivado v.2022.2 (lin64) Build 3671981 Fri Oct 14 04:59:54 MDT 2022
//Date        : Fri Feb 20 14:44:24 2026
//Host        : 33e619815b19 running 64-bit Ubuntu 22.04.1 LTS
//Command     : generate_target finn_design_wrapper.bd
//Design      : finn_design_wrapper
//Purpose     : IP block netlist
//--------------------------------------------------------------------------------
`timescale 1 ps / 1 ps

module finn_design_wrapper
   (ap_clk,
    ap_rst_n,
    m_axis_0_tdata,
    m_axis_0_tready,
    m_axis_0_tvalid,
    maxcount,
    maxcount_1,
    maxcount_10,
    maxcount_11,
    maxcount_12,
    maxcount_13,
    maxcount_14,
    maxcount_2,
    maxcount_3,
    maxcount_4,
    maxcount_5,
    maxcount_6,
    maxcount_7,
    maxcount_8,
    maxcount_9,
    s_axis_0_tdata,
    s_axis_0_tready,
    s_axis_0_tvalid);
  input ap_clk;
  input ap_rst_n;
  output [23:0]m_axis_0_tdata;
  input m_axis_0_tready;
  output m_axis_0_tvalid;
  output [9:0]maxcount;
  output [9:0]maxcount_1;
  output [12:0]maxcount_10;
  output [7:0]maxcount_11;
  output [5:0]maxcount_12;
  output [10:0]maxcount_13;
  output [3:0]maxcount_14;
  output [11:0]maxcount_2;
  output [14:0]maxcount_3;
  output [13:0]maxcount_4;
  output [9:0]maxcount_5;
  output [7:0]maxcount_6;
  output [8:0]maxcount_7;
  output [12:0]maxcount_8;
  output [14:0]maxcount_9;
  input [23:0]s_axis_0_tdata;
  output s_axis_0_tready;
  input s_axis_0_tvalid;

  wire ap_clk;
  wire ap_rst_n;
  wire [23:0]m_axis_0_tdata;
  wire m_axis_0_tready;
  wire m_axis_0_tvalid;
  wire [9:0]maxcount;
  wire [9:0]maxcount_1;
  wire [12:0]maxcount_10;
  wire [7:0]maxcount_11;
  wire [5:0]maxcount_12;
  wire [10:0]maxcount_13;
  wire [3:0]maxcount_14;
  wire [11:0]maxcount_2;
  wire [14:0]maxcount_3;
  wire [13:0]maxcount_4;
  wire [9:0]maxcount_5;
  wire [7:0]maxcount_6;
  wire [8:0]maxcount_7;
  wire [12:0]maxcount_8;
  wire [14:0]maxcount_9;
  wire [23:0]s_axis_0_tdata;
  wire s_axis_0_tready;
  wire s_axis_0_tvalid;

  finn_design finn_design_i
       (.ap_clk(ap_clk),
        .ap_rst_n(ap_rst_n),
        .m_axis_0_tdata(m_axis_0_tdata),
        .m_axis_0_tready(m_axis_0_tready),
        .m_axis_0_tvalid(m_axis_0_tvalid),
        .maxcount(maxcount),
        .maxcount_1(maxcount_1),
        .maxcount_10(maxcount_10),
        .maxcount_11(maxcount_11),
        .maxcount_12(maxcount_12),
        .maxcount_13(maxcount_13),
        .maxcount_14(maxcount_14),
        .maxcount_2(maxcount_2),
        .maxcount_3(maxcount_3),
        .maxcount_4(maxcount_4),
        .maxcount_5(maxcount_5),
        .maxcount_6(maxcount_6),
        .maxcount_7(maxcount_7),
        .maxcount_8(maxcount_8),
        .maxcount_9(maxcount_9),
        .s_axis_0_tdata(s_axis_0_tdata),
        .s_axis_0_tready(s_axis_0_tready),
        .s_axis_0_tvalid(s_axis_0_tvalid));
endmodule
//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/vivado_stitch_proj_w5fn6zuu/finn_vivado_stitch_proj.gen/sources_1/bd/finn_design/ipshared/18e4/hdl/verilog/MVAU_hls_0_Matrix_Vector_Activate_Stream_Batch_p_ZL7threshs_5_ROM_AUTO_1R.v


// ==============================================================
// Vitis HLS - High-Level Synthesis from C, C++ and OpenCL v2022.2 (64-bit)
// Version: 2022.2
// Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.
// ==============================================================
`timescale 1 ns / 1 ps
module MVAU_hls_0_Matrix_Vector_Activate_Stream_Batch_p_ZL7threshs_5_ROM_AUTO_1R (
    address0, ce0, q0, 
    reset, clk);

parameter DataWidth = 13;
parameter AddressWidth = 4;
parameter AddressRange = 16;
 
input[AddressWidth-1:0] address0;
input ce0;
output reg[DataWidth-1:0] q0;

input reset;
input clk;

 
reg [DataWidth-1:0] rom0[0:AddressRange-1];


initial begin
     
    $readmemh("/home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/code_gen_ipgen_MVAU_hls_0_z2r2fzak/project_MVAU_hls_0/sol1/impl/ip/hdl/verilog/MVAU_hls_0_Matrix_Vector_Activate_Stream_Batch_p_ZL7threshs_5_ROM_AUTO_1R.dat", rom0);
end

  
always @(posedge clk) 
begin 
    if (ce0) 
    begin
        q0 <= rom0[address0];
    end
end


endmodule

//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/vivado_stitch_proj_w5fn6zuu/finn_vivado_stitch_proj.gen/sources_1/bd/finn_design/ipshared/6bf6/hdl/verilog/StreamingMaxPool_hls_0_StreamingMaxPool_Precision_28u_2u_16u_ap_uint_4_0_64_s_buf_V_RAM_AUTO_1R1W.v


// ==============================================================
// Vitis HLS - High-Level Synthesis from C, C++ and OpenCL v2022.2 (64-bit)
// Version: 2022.2
// Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.
// ==============================================================
`timescale 1 ns / 1 ps
module StreamingMaxPool_hls_0_StreamingMaxPool_Precision_28u_2u_16u_ap_uint_4_0_64_s_buf_V_RAM_AUTO_1R1W (
     
    address0, ce0,
    d0, we0, 
    q0, 
     
    reset, clk);

parameter DataWidth = 4;
parameter AddressWidth = 4;
parameter AddressRange = 14;
 
input[AddressWidth-1:0] address0;
input ce0;
input[DataWidth-1:0] d0;
input we0; 
output reg[DataWidth-1:0] q0; 

input reset;
input clk;

(* ram_style = "auto"  *)reg [DataWidth-1:0] ram[0:AddressRange-1];


 





//read first
always @(posedge clk)  
begin 
    if (ce0) begin
        if (we0) 
            ram[address0] <= d0; 
        q0 <= ram[address0];

    end
end 
 
 

endmodule

//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/vivado_stitch_proj_w5fn6zuu/finn_vivado_stitch_proj.gen/sources_1/bd/finn_design/ip/finn_design_StreamingDataWidthConverter_rtl_1_0/synth/finn_design_StreamingDataWidthConverter_rtl_1_0.v


// (c) Copyright 1995-2026 Xilinx, Inc. All rights reserved.
// 
// This file contains confidential and proprietary information
// of Xilinx, Inc. and is protected under U.S. and
// international copyright and other intellectual property
// laws.
// 
// DISCLAIMER
// This disclaimer is not a license and does not grant any
// rights to the materials distributed herewith. Except as
// otherwise provided in a valid license issued to you by
// Xilinx, and to the maximum extent permitted by applicable
// law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
// WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
// AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
// BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
// INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
// (2) Xilinx shall not be liable (whether in contract or tort,
// including negligence, or under any other theory of
// liability) for any loss or damage of any kind or nature
// related to, arising under or in connection with these
// materials, including for any direct, or any indirect,
// special, incidental, or consequential loss or damage
// (including loss of data, profits, goodwill, or any type of
// loss or damage suffered as a result of any action brought
// by a third party) even if such damage or loss was
// reasonably foreseeable or Xilinx had been advised of the
// possibility of the same.
// 
// CRITICAL APPLICATIONS
// Xilinx products are not designed or intended to be fail-
// safe, or for use in any application requiring fail-safe
// performance, such as life-support or safety devices or
// systems, Class III medical devices, nuclear facilities,
// applications related to the deployment of airbags, or any
// other applications that could lead to death, personal
// injury, or severe property or environmental damage
// (individually and collectively, "Critical
// Applications"). Customer assumes the sole risk and
// liability of any use of Xilinx products in Critical
// Applications, subject only to applicable laws and
// regulations governing limitations on product liability.
// 
// THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
// PART OF THIS FILE AT ALL TIMES.
// 
// DO NOT MODIFY THIS FILE.


// IP VLNV: xilinx.com:module_ref:StreamingDataWidthConverter_rtl_1:1.0
// IP Revision: 1

(* X_CORE_INFO = "StreamingDataWidthConverter_rtl_1,Vivado 2022.2" *)
(* CHECK_LICENSE_TYPE = "finn_design_StreamingDataWidthConverter_rtl_1_0,StreamingDataWidthConverter_rtl_1,{}" *)
(* CORE_GENERATION_INFO = "finn_design_StreamingDataWidthConverter_rtl_1_0,StreamingDataWidthConverter_rtl_1,{x_ipProduct=Vivado 2022.2,x_ipVendor=xilinx.com,x_ipLibrary=module_ref,x_ipName=StreamingDataWidthConverter_rtl_1,x_ipVersion=1.0,x_ipCoreRevision=1,x_ipLanguage=VERILOG,x_ipSimLanguage=MIXED,IBITS=4,OBITS=64,AXI_IBITS=8,AXI_OBITS=64}" *)
(* IP_DEFINITION_SOURCE = "module_ref" *)
(* DowngradeIPIdentifiedWarnings = "yes" *)
module finn_design_StreamingDataWidthConverter_rtl_1_0 (
  ap_clk,
  ap_rst_n,
  in0_V_TREADY,
  in0_V_TVALID,
  in0_V_TDATA,
  out_V_TREADY,
  out_V_TVALID,
  out_V_TDATA
);

(* X_INTERFACE_PARAMETER = "XIL_INTERFACENAME ap_clk, ASSOCIATED_RESET ap_rst_n, ASSOCIATED_BUSIF in0_V:out_V, FREQ_HZ 100000000, FREQ_TOLERANCE_HZ 0, PHASE 0.0, CLK_DOMAIN finn_design_ap_clk_0, INSERT_VIP 0" *)
(* X_INTERFACE_INFO = "xilinx.com:signal:clock:1.0 ap_clk CLK" *)
input wire ap_clk;
(* X_INTERFACE_PARAMETER = "XIL_INTERFACENAME ap_rst_n, POLARITY ACTIVE_LOW, INSERT_VIP 0" *)
(* X_INTERFACE_INFO = "xilinx.com:signal:reset:1.0 ap_rst_n RST" *)
input wire ap_rst_n;
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 in0_V TREADY" *)
output wire in0_V_TREADY;
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 in0_V TVALID" *)
input wire in0_V_TVALID;
(* X_INTERFACE_PARAMETER = "XIL_INTERFACENAME in0_V, TDATA_NUM_BYTES 1, TDEST_WIDTH 0, TID_WIDTH 0, TUSER_WIDTH 0, HAS_TREADY 1, HAS_TSTRB 0, HAS_TKEEP 0, HAS_TLAST 0, FREQ_HZ 100000000, PHASE 0.0, CLK_DOMAIN finn_design_ap_clk_0, LAYERED_METADATA undef, INSERT_VIP 0" *)
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 in0_V TDATA" *)
input wire [7 : 0] in0_V_TDATA;
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 out_V TREADY" *)
input wire out_V_TREADY;
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 out_V TVALID" *)
output wire out_V_TVALID;
(* X_INTERFACE_PARAMETER = "XIL_INTERFACENAME out_V, TDATA_NUM_BYTES 8, TDEST_WIDTH 0, TID_WIDTH 0, TUSER_WIDTH 0, HAS_TREADY 1, HAS_TSTRB 0, HAS_TKEEP 0, HAS_TLAST 0, FREQ_HZ 100000000, PHASE 0.0, CLK_DOMAIN finn_design_ap_clk_0, LAYERED_METADATA undef, INSERT_VIP 0" *)
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 out_V TDATA" *)
output wire [63 : 0] out_V_TDATA;

  StreamingDataWidthConverter_rtl_1 #(
    .IBITS(4),
    .OBITS(64),
    .AXI_IBITS(8),
    .AXI_OBITS(64)
  ) inst (
    .ap_clk(ap_clk),
    .ap_rst_n(ap_rst_n),
    .in0_V_TREADY(in0_V_TREADY),
    .in0_V_TVALID(in0_V_TVALID),
    .in0_V_TDATA(in0_V_TDATA),
    .out_V_TREADY(out_V_TREADY),
    .out_V_TVALID(out_V_TVALID),
    .out_V_TDATA(out_V_TDATA)
  );
endmodule
//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/vivado_stitch_proj_w5fn6zuu/finn_vivado_stitch_proj.gen/sources_1/bd/finn_design/ip/finn_design_StreamingDataWidthConverter_rtl_4_0/synth/finn_design_StreamingDataWidthConverter_rtl_4_0.v


// (c) Copyright 1995-2026 Xilinx, Inc. All rights reserved.
// 
// This file contains confidential and proprietary information
// of Xilinx, Inc. and is protected under U.S. and
// international copyright and other intellectual property
// laws.
// 
// DISCLAIMER
// This disclaimer is not a license and does not grant any
// rights to the materials distributed herewith. Except as
// otherwise provided in a valid license issued to you by
// Xilinx, and to the maximum extent permitted by applicable
// law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
// WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
// AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
// BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
// INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
// (2) Xilinx shall not be liable (whether in contract or tort,
// including negligence, or under any other theory of
// liability) for any loss or damage of any kind or nature
// related to, arising under or in connection with these
// materials, including for any direct, or any indirect,
// special, incidental, or consequential loss or damage
// (including loss of data, profits, goodwill, or any type of
// loss or damage suffered as a result of any action brought
// by a third party) even if such damage or loss was
// reasonably foreseeable or Xilinx had been advised of the
// possibility of the same.
// 
// CRITICAL APPLICATIONS
// Xilinx products are not designed or intended to be fail-
// safe, or for use in any application requiring fail-safe
// performance, such as life-support or safety devices or
// systems, Class III medical devices, nuclear facilities,
// applications related to the deployment of airbags, or any
// other applications that could lead to death, personal
// injury, or severe property or environmental damage
// (individually and collectively, "Critical
// Applications"). Customer assumes the sole risk and
// liability of any use of Xilinx products in Critical
// Applications, subject only to applicable laws and
// regulations governing limitations on product liability.
// 
// THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
// PART OF THIS FILE AT ALL TIMES.
// 
// DO NOT MODIFY THIS FILE.


// IP VLNV: xilinx.com:module_ref:StreamingDataWidthConverter_rtl_4:1.0
// IP Revision: 1

(* X_CORE_INFO = "StreamingDataWidthConverter_rtl_4,Vivado 2022.2" *)
(* CHECK_LICENSE_TYPE = "finn_design_StreamingDataWidthConverter_rtl_4_0,StreamingDataWidthConverter_rtl_4,{}" *)
(* CORE_GENERATION_INFO = "finn_design_StreamingDataWidthConverter_rtl_4_0,StreamingDataWidthConverter_rtl_4,{x_ipProduct=Vivado 2022.2,x_ipVendor=xilinx.com,x_ipLibrary=module_ref,x_ipName=StreamingDataWidthConverter_rtl_4,x_ipVersion=1.0,x_ipCoreRevision=1,x_ipLanguage=VERILOG,x_ipSimLanguage=MIXED,IBITS=128,OBITS=4,AXI_IBITS=128,AXI_OBITS=8}" *)
(* IP_DEFINITION_SOURCE = "module_ref" *)
(* DowngradeIPIdentifiedWarnings = "yes" *)
module finn_design_StreamingDataWidthConverter_rtl_4_0 (
  ap_clk,
  ap_rst_n,
  in0_V_TREADY,
  in0_V_TVALID,
  in0_V_TDATA,
  out_V_TREADY,
  out_V_TVALID,
  out_V_TDATA
);

(* X_INTERFACE_PARAMETER = "XIL_INTERFACENAME ap_clk, ASSOCIATED_RESET ap_rst_n, ASSOCIATED_BUSIF in0_V:out_V, FREQ_HZ 100000000, FREQ_TOLERANCE_HZ 0, PHASE 0.0, CLK_DOMAIN finn_design_ap_clk_0, INSERT_VIP 0" *)
(* X_INTERFACE_INFO = "xilinx.com:signal:clock:1.0 ap_clk CLK" *)
input wire ap_clk;
(* X_INTERFACE_PARAMETER = "XIL_INTERFACENAME ap_rst_n, POLARITY ACTIVE_LOW, INSERT_VIP 0" *)
(* X_INTERFACE_INFO = "xilinx.com:signal:reset:1.0 ap_rst_n RST" *)
input wire ap_rst_n;
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 in0_V TREADY" *)
output wire in0_V_TREADY;
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 in0_V TVALID" *)
input wire in0_V_TVALID;
(* X_INTERFACE_PARAMETER = "XIL_INTERFACENAME in0_V, TDATA_NUM_BYTES 16, TDEST_WIDTH 0, TID_WIDTH 0, TUSER_WIDTH 0, HAS_TREADY 1, HAS_TSTRB 0, HAS_TKEEP 0, HAS_TLAST 0, FREQ_HZ 100000000, PHASE 0.0, CLK_DOMAIN finn_design_ap_clk_0, LAYERED_METADATA undef, INSERT_VIP 0" *)
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 in0_V TDATA" *)
input wire [127 : 0] in0_V_TDATA;
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 out_V TREADY" *)
input wire out_V_TREADY;
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 out_V TVALID" *)
output wire out_V_TVALID;
(* X_INTERFACE_PARAMETER = "XIL_INTERFACENAME out_V, TDATA_NUM_BYTES 1, TDEST_WIDTH 0, TID_WIDTH 0, TUSER_WIDTH 0, HAS_TREADY 1, HAS_TSTRB 0, HAS_TKEEP 0, HAS_TLAST 0, FREQ_HZ 100000000, PHASE 0.0, CLK_DOMAIN finn_design_ap_clk_0, LAYERED_METADATA undef, INSERT_VIP 0" *)
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 out_V TDATA" *)
output wire [7 : 0] out_V_TDATA;

  StreamingDataWidthConverter_rtl_4 #(
    .IBITS(128),
    .OBITS(4),
    .AXI_IBITS(128),
    .AXI_OBITS(8)
  ) inst (
    .ap_clk(ap_clk),
    .ap_rst_n(ap_rst_n),
    .in0_V_TREADY(in0_V_TREADY),
    .in0_V_TVALID(in0_V_TVALID),
    .in0_V_TDATA(in0_V_TDATA),
    .out_V_TREADY(out_V_TREADY),
    .out_V_TVALID(out_V_TVALID),
    .out_V_TDATA(out_V_TDATA)
  );
endmodule
//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/vivado_stitch_proj_w5fn6zuu/finn_vivado_stitch_proj.gen/sources_1/bd/finn_design/ipshared/4d6a/hdl/verilog/StreamingMaxPool_hls_1_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1.v


// ==============================================================
// RTL generated by Vitis HLS - High-Level Synthesis from C, C++ and OpenCL v2022.2 (64-bit)
// Version: 2022.2
// Copyright (C) Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.
// 
// ===========================================================

`timescale 1 ns / 1 ps 

module StreamingMaxPool_hls_1_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1 (
        ap_clk,
        ap_rst,
        ap_start,
        ap_done,
        ap_idle,
        ap_ready,
        buf_V_address0,
        buf_V_ce0,
        buf_V_we0,
        buf_V_d0,
        buf_V_1_address0,
        buf_V_1_ce0,
        buf_V_1_we0,
        buf_V_1_d0,
        buf_V_2_address0,
        buf_V_2_ce0,
        buf_V_2_we0,
        buf_V_2_d0,
        buf_V_3_address0,
        buf_V_3_ce0,
        buf_V_3_we0,
        buf_V_3_d0,
        buf_V_4_address0,
        buf_V_4_ce0,
        buf_V_4_we0,
        buf_V_4_d0,
        buf_V_5_address0,
        buf_V_5_ce0,
        buf_V_5_we0,
        buf_V_5_d0,
        buf_V_6_address0,
        buf_V_6_ce0,
        buf_V_6_we0,
        buf_V_6_d0,
        buf_V_7_address0,
        buf_V_7_ce0,
        buf_V_7_we0,
        buf_V_7_d0,
        buf_V_8_address0,
        buf_V_8_ce0,
        buf_V_8_we0,
        buf_V_8_d0,
        buf_V_9_address0,
        buf_V_9_ce0,
        buf_V_9_we0,
        buf_V_9_d0,
        buf_V_10_address0,
        buf_V_10_ce0,
        buf_V_10_we0,
        buf_V_10_d0,
        buf_V_11_address0,
        buf_V_11_ce0,
        buf_V_11_we0,
        buf_V_11_d0,
        buf_V_12_address0,
        buf_V_12_ce0,
        buf_V_12_we0,
        buf_V_12_d0,
        buf_V_13_address0,
        buf_V_13_ce0,
        buf_V_13_we0,
        buf_V_13_d0,
        buf_V_14_address0,
        buf_V_14_ce0,
        buf_V_14_we0,
        buf_V_14_d0,
        buf_V_15_address0,
        buf_V_15_ce0,
        buf_V_15_we0,
        buf_V_15_d0,
        buf_V_16_address0,
        buf_V_16_ce0,
        buf_V_16_we0,
        buf_V_16_d0,
        buf_V_17_address0,
        buf_V_17_ce0,
        buf_V_17_we0,
        buf_V_17_d0,
        buf_V_18_address0,
        buf_V_18_ce0,
        buf_V_18_we0,
        buf_V_18_d0,
        buf_V_19_address0,
        buf_V_19_ce0,
        buf_V_19_we0,
        buf_V_19_d0,
        buf_V_20_address0,
        buf_V_20_ce0,
        buf_V_20_we0,
        buf_V_20_d0,
        buf_V_21_address0,
        buf_V_21_ce0,
        buf_V_21_we0,
        buf_V_21_d0,
        buf_V_22_address0,
        buf_V_22_ce0,
        buf_V_22_we0,
        buf_V_22_d0,
        buf_V_23_address0,
        buf_V_23_ce0,
        buf_V_23_we0,
        buf_V_23_d0,
        buf_V_24_address0,
        buf_V_24_ce0,
        buf_V_24_we0,
        buf_V_24_d0,
        buf_V_25_address0,
        buf_V_25_ce0,
        buf_V_25_we0,
        buf_V_25_d0,
        buf_V_26_address0,
        buf_V_26_ce0,
        buf_V_26_we0,
        buf_V_26_d0,
        buf_V_27_address0,
        buf_V_27_ce0,
        buf_V_27_we0,
        buf_V_27_d0,
        buf_V_28_address0,
        buf_V_28_ce0,
        buf_V_28_we0,
        buf_V_28_d0,
        buf_V_29_address0,
        buf_V_29_ce0,
        buf_V_29_we0,
        buf_V_29_d0,
        buf_V_30_address0,
        buf_V_30_ce0,
        buf_V_30_we0,
        buf_V_30_d0,
        buf_V_31_address0,
        buf_V_31_ce0,
        buf_V_31_we0,
        buf_V_31_d0
);

parameter    ap_ST_fsm_state1 = 1'd1;

input   ap_clk;
input   ap_rst;
input   ap_start;
output   ap_done;
output   ap_idle;
output   ap_ready;
output  [2:0] buf_V_address0;
output   buf_V_ce0;
output   buf_V_we0;
output  [3:0] buf_V_d0;
output  [2:0] buf_V_1_address0;
output   buf_V_1_ce0;
output   buf_V_1_we0;
output  [3:0] buf_V_1_d0;
output  [2:0] buf_V_2_address0;
output   buf_V_2_ce0;
output   buf_V_2_we0;
output  [3:0] buf_V_2_d0;
output  [2:0] buf_V_3_address0;
output   buf_V_3_ce0;
output   buf_V_3_we0;
output  [3:0] buf_V_3_d0;
output  [2:0] buf_V_4_address0;
output   buf_V_4_ce0;
output   buf_V_4_we0;
output  [3:0] buf_V_4_d0;
output  [2:0] buf_V_5_address0;
output   buf_V_5_ce0;
output   buf_V_5_we0;
output  [3:0] buf_V_5_d0;
output  [2:0] buf_V_6_address0;
output   buf_V_6_ce0;
output   buf_V_6_we0;
output  [3:0] buf_V_6_d0;
output  [2:0] buf_V_7_address0;
output   buf_V_7_ce0;
output   buf_V_7_we0;
output  [3:0] buf_V_7_d0;
output  [2:0] buf_V_8_address0;
output   buf_V_8_ce0;
output   buf_V_8_we0;
output  [3:0] buf_V_8_d0;
output  [2:0] buf_V_9_address0;
output   buf_V_9_ce0;
output   buf_V_9_we0;
output  [3:0] buf_V_9_d0;
output  [2:0] buf_V_10_address0;
output   buf_V_10_ce0;
output   buf_V_10_we0;
output  [3:0] buf_V_10_d0;
output  [2:0] buf_V_11_address0;
output   buf_V_11_ce0;
output   buf_V_11_we0;
output  [3:0] buf_V_11_d0;
output  [2:0] buf_V_12_address0;
output   buf_V_12_ce0;
output   buf_V_12_we0;
output  [3:0] buf_V_12_d0;
output  [2:0] buf_V_13_address0;
output   buf_V_13_ce0;
output   buf_V_13_we0;
output  [3:0] buf_V_13_d0;
output  [2:0] buf_V_14_address0;
output   buf_V_14_ce0;
output   buf_V_14_we0;
output  [3:0] buf_V_14_d0;
output  [2:0] buf_V_15_address0;
output   buf_V_15_ce0;
output   buf_V_15_we0;
output  [3:0] buf_V_15_d0;
output  [2:0] buf_V_16_address0;
output   buf_V_16_ce0;
output   buf_V_16_we0;
output  [3:0] buf_V_16_d0;
output  [2:0] buf_V_17_address0;
output   buf_V_17_ce0;
output   buf_V_17_we0;
output  [3:0] buf_V_17_d0;
output  [2:0] buf_V_18_address0;
output   buf_V_18_ce0;
output   buf_V_18_we0;
output  [3:0] buf_V_18_d0;
output  [2:0] buf_V_19_address0;
output   buf_V_19_ce0;
output   buf_V_19_we0;
output  [3:0] buf_V_19_d0;
output  [2:0] buf_V_20_address0;
output   buf_V_20_ce0;
output   buf_V_20_we0;
output  [3:0] buf_V_20_d0;
output  [2:0] buf_V_21_address0;
output   buf_V_21_ce0;
output   buf_V_21_we0;
output  [3:0] buf_V_21_d0;
output  [2:0] buf_V_22_address0;
output   buf_V_22_ce0;
output   buf_V_22_we0;
output  [3:0] buf_V_22_d0;
output  [2:0] buf_V_23_address0;
output   buf_V_23_ce0;
output   buf_V_23_we0;
output  [3:0] buf_V_23_d0;
output  [2:0] buf_V_24_address0;
output   buf_V_24_ce0;
output   buf_V_24_we0;
output  [3:0] buf_V_24_d0;
output  [2:0] buf_V_25_address0;
output   buf_V_25_ce0;
output   buf_V_25_we0;
output  [3:0] buf_V_25_d0;
output  [2:0] buf_V_26_address0;
output   buf_V_26_ce0;
output   buf_V_26_we0;
output  [3:0] buf_V_26_d0;
output  [2:0] buf_V_27_address0;
output   buf_V_27_ce0;
output   buf_V_27_we0;
output  [3:0] buf_V_27_d0;
output  [2:0] buf_V_28_address0;
output   buf_V_28_ce0;
output   buf_V_28_we0;
output  [3:0] buf_V_28_d0;
output  [2:0] buf_V_29_address0;
output   buf_V_29_ce0;
output   buf_V_29_we0;
output  [3:0] buf_V_29_d0;
output  [2:0] buf_V_30_address0;
output   buf_V_30_ce0;
output   buf_V_30_we0;
output  [3:0] buf_V_30_d0;
output  [2:0] buf_V_31_address0;
output   buf_V_31_ce0;
output   buf_V_31_we0;
output  [3:0] buf_V_31_d0;

reg ap_idle;
reg buf_V_ce0;
reg buf_V_we0;
reg buf_V_1_ce0;
reg buf_V_1_we0;
reg buf_V_2_ce0;
reg buf_V_2_we0;
reg buf_V_3_ce0;
reg buf_V_3_we0;
reg buf_V_4_ce0;
reg buf_V_4_we0;
reg buf_V_5_ce0;
reg buf_V_5_we0;
reg buf_V_6_ce0;
reg buf_V_6_we0;
reg buf_V_7_ce0;
reg buf_V_7_we0;
reg buf_V_8_ce0;
reg buf_V_8_we0;
reg buf_V_9_ce0;
reg buf_V_9_we0;
reg buf_V_10_ce0;
reg buf_V_10_we0;
reg buf_V_11_ce0;
reg buf_V_11_we0;
reg buf_V_12_ce0;
reg buf_V_12_we0;
reg buf_V_13_ce0;
reg buf_V_13_we0;
reg buf_V_14_ce0;
reg buf_V_14_we0;
reg buf_V_15_ce0;
reg buf_V_15_we0;
reg buf_V_16_ce0;
reg buf_V_16_we0;
reg buf_V_17_ce0;
reg buf_V_17_we0;
reg buf_V_18_ce0;
reg buf_V_18_we0;
reg buf_V_19_ce0;
reg buf_V_19_we0;
reg buf_V_20_ce0;
reg buf_V_20_we0;
reg buf_V_21_ce0;
reg buf_V_21_we0;
reg buf_V_22_ce0;
reg buf_V_22_we0;
reg buf_V_23_ce0;
reg buf_V_23_we0;
reg buf_V_24_ce0;
reg buf_V_24_we0;
reg buf_V_25_ce0;
reg buf_V_25_we0;
reg buf_V_26_ce0;
reg buf_V_26_we0;
reg buf_V_27_ce0;
reg buf_V_27_we0;
reg buf_V_28_ce0;
reg buf_V_28_we0;
reg buf_V_29_ce0;
reg buf_V_29_we0;
reg buf_V_30_ce0;
reg buf_V_30_we0;
reg buf_V_31_ce0;
reg buf_V_31_we0;

(* fsm_encoding = "none" *) reg   [0:0] ap_CS_fsm;
wire    ap_CS_fsm_state1;
reg    ap_block_state1_pp0_stage0_iter0;
wire   [0:0] icmp_ln147_fu_552_p2;
reg    ap_condition_exit_pp0_iter0_stage0;
wire    ap_loop_exit_ready;
reg    ap_ready_int;
wire   [63:0] i_cast_fu_564_p1;
reg   [2:0] i_fu_92;
wire   [2:0] add_ln147_fu_558_p2;
wire    ap_loop_init;
reg   [2:0] ap_sig_allocacmp_i_1;
reg    ap_done_reg;
wire    ap_continue_int;
reg    ap_done_int;
reg   [0:0] ap_NS_fsm;
reg    ap_ST_fsm_state1_blk;
wire    ap_start_int;
wire    ap_ce_reg;

// power-on initialization
initial begin
#0 ap_CS_fsm = 1'd1;
#0 ap_done_reg = 1'b0;
end

StreamingMaxPool_hls_1_flow_control_loop_pipe_sequential_init flow_control_loop_pipe_sequential_init_U(
    .ap_clk(ap_clk),
    .ap_rst(ap_rst),
    .ap_start(ap_start),
    .ap_ready(ap_ready),
    .ap_done(ap_done),
    .ap_start_int(ap_start_int),
    .ap_loop_init(ap_loop_init),
    .ap_ready_int(ap_ready_int),
    .ap_loop_exit_ready(ap_condition_exit_pp0_iter0_stage0),
    .ap_loop_exit_done(ap_done_int),
    .ap_continue_int(ap_continue_int),
    .ap_done_int(ap_done_int)
);

always @ (posedge ap_clk) begin
    if (ap_rst == 1'b1) begin
        ap_CS_fsm <= ap_ST_fsm_state1;
    end else begin
        ap_CS_fsm <= ap_NS_fsm;
    end
end

always @ (posedge ap_clk) begin
    if (ap_rst == 1'b1) begin
        ap_done_reg <= 1'b0;
    end else begin
        if ((ap_continue_int == 1'b1)) begin
            ap_done_reg <= 1'b0;
        end else if (((ap_start_int == 1'b1) & (ap_loop_exit_ready == 1'b1) & (1'b1 == ap_CS_fsm_state1))) begin
            ap_done_reg <= 1'b1;
        end
    end
end

always @ (posedge ap_clk) begin
    if (((ap_start_int == 1'b1) & (1'b1 == ap_CS_fsm_state1))) begin
        if ((icmp_ln147_fu_552_p2 == 1'd0)) begin
            i_fu_92 <= add_ln147_fu_558_p2;
        end else if ((ap_loop_init == 1'b1)) begin
            i_fu_92 <= 3'd0;
        end
    end
end

always @ (*) begin
    if ((ap_start_int == 1'b0)) begin
        ap_ST_fsm_state1_blk = 1'b1;
    end else begin
        ap_ST_fsm_state1_blk = 1'b0;
    end
end

always @ (*) begin
    if (((ap_start_int == 1'b1) & (icmp_ln147_fu_552_p2 == 1'd1) & (1'b1 == ap_CS_fsm_state1))) begin
        ap_condition_exit_pp0_iter0_stage0 = 1'b1;
    end else begin
        ap_condition_exit_pp0_iter0_stage0 = 1'b0;
    end
end

always @ (*) begin
    if (((ap_start_int == 1'b1) & (ap_loop_exit_ready == 1'b1) & (1'b1 == ap_CS_fsm_state1))) begin
        ap_done_int = 1'b1;
    end else begin
        ap_done_int = ap_done_reg;
    end
end

always @ (*) begin
    if (((ap_start_int == 1'b0) & (1'b1 == ap_CS_fsm_state1))) begin
        ap_idle = 1'b1;
    end else begin
        ap_idle = 1'b0;
    end
end

always @ (*) begin
    if (((ap_start_int == 1'b1) & (1'b1 == ap_CS_fsm_state1))) begin
        ap_ready_int = 1'b1;
    end else begin
        ap_ready_int = 1'b0;
    end
end

always @ (*) begin
    if (((ap_loop_init == 1'b1) & (1'b1 == ap_CS_fsm_state1))) begin
        ap_sig_allocacmp_i_1 = 3'd0;
    end else begin
        ap_sig_allocacmp_i_1 = i_fu_92;
    end
end

always @ (*) begin
    if (((ap_start_int == 1'b1) & (1'b1 == ap_CS_fsm_state1))) begin
        buf_V_10_ce0 = 1'b1;
    end else begin
        buf_V_10_ce0 = 1'b0;
    end
end

always @ (*) begin
    if (((ap_start_int == 1'b1) & (icmp_ln147_fu_552_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state1))) begin
        buf_V_10_we0 = 1'b1;
    end else begin
        buf_V_10_we0 = 1'b0;
    end
end

always @ (*) begin
    if (((ap_start_int == 1'b1) & (1'b1 == ap_CS_fsm_state1))) begin
        buf_V_11_ce0 = 1'b1;
    end else begin
        buf_V_11_ce0 = 1'b0;
    end
end

always @ (*) begin
    if (((ap_start_int == 1'b1) & (icmp_ln147_fu_552_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state1))) begin
        buf_V_11_we0 = 1'b1;
    end else begin
        buf_V_11_we0 = 1'b0;
    end
end

always @ (*) begin
    if (((ap_start_int == 1'b1) & (1'b1 == ap_CS_fsm_state1))) begin
        buf_V_12_ce0 = 1'b1;
    end else begin
        buf_V_12_ce0 = 1'b0;
    end
end

always @ (*) begin
    if (((ap_start_int == 1'b1) & (icmp_ln147_fu_552_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state1))) begin
        buf_V_12_we0 = 1'b1;
    end else begin
        buf_V_12_we0 = 1'b0;
    end
end

always @ (*) begin
    if (((ap_start_int == 1'b1) & (1'b1 == ap_CS_fsm_state1))) begin
        buf_V_13_ce0 = 1'b1;
    end else begin
        buf_V_13_ce0 = 1'b0;
    end
end

always @ (*) begin
    if (((ap_start_int == 1'b1) & (icmp_ln147_fu_552_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state1))) begin
        buf_V_13_we0 = 1'b1;
    end else begin
        buf_V_13_we0 = 1'b0;
    end
end

always @ (*) begin
    if (((ap_start_int == 1'b1) & (1'b1 == ap_CS_fsm_state1))) begin
        buf_V_14_ce0 = 1'b1;
    end else begin
        buf_V_14_ce0 = 1'b0;
    end
end

always @ (*) begin
    if (((ap_start_int == 1'b1) & (icmp_ln147_fu_552_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state1))) begin
        buf_V_14_we0 = 1'b1;
    end else begin
        buf_V_14_we0 = 1'b0;
    end
end

always @ (*) begin
    if (((ap_start_int == 1'b1) & (1'b1 == ap_CS_fsm_state1))) begin
        buf_V_15_ce0 = 1'b1;
    end else begin
        buf_V_15_ce0 = 1'b0;
    end
end

always @ (*) begin
    if (((ap_start_int == 1'b1) & (icmp_ln147_fu_552_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state1))) begin
        buf_V_15_we0 = 1'b1;
    end else begin
        buf_V_15_we0 = 1'b0;
    end
end

always @ (*) begin
    if (((ap_start_int == 1'b1) & (1'b1 == ap_CS_fsm_state1))) begin
        buf_V_16_ce0 = 1'b1;
    end else begin
        buf_V_16_ce0 = 1'b0;
    end
end

always @ (*) begin
    if (((ap_start_int == 1'b1) & (icmp_ln147_fu_552_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state1))) begin
        buf_V_16_we0 = 1'b1;
    end else begin
        buf_V_16_we0 = 1'b0;
    end
end

always @ (*) begin
    if (((ap_start_int == 1'b1) & (1'b1 == ap_CS_fsm_state1))) begin
        buf_V_17_ce0 = 1'b1;
    end else begin
        buf_V_17_ce0 = 1'b0;
    end
end

always @ (*) begin
    if (((ap_start_int == 1'b1) & (icmp_ln147_fu_552_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state1))) begin
        buf_V_17_we0 = 1'b1;
    end else begin
        buf_V_17_we0 = 1'b0;
    end
end

always @ (*) begin
    if (((ap_start_int == 1'b1) & (1'b1 == ap_CS_fsm_state1))) begin
        buf_V_18_ce0 = 1'b1;
    end else begin
        buf_V_18_ce0 = 1'b0;
    end
end

always @ (*) begin
    if (((ap_start_int == 1'b1) & (icmp_ln147_fu_552_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state1))) begin
        buf_V_18_we0 = 1'b1;
    end else begin
        buf_V_18_we0 = 1'b0;
    end
end

always @ (*) begin
    if (((ap_start_int == 1'b1) & (1'b1 == ap_CS_fsm_state1))) begin
        buf_V_19_ce0 = 1'b1;
    end else begin
        buf_V_19_ce0 = 1'b0;
    end
end

always @ (*) begin
    if (((ap_start_int == 1'b1) & (icmp_ln147_fu_552_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state1))) begin
        buf_V_19_we0 = 1'b1;
    end else begin
        buf_V_19_we0 = 1'b0;
    end
end

always @ (*) begin
    if (((ap_start_int == 1'b1) & (1'b1 == ap_CS_fsm_state1))) begin
        buf_V_1_ce0 = 1'b1;
    end else begin
        buf_V_1_ce0 = 1'b0;
    end
end

always @ (*) begin
    if (((ap_start_int == 1'b1) & (icmp_ln147_fu_552_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state1))) begin
        buf_V_1_we0 = 1'b1;
    end else begin
        buf_V_1_we0 = 1'b0;
    end
end

always @ (*) begin
    if (((ap_start_int == 1'b1) & (1'b1 == ap_CS_fsm_state1))) begin
        buf_V_20_ce0 = 1'b1;
    end else begin
        buf_V_20_ce0 = 1'b0;
    end
end

always @ (*) begin
    if (((ap_start_int == 1'b1) & (icmp_ln147_fu_552_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state1))) begin
        buf_V_20_we0 = 1'b1;
    end else begin
        buf_V_20_we0 = 1'b0;
    end
end

always @ (*) begin
    if (((ap_start_int == 1'b1) & (1'b1 == ap_CS_fsm_state1))) begin
        buf_V_21_ce0 = 1'b1;
    end else begin
        buf_V_21_ce0 = 1'b0;
    end
end

always @ (*) begin
    if (((ap_start_int == 1'b1) & (icmp_ln147_fu_552_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state1))) begin
        buf_V_21_we0 = 1'b1;
    end else begin
        buf_V_21_we0 = 1'b0;
    end
end

always @ (*) begin
    if (((ap_start_int == 1'b1) & (1'b1 == ap_CS_fsm_state1))) begin
        buf_V_22_ce0 = 1'b1;
    end else begin
        buf_V_22_ce0 = 1'b0;
    end
end

always @ (*) begin
    if (((ap_start_int == 1'b1) & (icmp_ln147_fu_552_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state1))) begin
        buf_V_22_we0 = 1'b1;
    end else begin
        buf_V_22_we0 = 1'b0;
    end
end

always @ (*) begin
    if (((ap_start_int == 1'b1) & (1'b1 == ap_CS_fsm_state1))) begin
        buf_V_23_ce0 = 1'b1;
    end else begin
        buf_V_23_ce0 = 1'b0;
    end
end

always @ (*) begin
    if (((ap_start_int == 1'b1) & (icmp_ln147_fu_552_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state1))) begin
        buf_V_23_we0 = 1'b1;
    end else begin
        buf_V_23_we0 = 1'b0;
    end
end

always @ (*) begin
    if (((ap_start_int == 1'b1) & (1'b1 == ap_CS_fsm_state1))) begin
        buf_V_24_ce0 = 1'b1;
    end else begin
        buf_V_24_ce0 = 1'b0;
    end
end

always @ (*) begin
    if (((ap_start_int == 1'b1) & (icmp_ln147_fu_552_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state1))) begin
        buf_V_24_we0 = 1'b1;
    end else begin
        buf_V_24_we0 = 1'b0;
    end
end

always @ (*) begin
    if (((ap_start_int == 1'b1) & (1'b1 == ap_CS_fsm_state1))) begin
        buf_V_25_ce0 = 1'b1;
    end else begin
        buf_V_25_ce0 = 1'b0;
    end
end

always @ (*) begin
    if (((ap_start_int == 1'b1) & (icmp_ln147_fu_552_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state1))) begin
        buf_V_25_we0 = 1'b1;
    end else begin
        buf_V_25_we0 = 1'b0;
    end
end

always @ (*) begin
    if (((ap_start_int == 1'b1) & (1'b1 == ap_CS_fsm_state1))) begin
        buf_V_26_ce0 = 1'b1;
    end else begin
        buf_V_26_ce0 = 1'b0;
    end
end

always @ (*) begin
    if (((ap_start_int == 1'b1) & (icmp_ln147_fu_552_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state1))) begin
        buf_V_26_we0 = 1'b1;
    end else begin
        buf_V_26_we0 = 1'b0;
    end
end

always @ (*) begin
    if (((ap_start_int == 1'b1) & (1'b1 == ap_CS_fsm_state1))) begin
        buf_V_27_ce0 = 1'b1;
    end else begin
        buf_V_27_ce0 = 1'b0;
    end
end

always @ (*) begin
    if (((ap_start_int == 1'b1) & (icmp_ln147_fu_552_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state1))) begin
        buf_V_27_we0 = 1'b1;
    end else begin
        buf_V_27_we0 = 1'b0;
    end
end

always @ (*) begin
    if (((ap_start_int == 1'b1) & (1'b1 == ap_CS_fsm_state1))) begin
        buf_V_28_ce0 = 1'b1;
    end else begin
        buf_V_28_ce0 = 1'b0;
    end
end

always @ (*) begin
    if (((ap_start_int == 1'b1) & (icmp_ln147_fu_552_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state1))) begin
        buf_V_28_we0 = 1'b1;
    end else begin
        buf_V_28_we0 = 1'b0;
    end
end

always @ (*) begin
    if (((ap_start_int == 1'b1) & (1'b1 == ap_CS_fsm_state1))) begin
        buf_V_29_ce0 = 1'b1;
    end else begin
        buf_V_29_ce0 = 1'b0;
    end
end

always @ (*) begin
    if (((ap_start_int == 1'b1) & (icmp_ln147_fu_552_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state1))) begin
        buf_V_29_we0 = 1'b1;
    end else begin
        buf_V_29_we0 = 1'b0;
    end
end

always @ (*) begin
    if (((ap_start_int == 1'b1) & (1'b1 == ap_CS_fsm_state1))) begin
        buf_V_2_ce0 = 1'b1;
    end else begin
        buf_V_2_ce0 = 1'b0;
    end
end

always @ (*) begin
    if (((ap_start_int == 1'b1) & (icmp_ln147_fu_552_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state1))) begin
        buf_V_2_we0 = 1'b1;
    end else begin
        buf_V_2_we0 = 1'b0;
    end
end

always @ (*) begin
    if (((ap_start_int == 1'b1) & (1'b1 == ap_CS_fsm_state1))) begin
        buf_V_30_ce0 = 1'b1;
    end else begin
        buf_V_30_ce0 = 1'b0;
    end
end

always @ (*) begin
    if (((ap_start_int == 1'b1) & (icmp_ln147_fu_552_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state1))) begin
        buf_V_30_we0 = 1'b1;
    end else begin
        buf_V_30_we0 = 1'b0;
    end
end

always @ (*) begin
    if (((ap_start_int == 1'b1) & (1'b1 == ap_CS_fsm_state1))) begin
        buf_V_31_ce0 = 1'b1;
    end else begin
        buf_V_31_ce0 = 1'b0;
    end
end

always @ (*) begin
    if (((ap_start_int == 1'b1) & (icmp_ln147_fu_552_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state1))) begin
        buf_V_31_we0 = 1'b1;
    end else begin
        buf_V_31_we0 = 1'b0;
    end
end

always @ (*) begin
    if (((ap_start_int == 1'b1) & (1'b1 == ap_CS_fsm_state1))) begin
        buf_V_3_ce0 = 1'b1;
    end else begin
        buf_V_3_ce0 = 1'b0;
    end
end

always @ (*) begin
    if (((ap_start_int == 1'b1) & (icmp_ln147_fu_552_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state1))) begin
        buf_V_3_we0 = 1'b1;
    end else begin
        buf_V_3_we0 = 1'b0;
    end
end

always @ (*) begin
    if (((ap_start_int == 1'b1) & (1'b1 == ap_CS_fsm_state1))) begin
        buf_V_4_ce0 = 1'b1;
    end else begin
        buf_V_4_ce0 = 1'b0;
    end
end

always @ (*) begin
    if (((ap_start_int == 1'b1) & (icmp_ln147_fu_552_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state1))) begin
        buf_V_4_we0 = 1'b1;
    end else begin
        buf_V_4_we0 = 1'b0;
    end
end

always @ (*) begin
    if (((ap_start_int == 1'b1) & (1'b1 == ap_CS_fsm_state1))) begin
        buf_V_5_ce0 = 1'b1;
    end else begin
        buf_V_5_ce0 = 1'b0;
    end
end

always @ (*) begin
    if (((ap_start_int == 1'b1) & (icmp_ln147_fu_552_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state1))) begin
        buf_V_5_we0 = 1'b1;
    end else begin
        buf_V_5_we0 = 1'b0;
    end
end

always @ (*) begin
    if (((ap_start_int == 1'b1) & (1'b1 == ap_CS_fsm_state1))) begin
        buf_V_6_ce0 = 1'b1;
    end else begin
        buf_V_6_ce0 = 1'b0;
    end
end

always @ (*) begin
    if (((ap_start_int == 1'b1) & (icmp_ln147_fu_552_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state1))) begin
        buf_V_6_we0 = 1'b1;
    end else begin
        buf_V_6_we0 = 1'b0;
    end
end

always @ (*) begin
    if (((ap_start_int == 1'b1) & (1'b1 == ap_CS_fsm_state1))) begin
        buf_V_7_ce0 = 1'b1;
    end else begin
        buf_V_7_ce0 = 1'b0;
    end
end

always @ (*) begin
    if (((ap_start_int == 1'b1) & (icmp_ln147_fu_552_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state1))) begin
        buf_V_7_we0 = 1'b1;
    end else begin
        buf_V_7_we0 = 1'b0;
    end
end

always @ (*) begin
    if (((ap_start_int == 1'b1) & (1'b1 == ap_CS_fsm_state1))) begin
        buf_V_8_ce0 = 1'b1;
    end else begin
        buf_V_8_ce0 = 1'b0;
    end
end

always @ (*) begin
    if (((ap_start_int == 1'b1) & (icmp_ln147_fu_552_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state1))) begin
        buf_V_8_we0 = 1'b1;
    end else begin
        buf_V_8_we0 = 1'b0;
    end
end

always @ (*) begin
    if (((ap_start_int == 1'b1) & (1'b1 == ap_CS_fsm_state1))) begin
        buf_V_9_ce0 = 1'b1;
    end else begin
        buf_V_9_ce0 = 1'b0;
    end
end

always @ (*) begin
    if (((ap_start_int == 1'b1) & (icmp_ln147_fu_552_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state1))) begin
        buf_V_9_we0 = 1'b1;
    end else begin
        buf_V_9_we0 = 1'b0;
    end
end

always @ (*) begin
    if (((ap_start_int == 1'b1) & (1'b1 == ap_CS_fsm_state1))) begin
        buf_V_ce0 = 1'b1;
    end else begin
        buf_V_ce0 = 1'b0;
    end
end

always @ (*) begin
    if (((ap_start_int == 1'b1) & (icmp_ln147_fu_552_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state1))) begin
        buf_V_we0 = 1'b1;
    end else begin
        buf_V_we0 = 1'b0;
    end
end

always @ (*) begin
    case (ap_CS_fsm)
        ap_ST_fsm_state1 : begin
            ap_NS_fsm = ap_ST_fsm_state1;
        end
        default : begin
            ap_NS_fsm = 'bx;
        end
    endcase
end

assign add_ln147_fu_558_p2 = (ap_sig_allocacmp_i_1 + 3'd1);

assign ap_CS_fsm_state1 = ap_CS_fsm[32'd0];

always @ (*) begin
    ap_block_state1_pp0_stage0_iter0 = (ap_start_int == 1'b0);
end

assign ap_loop_exit_ready = ap_condition_exit_pp0_iter0_stage0;

assign buf_V_10_address0 = i_cast_fu_564_p1;

assign buf_V_10_d0 = 4'd0;

assign buf_V_11_address0 = i_cast_fu_564_p1;

assign buf_V_11_d0 = 4'd0;

assign buf_V_12_address0 = i_cast_fu_564_p1;

assign buf_V_12_d0 = 4'd0;

assign buf_V_13_address0 = i_cast_fu_564_p1;

assign buf_V_13_d0 = 4'd0;

assign buf_V_14_address0 = i_cast_fu_564_p1;

assign buf_V_14_d0 = 4'd0;

assign buf_V_15_address0 = i_cast_fu_564_p1;

assign buf_V_15_d0 = 4'd0;

assign buf_V_16_address0 = i_cast_fu_564_p1;

assign buf_V_16_d0 = 4'd0;

assign buf_V_17_address0 = i_cast_fu_564_p1;

assign buf_V_17_d0 = 4'd0;

assign buf_V_18_address0 = i_cast_fu_564_p1;

assign buf_V_18_d0 = 4'd0;

assign buf_V_19_address0 = i_cast_fu_564_p1;

assign buf_V_19_d0 = 4'd0;

assign buf_V_1_address0 = i_cast_fu_564_p1;

assign buf_V_1_d0 = 4'd0;

assign buf_V_20_address0 = i_cast_fu_564_p1;

assign buf_V_20_d0 = 4'd0;

assign buf_V_21_address0 = i_cast_fu_564_p1;

assign buf_V_21_d0 = 4'd0;

assign buf_V_22_address0 = i_cast_fu_564_p1;

assign buf_V_22_d0 = 4'd0;

assign buf_V_23_address0 = i_cast_fu_564_p1;

assign buf_V_23_d0 = 4'd0;

assign buf_V_24_address0 = i_cast_fu_564_p1;

assign buf_V_24_d0 = 4'd0;

assign buf_V_25_address0 = i_cast_fu_564_p1;

assign buf_V_25_d0 = 4'd0;

assign buf_V_26_address0 = i_cast_fu_564_p1;

assign buf_V_26_d0 = 4'd0;

assign buf_V_27_address0 = i_cast_fu_564_p1;

assign buf_V_27_d0 = 4'd0;

assign buf_V_28_address0 = i_cast_fu_564_p1;

assign buf_V_28_d0 = 4'd0;

assign buf_V_29_address0 = i_cast_fu_564_p1;

assign buf_V_29_d0 = 4'd0;

assign buf_V_2_address0 = i_cast_fu_564_p1;

assign buf_V_2_d0 = 4'd0;

assign buf_V_30_address0 = i_cast_fu_564_p1;

assign buf_V_30_d0 = 4'd0;

assign buf_V_31_address0 = i_cast_fu_564_p1;

assign buf_V_31_d0 = 4'd0;

assign buf_V_3_address0 = i_cast_fu_564_p1;

assign buf_V_3_d0 = 4'd0;

assign buf_V_4_address0 = i_cast_fu_564_p1;

assign buf_V_4_d0 = 4'd0;

assign buf_V_5_address0 = i_cast_fu_564_p1;

assign buf_V_5_d0 = 4'd0;

assign buf_V_6_address0 = i_cast_fu_564_p1;

assign buf_V_6_d0 = 4'd0;

assign buf_V_7_address0 = i_cast_fu_564_p1;

assign buf_V_7_d0 = 4'd0;

assign buf_V_8_address0 = i_cast_fu_564_p1;

assign buf_V_8_d0 = 4'd0;

assign buf_V_9_address0 = i_cast_fu_564_p1;

assign buf_V_9_d0 = 4'd0;

assign buf_V_address0 = i_cast_fu_564_p1;

assign buf_V_d0 = 4'd0;

assign i_cast_fu_564_p1 = ap_sig_allocacmp_i_1;

assign icmp_ln147_fu_552_p2 = ((ap_sig_allocacmp_i_1 == 3'd7) ? 1'b1 : 1'b0);

endmodule //StreamingMaxPool_hls_1_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1
//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/vivado_stitch_proj_w5fn6zuu/finn_vivado_stitch_proj.gen/sources_1/bd/finn_design/ipshared/fb57/hdl/verilog/MVAU_hls_1_Matrix_Vector_Activate_Stream_Batch_p_ZL7threshs_4_ROM_AUTO_1R.v


// ==============================================================
// Vitis HLS - High-Level Synthesis from C, C++ and OpenCL v2022.2 (64-bit)
// Version: 2022.2
// Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.
// ==============================================================
`timescale 1 ns / 1 ps
module MVAU_hls_1_Matrix_Vector_Activate_Stream_Batch_p_ZL7threshs_4_ROM_AUTO_1R (
    address0, ce0, q0, 
    reset, clk);

parameter DataWidth = 10;
parameter AddressWidth = 5;
parameter AddressRange = 32;
 
input[AddressWidth-1:0] address0;
input ce0;
output reg[DataWidth-1:0] q0;

input reset;
input clk;

 
reg [DataWidth-1:0] rom0[0:AddressRange-1];


initial begin
     
    $readmemh("/home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/code_gen_ipgen_MVAU_hls_1__774deg0/project_MVAU_hls_1/sol1/impl/ip/hdl/verilog/MVAU_hls_1_Matrix_Vector_Activate_Stream_Batch_p_ZL7threshs_4_ROM_AUTO_1R.dat", rom0);
end

  
always @(posedge clk) 
begin 
    if (ce0) 
    begin
        q0 <= rom0[address0];
    end
end


endmodule

//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/vivado_stitch_proj_w5fn6zuu/finn_vivado_stitch_proj.gen/sources_1/bd/finn_design/synth/finn_design.v


//Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.
//--------------------------------------------------------------------------------
//Tool Version: Vivado v.2022.2 (lin64) Build 3671981 Fri Oct 14 04:59:54 MDT 2022
//Date        : Fri Feb 20 14:44:24 2026
//Host        : 33e619815b19 running 64-bit Ubuntu 22.04.1 LTS
//Command     : generate_target finn_design.bd
//Design      : finn_design
//Purpose     : IP block netlist
//--------------------------------------------------------------------------------
`timescale 1 ps / 1 ps

module MVAU_hls_0_imp_7OH4JA
   (ap_clk,
    ap_rst_n,
    in0_V_tdata,
    in0_V_tready,
    in0_V_tvalid,
    out_V_tdata,
    out_V_tready,
    out_V_tvalid);
  input ap_clk;
  input ap_rst_n;
  input [7:0]in0_V_tdata;
  output in0_V_tready;
  input in0_V_tvalid;
  output [7:0]out_V_tdata;
  input out_V_tready;
  output out_V_tvalid;

  wire [7:0]MVAU_hls_0_out_V_TDATA;
  wire MVAU_hls_0_out_V_TREADY;
  wire MVAU_hls_0_out_V_TVALID;
  wire [7:0]MVAU_hls_0_wstrm_m_axis_0_TDATA;
  wire MVAU_hls_0_wstrm_m_axis_0_TREADY;
  wire MVAU_hls_0_wstrm_m_axis_0_TVALID;
  wire ap_clk_1;
  wire ap_rst_n_1;
  wire [7:0]in0_V_1_TDATA;
  wire in0_V_1_TREADY;
  wire in0_V_1_TVALID;

  assign MVAU_hls_0_out_V_TREADY = out_V_tready;
  assign ap_clk_1 = ap_clk;
  assign ap_rst_n_1 = ap_rst_n;
  assign in0_V_1_TDATA = in0_V_tdata[7:0];
  assign in0_V_1_TVALID = in0_V_tvalid;
  assign in0_V_tready = in0_V_1_TREADY;
  assign out_V_tdata[7:0] = MVAU_hls_0_out_V_TDATA;
  assign out_V_tvalid = MVAU_hls_0_out_V_TVALID;
  finn_design_MVAU_hls_0_0 MVAU_hls_0
       (.ap_clk(ap_clk_1),
        .ap_rst_n(ap_rst_n_1),
        .in0_V_TDATA(in0_V_1_TDATA),
        .in0_V_TREADY(in0_V_1_TREADY),
        .in0_V_TVALID(in0_V_1_TVALID),
        .out_V_TDATA(MVAU_hls_0_out_V_TDATA),
        .out_V_TREADY(MVAU_hls_0_out_V_TREADY),
        .out_V_TVALID(MVAU_hls_0_out_V_TVALID),
        .weights_V_TDATA(MVAU_hls_0_wstrm_m_axis_0_TDATA),
        .weights_V_TREADY(MVAU_hls_0_wstrm_m_axis_0_TREADY),
        .weights_V_TVALID(MVAU_hls_0_wstrm_m_axis_0_TVALID));
  finn_design_MVAU_hls_0_wstrm_0 MVAU_hls_0_wstrm
       (.ap_clk(ap_clk_1),
        .ap_rst_n(ap_rst_n_1),
        .araddr({1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0}),
        .arprot({1'b0,1'b0,1'b0}),
        .arvalid(1'b0),
        .awaddr({1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0}),
        .awprot({1'b0,1'b0,1'b0}),
        .awvalid(1'b0),
        .bready(1'b0),
        .m_axis_0_tdata(MVAU_hls_0_wstrm_m_axis_0_TDATA),
        .m_axis_0_tready(MVAU_hls_0_wstrm_m_axis_0_TREADY),
        .m_axis_0_tvalid(MVAU_hls_0_wstrm_m_axis_0_TVALID),
        .rready(1'b0),
        .wdata({1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0}),
        .wstrb({1'b1,1'b1,1'b1,1'b1}),
        .wvalid(1'b0));
endmodule

module MVAU_hls_1_imp_ZIW0NT
   (ap_clk,
    ap_rst_n,
    in0_V_tdata,
    in0_V_tready,
    in0_V_tvalid,
    out_V_tdata,
    out_V_tready,
    out_V_tvalid);
  input ap_clk;
  input ap_rst_n;
  input [7:0]in0_V_tdata;
  output in0_V_tready;
  input in0_V_tvalid;
  output [7:0]out_V_tdata;
  input out_V_tready;
  output out_V_tvalid;

  wire [7:0]MVAU_hls_1_out_V_TDATA;
  wire MVAU_hls_1_out_V_TREADY;
  wire MVAU_hls_1_out_V_TVALID;
  wire [7:0]MVAU_hls_1_wstrm_m_axis_0_TDATA;
  wire MVAU_hls_1_wstrm_m_axis_0_TREADY;
  wire MVAU_hls_1_wstrm_m_axis_0_TVALID;
  wire ap_clk_1;
  wire ap_rst_n_1;
  wire [7:0]in0_V_1_TDATA;
  wire in0_V_1_TREADY;
  wire in0_V_1_TVALID;

  assign MVAU_hls_1_out_V_TREADY = out_V_tready;
  assign ap_clk_1 = ap_clk;
  assign ap_rst_n_1 = ap_rst_n;
  assign in0_V_1_TDATA = in0_V_tdata[7:0];
  assign in0_V_1_TVALID = in0_V_tvalid;
  assign in0_V_tready = in0_V_1_TREADY;
  assign out_V_tdata[7:0] = MVAU_hls_1_out_V_TDATA;
  assign out_V_tvalid = MVAU_hls_1_out_V_TVALID;
  finn_design_MVAU_hls_1_0 MVAU_hls_1
       (.ap_clk(ap_clk_1),
        .ap_rst_n(ap_rst_n_1),
        .in0_V_TDATA(in0_V_1_TDATA),
        .in0_V_TREADY(in0_V_1_TREADY),
        .in0_V_TVALID(in0_V_1_TVALID),
        .out_V_TDATA(MVAU_hls_1_out_V_TDATA),
        .out_V_TREADY(MVAU_hls_1_out_V_TREADY),
        .out_V_TVALID(MVAU_hls_1_out_V_TVALID),
        .weights_V_TDATA(MVAU_hls_1_wstrm_m_axis_0_TDATA),
        .weights_V_TREADY(MVAU_hls_1_wstrm_m_axis_0_TREADY),
        .weights_V_TVALID(MVAU_hls_1_wstrm_m_axis_0_TVALID));
  finn_design_MVAU_hls_1_wstrm_0 MVAU_hls_1_wstrm
       (.ap_clk(ap_clk_1),
        .ap_rst_n(ap_rst_n_1),
        .araddr({1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0}),
        .arprot({1'b0,1'b0,1'b0}),
        .arvalid(1'b0),
        .awaddr({1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0}),
        .awprot({1'b0,1'b0,1'b0}),
        .awvalid(1'b0),
        .bready(1'b0),
        .m_axis_0_tdata(MVAU_hls_1_wstrm_m_axis_0_TDATA),
        .m_axis_0_tready(MVAU_hls_1_wstrm_m_axis_0_TREADY),
        .m_axis_0_tvalid(MVAU_hls_1_wstrm_m_axis_0_TVALID),
        .rready(1'b0),
        .wdata({1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0}),
        .wstrb({1'b1,1'b1,1'b1,1'b1}),
        .wvalid(1'b0));
endmodule

module MVAU_rtl_0_imp_1DNJB9Y
   (ap_clk,
    ap_rst_n,
    in0_V_tdata,
    in0_V_tready,
    in0_V_tvalid,
    out_V_tdata,
    out_V_tready,
    out_V_tvalid);
  input ap_clk;
  input ap_rst_n;
  input [7:0]in0_V_tdata;
  output in0_V_tready;
  input in0_V_tvalid;
  output [23:0]out_V_tdata;
  input out_V_tready;
  output out_V_tvalid;

  wire [23:0]MVAU_rtl_0_out_V_TDATA;
  wire MVAU_rtl_0_out_V_TREADY;
  wire MVAU_rtl_0_out_V_TVALID;
  wire [7:0]MVAU_rtl_0_wstrm_m_axis_0_TDATA;
  wire MVAU_rtl_0_wstrm_m_axis_0_TREADY;
  wire MVAU_rtl_0_wstrm_m_axis_0_TVALID;
  wire ap_clk_1;
  wire ap_rst_n_1;
  wire [7:0]in0_V_1_TDATA;
  wire in0_V_1_TREADY;
  wire in0_V_1_TVALID;

  assign MVAU_rtl_0_out_V_TREADY = out_V_tready;
  assign ap_clk_1 = ap_clk;
  assign ap_rst_n_1 = ap_rst_n;
  assign in0_V_1_TDATA = in0_V_tdata[7:0];
  assign in0_V_1_TVALID = in0_V_tvalid;
  assign in0_V_tready = in0_V_1_TREADY;
  assign out_V_tdata[23:0] = MVAU_rtl_0_out_V_TDATA;
  assign out_V_tvalid = MVAU_rtl_0_out_V_TVALID;
  finn_design_MVAU_rtl_0_0 MVAU_rtl_0
       (.ap_clk(ap_clk_1),
        .ap_rst_n(ap_rst_n_1),
        .in0_V_TDATA(in0_V_1_TDATA),
        .in0_V_TREADY(in0_V_1_TREADY),
        .in0_V_TVALID(in0_V_1_TVALID),
        .out_V_TDATA(MVAU_rtl_0_out_V_TDATA),
        .out_V_TREADY(MVAU_rtl_0_out_V_TREADY),
        .out_V_TVALID(MVAU_rtl_0_out_V_TVALID),
        .weights_V_TDATA(MVAU_rtl_0_wstrm_m_axis_0_TDATA),
        .weights_V_TREADY(MVAU_rtl_0_wstrm_m_axis_0_TREADY),
        .weights_V_TVALID(MVAU_rtl_0_wstrm_m_axis_0_TVALID));
  finn_design_MVAU_rtl_0_wstrm_0 MVAU_rtl_0_wstrm
       (.ap_clk(ap_clk_1),
        .ap_rst_n(ap_rst_n_1),
        .araddr({1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0}),
        .arprot({1'b0,1'b0,1'b0}),
        .arvalid(1'b0),
        .awaddr({1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0}),
        .awprot({1'b0,1'b0,1'b0}),
        .awvalid(1'b0),
        .bready(1'b0),
        .m_axis_0_tdata(MVAU_rtl_0_wstrm_m_axis_0_TDATA),
        .m_axis_0_tready(MVAU_rtl_0_wstrm_m_axis_0_TREADY),
        .m_axis_0_tvalid(MVAU_rtl_0_wstrm_m_axis_0_TVALID),
        .rready(1'b0),
        .wdata({1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0}),
        .wstrb({1'b1,1'b1,1'b1,1'b1}),
        .wvalid(1'b0));
endmodule

(* CORE_GENERATION_INFO = "finn_design,IP_Integrator,{x_ipVendor=xilinx.com,x_ipLibrary=BlockDiagram,x_ipName=finn_design,x_ipVersion=1.00.a,x_ipLanguage=VERILOG,numBlks=35,numReposBlks=32,numNonXlnxBlks=3,numHierBlks=3,maxHierDepth=1,numSysgenBlks=0,numHlsBlks=4,numHdlrefBlks=25,numPkgbdBlks=0,bdsource=USER,synth_mode=OOC_per_IP}" *) (* HW_HANDOFF = "finn_design.hwdef" *) 
module finn_design
   (ap_clk,
    ap_rst_n,
    m_axis_0_tdata,
    m_axis_0_tready,
    m_axis_0_tvalid,
    maxcount,
    maxcount_1,
    maxcount_10,
    maxcount_11,
    maxcount_12,
    maxcount_13,
    maxcount_14,
    maxcount_2,
    maxcount_3,
    maxcount_4,
    maxcount_5,
    maxcount_6,
    maxcount_7,
    maxcount_8,
    maxcount_9,
    s_axis_0_tdata,
    s_axis_0_tready,
    s_axis_0_tvalid);
  (* X_INTERFACE_INFO = "xilinx.com:signal:clock:1.0 CLK.AP_CLK CLK" *) (* X_INTERFACE_PARAMETER = "XIL_INTERFACENAME CLK.AP_CLK, ASSOCIATED_BUSIF s_axis_0:m_axis_0, ASSOCIATED_RESET ap_rst_n, CLK_DOMAIN finn_design_ap_clk_0, FREQ_HZ 100000000, FREQ_TOLERANCE_HZ 0, INSERT_VIP 0, PHASE 0.0" *) input ap_clk;
  (* X_INTERFACE_INFO = "xilinx.com:signal:reset:1.0 RST.AP_RST_N RST" *) (* X_INTERFACE_PARAMETER = "XIL_INTERFACENAME RST.AP_RST_N, INSERT_VIP 0, POLARITY ACTIVE_LOW" *) input ap_rst_n;
  (* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 m_axis_0 " *) (* X_INTERFACE_PARAMETER = "XIL_INTERFACENAME m_axis_0, CLK_DOMAIN finn_design_ap_clk_0, FREQ_HZ 100000000, HAS_TKEEP 0, HAS_TLAST 0, HAS_TREADY 1, HAS_TSTRB 0, INSERT_VIP 0, LAYERED_METADATA undef, PHASE 0.0, TDATA_NUM_BYTES 3, TDEST_WIDTH 0, TID_WIDTH 0, TUSER_WIDTH 0" *) output [23:0]m_axis_0_tdata;
  (* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 m_axis_0 " *) input m_axis_0_tready;
  (* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 m_axis_0 " *) output m_axis_0_tvalid;
  output [9:0]maxcount;
  output [9:0]maxcount_1;
  output [12:0]maxcount_10;
  output [7:0]maxcount_11;
  output [5:0]maxcount_12;
  output [10:0]maxcount_13;
  output [3:0]maxcount_14;
  output [11:0]maxcount_2;
  output [14:0]maxcount_3;
  output [13:0]maxcount_4;
  output [9:0]maxcount_5;
  output [7:0]maxcount_6;
  output [8:0]maxcount_7;
  output [12:0]maxcount_8;
  output [14:0]maxcount_9;
  (* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 s_axis_0 " *) (* X_INTERFACE_PARAMETER = "XIL_INTERFACENAME s_axis_0, CLK_DOMAIN finn_design_ap_clk_0, FREQ_HZ 100000000, HAS_TKEEP 0, HAS_TLAST 0, HAS_TREADY 1, HAS_TSTRB 0, INSERT_VIP 0, LAYERED_METADATA undef, PHASE 0.0, TDATA_NUM_BYTES 3, TDEST_WIDTH 0, TID_WIDTH 0, TUSER_WIDTH 0" *) input [23:0]s_axis_0_tdata;
  (* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 s_axis_0 " *) output s_axis_0_tready;
  (* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 s_axis_0 " *) input s_axis_0_tvalid;

  wire [7:0]ConvolutionInputGenerator_rtl_0_out_V_TDATA;
  wire ConvolutionInputGenerator_rtl_0_out_V_TREADY;
  wire ConvolutionInputGenerator_rtl_0_out_V_TVALID;
  wire [7:0]ConvolutionInputGenerator_rtl_1_out_V_TDATA;
  wire ConvolutionInputGenerator_rtl_1_out_V_TREADY;
  wire ConvolutionInputGenerator_rtl_1_out_V_TVALID;
  wire [23:0]FMPadding_rtl_0_out_V_TDATA;
  wire FMPadding_rtl_0_out_V_TREADY;
  wire FMPadding_rtl_0_out_V_TVALID;
  wire [63:0]FMPadding_rtl_1_out_V_TDATA;
  wire FMPadding_rtl_1_out_V_TREADY;
  wire FMPadding_rtl_1_out_V_TVALID;
  wire [7:0]MVAU_hls_0_out_V_TDATA;
  wire MVAU_hls_0_out_V_TREADY;
  wire MVAU_hls_0_out_V_TVALID;
  wire [7:0]MVAU_hls_1_out_V_TDATA;
  wire MVAU_hls_1_out_V_TREADY;
  wire MVAU_hls_1_out_V_TVALID;
  wire [23:0]MVAU_rtl_0_out_V_TDATA;
  wire MVAU_rtl_0_out_V_TREADY;
  wire MVAU_rtl_0_out_V_TVALID;
  wire [7:0]StreamingDataWidthConverter_rtl_0_out_V_TDATA;
  wire StreamingDataWidthConverter_rtl_0_out_V_TREADY;
  wire StreamingDataWidthConverter_rtl_0_out_V_TVALID;
  wire [63:0]StreamingDataWidthConverter_rtl_1_out_V_TDATA;
  wire StreamingDataWidthConverter_rtl_1_out_V_TREADY;
  wire StreamingDataWidthConverter_rtl_1_out_V_TVALID;
  wire [7:0]StreamingDataWidthConverter_rtl_2_out_V_TDATA;
  wire StreamingDataWidthConverter_rtl_2_out_V_TREADY;
  wire StreamingDataWidthConverter_rtl_2_out_V_TVALID;
  wire [127:0]StreamingDataWidthConverter_rtl_3_out_V_TDATA;
  wire StreamingDataWidthConverter_rtl_3_out_V_TREADY;
  wire StreamingDataWidthConverter_rtl_3_out_V_TVALID;
  wire [7:0]StreamingDataWidthConverter_rtl_4_out_V_TDATA;
  wire StreamingDataWidthConverter_rtl_4_out_V_TREADY;
  wire StreamingDataWidthConverter_rtl_4_out_V_TVALID;
  wire [9:0]StreamingFIFO_rtl_0_maxcount;
  wire [23:0]StreamingFIFO_rtl_0_out_V_TDATA;
  wire StreamingFIFO_rtl_0_out_V_TREADY;
  wire StreamingFIFO_rtl_0_out_V_TVALID;
  wire [12:0]StreamingFIFO_rtl_10_maxcount;
  wire [7:0]StreamingFIFO_rtl_10_out_V_TDATA;
  wire StreamingFIFO_rtl_10_out_V_TREADY;
  wire StreamingFIFO_rtl_10_out_V_TVALID;
  wire [7:0]StreamingFIFO_rtl_11_maxcount;
  wire [127:0]StreamingFIFO_rtl_11_out_V_TDATA;
  wire StreamingFIFO_rtl_11_out_V_TREADY;
  wire StreamingFIFO_rtl_11_out_V_TVALID;
  wire [5:0]StreamingFIFO_rtl_12_maxcount;
  wire [127:0]StreamingFIFO_rtl_12_out_V_TDATA;
  wire StreamingFIFO_rtl_12_out_V_TREADY;
  wire StreamingFIFO_rtl_12_out_V_TVALID;
  wire [10:0]StreamingFIFO_rtl_13_maxcount;
  wire [7:0]StreamingFIFO_rtl_13_out_V_TDATA;
  wire StreamingFIFO_rtl_13_out_V_TREADY;
  wire StreamingFIFO_rtl_13_out_V_TVALID;
  wire [3:0]StreamingFIFO_rtl_14_maxcount;
  wire [23:0]StreamingFIFO_rtl_14_out_V_TDATA;
  wire StreamingFIFO_rtl_14_out_V_TREADY;
  wire StreamingFIFO_rtl_14_out_V_TVALID;
  wire [9:0]StreamingFIFO_rtl_1_maxcount;
  wire [23:0]StreamingFIFO_rtl_1_out_V_TDATA;
  wire StreamingFIFO_rtl_1_out_V_TREADY;
  wire StreamingFIFO_rtl_1_out_V_TVALID;
  wire [11:0]StreamingFIFO_rtl_2_maxcount;
  wire [7:0]StreamingFIFO_rtl_2_out_V_TDATA;
  wire StreamingFIFO_rtl_2_out_V_TREADY;
  wire StreamingFIFO_rtl_2_out_V_TVALID;
  wire [14:0]StreamingFIFO_rtl_3_maxcount;
  wire [7:0]StreamingFIFO_rtl_3_out_V_TDATA;
  wire StreamingFIFO_rtl_3_out_V_TREADY;
  wire StreamingFIFO_rtl_3_out_V_TVALID;
  wire [13:0]StreamingFIFO_rtl_4_maxcount;
  wire [7:0]StreamingFIFO_rtl_4_out_V_TDATA;
  wire StreamingFIFO_rtl_4_out_V_TREADY;
  wire StreamingFIFO_rtl_4_out_V_TVALID;
  wire [9:0]StreamingFIFO_rtl_5_maxcount;
  wire [63:0]StreamingFIFO_rtl_5_out_V_TDATA;
  wire StreamingFIFO_rtl_5_out_V_TREADY;
  wire StreamingFIFO_rtl_5_out_V_TVALID;
  wire [7:0]StreamingFIFO_rtl_6_maxcount;
  wire [63:0]StreamingFIFO_rtl_6_out_V_TDATA;
  wire StreamingFIFO_rtl_6_out_V_TREADY;
  wire StreamingFIFO_rtl_6_out_V_TVALID;
  wire [8:0]StreamingFIFO_rtl_7_maxcount;
  wire [63:0]StreamingFIFO_rtl_7_out_V_TDATA;
  wire StreamingFIFO_rtl_7_out_V_TREADY;
  wire StreamingFIFO_rtl_7_out_V_TVALID;
  wire [12:0]StreamingFIFO_rtl_8_maxcount;
  wire [7:0]StreamingFIFO_rtl_8_out_V_TDATA;
  wire StreamingFIFO_rtl_8_out_V_TREADY;
  wire StreamingFIFO_rtl_8_out_V_TVALID;
  wire [14:0]StreamingFIFO_rtl_9_maxcount;
  wire [7:0]StreamingFIFO_rtl_9_out_V_TDATA;
  wire StreamingFIFO_rtl_9_out_V_TREADY;
  wire StreamingFIFO_rtl_9_out_V_TVALID;
  wire [63:0]StreamingMaxPool_hls_0_out_V_TDATA;
  wire StreamingMaxPool_hls_0_out_V_TREADY;
  wire StreamingMaxPool_hls_0_out_V_TVALID;
  wire [127:0]StreamingMaxPool_hls_1_out_V_TDATA;
  wire StreamingMaxPool_hls_1_out_V_TREADY;
  wire StreamingMaxPool_hls_1_out_V_TVALID;
  wire ap_clk_0_1;
  wire ap_rst_n_0_1;
  wire [23:0]in0_V_0_1_TDATA;
  wire in0_V_0_1_TREADY;
  wire in0_V_0_1_TVALID;

  assign StreamingFIFO_rtl_14_out_V_TREADY = m_axis_0_tready;
  assign ap_clk_0_1 = ap_clk;
  assign ap_rst_n_0_1 = ap_rst_n;
  assign in0_V_0_1_TDATA = s_axis_0_tdata[23:0];
  assign in0_V_0_1_TVALID = s_axis_0_tvalid;
  assign m_axis_0_tdata[23:0] = StreamingFIFO_rtl_14_out_V_TDATA;
  assign m_axis_0_tvalid = StreamingFIFO_rtl_14_out_V_TVALID;
  assign maxcount[9:0] = StreamingFIFO_rtl_0_maxcount;
  assign maxcount_1[9:0] = StreamingFIFO_rtl_1_maxcount;
  assign maxcount_10[12:0] = StreamingFIFO_rtl_10_maxcount;
  assign maxcount_11[7:0] = StreamingFIFO_rtl_11_maxcount;
  assign maxcount_12[5:0] = StreamingFIFO_rtl_12_maxcount;
  assign maxcount_13[10:0] = StreamingFIFO_rtl_13_maxcount;
  assign maxcount_14[3:0] = StreamingFIFO_rtl_14_maxcount;
  assign maxcount_2[11:0] = StreamingFIFO_rtl_2_maxcount;
  assign maxcount_3[14:0] = StreamingFIFO_rtl_3_maxcount;
  assign maxcount_4[13:0] = StreamingFIFO_rtl_4_maxcount;
  assign maxcount_5[9:0] = StreamingFIFO_rtl_5_maxcount;
  assign maxcount_6[7:0] = StreamingFIFO_rtl_6_maxcount;
  assign maxcount_7[8:0] = StreamingFIFO_rtl_7_maxcount;
  assign maxcount_8[12:0] = StreamingFIFO_rtl_8_maxcount;
  assign maxcount_9[14:0] = StreamingFIFO_rtl_9_maxcount;
  assign s_axis_0_tready = in0_V_0_1_TREADY;
  finn_design_ConvolutionInputGenerator_rtl_0_0 ConvolutionInputGenerator_rtl_0
       (.ap_clk(ap_clk_0_1),
        .ap_rst_n(ap_rst_n_0_1),
        .in0_V_TDATA(StreamingFIFO_rtl_2_out_V_TDATA),
        .in0_V_TREADY(StreamingFIFO_rtl_2_out_V_TREADY),
        .in0_V_TVALID(StreamingFIFO_rtl_2_out_V_TVALID),
        .out_V_TDATA(ConvolutionInputGenerator_rtl_0_out_V_TDATA),
        .out_V_TREADY(ConvolutionInputGenerator_rtl_0_out_V_TREADY),
        .out_V_TVALID(ConvolutionInputGenerator_rtl_0_out_V_TVALID));
  finn_design_ConvolutionInputGenerator_rtl_1_0 ConvolutionInputGenerator_rtl_1
       (.ap_clk(ap_clk_0_1),
        .ap_rst_n(ap_rst_n_0_1),
        .in0_V_TDATA(StreamingFIFO_rtl_8_out_V_TDATA),
        .in0_V_TREADY(StreamingFIFO_rtl_8_out_V_TREADY),
        .in0_V_TVALID(StreamingFIFO_rtl_8_out_V_TVALID),
        .out_V_TDATA(ConvolutionInputGenerator_rtl_1_out_V_TDATA),
        .out_V_TREADY(ConvolutionInputGenerator_rtl_1_out_V_TREADY),
        .out_V_TVALID(ConvolutionInputGenerator_rtl_1_out_V_TVALID));
  finn_design_FMPadding_rtl_0_0 FMPadding_rtl_0
       (.ap_clk(ap_clk_0_1),
        .ap_rst_n(ap_rst_n_0_1),
        .in0_V_TDATA(StreamingFIFO_rtl_0_out_V_TDATA),
        .in0_V_TREADY(StreamingFIFO_rtl_0_out_V_TREADY),
        .in0_V_TVALID(StreamingFIFO_rtl_0_out_V_TVALID),
        .out_V_TDATA(FMPadding_rtl_0_out_V_TDATA),
        .out_V_TREADY(FMPadding_rtl_0_out_V_TREADY),
        .out_V_TVALID(FMPadding_rtl_0_out_V_TVALID),
        .s_axilite_ARADDR({1'b0,1'b0,1'b0,1'b0,1'b0}),
        .s_axilite_ARVALID(1'b0),
        .s_axilite_AWADDR({1'b0,1'b0,1'b0,1'b0,1'b0}),
        .s_axilite_AWVALID(1'b0),
        .s_axilite_BREADY(1'b0),
        .s_axilite_RREADY(1'b0),
        .s_axilite_WDATA({1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0}),
        .s_axilite_WSTRB({1'b1,1'b1,1'b1,1'b1}),
        .s_axilite_WVALID(1'b0));
  finn_design_FMPadding_rtl_1_0 FMPadding_rtl_1
       (.ap_clk(ap_clk_0_1),
        .ap_rst_n(ap_rst_n_0_1),
        .in0_V_TDATA(StreamingFIFO_rtl_6_out_V_TDATA),
        .in0_V_TREADY(StreamingFIFO_rtl_6_out_V_TREADY),
        .in0_V_TVALID(StreamingFIFO_rtl_6_out_V_TVALID),
        .out_V_TDATA(FMPadding_rtl_1_out_V_TDATA),
        .out_V_TREADY(FMPadding_rtl_1_out_V_TREADY),
        .out_V_TVALID(FMPadding_rtl_1_out_V_TVALID),
        .s_axilite_ARADDR({1'b0,1'b0,1'b0,1'b0,1'b0}),
        .s_axilite_ARVALID(1'b0),
        .s_axilite_AWADDR({1'b0,1'b0,1'b0,1'b0,1'b0}),
        .s_axilite_AWVALID(1'b0),
        .s_axilite_BREADY(1'b0),
        .s_axilite_RREADY(1'b0),
        .s_axilite_WDATA({1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0}),
        .s_axilite_WSTRB({1'b1,1'b1,1'b1,1'b1}),
        .s_axilite_WVALID(1'b0));
  MVAU_hls_0_imp_7OH4JA MVAU_hls_0
       (.ap_clk(ap_clk_0_1),
        .ap_rst_n(ap_rst_n_0_1),
        .in0_V_tdata(StreamingFIFO_rtl_3_out_V_TDATA),
        .in0_V_tready(StreamingFIFO_rtl_3_out_V_TREADY),
        .in0_V_tvalid(StreamingFIFO_rtl_3_out_V_TVALID),
        .out_V_tdata(MVAU_hls_0_out_V_TDATA),
        .out_V_tready(MVAU_hls_0_out_V_TREADY),
        .out_V_tvalid(MVAU_hls_0_out_V_TVALID));
  MVAU_hls_1_imp_ZIW0NT MVAU_hls_1
       (.ap_clk(ap_clk_0_1),
        .ap_rst_n(ap_rst_n_0_1),
        .in0_V_tdata(StreamingFIFO_rtl_9_out_V_TDATA),
        .in0_V_tready(StreamingFIFO_rtl_9_out_V_TREADY),
        .in0_V_tvalid(StreamingFIFO_rtl_9_out_V_TVALID),
        .out_V_tdata(MVAU_hls_1_out_V_TDATA),
        .out_V_tready(MVAU_hls_1_out_V_TREADY),
        .out_V_tvalid(MVAU_hls_1_out_V_TVALID));
  MVAU_rtl_0_imp_1DNJB9Y MVAU_rtl_0
       (.ap_clk(ap_clk_0_1),
        .ap_rst_n(ap_rst_n_0_1),
        .in0_V_tdata(StreamingFIFO_rtl_13_out_V_TDATA),
        .in0_V_tready(StreamingFIFO_rtl_13_out_V_TREADY),
        .in0_V_tvalid(StreamingFIFO_rtl_13_out_V_TVALID),
        .out_V_tdata(MVAU_rtl_0_out_V_TDATA),
        .out_V_tready(MVAU_rtl_0_out_V_TREADY),
        .out_V_tvalid(MVAU_rtl_0_out_V_TVALID));
  finn_design_StreamingDataWidthConverter_rtl_0_0 StreamingDataWidthConverter_rtl_0
       (.ap_clk(ap_clk_0_1),
        .ap_rst_n(ap_rst_n_0_1),
        .in0_V_TDATA(StreamingFIFO_rtl_1_out_V_TDATA),
        .in0_V_TREADY(StreamingFIFO_rtl_1_out_V_TREADY),
        .in0_V_TVALID(StreamingFIFO_rtl_1_out_V_TVALID),
        .out_V_TDATA(StreamingDataWidthConverter_rtl_0_out_V_TDATA),
        .out_V_TREADY(StreamingDataWidthConverter_rtl_0_out_V_TREADY),
        .out_V_TVALID(StreamingDataWidthConverter_rtl_0_out_V_TVALID));
  finn_design_StreamingDataWidthConverter_rtl_1_0 StreamingDataWidthConverter_rtl_1
       (.ap_clk(ap_clk_0_1),
        .ap_rst_n(ap_rst_n_0_1),
        .in0_V_TDATA(StreamingFIFO_rtl_4_out_V_TDATA),
        .in0_V_TREADY(StreamingFIFO_rtl_4_out_V_TREADY),
        .in0_V_TVALID(StreamingFIFO_rtl_4_out_V_TVALID),
        .out_V_TDATA(StreamingDataWidthConverter_rtl_1_out_V_TDATA),
        .out_V_TREADY(StreamingDataWidthConverter_rtl_1_out_V_TREADY),
        .out_V_TVALID(StreamingDataWidthConverter_rtl_1_out_V_TVALID));
  finn_design_StreamingDataWidthConverter_rtl_2_0 StreamingDataWidthConverter_rtl_2
       (.ap_clk(ap_clk_0_1),
        .ap_rst_n(ap_rst_n_0_1),
        .in0_V_TDATA(StreamingFIFO_rtl_7_out_V_TDATA),
        .in0_V_TREADY(StreamingFIFO_rtl_7_out_V_TREADY),
        .in0_V_TVALID(StreamingFIFO_rtl_7_out_V_TVALID),
        .out_V_TDATA(StreamingDataWidthConverter_rtl_2_out_V_TDATA),
        .out_V_TREADY(StreamingDataWidthConverter_rtl_2_out_V_TREADY),
        .out_V_TVALID(StreamingDataWidthConverter_rtl_2_out_V_TVALID));
  finn_design_StreamingDataWidthConverter_rtl_3_0 StreamingDataWidthConverter_rtl_3
       (.ap_clk(ap_clk_0_1),
        .ap_rst_n(ap_rst_n_0_1),
        .in0_V_TDATA(StreamingFIFO_rtl_10_out_V_TDATA),
        .in0_V_TREADY(StreamingFIFO_rtl_10_out_V_TREADY),
        .in0_V_TVALID(StreamingFIFO_rtl_10_out_V_TVALID),
        .out_V_TDATA(StreamingDataWidthConverter_rtl_3_out_V_TDATA),
        .out_V_TREADY(StreamingDataWidthConverter_rtl_3_out_V_TREADY),
        .out_V_TVALID(StreamingDataWidthConverter_rtl_3_out_V_TVALID));
  finn_design_StreamingDataWidthConverter_rtl_4_0 StreamingDataWidthConverter_rtl_4
       (.ap_clk(ap_clk_0_1),
        .ap_rst_n(ap_rst_n_0_1),
        .in0_V_TDATA(StreamingFIFO_rtl_12_out_V_TDATA),
        .in0_V_TREADY(StreamingFIFO_rtl_12_out_V_TREADY),
        .in0_V_TVALID(StreamingFIFO_rtl_12_out_V_TVALID),
        .out_V_TDATA(StreamingDataWidthConverter_rtl_4_out_V_TDATA),
        .out_V_TREADY(StreamingDataWidthConverter_rtl_4_out_V_TREADY),
        .out_V_TVALID(StreamingDataWidthConverter_rtl_4_out_V_TVALID));
  finn_design_StreamingFIFO_rtl_0_0 StreamingFIFO_rtl_0
       (.ap_clk(ap_clk_0_1),
        .ap_rst_n(ap_rst_n_0_1),
        .in0_V_TDATA(in0_V_0_1_TDATA),
        .in0_V_TREADY(in0_V_0_1_TREADY),
        .in0_V_TVALID(in0_V_0_1_TVALID),
        .maxcount(StreamingFIFO_rtl_0_maxcount),
        .out_V_TDATA(StreamingFIFO_rtl_0_out_V_TDATA),
        .out_V_TREADY(StreamingFIFO_rtl_0_out_V_TREADY),
        .out_V_TVALID(StreamingFIFO_rtl_0_out_V_TVALID));
  finn_design_StreamingFIFO_rtl_1_0 StreamingFIFO_rtl_1
       (.ap_clk(ap_clk_0_1),
        .ap_rst_n(ap_rst_n_0_1),
        .in0_V_TDATA(FMPadding_rtl_0_out_V_TDATA),
        .in0_V_TREADY(FMPadding_rtl_0_out_V_TREADY),
        .in0_V_TVALID(FMPadding_rtl_0_out_V_TVALID),
        .maxcount(StreamingFIFO_rtl_1_maxcount),
        .out_V_TDATA(StreamingFIFO_rtl_1_out_V_TDATA),
        .out_V_TREADY(StreamingFIFO_rtl_1_out_V_TREADY),
        .out_V_TVALID(StreamingFIFO_rtl_1_out_V_TVALID));
  finn_design_StreamingFIFO_rtl_10_0 StreamingFIFO_rtl_10
       (.ap_clk(ap_clk_0_1),
        .ap_rst_n(ap_rst_n_0_1),
        .in0_V_TDATA(MVAU_hls_1_out_V_TDATA),
        .in0_V_TREADY(MVAU_hls_1_out_V_TREADY),
        .in0_V_TVALID(MVAU_hls_1_out_V_TVALID),
        .maxcount(StreamingFIFO_rtl_10_maxcount),
        .out_V_TDATA(StreamingFIFO_rtl_10_out_V_TDATA),
        .out_V_TREADY(StreamingFIFO_rtl_10_out_V_TREADY),
        .out_V_TVALID(StreamingFIFO_rtl_10_out_V_TVALID));
  finn_design_StreamingFIFO_rtl_11_0 StreamingFIFO_rtl_11
       (.ap_clk(ap_clk_0_1),
        .ap_rst_n(ap_rst_n_0_1),
        .in0_V_TDATA(StreamingDataWidthConverter_rtl_3_out_V_TDATA),
        .in0_V_TREADY(StreamingDataWidthConverter_rtl_3_out_V_TREADY),
        .in0_V_TVALID(StreamingDataWidthConverter_rtl_3_out_V_TVALID),
        .maxcount(StreamingFIFO_rtl_11_maxcount),
        .out_V_TDATA(StreamingFIFO_rtl_11_out_V_TDATA),
        .out_V_TREADY(StreamingFIFO_rtl_11_out_V_TREADY),
        .out_V_TVALID(StreamingFIFO_rtl_11_out_V_TVALID));
  finn_design_StreamingFIFO_rtl_12_0 StreamingFIFO_rtl_12
       (.ap_clk(ap_clk_0_1),
        .ap_rst_n(ap_rst_n_0_1),
        .in0_V_TDATA(StreamingMaxPool_hls_1_out_V_TDATA),
        .in0_V_TREADY(StreamingMaxPool_hls_1_out_V_TREADY),
        .in0_V_TVALID(StreamingMaxPool_hls_1_out_V_TVALID),
        .maxcount(StreamingFIFO_rtl_12_maxcount),
        .out_V_TDATA(StreamingFIFO_rtl_12_out_V_TDATA),
        .out_V_TREADY(StreamingFIFO_rtl_12_out_V_TREADY),
        .out_V_TVALID(StreamingFIFO_rtl_12_out_V_TVALID));
  finn_design_StreamingFIFO_rtl_13_0 StreamingFIFO_rtl_13
       (.ap_clk(ap_clk_0_1),
        .ap_rst_n(ap_rst_n_0_1),
        .in0_V_TDATA(StreamingDataWidthConverter_rtl_4_out_V_TDATA),
        .in0_V_TREADY(StreamingDataWidthConverter_rtl_4_out_V_TREADY),
        .in0_V_TVALID(StreamingDataWidthConverter_rtl_4_out_V_TVALID),
        .maxcount(StreamingFIFO_rtl_13_maxcount),
        .out_V_TDATA(StreamingFIFO_rtl_13_out_V_TDATA),
        .out_V_TREADY(StreamingFIFO_rtl_13_out_V_TREADY),
        .out_V_TVALID(StreamingFIFO_rtl_13_out_V_TVALID));
  finn_design_StreamingFIFO_rtl_14_0 StreamingFIFO_rtl_14
       (.ap_clk(ap_clk_0_1),
        .ap_rst_n(ap_rst_n_0_1),
        .in0_V_TDATA(MVAU_rtl_0_out_V_TDATA),
        .in0_V_TREADY(MVAU_rtl_0_out_V_TREADY),
        .in0_V_TVALID(MVAU_rtl_0_out_V_TVALID),
        .maxcount(StreamingFIFO_rtl_14_maxcount),
        .out_V_TDATA(StreamingFIFO_rtl_14_out_V_TDATA),
        .out_V_TREADY(StreamingFIFO_rtl_14_out_V_TREADY),
        .out_V_TVALID(StreamingFIFO_rtl_14_out_V_TVALID));
  finn_design_StreamingFIFO_rtl_2_0 StreamingFIFO_rtl_2
       (.ap_clk(ap_clk_0_1),
        .ap_rst_n(ap_rst_n_0_1),
        .in0_V_TDATA(StreamingDataWidthConverter_rtl_0_out_V_TDATA),
        .in0_V_TREADY(StreamingDataWidthConverter_rtl_0_out_V_TREADY),
        .in0_V_TVALID(StreamingDataWidthConverter_rtl_0_out_V_TVALID),
        .maxcount(StreamingFIFO_rtl_2_maxcount),
        .out_V_TDATA(StreamingFIFO_rtl_2_out_V_TDATA),
        .out_V_TREADY(StreamingFIFO_rtl_2_out_V_TREADY),
        .out_V_TVALID(StreamingFIFO_rtl_2_out_V_TVALID));
  finn_design_StreamingFIFO_rtl_3_0 StreamingFIFO_rtl_3
       (.ap_clk(ap_clk_0_1),
        .ap_rst_n(ap_rst_n_0_1),
        .in0_V_TDATA(ConvolutionInputGenerator_rtl_0_out_V_TDATA),
        .in0_V_TREADY(ConvolutionInputGenerator_rtl_0_out_V_TREADY),
        .in0_V_TVALID(ConvolutionInputGenerator_rtl_0_out_V_TVALID),
        .maxcount(StreamingFIFO_rtl_3_maxcount),
        .out_V_TDATA(StreamingFIFO_rtl_3_out_V_TDATA),
        .out_V_TREADY(StreamingFIFO_rtl_3_out_V_TREADY),
        .out_V_TVALID(StreamingFIFO_rtl_3_out_V_TVALID));
  finn_design_StreamingFIFO_rtl_4_0 StreamingFIFO_rtl_4
       (.ap_clk(ap_clk_0_1),
        .ap_rst_n(ap_rst_n_0_1),
        .in0_V_TDATA(MVAU_hls_0_out_V_TDATA),
        .in0_V_TREADY(MVAU_hls_0_out_V_TREADY),
        .in0_V_TVALID(MVAU_hls_0_out_V_TVALID),
        .maxcount(StreamingFIFO_rtl_4_maxcount),
        .out_V_TDATA(StreamingFIFO_rtl_4_out_V_TDATA),
        .out_V_TREADY(StreamingFIFO_rtl_4_out_V_TREADY),
        .out_V_TVALID(StreamingFIFO_rtl_4_out_V_TVALID));
  finn_design_StreamingFIFO_rtl_5_0 StreamingFIFO_rtl_5
       (.ap_clk(ap_clk_0_1),
        .ap_rst_n(ap_rst_n_0_1),
        .in0_V_TDATA(StreamingDataWidthConverter_rtl_1_out_V_TDATA),
        .in0_V_TREADY(StreamingDataWidthConverter_rtl_1_out_V_TREADY),
        .in0_V_TVALID(StreamingDataWidthConverter_rtl_1_out_V_TVALID),
        .maxcount(StreamingFIFO_rtl_5_maxcount),
        .out_V_TDATA(StreamingFIFO_rtl_5_out_V_TDATA),
        .out_V_TREADY(StreamingFIFO_rtl_5_out_V_TREADY),
        .out_V_TVALID(StreamingFIFO_rtl_5_out_V_TVALID));
  finn_design_StreamingFIFO_rtl_6_0 StreamingFIFO_rtl_6
       (.ap_clk(ap_clk_0_1),
        .ap_rst_n(ap_rst_n_0_1),
        .in0_V_TDATA(StreamingMaxPool_hls_0_out_V_TDATA),
        .in0_V_TREADY(StreamingMaxPool_hls_0_out_V_TREADY),
        .in0_V_TVALID(StreamingMaxPool_hls_0_out_V_TVALID),
        .maxcount(StreamingFIFO_rtl_6_maxcount),
        .out_V_TDATA(StreamingFIFO_rtl_6_out_V_TDATA),
        .out_V_TREADY(StreamingFIFO_rtl_6_out_V_TREADY),
        .out_V_TVALID(StreamingFIFO_rtl_6_out_V_TVALID));
  finn_design_StreamingFIFO_rtl_7_0 StreamingFIFO_rtl_7
       (.ap_clk(ap_clk_0_1),
        .ap_rst_n(ap_rst_n_0_1),
        .in0_V_TDATA(FMPadding_rtl_1_out_V_TDATA),
        .in0_V_TREADY(FMPadding_rtl_1_out_V_TREADY),
        .in0_V_TVALID(FMPadding_rtl_1_out_V_TVALID),
        .maxcount(StreamingFIFO_rtl_7_maxcount),
        .out_V_TDATA(StreamingFIFO_rtl_7_out_V_TDATA),
        .out_V_TREADY(StreamingFIFO_rtl_7_out_V_TREADY),
        .out_V_TVALID(StreamingFIFO_rtl_7_out_V_TVALID));
  finn_design_StreamingFIFO_rtl_8_0 StreamingFIFO_rtl_8
       (.ap_clk(ap_clk_0_1),
        .ap_rst_n(ap_rst_n_0_1),
        .in0_V_TDATA(StreamingDataWidthConverter_rtl_2_out_V_TDATA),
        .in0_V_TREADY(StreamingDataWidthConverter_rtl_2_out_V_TREADY),
        .in0_V_TVALID(StreamingDataWidthConverter_rtl_2_out_V_TVALID),
        .maxcount(StreamingFIFO_rtl_8_maxcount),
        .out_V_TDATA(StreamingFIFO_rtl_8_out_V_TDATA),
        .out_V_TREADY(StreamingFIFO_rtl_8_out_V_TREADY),
        .out_V_TVALID(StreamingFIFO_rtl_8_out_V_TVALID));
  finn_design_StreamingFIFO_rtl_9_0 StreamingFIFO_rtl_9
       (.ap_clk(ap_clk_0_1),
        .ap_rst_n(ap_rst_n_0_1),
        .in0_V_TDATA(ConvolutionInputGenerator_rtl_1_out_V_TDATA),
        .in0_V_TREADY(ConvolutionInputGenerator_rtl_1_out_V_TREADY),
        .in0_V_TVALID(ConvolutionInputGenerator_rtl_1_out_V_TVALID),
        .maxcount(StreamingFIFO_rtl_9_maxcount),
        .out_V_TDATA(StreamingFIFO_rtl_9_out_V_TDATA),
        .out_V_TREADY(StreamingFIFO_rtl_9_out_V_TREADY),
        .out_V_TVALID(StreamingFIFO_rtl_9_out_V_TVALID));
  finn_design_StreamingMaxPool_hls_0_0 StreamingMaxPool_hls_0
       (.ap_clk(ap_clk_0_1),
        .ap_rst_n(ap_rst_n_0_1),
        .in0_V_TDATA(StreamingFIFO_rtl_5_out_V_TDATA),
        .in0_V_TREADY(StreamingFIFO_rtl_5_out_V_TREADY),
        .in0_V_TVALID(StreamingFIFO_rtl_5_out_V_TVALID),
        .out_V_TDATA(StreamingMaxPool_hls_0_out_V_TDATA),
        .out_V_TREADY(StreamingMaxPool_hls_0_out_V_TREADY),
        .out_V_TVALID(StreamingMaxPool_hls_0_out_V_TVALID));
  finn_design_StreamingMaxPool_hls_1_0 StreamingMaxPool_hls_1
       (.ap_clk(ap_clk_0_1),
        .ap_rst_n(ap_rst_n_0_1),
        .in0_V_TDATA(StreamingFIFO_rtl_11_out_V_TDATA),
        .in0_V_TREADY(StreamingFIFO_rtl_11_out_V_TREADY),
        .in0_V_TVALID(StreamingFIFO_rtl_11_out_V_TVALID),
        .out_V_TDATA(StreamingMaxPool_hls_1_out_V_TDATA),
        .out_V_TREADY(StreamingMaxPool_hls_1_out_V_TREADY),
        .out_V_TVALID(StreamingMaxPool_hls_1_out_V_TVALID));
endmodule
//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/vivado_stitch_proj_w5fn6zuu/finn_vivado_stitch_proj.gen/sources_1/bd/finn_design/ipshared/4d6a/hdl/verilog/StreamingMaxPool_hls_1_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8.v


// ==============================================================
// RTL generated by Vitis HLS - High-Level Synthesis from C, C++ and OpenCL v2022.2 (64-bit)
// Version: 2022.2
// Copyright (C) Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.
// 
// ===========================================================

`timescale 1 ns / 1 ps 

module StreamingMaxPool_hls_1_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8 (
        ap_clk,
        ap_rst,
        ap_start,
        ap_done,
        ap_idle,
        ap_ready,
        out_V_TREADY,
        buf_V_address0,
        buf_V_ce0,
        buf_V_we0,
        buf_V_d0,
        buf_V_q0,
        buf_V_1_address0,
        buf_V_1_ce0,
        buf_V_1_we0,
        buf_V_1_d0,
        buf_V_1_q0,
        buf_V_2_address0,
        buf_V_2_ce0,
        buf_V_2_we0,
        buf_V_2_d0,
        buf_V_2_q0,
        buf_V_3_address0,
        buf_V_3_ce0,
        buf_V_3_we0,
        buf_V_3_d0,
        buf_V_3_q0,
        buf_V_4_address0,
        buf_V_4_ce0,
        buf_V_4_we0,
        buf_V_4_d0,
        buf_V_4_q0,
        buf_V_5_address0,
        buf_V_5_ce0,
        buf_V_5_we0,
        buf_V_5_d0,
        buf_V_5_q0,
        buf_V_6_address0,
        buf_V_6_ce0,
        buf_V_6_we0,
        buf_V_6_d0,
        buf_V_6_q0,
        buf_V_7_address0,
        buf_V_7_ce0,
        buf_V_7_we0,
        buf_V_7_d0,
        buf_V_7_q0,
        buf_V_8_address0,
        buf_V_8_ce0,
        buf_V_8_we0,
        buf_V_8_d0,
        buf_V_8_q0,
        buf_V_9_address0,
        buf_V_9_ce0,
        buf_V_9_we0,
        buf_V_9_d0,
        buf_V_9_q0,
        buf_V_10_address0,
        buf_V_10_ce0,
        buf_V_10_we0,
        buf_V_10_d0,
        buf_V_10_q0,
        buf_V_11_address0,
        buf_V_11_ce0,
        buf_V_11_we0,
        buf_V_11_d0,
        buf_V_11_q0,
        buf_V_12_address0,
        buf_V_12_ce0,
        buf_V_12_we0,
        buf_V_12_d0,
        buf_V_12_q0,
        buf_V_13_address0,
        buf_V_13_ce0,
        buf_V_13_we0,
        buf_V_13_d0,
        buf_V_13_q0,
        buf_V_14_address0,
        buf_V_14_ce0,
        buf_V_14_we0,
        buf_V_14_d0,
        buf_V_14_q0,
        buf_V_15_address0,
        buf_V_15_ce0,
        buf_V_15_we0,
        buf_V_15_d0,
        buf_V_15_q0,
        buf_V_16_address0,
        buf_V_16_ce0,
        buf_V_16_we0,
        buf_V_16_d0,
        buf_V_16_q0,
        buf_V_17_address0,
        buf_V_17_ce0,
        buf_V_17_we0,
        buf_V_17_d0,
        buf_V_17_q0,
        buf_V_18_address0,
        buf_V_18_ce0,
        buf_V_18_we0,
        buf_V_18_d0,
        buf_V_18_q0,
        buf_V_19_address0,
        buf_V_19_ce0,
        buf_V_19_we0,
        buf_V_19_d0,
        buf_V_19_q0,
        buf_V_20_address0,
        buf_V_20_ce0,
        buf_V_20_we0,
        buf_V_20_d0,
        buf_V_20_q0,
        buf_V_21_address0,
        buf_V_21_ce0,
        buf_V_21_we0,
        buf_V_21_d0,
        buf_V_21_q0,
        buf_V_22_address0,
        buf_V_22_ce0,
        buf_V_22_we0,
        buf_V_22_d0,
        buf_V_22_q0,
        buf_V_23_address0,
        buf_V_23_ce0,
        buf_V_23_we0,
        buf_V_23_d0,
        buf_V_23_q0,
        buf_V_24_address0,
        buf_V_24_ce0,
        buf_V_24_we0,
        buf_V_24_d0,
        buf_V_24_q0,
        buf_V_25_address0,
        buf_V_25_ce0,
        buf_V_25_we0,
        buf_V_25_d0,
        buf_V_25_q0,
        buf_V_26_address0,
        buf_V_26_ce0,
        buf_V_26_we0,
        buf_V_26_d0,
        buf_V_26_q0,
        buf_V_27_address0,
        buf_V_27_ce0,
        buf_V_27_we0,
        buf_V_27_d0,
        buf_V_27_q0,
        buf_V_28_address0,
        buf_V_28_ce0,
        buf_V_28_we0,
        buf_V_28_d0,
        buf_V_28_q0,
        buf_V_29_address0,
        buf_V_29_ce0,
        buf_V_29_we0,
        buf_V_29_d0,
        buf_V_29_q0,
        buf_V_30_address0,
        buf_V_30_ce0,
        buf_V_30_we0,
        buf_V_30_d0,
        buf_V_30_q0,
        buf_V_31_address0,
        buf_V_31_ce0,
        buf_V_31_we0,
        buf_V_31_d0,
        buf_V_31_q0,
        out_V_TDATA,
        out_V_TVALID
);

parameter    ap_ST_iter0_fsm_state1 = 1'd1;
parameter    ap_ST_iter1_fsm_state2 = 2'd2;
parameter    ap_ST_iter1_fsm_state0 = 2'd1;

input   ap_clk;
input   ap_rst;
input   ap_start;
output   ap_done;
output   ap_idle;
output   ap_ready;
input   out_V_TREADY;
output  [2:0] buf_V_address0;
output   buf_V_ce0;
output   buf_V_we0;
output  [3:0] buf_V_d0;
input  [3:0] buf_V_q0;
output  [2:0] buf_V_1_address0;
output   buf_V_1_ce0;
output   buf_V_1_we0;
output  [3:0] buf_V_1_d0;
input  [3:0] buf_V_1_q0;
output  [2:0] buf_V_2_address0;
output   buf_V_2_ce0;
output   buf_V_2_we0;
output  [3:0] buf_V_2_d0;
input  [3:0] buf_V_2_q0;
output  [2:0] buf_V_3_address0;
output   buf_V_3_ce0;
output   buf_V_3_we0;
output  [3:0] buf_V_3_d0;
input  [3:0] buf_V_3_q0;
output  [2:0] buf_V_4_address0;
output   buf_V_4_ce0;
output   buf_V_4_we0;
output  [3:0] buf_V_4_d0;
input  [3:0] buf_V_4_q0;
output  [2:0] buf_V_5_address0;
output   buf_V_5_ce0;
output   buf_V_5_we0;
output  [3:0] buf_V_5_d0;
input  [3:0] buf_V_5_q0;
output  [2:0] buf_V_6_address0;
output   buf_V_6_ce0;
output   buf_V_6_we0;
output  [3:0] buf_V_6_d0;
input  [3:0] buf_V_6_q0;
output  [2:0] buf_V_7_address0;
output   buf_V_7_ce0;
output   buf_V_7_we0;
output  [3:0] buf_V_7_d0;
input  [3:0] buf_V_7_q0;
output  [2:0] buf_V_8_address0;
output   buf_V_8_ce0;
output   buf_V_8_we0;
output  [3:0] buf_V_8_d0;
input  [3:0] buf_V_8_q0;
output  [2:0] buf_V_9_address0;
output   buf_V_9_ce0;
output   buf_V_9_we0;
output  [3:0] buf_V_9_d0;
input  [3:0] buf_V_9_q0;
output  [2:0] buf_V_10_address0;
output   buf_V_10_ce0;
output   buf_V_10_we0;
output  [3:0] buf_V_10_d0;
input  [3:0] buf_V_10_q0;
output  [2:0] buf_V_11_address0;
output   buf_V_11_ce0;
output   buf_V_11_we0;
output  [3:0] buf_V_11_d0;
input  [3:0] buf_V_11_q0;
output  [2:0] buf_V_12_address0;
output   buf_V_12_ce0;
output   buf_V_12_we0;
output  [3:0] buf_V_12_d0;
input  [3:0] buf_V_12_q0;
output  [2:0] buf_V_13_address0;
output   buf_V_13_ce0;
output   buf_V_13_we0;
output  [3:0] buf_V_13_d0;
input  [3:0] buf_V_13_q0;
output  [2:0] buf_V_14_address0;
output   buf_V_14_ce0;
output   buf_V_14_we0;
output  [3:0] buf_V_14_d0;
input  [3:0] buf_V_14_q0;
output  [2:0] buf_V_15_address0;
output   buf_V_15_ce0;
output   buf_V_15_we0;
output  [3:0] buf_V_15_d0;
input  [3:0] buf_V_15_q0;
output  [2:0] buf_V_16_address0;
output   buf_V_16_ce0;
output   buf_V_16_we0;
output  [3:0] buf_V_16_d0;
input  [3:0] buf_V_16_q0;
output  [2:0] buf_V_17_address0;
output   buf_V_17_ce0;
output   buf_V_17_we0;
output  [3:0] buf_V_17_d0;
input  [3:0] buf_V_17_q0;
output  [2:0] buf_V_18_address0;
output   buf_V_18_ce0;
output   buf_V_18_we0;
output  [3:0] buf_V_18_d0;
input  [3:0] buf_V_18_q0;
output  [2:0] buf_V_19_address0;
output   buf_V_19_ce0;
output   buf_V_19_we0;
output  [3:0] buf_V_19_d0;
input  [3:0] buf_V_19_q0;
output  [2:0] buf_V_20_address0;
output   buf_V_20_ce0;
output   buf_V_20_we0;
output  [3:0] buf_V_20_d0;
input  [3:0] buf_V_20_q0;
output  [2:0] buf_V_21_address0;
output   buf_V_21_ce0;
output   buf_V_21_we0;
output  [3:0] buf_V_21_d0;
input  [3:0] buf_V_21_q0;
output  [2:0] buf_V_22_address0;
output   buf_V_22_ce0;
output   buf_V_22_we0;
output  [3:0] buf_V_22_d0;
input  [3:0] buf_V_22_q0;
output  [2:0] buf_V_23_address0;
output   buf_V_23_ce0;
output   buf_V_23_we0;
output  [3:0] buf_V_23_d0;
input  [3:0] buf_V_23_q0;
output  [2:0] buf_V_24_address0;
output   buf_V_24_ce0;
output   buf_V_24_we0;
output  [3:0] buf_V_24_d0;
input  [3:0] buf_V_24_q0;
output  [2:0] buf_V_25_address0;
output   buf_V_25_ce0;
output   buf_V_25_we0;
output  [3:0] buf_V_25_d0;
input  [3:0] buf_V_25_q0;
output  [2:0] buf_V_26_address0;
output   buf_V_26_ce0;
output   buf_V_26_we0;
output  [3:0] buf_V_26_d0;
input  [3:0] buf_V_26_q0;
output  [2:0] buf_V_27_address0;
output   buf_V_27_ce0;
output   buf_V_27_we0;
output  [3:0] buf_V_27_d0;
input  [3:0] buf_V_27_q0;
output  [2:0] buf_V_28_address0;
output   buf_V_28_ce0;
output   buf_V_28_we0;
output  [3:0] buf_V_28_d0;
input  [3:0] buf_V_28_q0;
output  [2:0] buf_V_29_address0;
output   buf_V_29_ce0;
output   buf_V_29_we0;
output  [3:0] buf_V_29_d0;
input  [3:0] buf_V_29_q0;
output  [2:0] buf_V_30_address0;
output   buf_V_30_ce0;
output   buf_V_30_we0;
output  [3:0] buf_V_30_d0;
input  [3:0] buf_V_30_q0;
output  [2:0] buf_V_31_address0;
output   buf_V_31_ce0;
output   buf_V_31_we0;
output  [3:0] buf_V_31_d0;
input  [3:0] buf_V_31_q0;
output  [127:0] out_V_TDATA;
output   out_V_TVALID;

reg ap_idle;
reg buf_V_ce0;
reg buf_V_we0;
reg buf_V_1_ce0;
reg buf_V_1_we0;
reg buf_V_2_ce0;
reg buf_V_2_we0;
reg buf_V_3_ce0;
reg buf_V_3_we0;
reg buf_V_4_ce0;
reg buf_V_4_we0;
reg buf_V_5_ce0;
reg buf_V_5_we0;
reg buf_V_6_ce0;
reg buf_V_6_we0;
reg buf_V_7_ce0;
reg buf_V_7_we0;
reg buf_V_8_ce0;
reg buf_V_8_we0;
reg buf_V_9_ce0;
reg buf_V_9_we0;
reg buf_V_10_ce0;
reg buf_V_10_we0;
reg buf_V_11_ce0;
reg buf_V_11_we0;
reg buf_V_12_ce0;
reg buf_V_12_we0;
reg buf_V_13_ce0;
reg buf_V_13_we0;
reg buf_V_14_ce0;
reg buf_V_14_we0;
reg buf_V_15_ce0;
reg buf_V_15_we0;
reg buf_V_16_ce0;
reg buf_V_16_we0;
reg buf_V_17_ce0;
reg buf_V_17_we0;
reg buf_V_18_ce0;
reg buf_V_18_we0;
reg buf_V_19_ce0;
reg buf_V_19_we0;
reg buf_V_20_ce0;
reg buf_V_20_we0;
reg buf_V_21_ce0;
reg buf_V_21_we0;
reg buf_V_22_ce0;
reg buf_V_22_we0;
reg buf_V_23_ce0;
reg buf_V_23_we0;
reg buf_V_24_ce0;
reg buf_V_24_we0;
reg buf_V_25_ce0;
reg buf_V_25_we0;
reg buf_V_26_ce0;
reg buf_V_26_we0;
reg buf_V_27_ce0;
reg buf_V_27_we0;
reg buf_V_28_ce0;
reg buf_V_28_we0;
reg buf_V_29_ce0;
reg buf_V_29_we0;
reg buf_V_30_ce0;
reg buf_V_30_we0;
reg buf_V_31_ce0;
reg buf_V_31_we0;
reg out_V_TVALID;

reg   [0:0] ap_CS_iter0_fsm;
wire    ap_CS_iter0_fsm_state1;
reg   [1:0] ap_CS_iter1_fsm;
wire    ap_CS_iter1_fsm_state0;
reg    ap_block_state1_pp0_stage0_iter0;
reg   [0:0] icmp_ln174_reg_702;
wire   [0:0] icmp_ln174_reg_702_pp0_iter0_reg;
reg    ap_block_state2_pp0_stage0_iter1;
reg    ap_block_state2_io;
wire    ap_CS_iter1_fsm_state2;
wire   [0:0] icmp_ln174_fu_573_p2;
reg    ap_condition_exit_pp0_iter0_stage0;
wire    ap_loop_exit_ready;
reg    ap_ready_int;
reg    out_V_TDATA_blk_n;
wire   [63:0] outpix_cast_fu_585_p1;
reg   [2:0] outpix_fu_106;
wire   [2:0] add_ln174_fu_579_p2;
wire    ap_loop_init;
reg   [2:0] ap_sig_allocacmp_outpix_1;
reg    ap_done_reg;
wire    ap_continue_int;
reg    ap_done_int;
reg    ap_loop_exit_ready_pp0_iter1_reg;
reg   [0:0] ap_NS_iter0_fsm;
reg   [1:0] ap_NS_iter1_fsm;
reg    ap_ST_iter0_fsm_state1_blk;
reg    ap_ST_iter1_fsm_state2_blk;
wire    ap_start_int;
reg    ap_condition_583;
wire    ap_ce_reg;

// power-on initialization
initial begin
#0 ap_CS_iter0_fsm = 1'd1;
#0 ap_CS_iter1_fsm = 2'd1;
#0 ap_done_reg = 1'b0;
end

StreamingMaxPool_hls_1_flow_control_loop_pipe_sequential_init flow_control_loop_pipe_sequential_init_U(
    .ap_clk(ap_clk),
    .ap_rst(ap_rst),
    .ap_start(ap_start),
    .ap_ready(ap_ready),
    .ap_done(ap_done),
    .ap_start_int(ap_start_int),
    .ap_loop_init(ap_loop_init),
    .ap_ready_int(ap_ready_int),
    .ap_loop_exit_ready(ap_condition_exit_pp0_iter0_stage0),
    .ap_loop_exit_done(ap_done_int),
    .ap_continue_int(ap_continue_int),
    .ap_done_int(ap_done_int)
);

always @ (posedge ap_clk) begin
    if (ap_rst == 1'b1) begin
        ap_CS_iter0_fsm <= ap_ST_iter0_fsm_state1;
    end else begin
        ap_CS_iter0_fsm <= ap_NS_iter0_fsm;
    end
end

always @ (posedge ap_clk) begin
    if (ap_rst == 1'b1) begin
        ap_CS_iter1_fsm <= ap_ST_iter1_fsm_state0;
    end else begin
        ap_CS_iter1_fsm <= ap_NS_iter1_fsm;
    end
end

always @ (posedge ap_clk) begin
    if (ap_rst == 1'b1) begin
        ap_done_reg <= 1'b0;
    end else begin
        if ((ap_continue_int == 1'b1)) begin
            ap_done_reg <= 1'b0;
        end else if ((~((1'b1 == ap_block_state2_io) | ((icmp_ln174_reg_702 == 1'd0) & (out_V_TREADY == 1'b0))) & (ap_loop_exit_ready_pp0_iter1_reg == 1'b1) & (1'b1 == ap_CS_iter1_fsm_state2))) begin
            ap_done_reg <= 1'b1;
        end
    end
end

always @ (posedge ap_clk) begin
    if ((~((1'b1 == ap_block_state2_io) | ((icmp_ln174_reg_702 == 1'd0) & (out_V_TREADY == 1'b0))) & (ap_loop_exit_ready == 1'b0) & (1'b1 == ap_CS_iter1_fsm_state2))) begin
        ap_loop_exit_ready_pp0_iter1_reg <= 1'b0;
    end else if ((~((ap_start_int == 1'b0) | ((1'b1 == ap_CS_iter1_fsm_state2) & ((1'b1 == ap_block_state2_io) | ((icmp_ln174_reg_702 == 1'd0) & (out_V_TREADY == 1'b0))))) & (1'b1 == ap_CS_iter0_fsm_state1))) begin
        ap_loop_exit_ready_pp0_iter1_reg <= ap_loop_exit_ready;
    end
end

always @ (posedge ap_clk) begin
    if ((1'b1 == ap_condition_583)) begin
        if ((icmp_ln174_fu_573_p2 == 1'd0)) begin
            outpix_fu_106 <= add_ln174_fu_579_p2;
        end else if ((ap_loop_init == 1'b1)) begin
            outpix_fu_106 <= 3'd0;
        end
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((1'b1 == ap_CS_iter1_fsm_state2) & ((1'b1 == ap_block_state2_io) | ((icmp_ln174_reg_702 == 1'd0) & (out_V_TREADY == 1'b0))))) & (1'b1 == ap_CS_iter0_fsm_state1))) begin
        icmp_ln174_reg_702 <= icmp_ln174_fu_573_p2;
    end
end

always @ (*) begin
    if ((ap_start_int == 1'b0)) begin
        ap_ST_iter0_fsm_state1_blk = 1'b1;
    end else begin
        ap_ST_iter0_fsm_state1_blk = 1'b0;
    end
end

always @ (*) begin
    if (((1'b1 == ap_block_state2_io) | ((icmp_ln174_reg_702 == 1'd0) & (out_V_TREADY == 1'b0)))) begin
        ap_ST_iter1_fsm_state2_blk = 1'b1;
    end else begin
        ap_ST_iter1_fsm_state2_blk = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((1'b1 == ap_CS_iter1_fsm_state2) & ((1'b1 == ap_block_state2_io) | ((icmp_ln174_reg_702 == 1'd0) & (out_V_TREADY == 1'b0))))) & (icmp_ln174_fu_573_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1))) begin
        ap_condition_exit_pp0_iter0_stage0 = 1'b1;
    end else begin
        ap_condition_exit_pp0_iter0_stage0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((1'b1 == ap_block_state2_io) | ((icmp_ln174_reg_702 == 1'd0) & (out_V_TREADY == 1'b0))) & (ap_loop_exit_ready_pp0_iter1_reg == 1'b1) & (1'b1 == ap_CS_iter1_fsm_state2))) begin
        ap_done_int = 1'b1;
    end else begin
        ap_done_int = ap_done_reg;
    end
end

always @ (*) begin
    if (((ap_start_int == 1'b0) & (1'b1 == ap_CS_iter1_fsm_state0) & (1'b1 == ap_CS_iter0_fsm_state1))) begin
        ap_idle = 1'b1;
    end else begin
        ap_idle = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((1'b1 == ap_CS_iter1_fsm_state2) & ((1'b1 == ap_block_state2_io) | ((icmp_ln174_reg_702 == 1'd0) & (out_V_TREADY == 1'b0))))) & (1'b1 == ap_CS_iter0_fsm_state1))) begin
        ap_ready_int = 1'b1;
    end else begin
        ap_ready_int = 1'b0;
    end
end

always @ (*) begin
    if (((ap_loop_init == 1'b1) & (1'b1 == ap_CS_iter0_fsm_state1))) begin
        ap_sig_allocacmp_outpix_1 = 3'd0;
    end else begin
        ap_sig_allocacmp_outpix_1 = outpix_fu_106;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((1'b1 == ap_CS_iter1_fsm_state2) & ((1'b1 == ap_block_state2_io) | ((icmp_ln174_reg_702 == 1'd0) & (out_V_TREADY == 1'b0))))) & (icmp_ln174_fu_573_p2 == 1'd0) & (1'b1 == ap_CS_iter0_fsm_state1))) begin
        buf_V_10_ce0 = 1'b1;
    end else begin
        buf_V_10_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((1'b1 == ap_CS_iter1_fsm_state2) & ((1'b1 == ap_block_state2_io) | ((icmp_ln174_reg_702 == 1'd0) & (out_V_TREADY == 1'b0))))) & (icmp_ln174_fu_573_p2 == 1'd0) & (1'b1 == ap_CS_iter0_fsm_state1))) begin
        buf_V_10_we0 = 1'b1;
    end else begin
        buf_V_10_we0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((1'b1 == ap_CS_iter1_fsm_state2) & ((1'b1 == ap_block_state2_io) | ((icmp_ln174_reg_702 == 1'd0) & (out_V_TREADY == 1'b0))))) & (icmp_ln174_fu_573_p2 == 1'd0) & (1'b1 == ap_CS_iter0_fsm_state1))) begin
        buf_V_11_ce0 = 1'b1;
    end else begin
        buf_V_11_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((1'b1 == ap_CS_iter1_fsm_state2) & ((1'b1 == ap_block_state2_io) | ((icmp_ln174_reg_702 == 1'd0) & (out_V_TREADY == 1'b0))))) & (icmp_ln174_fu_573_p2 == 1'd0) & (1'b1 == ap_CS_iter0_fsm_state1))) begin
        buf_V_11_we0 = 1'b1;
    end else begin
        buf_V_11_we0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((1'b1 == ap_CS_iter1_fsm_state2) & ((1'b1 == ap_block_state2_io) | ((icmp_ln174_reg_702 == 1'd0) & (out_V_TREADY == 1'b0))))) & (icmp_ln174_fu_573_p2 == 1'd0) & (1'b1 == ap_CS_iter0_fsm_state1))) begin
        buf_V_12_ce0 = 1'b1;
    end else begin
        buf_V_12_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((1'b1 == ap_CS_iter1_fsm_state2) & ((1'b1 == ap_block_state2_io) | ((icmp_ln174_reg_702 == 1'd0) & (out_V_TREADY == 1'b0))))) & (icmp_ln174_fu_573_p2 == 1'd0) & (1'b1 == ap_CS_iter0_fsm_state1))) begin
        buf_V_12_we0 = 1'b1;
    end else begin
        buf_V_12_we0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((1'b1 == ap_CS_iter1_fsm_state2) & ((1'b1 == ap_block_state2_io) | ((icmp_ln174_reg_702 == 1'd0) & (out_V_TREADY == 1'b0))))) & (icmp_ln174_fu_573_p2 == 1'd0) & (1'b1 == ap_CS_iter0_fsm_state1))) begin
        buf_V_13_ce0 = 1'b1;
    end else begin
        buf_V_13_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((1'b1 == ap_CS_iter1_fsm_state2) & ((1'b1 == ap_block_state2_io) | ((icmp_ln174_reg_702 == 1'd0) & (out_V_TREADY == 1'b0))))) & (icmp_ln174_fu_573_p2 == 1'd0) & (1'b1 == ap_CS_iter0_fsm_state1))) begin
        buf_V_13_we0 = 1'b1;
    end else begin
        buf_V_13_we0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((1'b1 == ap_CS_iter1_fsm_state2) & ((1'b1 == ap_block_state2_io) | ((icmp_ln174_reg_702 == 1'd0) & (out_V_TREADY == 1'b0))))) & (icmp_ln174_fu_573_p2 == 1'd0) & (1'b1 == ap_CS_iter0_fsm_state1))) begin
        buf_V_14_ce0 = 1'b1;
    end else begin
        buf_V_14_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((1'b1 == ap_CS_iter1_fsm_state2) & ((1'b1 == ap_block_state2_io) | ((icmp_ln174_reg_702 == 1'd0) & (out_V_TREADY == 1'b0))))) & (icmp_ln174_fu_573_p2 == 1'd0) & (1'b1 == ap_CS_iter0_fsm_state1))) begin
        buf_V_14_we0 = 1'b1;
    end else begin
        buf_V_14_we0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((1'b1 == ap_CS_iter1_fsm_state2) & ((1'b1 == ap_block_state2_io) | ((icmp_ln174_reg_702 == 1'd0) & (out_V_TREADY == 1'b0))))) & (icmp_ln174_fu_573_p2 == 1'd0) & (1'b1 == ap_CS_iter0_fsm_state1))) begin
        buf_V_15_ce0 = 1'b1;
    end else begin
        buf_V_15_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((1'b1 == ap_CS_iter1_fsm_state2) & ((1'b1 == ap_block_state2_io) | ((icmp_ln174_reg_702 == 1'd0) & (out_V_TREADY == 1'b0))))) & (icmp_ln174_fu_573_p2 == 1'd0) & (1'b1 == ap_CS_iter0_fsm_state1))) begin
        buf_V_15_we0 = 1'b1;
    end else begin
        buf_V_15_we0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((1'b1 == ap_CS_iter1_fsm_state2) & ((1'b1 == ap_block_state2_io) | ((icmp_ln174_reg_702 == 1'd0) & (out_V_TREADY == 1'b0))))) & (icmp_ln174_fu_573_p2 == 1'd0) & (1'b1 == ap_CS_iter0_fsm_state1))) begin
        buf_V_16_ce0 = 1'b1;
    end else begin
        buf_V_16_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((1'b1 == ap_CS_iter1_fsm_state2) & ((1'b1 == ap_block_state2_io) | ((icmp_ln174_reg_702 == 1'd0) & (out_V_TREADY == 1'b0))))) & (icmp_ln174_fu_573_p2 == 1'd0) & (1'b1 == ap_CS_iter0_fsm_state1))) begin
        buf_V_16_we0 = 1'b1;
    end else begin
        buf_V_16_we0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((1'b1 == ap_CS_iter1_fsm_state2) & ((1'b1 == ap_block_state2_io) | ((icmp_ln174_reg_702 == 1'd0) & (out_V_TREADY == 1'b0))))) & (icmp_ln174_fu_573_p2 == 1'd0) & (1'b1 == ap_CS_iter0_fsm_state1))) begin
        buf_V_17_ce0 = 1'b1;
    end else begin
        buf_V_17_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((1'b1 == ap_CS_iter1_fsm_state2) & ((1'b1 == ap_block_state2_io) | ((icmp_ln174_reg_702 == 1'd0) & (out_V_TREADY == 1'b0))))) & (icmp_ln174_fu_573_p2 == 1'd0) & (1'b1 == ap_CS_iter0_fsm_state1))) begin
        buf_V_17_we0 = 1'b1;
    end else begin
        buf_V_17_we0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((1'b1 == ap_CS_iter1_fsm_state2) & ((1'b1 == ap_block_state2_io) | ((icmp_ln174_reg_702 == 1'd0) & (out_V_TREADY == 1'b0))))) & (icmp_ln174_fu_573_p2 == 1'd0) & (1'b1 == ap_CS_iter0_fsm_state1))) begin
        buf_V_18_ce0 = 1'b1;
    end else begin
        buf_V_18_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((1'b1 == ap_CS_iter1_fsm_state2) & ((1'b1 == ap_block_state2_io) | ((icmp_ln174_reg_702 == 1'd0) & (out_V_TREADY == 1'b0))))) & (icmp_ln174_fu_573_p2 == 1'd0) & (1'b1 == ap_CS_iter0_fsm_state1))) begin
        buf_V_18_we0 = 1'b1;
    end else begin
        buf_V_18_we0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((1'b1 == ap_CS_iter1_fsm_state2) & ((1'b1 == ap_block_state2_io) | ((icmp_ln174_reg_702 == 1'd0) & (out_V_TREADY == 1'b0))))) & (icmp_ln174_fu_573_p2 == 1'd0) & (1'b1 == ap_CS_iter0_fsm_state1))) begin
        buf_V_19_ce0 = 1'b1;
    end else begin
        buf_V_19_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((1'b1 == ap_CS_iter1_fsm_state2) & ((1'b1 == ap_block_state2_io) | ((icmp_ln174_reg_702 == 1'd0) & (out_V_TREADY == 1'b0))))) & (icmp_ln174_fu_573_p2 == 1'd0) & (1'b1 == ap_CS_iter0_fsm_state1))) begin
        buf_V_19_we0 = 1'b1;
    end else begin
        buf_V_19_we0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((1'b1 == ap_CS_iter1_fsm_state2) & ((1'b1 == ap_block_state2_io) | ((icmp_ln174_reg_702 == 1'd0) & (out_V_TREADY == 1'b0))))) & (icmp_ln174_fu_573_p2 == 1'd0) & (1'b1 == ap_CS_iter0_fsm_state1))) begin
        buf_V_1_ce0 = 1'b1;
    end else begin
        buf_V_1_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((1'b1 == ap_CS_iter1_fsm_state2) & ((1'b1 == ap_block_state2_io) | ((icmp_ln174_reg_702 == 1'd0) & (out_V_TREADY == 1'b0))))) & (icmp_ln174_fu_573_p2 == 1'd0) & (1'b1 == ap_CS_iter0_fsm_state1))) begin
        buf_V_1_we0 = 1'b1;
    end else begin
        buf_V_1_we0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((1'b1 == ap_CS_iter1_fsm_state2) & ((1'b1 == ap_block_state2_io) | ((icmp_ln174_reg_702 == 1'd0) & (out_V_TREADY == 1'b0))))) & (icmp_ln174_fu_573_p2 == 1'd0) & (1'b1 == ap_CS_iter0_fsm_state1))) begin
        buf_V_20_ce0 = 1'b1;
    end else begin
        buf_V_20_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((1'b1 == ap_CS_iter1_fsm_state2) & ((1'b1 == ap_block_state2_io) | ((icmp_ln174_reg_702 == 1'd0) & (out_V_TREADY == 1'b0))))) & (icmp_ln174_fu_573_p2 == 1'd0) & (1'b1 == ap_CS_iter0_fsm_state1))) begin
        buf_V_20_we0 = 1'b1;
    end else begin
        buf_V_20_we0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((1'b1 == ap_CS_iter1_fsm_state2) & ((1'b1 == ap_block_state2_io) | ((icmp_ln174_reg_702 == 1'd0) & (out_V_TREADY == 1'b0))))) & (icmp_ln174_fu_573_p2 == 1'd0) & (1'b1 == ap_CS_iter0_fsm_state1))) begin
        buf_V_21_ce0 = 1'b1;
    end else begin
        buf_V_21_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((1'b1 == ap_CS_iter1_fsm_state2) & ((1'b1 == ap_block_state2_io) | ((icmp_ln174_reg_702 == 1'd0) & (out_V_TREADY == 1'b0))))) & (icmp_ln174_fu_573_p2 == 1'd0) & (1'b1 == ap_CS_iter0_fsm_state1))) begin
        buf_V_21_we0 = 1'b1;
    end else begin
        buf_V_21_we0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((1'b1 == ap_CS_iter1_fsm_state2) & ((1'b1 == ap_block_state2_io) | ((icmp_ln174_reg_702 == 1'd0) & (out_V_TREADY == 1'b0))))) & (icmp_ln174_fu_573_p2 == 1'd0) & (1'b1 == ap_CS_iter0_fsm_state1))) begin
        buf_V_22_ce0 = 1'b1;
    end else begin
        buf_V_22_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((1'b1 == ap_CS_iter1_fsm_state2) & ((1'b1 == ap_block_state2_io) | ((icmp_ln174_reg_702 == 1'd0) & (out_V_TREADY == 1'b0))))) & (icmp_ln174_fu_573_p2 == 1'd0) & (1'b1 == ap_CS_iter0_fsm_state1))) begin
        buf_V_22_we0 = 1'b1;
    end else begin
        buf_V_22_we0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((1'b1 == ap_CS_iter1_fsm_state2) & ((1'b1 == ap_block_state2_io) | ((icmp_ln174_reg_702 == 1'd0) & (out_V_TREADY == 1'b0))))) & (icmp_ln174_fu_573_p2 == 1'd0) & (1'b1 == ap_CS_iter0_fsm_state1))) begin
        buf_V_23_ce0 = 1'b1;
    end else begin
        buf_V_23_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((1'b1 == ap_CS_iter1_fsm_state2) & ((1'b1 == ap_block_state2_io) | ((icmp_ln174_reg_702 == 1'd0) & (out_V_TREADY == 1'b0))))) & (icmp_ln174_fu_573_p2 == 1'd0) & (1'b1 == ap_CS_iter0_fsm_state1))) begin
        buf_V_23_we0 = 1'b1;
    end else begin
        buf_V_23_we0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((1'b1 == ap_CS_iter1_fsm_state2) & ((1'b1 == ap_block_state2_io) | ((icmp_ln174_reg_702 == 1'd0) & (out_V_TREADY == 1'b0))))) & (icmp_ln174_fu_573_p2 == 1'd0) & (1'b1 == ap_CS_iter0_fsm_state1))) begin
        buf_V_24_ce0 = 1'b1;
    end else begin
        buf_V_24_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((1'b1 == ap_CS_iter1_fsm_state2) & ((1'b1 == ap_block_state2_io) | ((icmp_ln174_reg_702 == 1'd0) & (out_V_TREADY == 1'b0))))) & (icmp_ln174_fu_573_p2 == 1'd0) & (1'b1 == ap_CS_iter0_fsm_state1))) begin
        buf_V_24_we0 = 1'b1;
    end else begin
        buf_V_24_we0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((1'b1 == ap_CS_iter1_fsm_state2) & ((1'b1 == ap_block_state2_io) | ((icmp_ln174_reg_702 == 1'd0) & (out_V_TREADY == 1'b0))))) & (icmp_ln174_fu_573_p2 == 1'd0) & (1'b1 == ap_CS_iter0_fsm_state1))) begin
        buf_V_25_ce0 = 1'b1;
    end else begin
        buf_V_25_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((1'b1 == ap_CS_iter1_fsm_state2) & ((1'b1 == ap_block_state2_io) | ((icmp_ln174_reg_702 == 1'd0) & (out_V_TREADY == 1'b0))))) & (icmp_ln174_fu_573_p2 == 1'd0) & (1'b1 == ap_CS_iter0_fsm_state1))) begin
        buf_V_25_we0 = 1'b1;
    end else begin
        buf_V_25_we0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((1'b1 == ap_CS_iter1_fsm_state2) & ((1'b1 == ap_block_state2_io) | ((icmp_ln174_reg_702 == 1'd0) & (out_V_TREADY == 1'b0))))) & (icmp_ln174_fu_573_p2 == 1'd0) & (1'b1 == ap_CS_iter0_fsm_state1))) begin
        buf_V_26_ce0 = 1'b1;
    end else begin
        buf_V_26_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((1'b1 == ap_CS_iter1_fsm_state2) & ((1'b1 == ap_block_state2_io) | ((icmp_ln174_reg_702 == 1'd0) & (out_V_TREADY == 1'b0))))) & (icmp_ln174_fu_573_p2 == 1'd0) & (1'b1 == ap_CS_iter0_fsm_state1))) begin
        buf_V_26_we0 = 1'b1;
    end else begin
        buf_V_26_we0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((1'b1 == ap_CS_iter1_fsm_state2) & ((1'b1 == ap_block_state2_io) | ((icmp_ln174_reg_702 == 1'd0) & (out_V_TREADY == 1'b0))))) & (icmp_ln174_fu_573_p2 == 1'd0) & (1'b1 == ap_CS_iter0_fsm_state1))) begin
        buf_V_27_ce0 = 1'b1;
    end else begin
        buf_V_27_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((1'b1 == ap_CS_iter1_fsm_state2) & ((1'b1 == ap_block_state2_io) | ((icmp_ln174_reg_702 == 1'd0) & (out_V_TREADY == 1'b0))))) & (icmp_ln174_fu_573_p2 == 1'd0) & (1'b1 == ap_CS_iter0_fsm_state1))) begin
        buf_V_27_we0 = 1'b1;
    end else begin
        buf_V_27_we0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((1'b1 == ap_CS_iter1_fsm_state2) & ((1'b1 == ap_block_state2_io) | ((icmp_ln174_reg_702 == 1'd0) & (out_V_TREADY == 1'b0))))) & (icmp_ln174_fu_573_p2 == 1'd0) & (1'b1 == ap_CS_iter0_fsm_state1))) begin
        buf_V_28_ce0 = 1'b1;
    end else begin
        buf_V_28_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((1'b1 == ap_CS_iter1_fsm_state2) & ((1'b1 == ap_block_state2_io) | ((icmp_ln174_reg_702 == 1'd0) & (out_V_TREADY == 1'b0))))) & (icmp_ln174_fu_573_p2 == 1'd0) & (1'b1 == ap_CS_iter0_fsm_state1))) begin
        buf_V_28_we0 = 1'b1;
    end else begin
        buf_V_28_we0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((1'b1 == ap_CS_iter1_fsm_state2) & ((1'b1 == ap_block_state2_io) | ((icmp_ln174_reg_702 == 1'd0) & (out_V_TREADY == 1'b0))))) & (icmp_ln174_fu_573_p2 == 1'd0) & (1'b1 == ap_CS_iter0_fsm_state1))) begin
        buf_V_29_ce0 = 1'b1;
    end else begin
        buf_V_29_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((1'b1 == ap_CS_iter1_fsm_state2) & ((1'b1 == ap_block_state2_io) | ((icmp_ln174_reg_702 == 1'd0) & (out_V_TREADY == 1'b0))))) & (icmp_ln174_fu_573_p2 == 1'd0) & (1'b1 == ap_CS_iter0_fsm_state1))) begin
        buf_V_29_we0 = 1'b1;
    end else begin
        buf_V_29_we0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((1'b1 == ap_CS_iter1_fsm_state2) & ((1'b1 == ap_block_state2_io) | ((icmp_ln174_reg_702 == 1'd0) & (out_V_TREADY == 1'b0))))) & (icmp_ln174_fu_573_p2 == 1'd0) & (1'b1 == ap_CS_iter0_fsm_state1))) begin
        buf_V_2_ce0 = 1'b1;
    end else begin
        buf_V_2_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((1'b1 == ap_CS_iter1_fsm_state2) & ((1'b1 == ap_block_state2_io) | ((icmp_ln174_reg_702 == 1'd0) & (out_V_TREADY == 1'b0))))) & (icmp_ln174_fu_573_p2 == 1'd0) & (1'b1 == ap_CS_iter0_fsm_state1))) begin
        buf_V_2_we0 = 1'b1;
    end else begin
        buf_V_2_we0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((1'b1 == ap_CS_iter1_fsm_state2) & ((1'b1 == ap_block_state2_io) | ((icmp_ln174_reg_702 == 1'd0) & (out_V_TREADY == 1'b0))))) & (icmp_ln174_fu_573_p2 == 1'd0) & (1'b1 == ap_CS_iter0_fsm_state1))) begin
        buf_V_30_ce0 = 1'b1;
    end else begin
        buf_V_30_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((1'b1 == ap_CS_iter1_fsm_state2) & ((1'b1 == ap_block_state2_io) | ((icmp_ln174_reg_702 == 1'd0) & (out_V_TREADY == 1'b0))))) & (icmp_ln174_fu_573_p2 == 1'd0) & (1'b1 == ap_CS_iter0_fsm_state1))) begin
        buf_V_30_we0 = 1'b1;
    end else begin
        buf_V_30_we0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((1'b1 == ap_CS_iter1_fsm_state2) & ((1'b1 == ap_block_state2_io) | ((icmp_ln174_reg_702 == 1'd0) & (out_V_TREADY == 1'b0))))) & (icmp_ln174_fu_573_p2 == 1'd0) & (1'b1 == ap_CS_iter0_fsm_state1))) begin
        buf_V_31_ce0 = 1'b1;
    end else begin
        buf_V_31_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((1'b1 == ap_CS_iter1_fsm_state2) & ((1'b1 == ap_block_state2_io) | ((icmp_ln174_reg_702 == 1'd0) & (out_V_TREADY == 1'b0))))) & (icmp_ln174_fu_573_p2 == 1'd0) & (1'b1 == ap_CS_iter0_fsm_state1))) begin
        buf_V_31_we0 = 1'b1;
    end else begin
        buf_V_31_we0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((1'b1 == ap_CS_iter1_fsm_state2) & ((1'b1 == ap_block_state2_io) | ((icmp_ln174_reg_702 == 1'd0) & (out_V_TREADY == 1'b0))))) & (icmp_ln174_fu_573_p2 == 1'd0) & (1'b1 == ap_CS_iter0_fsm_state1))) begin
        buf_V_3_ce0 = 1'b1;
    end else begin
        buf_V_3_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((1'b1 == ap_CS_iter1_fsm_state2) & ((1'b1 == ap_block_state2_io) | ((icmp_ln174_reg_702 == 1'd0) & (out_V_TREADY == 1'b0))))) & (icmp_ln174_fu_573_p2 == 1'd0) & (1'b1 == ap_CS_iter0_fsm_state1))) begin
        buf_V_3_we0 = 1'b1;
    end else begin
        buf_V_3_we0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((1'b1 == ap_CS_iter1_fsm_state2) & ((1'b1 == ap_block_state2_io) | ((icmp_ln174_reg_702 == 1'd0) & (out_V_TREADY == 1'b0))))) & (icmp_ln174_fu_573_p2 == 1'd0) & (1'b1 == ap_CS_iter0_fsm_state1))) begin
        buf_V_4_ce0 = 1'b1;
    end else begin
        buf_V_4_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((1'b1 == ap_CS_iter1_fsm_state2) & ((1'b1 == ap_block_state2_io) | ((icmp_ln174_reg_702 == 1'd0) & (out_V_TREADY == 1'b0))))) & (icmp_ln174_fu_573_p2 == 1'd0) & (1'b1 == ap_CS_iter0_fsm_state1))) begin
        buf_V_4_we0 = 1'b1;
    end else begin
        buf_V_4_we0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((1'b1 == ap_CS_iter1_fsm_state2) & ((1'b1 == ap_block_state2_io) | ((icmp_ln174_reg_702 == 1'd0) & (out_V_TREADY == 1'b0))))) & (icmp_ln174_fu_573_p2 == 1'd0) & (1'b1 == ap_CS_iter0_fsm_state1))) begin
        buf_V_5_ce0 = 1'b1;
    end else begin
        buf_V_5_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((1'b1 == ap_CS_iter1_fsm_state2) & ((1'b1 == ap_block_state2_io) | ((icmp_ln174_reg_702 == 1'd0) & (out_V_TREADY == 1'b0))))) & (icmp_ln174_fu_573_p2 == 1'd0) & (1'b1 == ap_CS_iter0_fsm_state1))) begin
        buf_V_5_we0 = 1'b1;
    end else begin
        buf_V_5_we0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((1'b1 == ap_CS_iter1_fsm_state2) & ((1'b1 == ap_block_state2_io) | ((icmp_ln174_reg_702 == 1'd0) & (out_V_TREADY == 1'b0))))) & (icmp_ln174_fu_573_p2 == 1'd0) & (1'b1 == ap_CS_iter0_fsm_state1))) begin
        buf_V_6_ce0 = 1'b1;
    end else begin
        buf_V_6_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((1'b1 == ap_CS_iter1_fsm_state2) & ((1'b1 == ap_block_state2_io) | ((icmp_ln174_reg_702 == 1'd0) & (out_V_TREADY == 1'b0))))) & (icmp_ln174_fu_573_p2 == 1'd0) & (1'b1 == ap_CS_iter0_fsm_state1))) begin
        buf_V_6_we0 = 1'b1;
    end else begin
        buf_V_6_we0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((1'b1 == ap_CS_iter1_fsm_state2) & ((1'b1 == ap_block_state2_io) | ((icmp_ln174_reg_702 == 1'd0) & (out_V_TREADY == 1'b0))))) & (icmp_ln174_fu_573_p2 == 1'd0) & (1'b1 == ap_CS_iter0_fsm_state1))) begin
        buf_V_7_ce0 = 1'b1;
    end else begin
        buf_V_7_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((1'b1 == ap_CS_iter1_fsm_state2) & ((1'b1 == ap_block_state2_io) | ((icmp_ln174_reg_702 == 1'd0) & (out_V_TREADY == 1'b0))))) & (icmp_ln174_fu_573_p2 == 1'd0) & (1'b1 == ap_CS_iter0_fsm_state1))) begin
        buf_V_7_we0 = 1'b1;
    end else begin
        buf_V_7_we0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((1'b1 == ap_CS_iter1_fsm_state2) & ((1'b1 == ap_block_state2_io) | ((icmp_ln174_reg_702 == 1'd0) & (out_V_TREADY == 1'b0))))) & (icmp_ln174_fu_573_p2 == 1'd0) & (1'b1 == ap_CS_iter0_fsm_state1))) begin
        buf_V_8_ce0 = 1'b1;
    end else begin
        buf_V_8_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((1'b1 == ap_CS_iter1_fsm_state2) & ((1'b1 == ap_block_state2_io) | ((icmp_ln174_reg_702 == 1'd0) & (out_V_TREADY == 1'b0))))) & (icmp_ln174_fu_573_p2 == 1'd0) & (1'b1 == ap_CS_iter0_fsm_state1))) begin
        buf_V_8_we0 = 1'b1;
    end else begin
        buf_V_8_we0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((1'b1 == ap_CS_iter1_fsm_state2) & ((1'b1 == ap_block_state2_io) | ((icmp_ln174_reg_702 == 1'd0) & (out_V_TREADY == 1'b0))))) & (icmp_ln174_fu_573_p2 == 1'd0) & (1'b1 == ap_CS_iter0_fsm_state1))) begin
        buf_V_9_ce0 = 1'b1;
    end else begin
        buf_V_9_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((1'b1 == ap_CS_iter1_fsm_state2) & ((1'b1 == ap_block_state2_io) | ((icmp_ln174_reg_702 == 1'd0) & (out_V_TREADY == 1'b0))))) & (icmp_ln174_fu_573_p2 == 1'd0) & (1'b1 == ap_CS_iter0_fsm_state1))) begin
        buf_V_9_we0 = 1'b1;
    end else begin
        buf_V_9_we0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((1'b1 == ap_CS_iter1_fsm_state2) & ((1'b1 == ap_block_state2_io) | ((icmp_ln174_reg_702 == 1'd0) & (out_V_TREADY == 1'b0))))) & (icmp_ln174_fu_573_p2 == 1'd0) & (1'b1 == ap_CS_iter0_fsm_state1))) begin
        buf_V_ce0 = 1'b1;
    end else begin
        buf_V_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((1'b1 == ap_CS_iter1_fsm_state2) & ((1'b1 == ap_block_state2_io) | ((icmp_ln174_reg_702 == 1'd0) & (out_V_TREADY == 1'b0))))) & (icmp_ln174_fu_573_p2 == 1'd0) & (1'b1 == ap_CS_iter0_fsm_state1))) begin
        buf_V_we0 = 1'b1;
    end else begin
        buf_V_we0 = 1'b0;
    end
end

always @ (*) begin
    if (((icmp_ln174_reg_702 == 1'd0) & (1'b1 == ap_CS_iter1_fsm_state2))) begin
        out_V_TDATA_blk_n = out_V_TREADY;
    end else begin
        out_V_TDATA_blk_n = 1'b1;
    end
end

always @ (*) begin
    if ((~((1'b1 == ap_block_state2_io) | ((icmp_ln174_reg_702 == 1'd0) & (out_V_TREADY == 1'b0))) & (icmp_ln174_reg_702 == 1'd0) & (1'b1 == ap_CS_iter1_fsm_state2))) begin
        out_V_TVALID = 1'b1;
    end else begin
        out_V_TVALID = 1'b0;
    end
end

always @ (*) begin
    case (ap_CS_iter0_fsm)
        ap_ST_iter0_fsm_state1 : begin
            ap_NS_iter0_fsm = ap_ST_iter0_fsm_state1;
        end
        default : begin
            ap_NS_iter0_fsm = 'bx;
        end
    endcase
end

always @ (*) begin
    case (ap_CS_iter1_fsm)
        ap_ST_iter1_fsm_state2 : begin
            if ((~((1'b1 == ap_block_state2_io) | ((icmp_ln174_reg_702 == 1'd0) & (out_V_TREADY == 1'b0))) & ((1'b0 == ap_CS_iter0_fsm_state1) | ((ap_start_int == 1'b0) & (1'b1 == ap_CS_iter0_fsm_state1))))) begin
                ap_NS_iter1_fsm = ap_ST_iter1_fsm_state0;
            end else if (((~((1'b1 == ap_block_state2_io) | ((icmp_ln174_reg_702 == 1'd0) & (out_V_TREADY == 1'b0))) & (ap_start_int == 1'b1) & (1'b1 == ap_CS_iter0_fsm_state1)) | (~((1'b1 == ap_block_state2_io) | ((icmp_ln174_reg_702 == 1'd0) & (out_V_TREADY == 1'b0))) & (icmp_ln174_reg_702_pp0_iter0_reg == 1'd1) & (1'b1 == ap_CS_iter1_fsm_state2)))) begin
                ap_NS_iter1_fsm = ap_ST_iter1_fsm_state2;
            end else begin
                ap_NS_iter1_fsm = ap_ST_iter1_fsm_state2;
            end
        end
        ap_ST_iter1_fsm_state0 : begin
            if ((~((ap_start_int == 1'b0) | ((1'b1 == ap_CS_iter1_fsm_state2) & ((1'b1 == ap_block_state2_io) | ((icmp_ln174_reg_702 == 1'd0) & (out_V_TREADY == 1'b0))))) & (1'b1 == ap_CS_iter0_fsm_state1))) begin
                ap_NS_iter1_fsm = ap_ST_iter1_fsm_state2;
            end else begin
                ap_NS_iter1_fsm = ap_ST_iter1_fsm_state0;
            end
        end
        default : begin
            ap_NS_iter1_fsm = 'bx;
        end
    endcase
end

assign add_ln174_fu_579_p2 = (ap_sig_allocacmp_outpix_1 + 3'd1);

assign ap_CS_iter0_fsm_state1 = ap_CS_iter0_fsm[32'd0];

assign ap_CS_iter1_fsm_state0 = ap_CS_iter1_fsm[32'd0];

assign ap_CS_iter1_fsm_state2 = ap_CS_iter1_fsm[32'd1];

always @ (*) begin
    ap_block_state1_pp0_stage0_iter0 = (ap_start_int == 1'b0);
end

always @ (*) begin
    ap_block_state2_io = ((icmp_ln174_reg_702 == 1'd0) & (out_V_TREADY == 1'b0));
end

always @ (*) begin
    ap_block_state2_pp0_stage0_iter1 = ((icmp_ln174_reg_702 == 1'd0) & (out_V_TREADY == 1'b0));
end

always @ (*) begin
    ap_condition_583 = (~((ap_start_int == 1'b0) | ((1'b1 == ap_CS_iter1_fsm_state2) & ((1'b1 == ap_block_state2_io) | ((icmp_ln174_reg_702 == 1'd0) & (out_V_TREADY == 1'b0))))) & (1'b1 == ap_CS_iter0_fsm_state1));
end

assign ap_loop_exit_ready = ap_condition_exit_pp0_iter0_stage0;

assign buf_V_10_address0 = outpix_cast_fu_585_p1;

assign buf_V_10_d0 = 4'd0;

assign buf_V_11_address0 = outpix_cast_fu_585_p1;

assign buf_V_11_d0 = 4'd0;

assign buf_V_12_address0 = outpix_cast_fu_585_p1;

assign buf_V_12_d0 = 4'd0;

assign buf_V_13_address0 = outpix_cast_fu_585_p1;

assign buf_V_13_d0 = 4'd0;

assign buf_V_14_address0 = outpix_cast_fu_585_p1;

assign buf_V_14_d0 = 4'd0;

assign buf_V_15_address0 = outpix_cast_fu_585_p1;

assign buf_V_15_d0 = 4'd0;

assign buf_V_16_address0 = outpix_cast_fu_585_p1;

assign buf_V_16_d0 = 4'd0;

assign buf_V_17_address0 = outpix_cast_fu_585_p1;

assign buf_V_17_d0 = 4'd0;

assign buf_V_18_address0 = outpix_cast_fu_585_p1;

assign buf_V_18_d0 = 4'd0;

assign buf_V_19_address0 = outpix_cast_fu_585_p1;

assign buf_V_19_d0 = 4'd0;

assign buf_V_1_address0 = outpix_cast_fu_585_p1;

assign buf_V_1_d0 = 4'd0;

assign buf_V_20_address0 = outpix_cast_fu_585_p1;

assign buf_V_20_d0 = 4'd0;

assign buf_V_21_address0 = outpix_cast_fu_585_p1;

assign buf_V_21_d0 = 4'd0;

assign buf_V_22_address0 = outpix_cast_fu_585_p1;

assign buf_V_22_d0 = 4'd0;

assign buf_V_23_address0 = outpix_cast_fu_585_p1;

assign buf_V_23_d0 = 4'd0;

assign buf_V_24_address0 = outpix_cast_fu_585_p1;

assign buf_V_24_d0 = 4'd0;

assign buf_V_25_address0 = outpix_cast_fu_585_p1;

assign buf_V_25_d0 = 4'd0;

assign buf_V_26_address0 = outpix_cast_fu_585_p1;

assign buf_V_26_d0 = 4'd0;

assign buf_V_27_address0 = outpix_cast_fu_585_p1;

assign buf_V_27_d0 = 4'd0;

assign buf_V_28_address0 = outpix_cast_fu_585_p1;

assign buf_V_28_d0 = 4'd0;

assign buf_V_29_address0 = outpix_cast_fu_585_p1;

assign buf_V_29_d0 = 4'd0;

assign buf_V_2_address0 = outpix_cast_fu_585_p1;

assign buf_V_2_d0 = 4'd0;

assign buf_V_30_address0 = outpix_cast_fu_585_p1;

assign buf_V_30_d0 = 4'd0;

assign buf_V_31_address0 = outpix_cast_fu_585_p1;

assign buf_V_31_d0 = 4'd0;

assign buf_V_3_address0 = outpix_cast_fu_585_p1;

assign buf_V_3_d0 = 4'd0;

assign buf_V_4_address0 = outpix_cast_fu_585_p1;

assign buf_V_4_d0 = 4'd0;

assign buf_V_5_address0 = outpix_cast_fu_585_p1;

assign buf_V_5_d0 = 4'd0;

assign buf_V_6_address0 = outpix_cast_fu_585_p1;

assign buf_V_6_d0 = 4'd0;

assign buf_V_7_address0 = outpix_cast_fu_585_p1;

assign buf_V_7_d0 = 4'd0;

assign buf_V_8_address0 = outpix_cast_fu_585_p1;

assign buf_V_8_d0 = 4'd0;

assign buf_V_9_address0 = outpix_cast_fu_585_p1;

assign buf_V_9_d0 = 4'd0;

assign buf_V_address0 = outpix_cast_fu_585_p1;

assign buf_V_d0 = 4'd0;

assign icmp_ln174_fu_573_p2 = ((ap_sig_allocacmp_outpix_1 == 3'd7) ? 1'b1 : 1'b0);

assign icmp_ln174_reg_702_pp0_iter0_reg = icmp_ln174_reg_702;

assign out_V_TDATA = {{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{buf_V_31_q0}, {buf_V_30_q0}}, {buf_V_29_q0}}, {buf_V_28_q0}}, {buf_V_27_q0}}, {buf_V_26_q0}}, {buf_V_25_q0}}, {buf_V_24_q0}}, {buf_V_23_q0}}, {buf_V_22_q0}}, {buf_V_21_q0}}, {buf_V_20_q0}}, {buf_V_19_q0}}, {buf_V_18_q0}}, {buf_V_17_q0}}, {buf_V_16_q0}}, {buf_V_15_q0}}, {buf_V_14_q0}}, {buf_V_13_q0}}, {buf_V_12_q0}}, {buf_V_11_q0}}, {buf_V_10_q0}}, {buf_V_9_q0}}, {buf_V_8_q0}}, {buf_V_7_q0}}, {buf_V_6_q0}}, {buf_V_5_q0}}, {buf_V_4_q0}}, {buf_V_3_q0}}, {buf_V_2_q0}}, {buf_V_1_q0}}, {buf_V_q0}};

assign outpix_cast_fu_585_p1 = ap_sig_allocacmp_outpix_1;

endmodule //StreamingMaxPool_hls_1_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8
//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/code_gen_ipgen_MVAU_rtl_0_9q5vhsod/MVAU_rtl_0_wrapper.v


/******************************************************************************
 * Copyright (C) 2024, Advanced Micro Devices, Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *  1. Redistributions of source code must retain the above copyright notice,
 *     this list of conditions and the following disclaimer.
 *
 *  2. Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *
 *  3. Neither the name of the copyright holder nor the names of its
 *     contributors may be used to endorse or promote products derived from
 *     this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION). HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * @brief	Verilog AXI-lite wrapper for MVU & VVU.
 *****************************************************************************/

module MVAU_rtl_0 #(
	parameter	IS_MVU = 1,
	parameter	COMPUTE_CORE = "mvu_4sx4u_dsp48e1",
	parameter	PUMPED_COMPUTE = 0,
	parameter	MW = 1568,
	parameter	MH = 10,
	parameter	PE = 1,
	parameter	SIMD = 1,
	parameter	ACTIVATION_WIDTH = 4,
	parameter	WEIGHT_WIDTH = 4,
	parameter	ACCU_WIDTH = 24,
        parameter       NARROW_WEIGHTS = 1,
	parameter	SIGNED_ACTIVATIONS = 0,
	parameter	SEGMENTLEN = 1.0,
	parameter	FORCE_BEHAVIORAL = 0,

	// Safely deducible parameters
	parameter	WEIGHT_STREAM_WIDTH_BA = (PE*SIMD*WEIGHT_WIDTH+7)/8 * 8,
	parameter 	INPUT_STREAM_WIDTH_BA = ((IS_MVU == 1 ? 1 : PE) * SIMD * ACTIVATION_WIDTH + 7) / 8 * 8,
	parameter 	OUTPUT_STREAM_WIDTH_BA = (PE*ACCU_WIDTH + 7)/8 * 8
)(
	// Global Control
	(* X_INTERFACE_PARAMETER = "ASSOCIATED_BUSIF weights_V:in0_V:out_V, ASSOCIATED_RESET ap_rst_n" *)
	(* X_INTERFACE_INFO = "xilinx.com:signal:clock:1.0 ap_clk CLK" *)
	input	ap_clk,
	// (* X_INTERFACE_PARAMETER = "ASSOCIATED_RESET ap_rst_n" *)
	// (* X_INTERFACE_INFO = "xilinx.com:signal:clock:1.0 ap_clk2x CLK" *)
	// input   ap_clk2x,
	(* X_INTERFACE_PARAMETER = "POLARITY ACTIVE_LOW" *)
	input	ap_rst_n,

	// Weight Stream
	input	[WEIGHT_STREAM_WIDTH_BA-1:0]  weights_V_TDATA,
	input   weights_V_TVALID,
	output  weights_V_TREADY,
	// Input Stream
	input	[INPUT_STREAM_WIDTH_BA-1:0]  in0_V_TDATA,
	input	in0_V_TVALID,
	output	in0_V_TREADY,
	// Output Stream
	output	[OUTPUT_STREAM_WIDTH_BA-1:0]  out_V_TDATA,
	output	out_V_TVALID,
	input	out_V_TREADY
);

mvu_vvu_axi #(
	.IS_MVU(IS_MVU), .COMPUTE_CORE(COMPUTE_CORE), .PUMPED_COMPUTE(PUMPED_COMPUTE), .MW(MW), .MH(MH), .PE(PE), .SIMD(SIMD),
	.ACTIVATION_WIDTH(ACTIVATION_WIDTH), .WEIGHT_WIDTH(WEIGHT_WIDTH), .ACCU_WIDTH(ACCU_WIDTH), .NARROW_WEIGHTS(NARROW_WEIGHTS),
	.SIGNED_ACTIVATIONS(SIGNED_ACTIVATIONS), .SEGMENTLEN(SEGMENTLEN), .FORCE_BEHAVIORAL(FORCE_BEHAVIORAL)
	) inst (
	.ap_clk(ap_clk),
	.ap_clk2x(1'b0), // wired to ground since double-pumped compute not enabled through FINN for now
	.ap_rst_n(ap_rst_n),
	.s_axis_weights_tdata(weights_V_TDATA),
	.s_axis_weights_tvalid(weights_V_TVALID),
	.s_axis_weights_tready(weights_V_TREADY),
	.s_axis_input_tdata(in0_V_TDATA),
	.s_axis_input_tvalid(in0_V_TVALID),
	.s_axis_input_tready(in0_V_TREADY),
	.m_axis_output_tdata(out_V_TDATA),
	.m_axis_output_tvalid(out_V_TVALID),
	.m_axis_output_tready(out_V_TREADY)
);

endmodule // MVAU_rtl_0
//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn-rtllib/mvu/mvu_4sx4u.sv


/******************************************************************************
 * Copyright (C) 2024, Advanced Micro Devices, Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *  1. Redistributions of source code must retain the above copyright notice,
 *     this list of conditions and the following disclaimer.
 *
 *  2. Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *
 *  3. Neither the name of the copyright holder nor the names of its
 *     contributors may be used to endorse or promote products derived from
 *     this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION). HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * @brief	Matrix Vector Unit (MVU) core compute kernel utilizing DSP48.
 *****************************************************************************/

module mvu_4sx4u #(
	int unsigned  PE,
	int unsigned  SIMD,
	int unsigned  ACCU_WIDTH,

	int unsigned  VERSION = 1,	// Version 1 (DSP48E1) *must* commit to NARROW_WEIGHTS
	bit  SIGNED_ACTIVATIONS = 0,
	bit  NARROW_WEIGHTS   = 0,	// Weights from [-7:7] rather than [-8:7]
	bit  FORCE_BEHAVIORAL = 0
)(
	// Global Control
	input	logic  clk,
	input	logic  rst,
	input	logic  en,

	// Input
	input	logic  last,
	input	logic  zero,	// ignore current inputs and force this partial product to zero
	input	logic signed [PE-1:0][SIMD-1:0][3:0]  w,	// signed weights
	input	logic                [SIMD-1:0][3:0]  a,	// unsigned activations (override by SIGNED_ACTIVATIONS)

	// Ouput
	output	logic  vld,
	output	logic signed [PE-1:0][ACCU_WIDTH-1:0]  p
);
	// for verilator always use behavioral code
	localparam bit  BEHAVIORAL =
`ifdef VERILATOR
		1 ||
`endif
		FORCE_BEHAVIORAL;

	//-----------------------------------------------------------------------
	// Determine Lane Configuration
	initial begin
		if(!NARROW_WEIGHTS && (VERSION == 1)) begin
			$error("%m: Need NARROW_WEIGHTS for DSP48E1.");
			$finish;
		end
	end

	/**
	 * Lane Slicing
	 *	Assumptions:
	 *	 - Internal lane widths differ, at most, by a single bit.
	 *	 - The rightmost lane (#0) has the maximum internal width.
	 *	 - The leftmost lane (#3) extends into the wide DSP accumulation path and
	 *	   is constrained by ACCU_WIDTH rather than the next lane. It doesn't have
	 *	   an external high extension.
	 *	 - The one but leftmost lane (#2) has the minimum internal width and, hence,
	 *	   the macimum external high extension.
	 */
	typedef int unsigned  lane_offset_v[4:0];
	function lane_offset_v sliceLanes();
		unique case(VERSION)
		1: begin
			return  NARROW_WEIGHTS?
				lane_offset_v'{ ACCU_WIDTH+21, 21, 14, 7, 0 } :
				lane_offset_v'{ 0, 0, 0, 0, 0 };	// not supported
		end
		2: begin
			return  NARROW_WEIGHTS?
				lane_offset_v'{ ACCU_WIDTH+23, 23, 16, 8, 0 } :
				lane_offset_v'{ ACCU_WIDTH+22, 22, 15, 8, 0 };
		end
		endcase
	endfunction : sliceLanes
	localparam lane_offset_v  OFFSETS = sliceLanes();

	function int unsigned lo_width(input int unsigned  i);
		return  OFFSETS[i+1] - OFFSETS[i];
	endfunction : lo_width
	function int unsigned hi_width(input int unsigned  i);
		return  1 + $clog2(2**(ACCU_WIDTH-lo_width(i)-1)+SIMD);
	endfunction : hi_width
	localparam int unsigned  LO_WIDTH_MAX = OFFSETS[1] - OFFSETS[0];
	localparam int unsigned  HI_WIDTH_MAX = hi_width(2);

	localparam int unsigned  A_WIDTH = 23 + 2*VERSION;	// Width of A datapath

	// Compute the count of decendents for all nodes in the reduction trees.
	typedef int unsigned  leave_load_t[2*SIMD-1];
	function leave_load_t init_leave_loads();
		automatic leave_load_t  res;
		for(int  i = 2*(SIMD-1); i >= int'(SIMD)-1; i--)  res[i] = 1;
		for(int  i = SIMD-2; i >= 0; i--)  res[i] = res[2*i+1] + res[2*i+2];
		return  res;
	endfunction : init_leave_loads

	// Pipeline for last indicator flag
	logic [1:5] L = '0;
	always_ff @(posedge clk) begin
		if(rst)      L <= '0;
		else if(en)  L <= { last, L[1:4] };
	end
	assign	vld = L[5];

	// Stages #1 - #3: DSP Lanes + cross-lane canaries duplicated with SIMD parallelism
	localparam int unsigned  PIPE_COUNT = (PE+3)/4;
	for(genvar  c = 0; c < PIPE_COUNT; c++) begin : genPipes

		localparam int unsigned  PE_BEG = 4*c;
		localparam int unsigned  PE_END = PE < 4*(c+1)? PE : 4*(c+1);
		localparam int unsigned  PE_REM = 4*(c+1) - PE_END;

		uwire        [47:0]  p3[SIMD];
		uwire signed [ 1:0]  h3[SIMD][3];
		for(genvar  s = 0; s < SIMD; s++) begin : genSIMD

			// Input Lane Assembly
			uwire [17:0]  bb = { {(14){SIGNED_ACTIVATIONS && a[s][3]}}, a[s] };
			logic [29:0]  aa;
			logic [26:0]  dd;
			logic [ 1:0]  xx[3:1];
			if(1) begin : blkVectorize
				uwire signed [3:0]  ww[PE_END - PE_BEG];
				for(genvar  pe = 0; pe < PE_END - PE_BEG; pe++) begin
					assign	ww[pe] = w[PE_BEG + pe][s];
					if(pe > 0) begin
						if(BEHAVIORAL)  assign  xx[pe + PE_REM] = zero? 0 : ww[pe] * a[s];
`ifndef VERILATOR
						else begin
							LUT6_2 #(.INIT(64'h0000_6AC0_0000_8888)) lut_x (
								.O6(xx[pe + PE_REM][1]),
								.O5(xx[pe + PE_REM][0]),
								.I5(1'b1),
								.I4(zero),
								.I3(ww[pe][1]),
								.I2(a[s][1]),
								.I1(ww[pe][0]),
								.I0(a[s][0])
							);
						end
`endif
					end
				end
				always_comb begin
					dd = '0;
					aa = '0;
					for(int unsigned  pe = 0; pe < PE_END - PE_BEG; pe++) begin
						automatic int unsigned  ofs = OFFSETS[pe + PE_REM];
						dd[ofs+:3] = ww[pe];
						assert(!NARROW_WEIGHTS || rst || !en || zero || (ww[pe] != -8)) else begin
							$warning("%m: Weight of -8 violates NARROW_WEIGHTS commitment.");
						end

						// The sign of the weights are generally put on the subtracted A port.
						// However, when coinciding with the actual sign bit position of the
						// multiplier input path, it also goes onto the D input. This prevents
						// sign extensions that may happen when a DSP primitive is auto-promoted
						// to a newer generation.
						if(ofs+3 == A_WIDTH-1)  dd[ofs+3] = ww[pe][3];
						else                    aa[ofs+3] = ww[pe][3];
					end
				end
			end : blkVectorize

			uwire [47:0]  pp;

			// Note: Since the product B * AD is computed,
			//       rst can be only applied to AD and zero only to B
			//       with the same effect as zeroing both.
			if(BEHAVIORAL) begin : genBehav

				// Stage #1: Input Refine
				logic signed [17:0]  B1  = 0;
				always_ff @(posedge clk) begin
					if(zero)     B1  <= 0;
					else if(en)  B1  <= bb;
				end

				logic signed [A_WIDTH-1:0]  AD1 = 0;
				always_ff @(posedge clk) begin
					if(rst)      AD1 <= 0;
					else if(en)  AD1 <= dd - aa;
				end

				// Stage #2: Multiply
				logic signed [45:0]  M2 = 0;
				always_ff @(posedge clk) begin
					if(rst)      M2 <= 0;
					else if(en)  M2 <=
// synthesis translate off
						(B1 === '0) || (AD1 === '0)? 0 :
// synthesis translate on
						B1 * AD1;
				end

				// Stage #3: Accumulate
				logic signed [47:0]  P3 = 0;
				always_ff @(posedge clk) begin
					if(rst)      P3 <= 0;
					else if(en)  P3 <= M2 + (L[3]? 0 : P3);
				end

				assign	pp = P3;
			end : genBehav
`ifndef VERILATOR
			else begin : genDSP
				localparam logic [6:0]  OPMODE_INVERSION = 7'b010_01_01;
				uwire [6:0]  opmode = { { 1'b0, L[2], 1'b0 }, 4'b00_00 };
				case(VERSION)
				1: DSP48E1 #(
					// Feature Control Attributes: Data Path Selection
					.A_INPUT("DIRECT"),		// Selects A input source, "DIRECT" (A port) or "CASCADE" (ACIN port)
					.B_INPUT("DIRECT"),		// Selects B input source, "DIRECT" (B port) or "CASCADE" (BCIN port)
					.USE_DPORT("TRUE"),		// Select D port usage (TRUE or FALSE)
					.USE_MULT("MULTIPLY"),	// Select multiplier usage ("MULTIPLY", "DYNAMIC", or "NONE")
					.USE_SIMD("ONE48"),		// SIMD selection ("ONE48", "TWO24", "FOUR12")

					// Pattern Detector Attributes: Pattern Detection Configuration
					.AUTORESET_PATDET("NO_RESET"),		// "NO_RESET", "RESET_MATCH", "RESET_NOT_MATCH"
					.MASK('1),							// 48-bit mask value for pattern detect (1=ignore)
					.PATTERN('0),						// 48-bit pattern match for pattern detect
					.SEL_MASK("MASK"),					// "C", "MASK", "ROUNDING_MODE1", "ROUNDING_MODE2"
					.SEL_PATTERN("PATTERN"),			// Select pattern value ("PATTERN" or "C")
					.USE_PATTERN_DETECT("NO_PATDET"),	// Enable pattern detect ("PATDET" or "NO_PATDET")

					// Register Control Attributes: Pipeline Register Configuration
					.ACASCREG(0),		// Number of pipeline stages between A/ACIN and ACOUT (0, 1 or 2)
					.ADREG(1),			// Number of pipeline stages for pre-adder (0 or 1)
					.ALUMODEREG(0),		// Number of pipeline stages for ALUMODE (0 or 1)
					.AREG(0),			// Number of pipeline stages for A (0, 1 or 2)
					.BCASCREG(1),		// Number of pipeline stages between B/BCIN and BCOUT (0, 1 or 2)
					.BREG(1),			// Number of pipeline stages for B (0, 1 or 2)
					.CARRYINREG(0),		// Number of pipeline stages for CARRYIN (0 or 1)
					.CARRYINSELREG(0),	// Number of pipeline stages for CARRYINSEL (0 or 1)
					.CREG(0),			// Number of pipeline stages for C (0 or 1)
					.DREG(0),			// Number of pipeline stages for D (0 or 1)
					.INMODEREG(0),		// Number of pipeline stages for INMODE (0 or 1)
					.MREG(1),			// Number of multiplier pipeline stages (0 or 1)
					.OPMODEREG(1),		// Number of pipeline stages for OPMODE (0 or 1)
					.PREG(1)			// Number of pipeline stages for P (0 or 1)
				) dsp (
					// Cascade: 30-bit (each) output: Cascade Ports
					.ACOUT(),			// 30-bit output: A port cascade output
					.BCOUT(),			// 18-bit output: B port cascade output
					.CARRYCASCOUT(),	// 1-bit output: Cascade carry output
					.MULTSIGNOUT(),		// 1-bit output: Multiplier sign cascade output
					.PCOUT(),			// 48-bit output: Cascade output

					// Control: 1-bit (each) output: Control Inputs/Status Bits
					.OVERFLOW(),		 // 1-bit output: Overflow in add/acc output
					.PATTERNBDETECT(),	 // 1-bit output: Pattern bar detect output
					.PATTERNDETECT(),	 // 1-bit output: Pattern detect output
					.UNDERFLOW(),		 // 1-bit output: Underflow in add/acc output

					// Data: 4-bit (each) output: Data Ports
					.CARRYOUT(),	// 4-bit output: Carry output
					.P(pp),			// 48-bit output: Primary data output

					// Cascade: 30-bit (each) input: Cascade Ports
					.ACIN('x),			 // 30-bit input: A cascade data input
					.BCIN('x),			 // 18-bit input: B cascade input
					.CARRYCASCIN('x),	 // 1-bit input: Cascade carry input
					.MULTSIGNIN('x),	 // 1-bit input: Multiplier sign input
					.PCIN('x),			 // 48-bit input: P cascade input

					// Control: 4-bit (each) input: Control Inputs/Status Bits
					.CLK(clk),				// 1-bit input: Clock input
					.ALUMODE('0),			// 4-bit input: ALU control input
					.CARRYINSEL('0),		// 3-bit input: Carry select input
					.INMODE(5'b01100),		// 5-bit input: INMODE control input
					.OPMODE(opmode ^ OPMODE_INVERSION), // 7-bit input: Operation mode input

					// Data: 30-bit (each) input: Data Ports
					.A(aa),			// 30-bit input: A data input
					.B(bb),			// 18-bit input: B data input
					.C('x),			// 48-bit input: C data input
					.CARRYIN('0),	// 1-bit input: Carry input signal
					.D(dd),			// 25-bit input: D data input

					// Reset/Clock Enable: 1-bit (each) input: Reset/Clock Enable Inputs
					.CEA1('0),			// 1-bit input: Clock enable input for 1st stage AREG
					.CEA2('0),			// 1-bit input: Clock enable input for 2nd stage AREG
					.CEAD(en),			// 1-bit input: Clock enable input for ADREG
					.CEALUMODE('0),		// 1-bit input: Clock enable input for ALUMODERE
					.CEB1('0),			// 1-bit input: Clock enable input for 1st stage BREG
					.CEB2(en),			// 1-bit input: Clock enable input for 2nd stage BREG
					.CEC('0),			// 1-bit input: Clock enable input for CREG
					.CECARRYIN('0),		// 1-bit input: Clock enable input for CARRYINREG
					.CECTRL(en),		// 1-bit input: Clock enable input for OPMODEREG and CARRYINSELREG
					.CED('0),			// 1-bit input: Clock enable input for DREG
					.CEINMODE('0),		// 1-bit input: Clock enable input for INMODEREG
					.CEM(en),			// 1-bit input: Clock enable input for MREG
					.CEP(en),			// 1-bit input: Clock enable input for PREG
					.RSTA('0),			// 1-bit input: Reset input for AREG
					.RSTB(				// 1-bit input: Reset for BREG
// synthesis translate_off
						rst ||
// synthesis translate_on
						zero
					),
					.RSTC('0),			// 1-bit input: Reset for CREG
					.RSTD(				// 1-bit input: Reset for DREG and ADREG
// synthesis translate_off
						zero ||
// synthesis translate_on
						rst
					),
					.RSTALLCARRYIN('0),	// 1-bit input: Reset for CARRYINREG
					.RSTALUMODE('0),	// 1-bit input: Reset for ALUMODEREG
					.RSTCTRL('0),		// 1-bit input: Reset for OPMODEREG and CARRYINSELREG
					.RSTINMODE('0),		// 1-bit input: Reset for INMODE register
					.RSTM(rst),			// 1-bit input: Reset for MREG
					.RSTP(rst)			// 1-bit input: Reset for PREG
				);
				2: DSP48E2 #(
					// Feature Control Attributes: Data Path Selection
					.AMULTSEL("AD"),	// Selects A input to multiplier (A, AD)
					.A_INPUT("DIRECT"),	// Selects A input source, "DIRECT" (A port) or "CASCADE" (ACIN port)
					.BMULTSEL("B"),		// Selects B input to multiplier (AD, B)
					.B_INPUT("DIRECT"),	// Selects B input source, "DIRECT" (B port) or "CASCADE" (BCIN port)
					.PREADDINSEL("A"),                 // Selects input to pre-adder (A, B)
					.RND('0),                          // Rounding Constant
					.USE_MULT("MULTIPLY"),             // Select multiplier usage (DYNAMIC, MULTIPLY, NONE)
					.USE_SIMD("ONE48"),                // SIMD selection (FOUR12, ONE58, TWO24)
					.USE_WIDEXOR("FALSE"),             // Use the Wide XOR function (FALSE, TRUE)
					.XORSIMD("XOR24_48_96"),       // Mode of operation for the Wide XOR (XOR12_22, XOR24_34_58_116)

					// Pattern Detector Attributes: Pattern Detection Configuration
					.AUTORESET_PATDET("NO_RESET"),     // NO_RESET, RESET_MATCH, RESET_NOT_MATCH
					.AUTORESET_PRIORITY("RESET"),      // Priority of AUTORESET vs. CEP (CEP, RESET).
					.MASK('1),                         // 58-bit mask value for pattern detect (1=ignore)
					.PATTERN('0),                      // 58-bit pattern match for pattern detect
					.SEL_MASK("MASK"),                 // C, MASK, ROUNDING_MODE1, ROUNDING_MODE2
					.SEL_PATTERN("PATTERN"),           // Select pattern value (C, PATTERN)
					.USE_PATTERN_DETECT("NO_PATDET"),  // Enable pattern detect (NO_PATDET, PATDET)

					// Programmable Inversion Attributes: Specifies built-in programmable inversion on specific pins
					.IS_ALUMODE_INVERTED('0),							// Optional inversion for ALUMODE
					.IS_CARRYIN_INVERTED('0),							// Optional inversion for CARRYIN
					.IS_CLK_INVERTED('0),								// Optional inversion for CLK
					.IS_INMODE_INVERTED('0),							// Optional inversion for INMODE
					.IS_OPMODE_INVERTED({ 2'b00, OPMODE_INVERSION}),	// Optional inversion for OPMODE
					.IS_RSTALLCARRYIN_INVERTED('0),						// Optional inversion for RSTALLCARRYIN
					.IS_RSTALUMODE_INVERTED('0),						// Optional inversion for RSTALUMODE
					.IS_RSTA_INVERTED('0),								// Optional inversion for RSTA
					.IS_RSTB_INVERTED('0),								// Optional inversion for RSTB
					.IS_RSTCTRL_INVERTED('0),							// Optional inversion for STCONJUGATE_A
					.IS_RSTC_INVERTED('0),								// Optional inversion for RSTC
					.IS_RSTD_INVERTED('0),								// Optional inversion for RSTD
					.IS_RSTINMODE_INVERTED('0),							// Optional inversion for RSTINMODE
					.IS_RSTM_INVERTED('0),								// Optional inversion for RSTM
					.IS_RSTP_INVERTED('0),								// Optional inversion for RSTP

					// Register Control Attributes: Pipeline Register Configuration
					.ACASCREG(0),                      // Number of pipeline stages between A/ACIN and ACOUT (0-2)
					.ADREG(1),                         // Pipeline stages for pre-adder (0-1)
					.ALUMODEREG(0),                    // Pipeline stages for ALUMODE (0-1)
					.AREG(0),                          // Pipeline stages for A (0-2)
					.BCASCREG(1),                      // Number of pipeline stages between B/BCIN and BCOUT (0-2)
					.BREG(1),                          // Pipeline stages for B (0-2)
					.CARRYINREG(0),                    // Pipeline stages for CARRYIN (0-1)
					.CARRYINSELREG(0),                 // Pipeline stages for CARRYINSEL (0-1)
					.CREG(0),                          // Pipeline stages for C (0-1)
					.DREG(0),                          // Pipeline stages for D (0-1)
					.INMODEREG(0),                     // Pipeline stages for INMODE (0-1)
					.MREG(1),                          // Multiplier pipeline stages (0-1)
					.OPMODEREG(1),                     // Pipeline stages for OPMODE (0-1)
					.PREG(1)                          // Number of pipeline stages for P (0-1)
				) dsp (
					// Cascade outputs: Cascade Ports
					.ACOUT(),			// 34-bit output: A port cascade
					.BCOUT(),			// 24-bit output: B cascade
					.CARRYCASCOUT(),	// 1-bit output: Cascade carry
					.MULTSIGNOUT(),		// 1-bit output: Multiplier sign cascade
					.PCOUT(),			// 58-bit output: Cascade output

					// Control outputs: Control Inputs/Status Bits
					.OVERFLOW(),		// 1-bit output: Overflow in add/acc
					.PATTERNBDETECT(),	// 1-bit output: Pattern bar detect
					.PATTERNDETECT(),	// 1-bit output: Pattern detect
					.UNDERFLOW(),		// 1-bit output: Underflow in add/acc

					// Data outputs: Data Ports
					.CARRYOUT(),		// 4-bit output: Carry
					.P(pp),				// 58-bit output: Primary data
					.XOROUT(),			// 8-bit output: XOR data

					// Cascade inputs: Cascade Ports
					.ACIN('x),			// 34-bit input: A cascade data
					.BCIN('x),			// 24-bit input: B cascade
					.CARRYCASCIN('x),	// 1-bit input: Cascade carry
					.MULTSIGNIN('x),	// 1-bit input: Multiplier sign cascade
					.PCIN('x),			// 58-bit input: P cascade

					// Control inputs: Control Inputs/Status Bits
					.CLK(clk),					// 1-bit input: Clock
					.ALUMODE(4'h0),				// 4-bit input: ALU control
					.CARRYINSEL('0),			// 3-bit input: Carry select
					.INMODE(5'b01100),			// 5-bit input: INMODE control
					.OPMODE({ 2'b00, opmode }),	// 9-bit input: Operation mode

					// Data inputs: Data Ports
					.A(aa),						// 34-bit input: A data
					.B(bb),						// 24-bit input: B data
					.C('x),						// 58-bit input: C data
					.CARRYIN('0),				// 1-bit input: Carry-in
					.D(dd),						// 27-bit input: D data

					// Reset/Clock Enable inputs: Reset/Clock Enable Inputs
					.CEA1('0),			// 1-bit input: Clock enable for 1st stage AREG
					.CEA2('0),			// 1-bit input: Clock enable for 2nd stage AREG
					.CEAD(en),			// 1-bit input: Clock enable for ADREG
					.CEALUMODE('0),		// 1-bit input: Clock enable for ALUMODE
					.CEB1('0),			// 1-bit input: Clock enable for 1st stage BREG
					.CEB2(en),			// 1-bit input: Clock enable for 2nd stage BREG
					.CEC('0),			// 1-bit input: Clock enable for CREG
					.CECARRYIN('0),		// 1-bit input: Clock enable for CARRYINREG
					.CECTRL(en),		// 1-bit input: Clock enable for OPMODEREG and CARRYINSELREG
					.CED('0),			// 1-bit input: Clock enable for DREG
					.CEINMODE('0),		// 1-bit input: Clock enable for INMODEREG
					.CEM(en),			// 1-bit input: Clock enable for MREG
					.CEP(en),			// 1-bit input: Clock enable for PREG
					.RSTA('0),			// 1-bit input: Reset for AREG
					.RSTB(				// 1-bit input: Reset for BREG
// synthesis translate_off
						rst ||
// synthesis translate_on
						zero
					),
					.RSTC('0),			// 1-bit input: Reset for CREG
					.RSTD(				// 1-bit input: Reset for DREG and ADREG
// synthesis translate_off
						zero ||
// synthesis translate_on
						rst
					),
					.RSTALLCARRYIN('0),	// 1-bit input: Reset for CARRYINREG
					.RSTALUMODE('0),	// 1-bit input: Reset for ALUMODEREG
					.RSTCTRL('0),		// 1-bit input: Reset for OPMODEREG and CARRYINSELREG
					.RSTINMODE('0),		// 1-bit input: Reset for INMODE register
					.RSTM(rst),			// 1-bit input: Reset for MREG
					.RSTP(rst)			// 1-bit input: Reset for PREG
				);
				default: initial begin
					$error("Unknown version DSP48E%0d.", VERSION);
					$finish;
				end
				endcase
			end : genDSP
`endif

			// External Canary Pipeline
			logic [1:0]  X1[3:1] = '{ default: 0 };
			logic [1:0]  X2[3:1] = '{ default: 0 };
			logic [1:0]  X3[3:1] = '{ default: 0 };
			always_ff @(posedge clk) begin
				if(rst) begin
					X1 <= '{ default: 0 };
					X2 <= '{ default: 0 };
					X3 <= '{ default: 0 };
				end
				else if(en) begin
					X1 <= xx;
					X2 <= X1;
					foreach(X3[i]) begin
						X3[i] <= X2[i] + (L[3]? 2'h0 : pp[OFFSETS[i]+:2]);
					end
				end
			end

			// Derive actual cross-lane overflows
			for(genvar  i = 0; i < 3; i++) begin
				assign	h3[s][i] = pp[OFFSETS[i+1]+:2] - X3[i+1];
			end
			assign	p3[s] = pp;

		end : genSIMD

		// Stage #4: Cross-SIMD Reduction

		// Count leaves reachable from each node
		localparam leave_load_t  LEAVE_LOAD = SIMD > 1 ? init_leave_loads() : '{ default: 1 }; // SIMD=1 requires no adder tree, so zero-ing out, otherwise init_leave_loads ends up in infinite loop

		uwire signed [ACCU_WIDTH-1:0]  up4;
		uwire signed [             HI_WIDTH_MAX-1:0]  hi4[3];
		uwire        [$clog2(SIMD)+LO_WIDTH_MAX-1:0]  lo4[3];
		for(genvar  i = 0; i < 4; i++) begin

			// Conclusive high part accumulation
			if(i < 3) begin : genHi
				if(i < PE_REM)  assign  hi4[i] = '0;
				else begin
					localparam int unsigned  HI_WIDTH = hi_width(i);

					// Adder Tree across all SIMD high contributions, each from [-1:1]
					uwire signed [2*SIMD-2:0][$clog2(1+SIMD):0]  tree;
					for(genvar  s = 0; s < SIMD;   s++)  assign  tree[SIMD-1+s] = h3[s][i];
					for(genvar  n = 0; n < SIMD-1; n++) begin
						// Sum truncated to actual maximum bit width at this node
						uwire signed [$clog2(1+LEAVE_LOAD[n]):0]  s = $signed(tree[2*n+1]) + $signed(tree[2*n+2]);
						assign  tree[n] = s;
					end

					// High Sideband Accumulation
					logic signed [HI_WIDTH-1:0]  Hi4 = 0;
					always_ff @(posedge clk) begin
						if(rst)      Hi4 <= 0;
						else if(en) begin
							automatic logic signed [HI_WIDTH:0]  h = $signed(L[4]? 0 : Hi4) + $signed(tree[0]);
							assert(h[HI_WIDTH] == h[HI_WIDTH-1]) else begin
								$error("%m: Accumulation overflow for ACCU_WIDTH=%0d", ACCU_WIDTH);
								$stop;
							end
							Hi4 <= h;
						end
					end
					assign	hi4[i] = Hi4;

				end
			end : genHi

			// Conclusive low part accumulation (all unsigned arithmetic)
			if(i < PE_REM)  assign  lo4[i] = '0;
			else begin : genLo
				localparam int unsigned  LO_WIDTH = lo_width(i);

				// Adder Tree across all SIMD low contributions
				localparam int unsigned  ROOT_WIDTH = $clog2(1 + SIMD*(2**LO_WIDTH-1));
				uwire [2*SIMD-2:0][ROOT_WIDTH-1:0]  tree;
				for(genvar  s = 0; s < SIMD;   s++)  assign  tree[SIMD-1+s] = p3[s][OFFSETS[i]+:LO_WIDTH];
				for(genvar  n = 0; n < SIMD-1; n++) begin
					// Sum truncated to actual maximum bit width at this node
					localparam int unsigned  NODE_WIDTH = $clog2(1 + LEAVE_LOAD[n]*(2**LO_WIDTH-1));
					uwire [NODE_WIDTH-1:0]  s = tree[2*n+1] + tree[2*n+2];
					assign  tree[n] = s;
				end

				logic [ROOT_WIDTH-1:0]  Lo4 = 0;
				always_ff @(posedge clk) begin
					if(rst)      Lo4 <= 0;
					else if(en)  Lo4 <= tree[0];
				end

				if(i == 3)  assign  up4 = Lo4;
				else  assign  lo4[i] = Lo4;
			end : genLo

		end

		// Stage #5: Resolve lane totals
		logic signed [3:0][ACCU_WIDTH-1:0]  Res5 = '{ default: 0 };
		always_ff @(posedge clk) begin
			if(rst)  Res5 <= '{ default: 0 };
			else if(en) begin
				Res5[3] <= up4 - hi4[2];
				Res5[2] <= $signed({ hi4[2], {(lo_width(2)){1'b0}} }) + $signed({ 1'b0, lo4[2] }) - hi4[1];
				Res5[1] <= $signed({ hi4[1], {(lo_width(1)){1'b0}} }) + $signed({ 1'b0, lo4[1] }) - hi4[0];
				Res5[0] <= $signed({ hi4[0], {(lo_width(0)){1'b0}} }) + $signed({ 1'b0, lo4[0] });
			end
		end

		// Output
		for(genvar  pe = PE_BEG; pe < PE_END; pe++) begin
			assign	p[pe] = Res5[pe - PE_BEG + PE_REM];
		end

	end : genPipes

endmodule : mvu_4sx4u
//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/code_gen_ipgen_StreamingFIFO_rtl_4_aqxw_l15/StreamingFIFO_rtl_4.v


/******************************************************************************
 * Copyright (C) 2024, Advanced Micro Devices, Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *  1. Redistributions of source code must retain the above copyright notice,
 *     this list of conditions and the following disclaimer.
 *
 *  2. Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *
 *  3. Neither the name of the copyright holder nor the names of its
 *     contributors may be used to endorse or promote products derived from
 *     this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION). HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *****************************************************************************/

module StreamingFIFO_rtl_4(
//- Global Control ------------------
(* X_INTERFACE_PARAMETER = "ASSOCIATED_BUSIF in0_V:out_V, ASSOCIATED_RESET = ap_rst_n" *)
(* X_INTERFACE_INFO = "xilinx.com:signal:clock:1.0 ap_clk CLK" *)
input   ap_clk,
(* X_INTERFACE_PARAMETER = "POLARITY ACTIVE_LOW" *)
input   ap_rst_n,

output [13:0] count,
output [13:0] maxcount,

//- AXI Stream - Input --------------
output   in0_V_TREADY,
input   in0_V_TVALID,
input  [7:0] in0_V_TDATA,

//- AXI Stream - Output --------------
input   out_V_TREADY,
output   out_V_TVALID,
output  [7:0] out_V_TDATA
);

Q_srl #(
.depth(12544),
.width(8)
)
impl
(
 .clock(ap_clk),
 .reset(!ap_rst_n),
 .count(count),
 .maxcount(maxcount),
 .i_d(in0_V_TDATA),
 .i_v(in0_V_TVALID),
 .i_r(in0_V_TREADY),
 .o_d(out_V_TDATA),
 .o_v(out_V_TVALID),
 .o_r(out_V_TREADY)
);

endmodule
//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/vivado_stitch_proj_w5fn6zuu/finn_vivado_stitch_proj.gen/sources_1/bd/finn_design/ipshared/fb57/hdl/verilog/MVAU_hls_1_Matrix_Vector_Activate_Stream_Batch_p_ZL7threshs_5_ROM_AUTO_1R.v


// ==============================================================
// Vitis HLS - High-Level Synthesis from C, C++ and OpenCL v2022.2 (64-bit)
// Version: 2022.2
// Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.
// ==============================================================
`timescale 1 ns / 1 ps
module MVAU_hls_1_Matrix_Vector_Activate_Stream_Batch_p_ZL7threshs_5_ROM_AUTO_1R (
    address0, ce0, q0, 
    reset, clk);

parameter DataWidth = 10;
parameter AddressWidth = 5;
parameter AddressRange = 32;
 
input[AddressWidth-1:0] address0;
input ce0;
output reg[DataWidth-1:0] q0;

input reset;
input clk;

 
reg [DataWidth-1:0] rom0[0:AddressRange-1];


initial begin
     
    $readmemh("/home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/code_gen_ipgen_MVAU_hls_1__774deg0/project_MVAU_hls_1/sol1/impl/ip/hdl/verilog/MVAU_hls_1_Matrix_Vector_Activate_Stream_Batch_p_ZL7threshs_5_ROM_AUTO_1R.dat", rom0);
end

  
always @(posedge clk) 
begin 
    if (ce0) 
    begin
        q0 <= rom0[address0];
    end
end


endmodule

//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn-rtllib/mvu/mvu_vvu_axi.sv


/******************************************************************************
 * Copyright (C) 2024, Advanced Micro Devices, Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *  1. Redistributions of source code must retain the above copyright notice,
 *     this list of conditions and the following disclaimer.
 *
 *  2. Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *
 *  3. Neither the name of the copyright holder nor the names of its
 *     contributors may be used to endorse or promote products derived from
 *     this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION). HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * @brief	Matrix Vector Unit (MVU) & Vector Vector Unit (VVU) AXI-lite interface wrapper.
 * @details
 *	 The following compute cores are supported:
 *   - 4-bit MVU on DSP48 achieving 4 MACs/DSP,
 *   - (4,8]-bit MVU on DSP48 achieving 2 MACs/DSP,
 *   - [4,9]-bit MVU and VVU on DSP58 achieving 3 MACs/DSP,
 *  Folding hints:
 *	 - PE scaling should divide MH.
 *   - SIMD scaling should divide MW.
 *	 - Otherwise, keep SIMD and PE somewhat balanced. SIMD scaling tends to
 *	   impact critical paths more than PE scaling. PE scaling implies a
 *	   bigger fanout on the input activations.
 *	 - Full unfolding along MH (PE=MH) results in no replay buffer instantiated
 *****************************************************************************/

module mvu_vvu_axi #(
	bit IS_MVU,
	parameter COMPUTE_CORE,
	int unsigned MW,
	int unsigned MH,
	int unsigned PE,
	int unsigned SIMD,
	int unsigned SEGMENTLEN = 0,

	int unsigned ACTIVATION_WIDTH,
	int unsigned WEIGHT_WIDTH,
	int unsigned ACCU_WIDTH,
	bit NARROW_WEIGHTS     = 0,
	bit SIGNED_ACTIVATIONS = 0,

	bit PUMPED_COMPUTE = 0,
	bit FORCE_BEHAVIORAL = 0,
	bit M_REG_LUT = 1,

	// Safely deducible parameters
	localparam int unsigned  WEIGHT_STREAM_WIDTH    = PE * SIMD * WEIGHT_WIDTH,
	localparam int unsigned  WEIGHT_STREAM_WIDTH_BA = (WEIGHT_STREAM_WIDTH + 7)/8 * 8,
	localparam int unsigned  INPUT_STREAM_WIDTH     = (IS_MVU ? 1 : PE) * SIMD * ACTIVATION_WIDTH,
	localparam int unsigned  INPUT_STREAM_WIDTH_BA  = (INPUT_STREAM_WIDTH  + 7)/8 * 8,
	localparam int unsigned  OUTPUT_STREAM_WIDTH    = PE*ACCU_WIDTH,
	localparam int unsigned  OUTPUT_STREAM_WIDTH_BA = (OUTPUT_STREAM_WIDTH + 7)/8 * 8,
	localparam bit  		 SIMD_UNEVEN = SIMD % 2
)(
	// Global Control
	input	logic  ap_clk,
	input	logic  ap_clk2x,	// synchronous, double-speed clock; only used for PUMPED_COMPUTE
	input	logic  ap_rst_n,

	// Weight Stream
	input	logic [WEIGHT_STREAM_WIDTH_BA-1:0]  s_axis_weights_tdata,
	input	logic  s_axis_weights_tvalid,
	output	logic  s_axis_weights_tready,

	// Input Stream
	input	logic [INPUT_STREAM_WIDTH_BA-1:0]  s_axis_input_tdata,
	input	logic  s_axis_input_tvalid,
	output	logic  s_axis_input_tready,

	// Output Stream
	output	logic [OUTPUT_STREAM_WIDTH_BA-1:0]  m_axis_output_tdata,
	output	logic  m_axis_output_tvalid,
	input	logic  m_axis_output_tready
);

//-------------------- Parameter sanity checks --------------------\\
	initial begin
		if (MW % SIMD != 0) begin
			$error("Matrix width (%0d) is not a multiple of SIMD (%0d).", MW, SIMD);
			$finish;
		end
		if (MH % PE != 0) begin
			$error("Matrix height (%0d) is not a multiple of PE (%0d).", MH, PE);
			$finish;
		end
		if (WEIGHT_WIDTH > 8) begin
			$error("Weight width of %0d-bits exceeds maximum of 8-bits", WEIGHT_WIDTH);
			$finish;
		end
		if (ACTIVATION_WIDTH > 8) begin
			if (!(SIGNED_ACTIVATIONS == 1 && ACTIVATION_WIDTH == 9 && COMPUTE_CORE == "mvu_vvu_8sx9_dsp58")) begin
				$error("Activation width of %0d-bits exceeds maximum of 9-bits for signed numbers on DSP48", ACTIVATION_WIDTH);
				$finish;
			end
		end
		if (COMPUTE_CORE == "mvu_vvu_8sx9_dsp58") begin
			if (SEGMENTLEN == 0) begin
				$warning("Segment length of %0d defaults to chain length of %0d", SEGMENTLEN, (SIMD+2)/3);
			end
			if (SEGMENTLEN > (SIMD+2)/3) begin
				$error("Segment length of %0d exceeds chain length of %0d", SEGMENTLEN, (SIMD+2)/3);
				$finish;
			end
		end
		if (!IS_MVU) begin
			if (COMPUTE_CORE != "mvu_vvu_8sx9_dsp58" && COMPUTE_CORE != "mvu_vvu_lut") begin
				$error("VVU only supported on DSP58 or LUT-based implementation");
				$finish;
			end
		end
	end

	uwire  clk = ap_clk;
	uwire  clk2x = ap_clk2x;
	uwire  rst = !ap_rst_n;

	//- Replay to Accommodate Neuron Fold -----------------------------------
	typedef logic [(IS_MVU? 1:PE)*SIMD-1:0][ACTIVATION_WIDTH-1:0]  mvu_flatin_t;
	uwire mvu_flatin_t amvau;
	uwire alast;
	uwire afin;
	uwire avld;
	uwire ardy;

	localparam int unsigned  SF = MW/SIMD;
	localparam int unsigned  NF = MH/PE;
	replay_buffer #(.LEN(SF), .REP(IS_MVU ? NF : 1), .W($bits(mvu_flatin_t))) activation_replay (
		.clk, .rst,
		.ivld(s_axis_input_tvalid), .irdy(s_axis_input_tready), .idat(mvu_flatin_t'(s_axis_input_tdata)),
		.ovld(avld), .ordy(ardy), .odat(amvau), .olast(alast), .ofin(afin)
	);

	//- Unflatten inputs into structured matrices ---------------------------
	localparam int unsigned  ACT_PE = IS_MVU? 1 : PE;
	typedef logic [PE    -1:0][SIMD-1:0][WEIGHT_WIDTH    -1:0]  mvu_w_t;
	typedef logic [ACT_PE-1:0][SIMD-1:0][ACTIVATION_WIDTH-1:0]  mvu_a_t;

	uwire  mvu_w_t  mvu_w = s_axis_weights_tdata;

	//- Conditional Activations Layout Adjustment for VVU
	uwire mvu_a_t  amvau_i;
	if (IS_MVU || (PE == 1)) begin : genMVUInput
		assign  amvau_i = amvau;
	end : genMVUInput
	else begin : genVVUInput
		// The input stream will have the channels interleaved for VVU when PE>1
		// Hence, we need to 'untangle' the input stream, i.e. [..][SIMD*PE][..] --> [..][PE][SIMD][..]
		// Note that for each 'SIMD' (S) and 'PE' (P) element, we have something like:
		// (S_0, P_0), ..., (S_0, P_i), (S_1, P_0), ..., (S_1, P_i), ..., (S_i, P_i) which we need to 'untangle' to
		// (S_0, P_0), ..., (S_i, P_0), (S_0, P_1), ..., (S_i, P_1), ..., (S_i, P_i)
		for(genvar  pe = 0; pe < ACT_PE; pe++) begin
			for(genvar  simd = 0; simd < SIMD; simd++) begin
				assign	amvau_i[pe][simd] = amvau[simd*ACT_PE+pe];
			end
		end
	end : genVVUInput

	//- Flow Control Bracket around Compute Core ----------------------------
	uwire en;
	uwire istb = avld && s_axis_weights_tvalid;
	assign ardy = en && s_axis_weights_tvalid;
	assign s_axis_weights_tready = en && avld;

	//- Conditionally Pumped DSP Compute ------------------------------------
	typedef logic [PE-1:0][ACCU_WIDTH-1:0]  dsp_p_t;
	uwire  ovld;
	uwire dsp_p_t  odat;
	if(1) begin : blkDsp
		localparam int unsigned  EFFECTIVE_SIMD = SIMD_UNEVEN && PUMPED_COMPUTE ? SIMD+1 : SIMD;
		localparam int unsigned  DSP_SIMD = EFFECTIVE_SIMD/(PUMPED_COMPUTE+1);
		typedef logic [PE    -1:0][DSP_SIMD-1:0][WEIGHT_WIDTH    -1:0]  dsp_w_t;
		typedef logic [ACT_PE-1:0][DSP_SIMD-1:0][ACTIVATION_WIDTH-1:0]  dsp_a_t;

		uwire  dsp_clk;
		uwire  dsp_en;

		uwire  dsp_last;
		uwire  dsp_zero;
		uwire dsp_w_t  dsp_w;
		uwire dsp_a_t  dsp_a;

		uwire  dsp_vld;
		uwire dsp_p_t  dsp_p;

		if(!PUMPED_COMPUTE) begin : genUnpumpedCompute
			assign	dsp_clk = clk;
			assign	dsp_en  = en;

			assign	dsp_last = alast && avld;
			assign	dsp_zero = !istb;
			assign	dsp_w = mvu_w;
			assign	dsp_a = amvau_i;

			assign	ovld = dsp_vld;
			assign	odat = dsp_p;
		end : genUnpumpedCompute
		else begin : genPumpedCompute
			assign	dsp_clk = clk2x;

			// Identify second fast cycle just before active slow clock edge
			logic  Active = 0;
			if(1) begin : blkActive
				uwire  clk_lut[2];	// Put some LUT delay on the input from the fast clock net
				(* DONT_TOUCH = "TRUE", HLUTNM = "CLK_LUT" *) LUT1 #(.INIT(2'b10)) lut0(.O(clk_lut[0]), .I0(clk));
				(* DONT_TOUCH = "TRUE", HLUTNM = "CLK_LUT" *) LUT1 #(.INIT(2'b10)) lut1(.O(clk_lut[1]), .I0(clk_lut[0]));
				always_ff @(posedge clk2x)  Active <= clk_lut[1];
			end : blkActive

			// The input for a slow cycle is split across two fast cycles along the SIMD dimension.
			//	- Both fast cycles are controlled by the same enable state.
			//	- A zero cycle is duplicated across both fast cycles.
			//	- The last flag must be restricted to the second fast cycle.

			dsp_w_t  W = 'x;
			for(genvar  pe = 0; pe < PE; pe++) begin : genPERegW

				uwire [2*DSP_SIMD-1:0][WEIGHT_WIDTH-1:0]  w;
				for(genvar  i =    0; i <       SIMD; i++)  assign  w[i] = mvu_w[pe][i];
				for(genvar  i = SIMD; i < 2*DSP_SIMD; i++)  assign  w[i] = 0;

				always_ff @(posedge clk2x) begin
					if(rst)      W[pe] <= 'x;
					else if(en)  W[pe] <= w[(Active? DSP_SIMD : 0) +: DSP_SIMD];
				end

			end : genPERegW

			dsp_a_t  A = 'x;
			for(genvar  pe = 0; pe < ACT_PE; pe++) begin : genPERegA

				uwire [2*DSP_SIMD-1:0][ACTIVATION_WIDTH-1:0]  a;
				for(genvar  i =    0; i <       SIMD; i++)  assign  a[i] = amvau_i[pe][i];
				for(genvar  i = SIMD; i < 2*DSP_SIMD; i++)  assign  a[i] = 0;

				always_ff @(posedge clk2x) begin
					if(rst)      A[pe] <= 'x;
					else if(en)  A[pe] <= a[(Active? DSP_SIMD : 0) +: DSP_SIMD];
				end

			end : genPERegA

			logic  Zero = 1;
			logic  Last = 0;
			always_ff @(posedge clk2x) begin
				if(rst) begin
					Zero <= 1;
					Last <= 0;
				end
				else if(en) begin
					Zero <= !istb;
					Last <= alast && avld && Active;
				end
			end

			assign	dsp_en = en;
			assign	dsp_last = Last;
			assign	dsp_zero = Zero;
			assign	dsp_w = W;
			assign	dsp_a = A;

			// Since no two consecutive last cycles will ever be asserted on the input,
			// valid outputs will also always be spaced by, at least, one other cycle.
			// We can always hold a captured output for two cycles to allow the slow
			// clock to pick it up.
			logic    Vld = 0;
			dsp_p_t  P = 'x;
			always_ff @(posedge clk2x) begin
				if(rst) begin
					Vld <= 0;
					P   <= 'x;
				end
				else if(en) begin
					if(dsp_vld)  P <= dsp_p;
					Vld <= dsp_vld || (Vld && !Active);
				end
			end
			assign	ovld = Vld;
			assign	odat = P;

		end : genPumpedCompute

		case(COMPUTE_CORE)
		"mvu_vvu_8sx9_dsp58":
			mvu_vvu_8sx9_dsp58 #(.IS_MVU(IS_MVU), .PE(PE), .SIMD(DSP_SIMD), .ACTIVATION_WIDTH(ACTIVATION_WIDTH), .WEIGHT_WIDTH(WEIGHT_WIDTH),
			.ACCU_WIDTH(ACCU_WIDTH), .SIGNED_ACTIVATIONS(SIGNED_ACTIVATIONS), .SEGMENTLEN(SEGMENTLEN),
			.FORCE_BEHAVIORAL(FORCE_BEHAVIORAL)) core (
				.clk(dsp_clk), .rst, .en(dsp_en),
				.last(dsp_last), .zero(dsp_zero), .w(dsp_w), .a(dsp_a),
				.vld(dsp_vld), .p(dsp_p)
			);
		"mvu_4sx4u_dsp48e1":
			mvu_4sx4u #(
				.PE(PE), .SIMD(DSP_SIMD),
				.ACCU_WIDTH(ACCU_WIDTH), .SIGNED_ACTIVATIONS(SIGNED_ACTIVATIONS), .NARROW_WEIGHTS(NARROW_WEIGHTS),
				.VERSION(1), .FORCE_BEHAVIORAL(FORCE_BEHAVIORAL)
			) core (
				.clk(dsp_clk), .rst, .en(dsp_en),
				.last(dsp_last), .zero(dsp_zero), .w(dsp_w), .a(dsp_a),
				.vld(dsp_vld), .p(dsp_p)
			);
		"mvu_4sx4u_dsp48e2":
			mvu_4sx4u #(
				.PE(PE), .SIMD(DSP_SIMD),
				.ACCU_WIDTH(ACCU_WIDTH), .SIGNED_ACTIVATIONS(SIGNED_ACTIVATIONS), .NARROW_WEIGHTS(NARROW_WEIGHTS),
				.VERSION(2), .FORCE_BEHAVIORAL(FORCE_BEHAVIORAL)
			) core (
				.clk(dsp_clk), .rst, .en(dsp_en),
				.last(dsp_last), .zero(dsp_zero), .w(dsp_w), .a(dsp_a),
				.vld(dsp_vld), .p(dsp_p)
			);
		"mvu_8sx8u_dsp48":
			mvu_8sx8u_dsp48 #(.PE(PE), .SIMD(DSP_SIMD), .ACCU_WIDTH(ACCU_WIDTH), .ACTIVATION_WIDTH(ACTIVATION_WIDTH), .WEIGHT_WIDTH(WEIGHT_WIDTH),
			.SIGNED_ACTIVATIONS(SIGNED_ACTIVATIONS), .FORCE_BEHAVIORAL(FORCE_BEHAVIORAL)) core (
				.clk(dsp_clk), .rst, .en(dsp_en),
				.last(dsp_last), .zero(dsp_zero), .w(dsp_w), .a(dsp_a),
				.vld(dsp_vld), .p(dsp_p)
			);
		default: initial begin
			$error("Unrecognized COMPUTE_CORE '%s'", COMPUTE_CORE);
			$finish;
		end
		endcase

	end : blkDsp

//-------------------- Output register slice --------------------\\
	// Make `en`computation independent from external inputs.
	// Drive all outputs from registers.
	struct packed {
		logic rdy;
		logic [PE-1:0][ACCU_WIDTH-1:0] dat;
	}  A = '{ rdy: 1, default: 'x };	// side-step register used when encountering backpressure
	struct packed {
		logic vld;
		logic [PE-1:0][ACCU_WIDTH-1:0] dat;
	}  B = '{ vld: 0, default: 'x };	// ultimate output register

	assign	en = A.rdy;
	uwire  b_load = !B.vld || m_axis_output_tready;

	always_ff @(posedge clk) begin
		if(rst) begin
			A <= '{ rdy: 1, default: 'x };
			B <= '{ vld: 0, default: 'x };
		end
		else begin
			if(A.rdy)  A.dat <= odat;
			A.rdy <= (A.rdy && !ovld) || b_load;

			if(b_load) begin
				B <= '{
					vld: ovld || !A.rdy,
					dat: A.rdy? odat : A.dat
				};
			end
		end
	end
	assign	m_axis_output_tvalid = B.vld;
	// Why would we need a sign extension here potentially creating a higher signal load into the next FIFO?
	// These extra bits should never be used. Why not 'x them out?
	assign	m_axis_output_tdata  = { {(OUTPUT_STREAM_WIDTH_BA-OUTPUT_STREAM_WIDTH){B.dat[PE-1][ACCU_WIDTH-1]}}, B.dat};

endmodule : mvu_vvu_axi
//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/code_gen_ipgen_FMPadding_rtl_1_bx8daa0b/axi2we.sv


/******************************************************************************
 * Copyright (C) 2022, Advanced Micro Devices, Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *  1. Redistributions of source code must retain the above copyright notice,
 *     this list of conditions and the following disclaimer.
 *
 *  2. Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *
 *  3. Neither the name of the copyright holder nor the names of its
 *     contributors may be used to endorse or promote products derived from
 *     this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION). HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * @brief	AXI-Light adapter for trivial write enable interface.
 * @author	Thomas B. Preuer <tpreusse@amd.com>
 *****************************************************************************/

module axi2we #(
	int unsigned  ADDR_BITS
)(
	//- Global Control ------------------
	input	logic  ap_clk,
	input	logic  ap_rst_n,

	//- AXI Lite ------------------------
	// Writing
	input	                 s_axilite_AWVALID,
	output	                 s_axilite_AWREADY,
	input	[ADDR_BITS-1:0]  s_axilite_AWADDR,

	input	        s_axilite_WVALID,
	output	        s_axilite_WREADY,
	input	[31:0]  s_axilite_WDATA,
	input	[ 3:0]  s_axilite_WSTRB,

	output	       s_axilite_BVALID,
	input	       s_axilite_BREADY,
	output	[1:0]  s_axilite_BRESP,

	// Reading tied to all-ones
	input	       s_axilite_ARVALID,
	output	       s_axilite_ARREADY,
	input	[ADDR_BITS-1:0]  s_axilite_ARADDR,

	output	        s_axilite_RVALID,
	input	        s_axilite_RREADY,
	output	[31:0]  s_axilite_RDATA,
	output	[ 1:0]  s_axilite_RRESP,

	// Write Enable Interface
	output	logic                  we,
	output	logic [ADDR_BITS-1:0]  wa,
	output	logic [         31:0]  wd
);

	uwire  clk = ap_clk;
	uwire  rst = !ap_rst_n;


	logic  WABusy = 0;
	logic  WDBusy = 0;
	logic [ADDR_BITS-1:0]  Addr = 'x;
	logic [         31:0]  Data = 'x;

	assign	we = WABusy && WDBusy && s_axilite_BREADY;
	assign	wa = Addr;
	assign	wd = Data;

	uwire  clr_wr = rst || we;
	always_ff @(posedge clk) begin
		if(clr_wr) begin
			WABusy <= 0;
			Addr <= 'x;
			WDBusy <= 0;
			Data <= 'x;
		end
		else begin
			if(!WABusy) begin
				WABusy <= s_axilite_AWVALID;
				Addr   <= s_axilite_AWADDR;
			end
			if(!WDBusy) begin
				WDBusy <= s_axilite_WVALID;
				Data   <= s_axilite_WDATA;
			end
		end
	end
	assign	s_axilite_AWREADY = !WABusy;
	assign	s_axilite_WREADY  = !WDBusy;
	assign	s_axilite_BVALID  = WABusy && WDBusy;
	assign	s_axilite_BRESP   = '0; // OK

	// Answer all reads with '1
	logic  RValid =  0;
	uwire  clr_rd = rst || (RValid && s_axilite_RREADY);
	always_ff @(posedge clk) begin
		if(clr_rd)        RValid <=  0;
		else if(!RValid)  RValid <= s_axilite_ARVALID;
	end
	assign	s_axilite_ARREADY = !RValid;
	assign	s_axilite_RVALID  = RValid;
	assign	s_axilite_RDATA   = '1;
	assign	s_axilite_RRESP   = '0; // OK

endmodule : axi2we
//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/code_gen_ipgen_StreamingFIFO_rtl_5_pvgvb9s1/StreamingFIFO_rtl_5.v


/******************************************************************************
 * Copyright (C) 2024, Advanced Micro Devices, Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *  1. Redistributions of source code must retain the above copyright notice,
 *     this list of conditions and the following disclaimer.
 *
 *  2. Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *
 *  3. Neither the name of the copyright holder nor the names of its
 *     contributors may be used to endorse or promote products derived from
 *     this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION). HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *****************************************************************************/

module StreamingFIFO_rtl_5(
//- Global Control ------------------
(* X_INTERFACE_PARAMETER = "ASSOCIATED_BUSIF in0_V:out_V, ASSOCIATED_RESET = ap_rst_n" *)
(* X_INTERFACE_INFO = "xilinx.com:signal:clock:1.0 ap_clk CLK" *)
input   ap_clk,
(* X_INTERFACE_PARAMETER = "POLARITY ACTIVE_LOW" *)
input   ap_rst_n,

output [9:0] count,
output [9:0] maxcount,

//- AXI Stream - Input --------------
output   in0_V_TREADY,
input   in0_V_TVALID,
input  [63:0] in0_V_TDATA,

//- AXI Stream - Output --------------
input   out_V_TREADY,
output   out_V_TVALID,
output  [63:0] out_V_TDATA
);

Q_srl #(
.depth(784),
.width(64)
)
impl
(
 .clock(ap_clk),
 .reset(!ap_rst_n),
 .count(count),
 .maxcount(maxcount),
 .i_d(in0_V_TDATA),
 .i_v(in0_V_TVALID),
 .i_r(in0_V_TREADY),
 .o_d(out_V_TDATA),
 .o_v(out_V_TVALID),
 .o_r(out_V_TREADY)
);

endmodule
//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/code_gen_ipgen_StreamingFIFO_rtl_2_9upbug_e/StreamingFIFO_rtl_2.v


/******************************************************************************
 * Copyright (C) 2024, Advanced Micro Devices, Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *  1. Redistributions of source code must retain the above copyright notice,
 *     this list of conditions and the following disclaimer.
 *
 *  2. Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *
 *  3. Neither the name of the copyright holder nor the names of its
 *     contributors may be used to endorse or promote products derived from
 *     this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION). HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *****************************************************************************/

module StreamingFIFO_rtl_2(
//- Global Control ------------------
(* X_INTERFACE_PARAMETER = "ASSOCIATED_BUSIF in0_V:out_V, ASSOCIATED_RESET = ap_rst_n" *)
(* X_INTERFACE_INFO = "xilinx.com:signal:clock:1.0 ap_clk CLK" *)
input   ap_clk,
(* X_INTERFACE_PARAMETER = "POLARITY ACTIVE_LOW" *)
input   ap_rst_n,

output [11:0] count,
output [11:0] maxcount,

//- AXI Stream - Input --------------
output   in0_V_TREADY,
input   in0_V_TVALID,
input  [7:0] in0_V_TDATA,

//- AXI Stream - Output --------------
input   out_V_TREADY,
output   out_V_TVALID,
output  [7:0] out_V_TDATA
);

Q_srl #(
.depth(2700),
.width(8)
)
impl
(
 .clock(ap_clk),
 .reset(!ap_rst_n),
 .count(count),
 .maxcount(maxcount),
 .i_d(in0_V_TDATA),
 .i_v(in0_V_TVALID),
 .i_r(in0_V_TREADY),
 .o_d(out_V_TDATA),
 .o_v(out_V_TVALID),
 .o_r(out_V_TREADY)
);

endmodule
//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/code_gen_ipgen_ConvolutionInputGenerator_rtl_0_sgzv3feu/ConvolutionInputGenerator_rtl_0_wrapper.v


/******************************************************************************
 * Copyright (C) 2022, Advanced Micro Devices, Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *  1. Redistributions of source code must retain the above copyright notice,
 *     this list of conditions and the following disclaimer.
 *
 *  2. Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *
 *  3. Neither the name of the copyright holder nor the names of its
 *     contributors may be used to endorse or promote products derived from
 *     this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION). HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *****************************************************************************/

module ConvolutionInputGenerator_rtl_0 (
	(* X_INTERFACE_PARAMETER = "ASSOCIATED_BUSIF in0_V:out_V, ASSOCIATED_RESET ap_rst_n" *)
	(* X_INTERFACE_INFO = "xilinx.com:signal:clock:1.0 ap_clk CLK" *)
	input  ap_clk,
	(* X_INTERFACE_PARAMETER = "POLARITY ACTIVE_LOW" *)
	input  ap_rst_n,
	input  [IN_WIDTH_PADDED-1:0] in0_V_TDATA,
	input  in0_V_TVALID,
	output in0_V_TREADY,
	output [OUT_WIDTH_PADDED-1:0] out_V_TDATA,
	output out_V_TVALID,
	input  out_V_TREADY
);

// top-level parameters (set via code-generation)
parameter BIT_WIDTH = 8;
parameter SIMD = 1;
parameter MMV_IN = 1;
parameter MMV_OUT = 1;
parameter IN_WIDTH_PADDED = 8;
parameter OUT_WIDTH_PADDED = 8;

// derived constants
parameter BUF_IN_WIDTH = BIT_WIDTH * SIMD * MMV_IN;
parameter BUF_OUT_WIDTH = BIT_WIDTH * SIMD * MMV_OUT;

ConvolutionInputGenerator_rtl_0_impl #(
	.BIT_WIDTH(BIT_WIDTH),
	.SIMD(SIMD),
	.MMV_IN(MMV_IN),
	.MMV_OUT(MMV_OUT)
) impl (
	.ap_clk(ap_clk),
	.ap_rst_n(ap_rst_n),
	.in0_V_V_TDATA(in0_V_TDATA[BUF_IN_WIDTH-1:0]),
	.in0_V_V_TVALID(in0_V_TVALID),
	.in0_V_V_TREADY(in0_V_TREADY),
	.out_V_V_TDATA(out_V_TDATA[BUF_OUT_WIDTH-1:0]),
	.out_V_V_TVALID(out_V_TVALID),
	.out_V_V_TREADY(out_V_TREADY)
);

endmodule : ConvolutionInputGenerator_rtl_0
//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/vivado_stitch_proj_w5fn6zuu/finn_vivado_stitch_proj.gen/sources_1/bd/finn_design/ipshared/fb57/hdl/verilog/MVAU_hls_1_Matrix_Vector_Activate_Stream_Batch_p_ZL7threshs_12_ROM_AUTO_1R.v


// ==============================================================
// Vitis HLS - High-Level Synthesis from C, C++ and OpenCL v2022.2 (64-bit)
// Version: 2022.2
// Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.
// ==============================================================
`timescale 1 ns / 1 ps
module MVAU_hls_1_Matrix_Vector_Activate_Stream_Batch_p_ZL7threshs_12_ROM_AUTO_1R (
    address0, ce0, q0, 
    reset, clk);

parameter DataWidth = 10;
parameter AddressWidth = 5;
parameter AddressRange = 32;
 
input[AddressWidth-1:0] address0;
input ce0;
output reg[DataWidth-1:0] q0;

input reset;
input clk;

 
reg [DataWidth-1:0] rom0[0:AddressRange-1];


initial begin
     
    $readmemh("/home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/code_gen_ipgen_MVAU_hls_1__774deg0/project_MVAU_hls_1/sol1/impl/ip/hdl/verilog/MVAU_hls_1_Matrix_Vector_Activate_Stream_Batch_p_ZL7threshs_12_ROM_AUTO_1R.dat", rom0);
end

  
always @(posedge clk) 
begin 
    if (ce0) 
    begin
        q0 <= rom0[address0];
    end
end


endmodule

//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/vivado_stitch_proj_w5fn6zuu/finn_vivado_stitch_proj.gen/sources_1/bd/finn_design/ipshared/6bf6/hdl/verilog/StreamingMaxPool_hls_0_flow_control_loop_pipe_sequential_init.v


// ==============================================================
// Vitis HLS - High-Level Synthesis from C, C++ and OpenCL v2022.2 (64-bit)
// Tool Version Limit: 2019.12
// Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.
// ==============================================================

`timescale 1 ns / 1 ps

module StreamingMaxPool_hls_0_flow_control_loop_pipe_sequential_init(
        ap_clk,
        ap_rst,
        ap_start,
        ap_ready,
        ap_done,
        ap_start_int,
        ap_ready_int,
        ap_done_int,
        ap_continue_int,
        ap_loop_init,
        ap_loop_exit_ready,
        ap_loop_exit_done
);

input   ap_clk;
input   ap_rst;

//Block level handshake with outside loop
input   ap_start;
output  ap_ready;
output  ap_done;

//Block level handshake with loop body
output  ap_start_int;
input   ap_ready_int;
input   ap_done_int;
output  ap_continue_int;

//Init live in variables
output   ap_loop_init;
wire     ap_loop_init;
reg ap_loop_init_int;
reg ap_done;
reg ap_done_cache;

//Exit signal from loop body
input   ap_loop_exit_ready;
input   ap_loop_exit_done;

// power-on initialization
initial begin
#0 ap_loop_init_int = 1'b1;
#0 ap_done_cache = 1'b0;
end

assign ap_start_int = ap_start;

assign ap_continue_int = 1'b1;

assign ap_ready = ap_loop_exit_ready;

//ap_loop_init is valid for the first II
//of the first loop run so as to enable
//the init block ops which are pushed into
//the first state of the pipeline region
always @ (posedge ap_clk)
begin
    if (ap_rst == 1'b1) begin
        ap_loop_init_int <= 1'b1;
    end else if(ap_loop_exit_done == 1'b1) begin
        ap_loop_init_int <= 1'b1;
    end else if(ap_ready_int == 1'b1) begin
        ap_loop_init_int <= 1'b0;
    end
end

assign ap_loop_init = ap_loop_init_int & ap_start;

// if no ap_continue port and current module is not top module, 
// ap_done handshakes with ap_start. Internally, flow control sends out 
// ap_conintue_int = 1'b1 so the ap_done_int is asserted high for 1 clock cycle.
// ap_done_cache is used to record ap_done_int, and de-assert if ap_start_int
// is asserted, so DUT can start the next run
always @(posedge ap_clk)
begin
    if (ap_rst == 1'b1) begin
        ap_done_cache <= 1'b0;
    end else if (ap_done_int == 1'b1) begin
        ap_done_cache <= 1'b1;
    end else if (ap_start_int == 1'b1) begin
        ap_done_cache <= 1'b0;
    end
end

// if no ap_continue port and current module is not top module, ap_done handshakes with ap_start
always @(*)
begin
    if ((ap_done_int == 1'b1) || ((ap_done_cache == 1'b1) && (ap_start_int == 1'b0))) begin
        ap_done = 1'b1;
    end else begin
        ap_done = 1'b0;
    end
end

endmodule
        
//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/vivado_stitch_proj_w5fn6zuu/finn_vivado_stitch_proj.gen/sources_1/bd/finn_design/ipshared/18e4/hdl/verilog/MVAU_hls_0_Matrix_Vector_Activate_Stream_Batch.v


// ==============================================================
// RTL generated by Vitis HLS - High-Level Synthesis from C, C++ and OpenCL v2022.2 (64-bit)
// Version: 2022.2
// Copyright (C) Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.
// 
// ===========================================================

`timescale 1 ns / 1 ps 

module MVAU_hls_0_Matrix_Vector_Activate_Stream_Batch (
        ap_clk,
        ap_rst,
        ap_start,
        ap_done,
        ap_idle,
        ap_ready,
        in0_V_TVALID,
        weights_V_TVALID,
        out_V_TREADY,
        in0_V_TDATA,
        in0_V_TREADY,
        out_V_TDATA,
        out_V_TVALID,
        weights_V_TDATA,
        weights_V_TREADY
);

parameter    ap_ST_iter0_fsm_state1 = 1'd1;
parameter    ap_ST_iter1_fsm_state2 = 2'd2;
parameter    ap_ST_iter2_fsm_state3 = 2'd2;
parameter    ap_ST_iter3_fsm_state4 = 2'd2;
parameter    ap_ST_iter4_fsm_state5 = 2'd2;
parameter    ap_ST_iter5_fsm_state6 = 2'd2;
parameter    ap_ST_iter6_fsm_state7 = 2'd2;
parameter    ap_ST_iter1_fsm_state0 = 2'd1;
parameter    ap_ST_iter2_fsm_state0 = 2'd1;
parameter    ap_ST_iter3_fsm_state0 = 2'd1;
parameter    ap_ST_iter4_fsm_state0 = 2'd1;
parameter    ap_ST_iter5_fsm_state0 = 2'd1;
parameter    ap_ST_iter6_fsm_state0 = 2'd1;

input   ap_clk;
input   ap_rst;
input   ap_start;
output   ap_done;
output   ap_idle;
output   ap_ready;
input   in0_V_TVALID;
input   weights_V_TVALID;
input   out_V_TREADY;
input  [7:0] in0_V_TDATA;
output   in0_V_TREADY;
output  [7:0] out_V_TDATA;
output   out_V_TVALID;
input  [7:0] weights_V_TDATA;
output   weights_V_TREADY;

reg ap_idle;
reg in0_V_TREADY;
reg out_V_TVALID;
reg weights_V_TREADY;

reg   [0:0] ap_CS_iter0_fsm;
wire    ap_CS_iter0_fsm_state1;
reg   [1:0] ap_CS_iter1_fsm;
wire    ap_CS_iter1_fsm_state0;
reg   [1:0] ap_CS_iter2_fsm;
wire    ap_CS_iter2_fsm_state0;
reg   [1:0] ap_CS_iter3_fsm;
wire    ap_CS_iter3_fsm_state0;
reg   [1:0] ap_CS_iter4_fsm;
wire    ap_CS_iter4_fsm_state0;
reg   [1:0] ap_CS_iter5_fsm;
wire    ap_CS_iter5_fsm_state0;
reg   [1:0] ap_CS_iter6_fsm;
wire    ap_CS_iter6_fsm_state0;
wire   [0:0] icmp_ln249_fu_559_p2;
wire   [0:0] icmp_ln253_fu_571_p2;
reg    ap_predicate_op89_read_state1;
reg    ap_block_state1_pp0_stage0_iter0;
wire    ap_block_state2_pp0_stage0_iter1;
wire    ap_CS_iter1_fsm_state2;
wire    ap_block_state5_pp0_stage0_iter4;
wire    ap_CS_iter4_fsm_state5;
wire    ap_block_state4_pp0_stage0_iter3;
wire    ap_CS_iter3_fsm_state4;
wire    ap_block_state3_pp0_stage0_iter2;
wire    ap_CS_iter2_fsm_state3;
wire    ap_block_state6_pp0_stage0_iter5;
wire    ap_CS_iter5_fsm_state6;
reg   [0:0] icmp_ln249_reg_1577;
reg   [0:0] icmp_ln249_reg_1577_pp0_iter5_reg;
reg   [0:0] icmp_ln290_reg_1635;
reg   [0:0] icmp_ln290_reg_1635_pp0_iter5_reg;
reg    ap_predicate_op304_write_state7;
reg    ap_block_state7_pp0_stage0_iter6;
reg    ap_block_state7_io;
wire    ap_CS_iter6_fsm_state7;
reg    ap_condition_exit_pp0_iter0_stage0;
wire    ap_loop_exit_ready;
reg    ap_ready_int;
wire   [3:0] p_ZL7threshs_0_address0;
reg    p_ZL7threshs_0_ce0;
wire   [11:0] p_ZL7threshs_0_q0;
wire   [3:0] p_ZL7threshs_1_address0;
reg    p_ZL7threshs_1_ce0;
wire   [11:0] p_ZL7threshs_1_q0;
wire   [3:0] p_ZL7threshs_2_address0;
reg    p_ZL7threshs_2_ce0;
wire   [11:0] p_ZL7threshs_2_q0;
wire   [3:0] p_ZL7threshs_3_address0;
reg    p_ZL7threshs_3_ce0;
wire   [12:0] p_ZL7threshs_3_q0;
wire   [3:0] p_ZL7threshs_4_address0;
reg    p_ZL7threshs_4_ce0;
wire   [12:0] p_ZL7threshs_4_q0;
wire   [3:0] p_ZL7threshs_5_address0;
reg    p_ZL7threshs_5_ce0;
wire   [12:0] p_ZL7threshs_5_q0;
wire   [3:0] p_ZL7threshs_6_address0;
reg    p_ZL7threshs_6_ce0;
wire   [12:0] p_ZL7threshs_6_q0;
wire   [3:0] p_ZL7threshs_7_address0;
reg    p_ZL7threshs_7_ce0;
wire   [12:0] p_ZL7threshs_7_q0;
wire   [3:0] p_ZL7threshs_8_address0;
reg    p_ZL7threshs_8_ce0;
wire   [12:0] p_ZL7threshs_8_q0;
wire   [3:0] p_ZL7threshs_9_address0;
reg    p_ZL7threshs_9_ce0;
wire   [12:0] p_ZL7threshs_9_q0;
wire   [3:0] p_ZL7threshs_10_address0;
reg    p_ZL7threshs_10_ce0;
wire   [11:0] p_ZL7threshs_10_q0;
wire   [3:0] p_ZL7threshs_11_address0;
reg    p_ZL7threshs_11_ce0;
wire   [11:0] p_ZL7threshs_11_q0;
wire   [3:0] p_ZL7threshs_12_address0;
reg    p_ZL7threshs_12_ce0;
wire   [11:0] p_ZL7threshs_12_q0;
wire   [3:0] p_ZL7threshs_13_address0;
reg    p_ZL7threshs_13_ce0;
wire   [11:0] p_ZL7threshs_13_q0;
wire   [3:0] p_ZL7threshs_14_address0;
reg    p_ZL7threshs_14_ce0;
wire   [11:0] p_ZL7threshs_14_q0;
reg    in0_V_TDATA_blk_n;
reg    out_V_TDATA_blk_n;
reg    weights_V_TDATA_blk_n;
reg   [31:0] nf_2_reg_1572;
reg   [31:0] nf_2_reg_1572_pp0_iter1_reg;
reg   [31:0] nf_2_reg_1572_pp0_iter2_reg;
reg   [0:0] icmp_ln249_reg_1577_pp0_iter1_reg;
reg   [0:0] icmp_ln249_reg_1577_pp0_iter2_reg;
reg   [0:0] icmp_ln249_reg_1577_pp0_iter3_reg;
reg   [0:0] icmp_ln249_reg_1577_pp0_iter4_reg;
wire   [7:0] tmp_fu_662_p29;
wire   [4:0] trunc_ln257_fu_722_p1;
wire   [3:0] W_packed_V_fu_861_p1;
reg  signed [3:0] W_packed_V_reg_1625;
wire   [0:0] icmp_ln272_fu_865_p2;
reg   [0:0] icmp_ln272_reg_1630;
reg   [0:0] icmp_ln272_reg_1630_pp0_iter1_reg;
reg   [0:0] icmp_ln272_reg_1630_pp0_iter2_reg;
wire   [0:0] icmp_ln290_fu_877_p2;
reg   [0:0] icmp_ln290_reg_1635_pp0_iter1_reg;
reg   [0:0] icmp_ln290_reg_1635_pp0_iter2_reg;
reg   [0:0] icmp_ln290_reg_1635_pp0_iter3_reg;
reg   [0:0] icmp_ln290_reg_1635_pp0_iter4_reg;
wire   [0:0] icmp_ln1039_fu_962_p2;
reg   [0:0] icmp_ln1039_reg_1729;
wire   [0:0] icmp_ln1039_1_fu_971_p2;
reg   [0:0] icmp_ln1039_1_reg_1734;
wire   [0:0] icmp_ln1039_2_fu_980_p2;
reg   [0:0] icmp_ln1039_2_reg_1739;
wire   [0:0] icmp_ln1039_3_fu_989_p2;
reg   [0:0] icmp_ln1039_3_reg_1744;
wire   [0:0] icmp_ln1039_4_fu_998_p2;
reg   [0:0] icmp_ln1039_4_reg_1749;
wire   [0:0] icmp_ln1039_5_fu_1007_p2;
reg   [0:0] icmp_ln1039_5_reg_1754;
wire   [0:0] icmp_ln1039_6_fu_1016_p2;
reg   [0:0] icmp_ln1039_6_reg_1759;
wire   [0:0] icmp_ln1039_7_fu_1025_p2;
reg   [0:0] icmp_ln1039_7_reg_1764;
wire   [0:0] icmp_ln1039_8_fu_1034_p2;
reg   [0:0] icmp_ln1039_8_reg_1769;
wire   [0:0] icmp_ln1039_9_fu_1043_p2;
reg   [0:0] icmp_ln1039_9_reg_1774;
wire   [0:0] icmp_ln1039_10_fu_1052_p2;
reg   [0:0] icmp_ln1039_10_reg_1779;
wire   [0:0] icmp_ln1039_11_fu_1061_p2;
reg   [0:0] icmp_ln1039_11_reg_1784;
wire   [0:0] icmp_ln1039_12_fu_1070_p2;
reg   [0:0] icmp_ln1039_12_reg_1789;
wire   [0:0] icmp_ln1039_13_fu_1079_p2;
reg   [0:0] icmp_ln1039_13_reg_1794;
wire   [0:0] icmp_ln1039_14_fu_1088_p2;
reg   [0:0] icmp_ln1039_14_reg_1799;
wire   [2:0] add_ln840_6_fu_1274_p2;
reg   [2:0] add_ln840_6_reg_1804;
wire   [2:0] add_ln840_9_fu_1300_p2;
reg   [2:0] add_ln840_9_reg_1809;
wire   [2:0] add_ln840_12_fu_1326_p2;
reg   [2:0] add_ln840_12_reg_1814;
wire   [7:0] ap_phi_reg_pp0_iter0_inElem_1_reg_474;
reg  signed [7:0] ap_phi_reg_pp0_iter1_inElem_1_reg_474;
wire   [63:0] idxprom2_i_fu_940_p1;
reg   [31:0] sf_fu_136;
wire   [31:0] sf_2_fu_871_p2;
wire    ap_loop_init;
reg   [31:0] ap_sig_allocacmp_sf_1;
reg   [18:0] i_fu_140;
wire   [18:0] i_2_fu_565_p2;
reg   [18:0] ap_sig_allocacmp_i_1;
reg   [14:0] add_i4_i338_fu_144;
wire  signed [14:0] grp_fu_1358_p3;
reg   [14:0] ap_sig_allocacmp_add_i4_i338_load;
reg   [7:0] inputBuf_V_fu_148;
reg   [7:0] inputBuf_V_1_fu_152;
reg   [7:0] inputBuf_V_2_fu_156;
reg   [7:0] inputBuf_V_3_fu_160;
reg   [7:0] inputBuf_V_4_fu_164;
reg   [7:0] inputBuf_V_5_fu_168;
reg   [7:0] inputBuf_V_6_fu_172;
reg   [7:0] inputBuf_V_7_fu_176;
reg   [7:0] inputBuf_V_8_fu_180;
reg   [7:0] inputBuf_V_9_fu_184;
reg   [7:0] inputBuf_V_10_fu_188;
reg   [7:0] inputBuf_V_11_fu_192;
reg   [7:0] inputBuf_V_12_fu_196;
reg   [7:0] inputBuf_V_13_fu_200;
reg   [7:0] inputBuf_V_14_fu_204;
reg   [7:0] inputBuf_V_15_fu_208;
reg   [7:0] inputBuf_V_16_fu_212;
reg   [7:0] inputBuf_V_17_fu_216;
reg   [7:0] inputBuf_V_18_fu_220;
reg   [7:0] inputBuf_V_19_fu_224;
reg   [7:0] inputBuf_V_20_fu_228;
reg   [7:0] inputBuf_V_21_fu_232;
reg   [7:0] inputBuf_V_22_fu_236;
reg   [7:0] inputBuf_V_23_fu_240;
reg   [7:0] inputBuf_V_24_fu_244;
reg   [7:0] inputBuf_V_25_fu_248;
reg   [7:0] inputBuf_V_26_fu_252;
reg   [31:0] nf_1_fu_256;
wire   [31:0] nf_3_fu_900_p3;
reg   [31:0] ap_sig_allocacmp_nf_2;
wire   [4:0] tmp_fu_662_p28;
wire   [31:0] nf_fu_888_p2;
wire   [0:0] icmp_ln302_fu_894_p2;
wire  signed [14:0] sext_ln1039_fu_958_p1;
wire  signed [14:0] sext_ln1039_1_fu_967_p1;
wire  signed [14:0] sext_ln1039_2_fu_976_p1;
wire  signed [14:0] sext_ln1039_3_fu_985_p1;
wire  signed [14:0] sext_ln1039_4_fu_994_p1;
wire  signed [14:0] sext_ln1039_5_fu_1003_p1;
wire  signed [14:0] sext_ln1039_6_fu_1012_p1;
wire  signed [14:0] sext_ln1039_7_fu_1021_p1;
wire  signed [14:0] sext_ln1039_8_fu_1030_p1;
wire  signed [14:0] sext_ln1039_9_fu_1039_p1;
wire   [14:0] zext_ln1039_fu_1048_p1;
wire   [14:0] zext_ln1039_1_fu_1057_p1;
wire   [14:0] zext_ln1039_2_fu_1066_p1;
wire   [14:0] zext_ln1039_3_fu_1075_p1;
wire   [14:0] zext_ln1039_4_fu_1084_p1;
wire   [0:0] result_V_fu_1097_p2;
wire   [0:0] xor_ln1039_fu_1106_p2;
wire   [0:0] xor_ln1039_1_fu_1115_p2;
wire   [0:0] xor_ln1039_2_fu_1124_p2;
wire   [0:0] xor_ln1039_3_fu_1133_p2;
wire   [0:0] xor_ln1039_4_fu_1142_p2;
wire   [0:0] xor_ln1039_5_fu_1151_p2;
wire   [0:0] xor_ln1039_6_fu_1160_p2;
wire   [0:0] xor_ln1039_7_fu_1169_p2;
wire   [0:0] xor_ln1039_8_fu_1178_p2;
wire   [0:0] xor_ln1039_9_fu_1187_p2;
wire   [0:0] xor_ln1039_10_fu_1196_p2;
wire   [0:0] xor_ln1039_11_fu_1205_p2;
wire   [0:0] xor_ln1039_12_fu_1214_p2;
wire   [0:0] xor_ln1039_13_fu_1223_p2;
wire   [1:0] zext_ln215_fu_1102_p1;
wire   [1:0] zext_ln218_1_fu_1120_p1;
wire   [1:0] add_ln840_1_fu_1232_p2;
wire   [1:0] zext_ln218_fu_1111_p1;
wire   [1:0] add_ln840_2_fu_1238_p2;
wire   [1:0] zext_ln218_2_fu_1129_p1;
wire   [1:0] zext_ln218_3_fu_1138_p1;
wire   [1:0] add_ln840_3_fu_1248_p2;
wire   [1:0] zext_ln218_4_fu_1147_p1;
wire   [1:0] zext_ln218_5_fu_1156_p1;
wire   [1:0] add_ln840_4_fu_1258_p2;
wire   [2:0] zext_ln840_3_fu_1264_p1;
wire   [2:0] zext_ln840_2_fu_1254_p1;
wire   [2:0] add_ln840_5_fu_1268_p2;
wire   [2:0] zext_ln840_1_fu_1244_p1;
wire   [1:0] zext_ln218_6_fu_1165_p1;
wire   [1:0] zext_ln218_7_fu_1174_p1;
wire   [1:0] add_ln840_7_fu_1280_p2;
wire   [1:0] zext_ln218_8_fu_1183_p1;
wire   [1:0] zext_ln218_9_fu_1192_p1;
wire   [1:0] add_ln840_8_fu_1290_p2;
wire   [2:0] zext_ln840_6_fu_1296_p1;
wire   [2:0] zext_ln840_5_fu_1286_p1;
wire   [1:0] zext_ln218_10_fu_1201_p1;
wire   [1:0] zext_ln218_11_fu_1210_p1;
wire   [1:0] add_ln840_10_fu_1306_p2;
wire   [1:0] zext_ln218_12_fu_1219_p1;
wire   [1:0] zext_ln840_fu_1228_p1;
wire   [1:0] add_ln840_11_fu_1316_p2;
wire   [2:0] zext_ln840_9_fu_1322_p1;
wire   [2:0] zext_ln840_8_fu_1312_p1;
wire   [3:0] zext_ln840_10_fu_1338_p1;
wire   [3:0] zext_ln840_7_fu_1335_p1;
wire   [3:0] add_ln840_13_fu_1341_p2;
wire   [3:0] zext_ln840_4_fu_1332_p1;
wire   [3:0] result_V_2_fu_1347_p2;
wire  signed [14:0] grp_fu_1358_p2;
reg    grp_fu_1358_ce;
reg    ap_done_reg;
wire    ap_continue_int;
reg    ap_done_int;
reg    ap_loop_exit_ready_pp0_iter1_reg;
reg    ap_loop_exit_ready_pp0_iter2_reg;
reg    ap_loop_exit_ready_pp0_iter3_reg;
reg    ap_loop_exit_ready_pp0_iter4_reg;
reg    ap_loop_exit_ready_pp0_iter5_reg;
reg    ap_loop_exit_ready_pp0_iter6_reg;
reg   [0:0] ap_NS_iter0_fsm;
reg   [1:0] ap_NS_iter1_fsm;
reg   [1:0] ap_NS_iter2_fsm;
reg   [1:0] ap_NS_iter3_fsm;
reg   [1:0] ap_NS_iter4_fsm;
reg   [1:0] ap_NS_iter5_fsm;
reg   [1:0] ap_NS_iter6_fsm;
reg    ap_ST_iter0_fsm_state1_blk;
wire    ap_ST_iter1_fsm_state2_blk;
wire    ap_ST_iter2_fsm_state3_blk;
wire    ap_ST_iter3_fsm_state4_blk;
wire    ap_ST_iter4_fsm_state5_blk;
wire    ap_ST_iter5_fsm_state6_blk;
reg    ap_ST_iter6_fsm_state7_blk;
wire    ap_start_int;
reg    ap_condition_1254;
wire    ap_ce_reg;

// power-on initialization
initial begin
#0 ap_CS_iter0_fsm = 1'd1;
#0 ap_CS_iter1_fsm = 2'd1;
#0 ap_CS_iter2_fsm = 2'd1;
#0 ap_CS_iter3_fsm = 2'd1;
#0 ap_CS_iter4_fsm = 2'd1;
#0 ap_CS_iter5_fsm = 2'd1;
#0 ap_CS_iter6_fsm = 2'd1;
#0 ap_done_reg = 1'b0;
end

MVAU_hls_0_Matrix_Vector_Activate_Stream_Batch_p_ZL7threshs_0_ROM_AUTO_1R #(
    .DataWidth( 12 ),
    .AddressRange( 16 ),
    .AddressWidth( 4 ))
p_ZL7threshs_0_U(
    .clk(ap_clk),
    .reset(ap_rst),
    .address0(p_ZL7threshs_0_address0),
    .ce0(p_ZL7threshs_0_ce0),
    .q0(p_ZL7threshs_0_q0)
);

MVAU_hls_0_Matrix_Vector_Activate_Stream_Batch_p_ZL7threshs_1_ROM_AUTO_1R #(
    .DataWidth( 12 ),
    .AddressRange( 16 ),
    .AddressWidth( 4 ))
p_ZL7threshs_1_U(
    .clk(ap_clk),
    .reset(ap_rst),
    .address0(p_ZL7threshs_1_address0),
    .ce0(p_ZL7threshs_1_ce0),
    .q0(p_ZL7threshs_1_q0)
);

MVAU_hls_0_Matrix_Vector_Activate_Stream_Batch_p_ZL7threshs_2_ROM_AUTO_1R #(
    .DataWidth( 12 ),
    .AddressRange( 16 ),
    .AddressWidth( 4 ))
p_ZL7threshs_2_U(
    .clk(ap_clk),
    .reset(ap_rst),
    .address0(p_ZL7threshs_2_address0),
    .ce0(p_ZL7threshs_2_ce0),
    .q0(p_ZL7threshs_2_q0)
);

MVAU_hls_0_Matrix_Vector_Activate_Stream_Batch_p_ZL7threshs_3_ROM_AUTO_1R #(
    .DataWidth( 13 ),
    .AddressRange( 16 ),
    .AddressWidth( 4 ))
p_ZL7threshs_3_U(
    .clk(ap_clk),
    .reset(ap_rst),
    .address0(p_ZL7threshs_3_address0),
    .ce0(p_ZL7threshs_3_ce0),
    .q0(p_ZL7threshs_3_q0)
);

MVAU_hls_0_Matrix_Vector_Activate_Stream_Batch_p_ZL7threshs_4_ROM_AUTO_1R #(
    .DataWidth( 13 ),
    .AddressRange( 16 ),
    .AddressWidth( 4 ))
p_ZL7threshs_4_U(
    .clk(ap_clk),
    .reset(ap_rst),
    .address0(p_ZL7threshs_4_address0),
    .ce0(p_ZL7threshs_4_ce0),
    .q0(p_ZL7threshs_4_q0)
);

MVAU_hls_0_Matrix_Vector_Activate_Stream_Batch_p_ZL7threshs_5_ROM_AUTO_1R #(
    .DataWidth( 13 ),
    .AddressRange( 16 ),
    .AddressWidth( 4 ))
p_ZL7threshs_5_U(
    .clk(ap_clk),
    .reset(ap_rst),
    .address0(p_ZL7threshs_5_address0),
    .ce0(p_ZL7threshs_5_ce0),
    .q0(p_ZL7threshs_5_q0)
);

MVAU_hls_0_Matrix_Vector_Activate_Stream_Batch_p_ZL7threshs_6_ROM_AUTO_1R #(
    .DataWidth( 13 ),
    .AddressRange( 16 ),
    .AddressWidth( 4 ))
p_ZL7threshs_6_U(
    .clk(ap_clk),
    .reset(ap_rst),
    .address0(p_ZL7threshs_6_address0),
    .ce0(p_ZL7threshs_6_ce0),
    .q0(p_ZL7threshs_6_q0)
);

MVAU_hls_0_Matrix_Vector_Activate_Stream_Batch_p_ZL7threshs_7_ROM_AUTO_1R #(
    .DataWidth( 13 ),
    .AddressRange( 16 ),
    .AddressWidth( 4 ))
p_ZL7threshs_7_U(
    .clk(ap_clk),
    .reset(ap_rst),
    .address0(p_ZL7threshs_7_address0),
    .ce0(p_ZL7threshs_7_ce0),
    .q0(p_ZL7threshs_7_q0)
);

MVAU_hls_0_Matrix_Vector_Activate_Stream_Batch_p_ZL7threshs_8_ROM_AUTO_1R #(
    .DataWidth( 13 ),
    .AddressRange( 16 ),
    .AddressWidth( 4 ))
p_ZL7threshs_8_U(
    .clk(ap_clk),
    .reset(ap_rst),
    .address0(p_ZL7threshs_8_address0),
    .ce0(p_ZL7threshs_8_ce0),
    .q0(p_ZL7threshs_8_q0)
);

MVAU_hls_0_Matrix_Vector_Activate_Stream_Batch_p_ZL7threshs_9_ROM_AUTO_1R #(
    .DataWidth( 13 ),
    .AddressRange( 16 ),
    .AddressWidth( 4 ))
p_ZL7threshs_9_U(
    .clk(ap_clk),
    .reset(ap_rst),
    .address0(p_ZL7threshs_9_address0),
    .ce0(p_ZL7threshs_9_ce0),
    .q0(p_ZL7threshs_9_q0)
);

MVAU_hls_0_Matrix_Vector_Activate_Stream_Batch_p_ZL7threshs_10_ROM_AUTO_1R #(
    .DataWidth( 12 ),
    .AddressRange( 16 ),
    .AddressWidth( 4 ))
p_ZL7threshs_10_U(
    .clk(ap_clk),
    .reset(ap_rst),
    .address0(p_ZL7threshs_10_address0),
    .ce0(p_ZL7threshs_10_ce0),
    .q0(p_ZL7threshs_10_q0)
);

MVAU_hls_0_Matrix_Vector_Activate_Stream_Batch_p_ZL7threshs_11_ROM_AUTO_1R #(
    .DataWidth( 12 ),
    .AddressRange( 16 ),
    .AddressWidth( 4 ))
p_ZL7threshs_11_U(
    .clk(ap_clk),
    .reset(ap_rst),
    .address0(p_ZL7threshs_11_address0),
    .ce0(p_ZL7threshs_11_ce0),
    .q0(p_ZL7threshs_11_q0)
);

MVAU_hls_0_Matrix_Vector_Activate_Stream_Batch_p_ZL7threshs_12_ROM_AUTO_1R #(
    .DataWidth( 12 ),
    .AddressRange( 16 ),
    .AddressWidth( 4 ))
p_ZL7threshs_12_U(
    .clk(ap_clk),
    .reset(ap_rst),
    .address0(p_ZL7threshs_12_address0),
    .ce0(p_ZL7threshs_12_ce0),
    .q0(p_ZL7threshs_12_q0)
);

MVAU_hls_0_Matrix_Vector_Activate_Stream_Batch_p_ZL7threshs_13_ROM_AUTO_1R #(
    .DataWidth( 12 ),
    .AddressRange( 16 ),
    .AddressWidth( 4 ))
p_ZL7threshs_13_U(
    .clk(ap_clk),
    .reset(ap_rst),
    .address0(p_ZL7threshs_13_address0),
    .ce0(p_ZL7threshs_13_ce0),
    .q0(p_ZL7threshs_13_q0)
);

MVAU_hls_0_Matrix_Vector_Activate_Stream_Batch_p_ZL7threshs_14_ROM_AUTO_1R #(
    .DataWidth( 12 ),
    .AddressRange( 16 ),
    .AddressWidth( 4 ))
p_ZL7threshs_14_U(
    .clk(ap_clk),
    .reset(ap_rst),
    .address0(p_ZL7threshs_14_address0),
    .ce0(p_ZL7threshs_14_ce0),
    .q0(p_ZL7threshs_14_q0)
);

MVAU_hls_0_mux_275_8_1_1 #(
    .ID( 1 ),
    .NUM_STAGE( 1 ),
    .din0_WIDTH( 8 ),
    .din1_WIDTH( 8 ),
    .din2_WIDTH( 8 ),
    .din3_WIDTH( 8 ),
    .din4_WIDTH( 8 ),
    .din5_WIDTH( 8 ),
    .din6_WIDTH( 8 ),
    .din7_WIDTH( 8 ),
    .din8_WIDTH( 8 ),
    .din9_WIDTH( 8 ),
    .din10_WIDTH( 8 ),
    .din11_WIDTH( 8 ),
    .din12_WIDTH( 8 ),
    .din13_WIDTH( 8 ),
    .din14_WIDTH( 8 ),
    .din15_WIDTH( 8 ),
    .din16_WIDTH( 8 ),
    .din17_WIDTH( 8 ),
    .din18_WIDTH( 8 ),
    .din19_WIDTH( 8 ),
    .din20_WIDTH( 8 ),
    .din21_WIDTH( 8 ),
    .din22_WIDTH( 8 ),
    .din23_WIDTH( 8 ),
    .din24_WIDTH( 8 ),
    .din25_WIDTH( 8 ),
    .din26_WIDTH( 8 ),
    .din27_WIDTH( 5 ),
    .dout_WIDTH( 8 ))
mux_275_8_1_1_U1(
    .din0(inputBuf_V_fu_148),
    .din1(inputBuf_V_1_fu_152),
    .din2(inputBuf_V_2_fu_156),
    .din3(inputBuf_V_3_fu_160),
    .din4(inputBuf_V_4_fu_164),
    .din5(inputBuf_V_5_fu_168),
    .din6(inputBuf_V_6_fu_172),
    .din7(inputBuf_V_7_fu_176),
    .din8(inputBuf_V_8_fu_180),
    .din9(inputBuf_V_9_fu_184),
    .din10(inputBuf_V_10_fu_188),
    .din11(inputBuf_V_11_fu_192),
    .din12(inputBuf_V_12_fu_196),
    .din13(inputBuf_V_13_fu_200),
    .din14(inputBuf_V_14_fu_204),
    .din15(inputBuf_V_15_fu_208),
    .din16(inputBuf_V_16_fu_212),
    .din17(inputBuf_V_17_fu_216),
    .din18(inputBuf_V_18_fu_220),
    .din19(inputBuf_V_19_fu_224),
    .din20(inputBuf_V_20_fu_228),
    .din21(inputBuf_V_21_fu_232),
    .din22(inputBuf_V_22_fu_236),
    .din23(inputBuf_V_23_fu_240),
    .din24(inputBuf_V_24_fu_244),
    .din25(inputBuf_V_25_fu_248),
    .din26(inputBuf_V_26_fu_252),
    .din27(tmp_fu_662_p28),
    .dout(tmp_fu_662_p29)
);

MVAU_hls_0_mac_muladd_8s_4s_15s_15_4_1 #(
    .ID( 1 ),
    .NUM_STAGE( 4 ),
    .din0_WIDTH( 8 ),
    .din1_WIDTH( 4 ),
    .din2_WIDTH( 15 ),
    .dout_WIDTH( 15 ))
mac_muladd_8s_4s_15s_15_4_1_U2(
    .clk(ap_clk),
    .reset(ap_rst),
    .din0(ap_phi_reg_pp0_iter1_inElem_1_reg_474),
    .din1(W_packed_V_reg_1625),
    .din2(grp_fu_1358_p2),
    .ce(grp_fu_1358_ce),
    .dout(grp_fu_1358_p3)
);

MVAU_hls_0_flow_control_loop_pipe_sequential_init flow_control_loop_pipe_sequential_init_U(
    .ap_clk(ap_clk),
    .ap_rst(ap_rst),
    .ap_start(ap_start),
    .ap_ready(ap_ready),
    .ap_done(ap_done),
    .ap_start_int(ap_start_int),
    .ap_loop_init(ap_loop_init),
    .ap_ready_int(ap_ready_int),
    .ap_loop_exit_ready(ap_condition_exit_pp0_iter0_stage0),
    .ap_loop_exit_done(ap_done_int),
    .ap_continue_int(ap_continue_int),
    .ap_done_int(ap_done_int)
);

always @ (posedge ap_clk) begin
    if (ap_rst == 1'b1) begin
        ap_CS_iter0_fsm <= ap_ST_iter0_fsm_state1;
    end else begin
        ap_CS_iter0_fsm <= ap_NS_iter0_fsm;
    end
end

always @ (posedge ap_clk) begin
    if (ap_rst == 1'b1) begin
        ap_CS_iter1_fsm <= ap_ST_iter1_fsm_state0;
    end else begin
        ap_CS_iter1_fsm <= ap_NS_iter1_fsm;
    end
end

always @ (posedge ap_clk) begin
    if (ap_rst == 1'b1) begin
        ap_CS_iter2_fsm <= ap_ST_iter2_fsm_state0;
    end else begin
        ap_CS_iter2_fsm <= ap_NS_iter2_fsm;
    end
end

always @ (posedge ap_clk) begin
    if (ap_rst == 1'b1) begin
        ap_CS_iter3_fsm <= ap_ST_iter3_fsm_state0;
    end else begin
        ap_CS_iter3_fsm <= ap_NS_iter3_fsm;
    end
end

always @ (posedge ap_clk) begin
    if (ap_rst == 1'b1) begin
        ap_CS_iter4_fsm <= ap_ST_iter4_fsm_state0;
    end else begin
        ap_CS_iter4_fsm <= ap_NS_iter4_fsm;
    end
end

always @ (posedge ap_clk) begin
    if (ap_rst == 1'b1) begin
        ap_CS_iter5_fsm <= ap_ST_iter5_fsm_state0;
    end else begin
        ap_CS_iter5_fsm <= ap_NS_iter5_fsm;
    end
end

always @ (posedge ap_clk) begin
    if (ap_rst == 1'b1) begin
        ap_CS_iter6_fsm <= ap_ST_iter6_fsm_state0;
    end else begin
        ap_CS_iter6_fsm <= ap_NS_iter6_fsm;
    end
end

always @ (posedge ap_clk) begin
    if (ap_rst == 1'b1) begin
        ap_done_reg <= 1'b0;
    end else begin
        if ((ap_continue_int == 1'b1)) begin
            ap_done_reg <= 1'b0;
        end else if ((~((1'b1 == ap_block_state7_io) | ((ap_predicate_op304_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))) & (1'b1 == ap_CS_iter6_fsm_state7) & (ap_loop_exit_ready_pp0_iter6_reg == 1'b1))) begin
            ap_done_reg <= 1'b1;
        end
    end
end

always @ (posedge ap_clk) begin
    if ((~((1'b1 == ap_block_state7_io) | ((ap_predicate_op304_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))) & (1'b1 == ap_CS_iter6_fsm_state7) & (ap_loop_exit_ready_pp0_iter5_reg == 1'b0))) begin
        ap_loop_exit_ready_pp0_iter6_reg <= 1'b0;
    end else if ((~((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op304_write_state7 == 1'b1) & (out_V_TREADY == 1'b0)))) & (1'b1 == ap_CS_iter5_fsm_state6))) begin
        ap_loop_exit_ready_pp0_iter6_reg <= ap_loop_exit_ready_pp0_iter5_reg;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_559_p2 == 1'd0)) | ((ap_predicate_op89_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op304_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_571_p2 == 1'd0) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_559_p2 == 1'd0))) begin
        ap_phi_reg_pp0_iter1_inElem_1_reg_474 <= tmp_fu_662_p29;
    end else if (((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_559_p2 == 1'd0)) | ((ap_predicate_op89_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op304_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_571_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_559_p2 == 1'd0) & (trunc_ln257_fu_722_p1 == 5'd25)) | (~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_559_p2 == 1'd0)) | ((ap_predicate_op89_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op304_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_571_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_559_p2 == 1'd0) & (trunc_ln257_fu_722_p1 == 5'd0)) | (~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_559_p2 == 1'd0)) | ((ap_predicate_op89_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op304_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_571_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_559_p2 == 1'd0) & (trunc_ln257_fu_722_p1 == 5'd1)) | (~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_559_p2 == 1'd0)) | ((ap_predicate_op89_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op304_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_571_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_559_p2 == 1'd0) & (trunc_ln257_fu_722_p1 == 5'd2)) | (~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_559_p2 == 1'd0)) | ((ap_predicate_op89_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op304_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_571_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_559_p2 == 1'd0) & (trunc_ln257_fu_722_p1 == 5'd3)) | (~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_559_p2 == 1'd0)) | ((ap_predicate_op89_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op304_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_571_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_559_p2 == 1'd0) & (trunc_ln257_fu_722_p1 == 5'd4)) | (~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_559_p2 == 1'd0)) | ((ap_predicate_op89_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op304_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_571_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_559_p2 == 1'd0) & (trunc_ln257_fu_722_p1 == 5'd5)) | (~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_559_p2 == 1'd0)) | ((ap_predicate_op89_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op304_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_571_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_559_p2 == 1'd0) & (trunc_ln257_fu_722_p1 == 5'd6)) | (~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_559_p2 == 1'd0)) | ((ap_predicate_op89_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op304_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_571_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_559_p2 == 1'd0) & (trunc_ln257_fu_722_p1 == 5'd7)) | (~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_559_p2 == 1'd0)) | ((ap_predicate_op89_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op304_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_571_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_559_p2 == 1'd0) & (trunc_ln257_fu_722_p1 == 5'd8)) | (~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_559_p2 == 1'd0)) | ((ap_predicate_op89_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op304_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_571_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_559_p2 == 1'd0) & (trunc_ln257_fu_722_p1 == 5'd9)) | (~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_559_p2 == 1'd0)) | ((ap_predicate_op89_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op304_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_571_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_559_p2 == 1'd0) & (trunc_ln257_fu_722_p1 == 5'd10)) | (~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_559_p2 == 1'd0)) | ((ap_predicate_op89_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op304_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_571_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_559_p2 == 1'd0) & (trunc_ln257_fu_722_p1 == 5'd11)) | (~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_559_p2 == 1'd0)) | ((ap_predicate_op89_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op304_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_571_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_559_p2 == 1'd0) & (trunc_ln257_fu_722_p1 == 5'd12)) | (~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_559_p2 == 1'd0)) | ((ap_predicate_op89_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op304_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_571_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_559_p2 == 1'd0) & (trunc_ln257_fu_722_p1 == 5'd13)) | (~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_559_p2 == 1'd0)) | ((ap_predicate_op89_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op304_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_571_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_559_p2 == 1'd0) & (trunc_ln257_fu_722_p1 == 5'd14)) | (~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_559_p2 == 1'd0)) | ((ap_predicate_op89_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op304_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_571_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_559_p2 == 1'd0) & (trunc_ln257_fu_722_p1 == 5'd15)) | (~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_559_p2 == 1'd0)) | ((ap_predicate_op89_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op304_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_571_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_559_p2 == 1'd0) & (trunc_ln257_fu_722_p1 == 5'd16)) | (~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_559_p2 == 1'd0)) | ((ap_predicate_op89_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op304_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_571_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_559_p2 == 1'd0) & (trunc_ln257_fu_722_p1 == 5'd17)) | (~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_559_p2 == 1'd0)) | ((ap_predicate_op89_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op304_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_571_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_559_p2 == 1'd0) & (trunc_ln257_fu_722_p1 == 5'd18)) | (~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_559_p2 == 1'd0)) | ((ap_predicate_op89_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op304_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_571_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_559_p2 == 1'd0) & (trunc_ln257_fu_722_p1 == 5'd19)) | (~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_559_p2 == 1'd0)) | ((ap_predicate_op89_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op304_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_571_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_559_p2 == 1'd0) & (trunc_ln257_fu_722_p1 == 5'd20)) | (~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_559_p2 == 1'd0)) | ((ap_predicate_op89_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op304_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_571_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_559_p2 == 1'd0) & (trunc_ln257_fu_722_p1 == 5'd21)) | (~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_559_p2 == 1'd0)) | ((ap_predicate_op89_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op304_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_571_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_559_p2 == 1'd0) & (trunc_ln257_fu_722_p1 == 5'd22)) | (~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_559_p2 == 1'd0)) | ((ap_predicate_op89_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op304_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_571_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_559_p2 == 1'd0) & (trunc_ln257_fu_722_p1 == 5'd23)) | (~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_559_p2 == 1'd0)) | ((ap_predicate_op89_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op304_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_571_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_559_p2 == 1'd0) & (trunc_ln257_fu_722_p1 == 5'd24)) | (~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_559_p2 == 1'd0)) | ((ap_predicate_op89_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op304_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (1'b1 == ap_CS_iter0_fsm_state1) & (((((((icmp_ln253_fu_571_p2 == 1'd1) & (icmp_ln249_fu_559_p2 == 1'd0) & (trunc_ln257_fu_722_p1 == 5'd30)) | ((icmp_ln253_fu_571_p2 == 1'd1) & (icmp_ln249_fu_559_p2 == 1'd0) & (trunc_ln257_fu_722_p1 == 5'd31))) | ((icmp_ln253_fu_571_p2 == 1'd1) & (icmp_ln249_fu_559_p2 == 1'd0) & (trunc_ln257_fu_722_p1 == 5'd29))) | ((icmp_ln253_fu_571_p2 == 1'd1) & (icmp_ln249_fu_559_p2 == 1'd0) & (trunc_ln257_fu_722_p1 == 5'd28))) | ((icmp_ln253_fu_571_p2 == 1'd1) & (icmp_ln249_fu_559_p2 == 1'd0) & (trunc_ln257_fu_722_p1 == 5'd27))) | ((icmp_ln253_fu_571_p2 == 1'd1) & (icmp_ln249_fu_559_p2 == 1'd0) & (trunc_ln257_fu_722_p1 == 5'd26)))))) begin
        ap_phi_reg_pp0_iter1_inElem_1_reg_474 <= in0_V_TDATA;
    end else if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_559_p2 == 1'd0)) | ((ap_predicate_op89_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op304_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (1'b1 == ap_CS_iter0_fsm_state1))) begin
        ap_phi_reg_pp0_iter1_inElem_1_reg_474 <= ap_phi_reg_pp0_iter0_inElem_1_reg_474;
    end
end

always @ (posedge ap_clk) begin
    if ((1'b1 == ap_condition_1254)) begin
        if ((icmp_ln249_fu_559_p2 == 1'd0)) begin
            i_fu_140 <= i_2_fu_565_p2;
        end else if ((ap_loop_init == 1'b1)) begin
            i_fu_140 <= 19'd0;
        end
    end
end

always @ (posedge ap_clk) begin
    if ((1'b1 == ap_condition_1254)) begin
        if (((icmp_ln249_fu_559_p2 == 1'd0) & (icmp_ln290_fu_877_p2 == 1'd1))) begin
            nf_1_fu_256 <= nf_3_fu_900_p3;
        end else if ((ap_loop_init == 1'b1)) begin
            nf_1_fu_256 <= 32'd0;
        end
    end
end

always @ (posedge ap_clk) begin
    if ((1'b1 == ap_condition_1254)) begin
        if (((icmp_ln249_fu_559_p2 == 1'd0) & (icmp_ln290_fu_877_p2 == 1'd1))) begin
            sf_fu_136 <= 32'd0;
        end else if (((icmp_ln249_fu_559_p2 == 1'd0) & (icmp_ln290_fu_877_p2 == 1'd0))) begin
            sf_fu_136 <= sf_2_fu_871_p2;
        end else if ((ap_loop_init == 1'b1)) begin
            sf_fu_136 <= 32'd0;
        end
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_559_p2 == 1'd0)) | ((ap_predicate_op89_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op304_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_559_p2 == 1'd0))) begin
        W_packed_V_reg_1625 <= W_packed_V_fu_861_p1;
        icmp_ln272_reg_1630 <= icmp_ln272_fu_865_p2;
        icmp_ln290_reg_1635 <= icmp_ln290_fu_877_p2;
    end
end

always @ (posedge ap_clk) begin
    if ((~((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op304_write_state7 == 1'b1) & (out_V_TREADY == 1'b0)))) & (1'b1 == ap_CS_iter4_fsm_state5) & (icmp_ln249_reg_1577_pp0_iter3_reg == 1'd0))) begin
        add_i4_i338_fu_144 <= grp_fu_1358_p3;
    end
end

always @ (posedge ap_clk) begin
    if ((~((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op304_write_state7 == 1'b1) & (out_V_TREADY == 1'b0)))) & (1'b1 == ap_CS_iter5_fsm_state6) & (icmp_ln290_reg_1635_pp0_iter4_reg == 1'd1) & (icmp_ln249_reg_1577_pp0_iter4_reg == 1'd0))) begin
        add_ln840_12_reg_1814 <= add_ln840_12_fu_1326_p2;
        add_ln840_6_reg_1804 <= add_ln840_6_fu_1274_p2;
        add_ln840_9_reg_1809 <= add_ln840_9_fu_1300_p2;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_559_p2 == 1'd0)) | ((ap_predicate_op89_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op304_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (1'b1 == ap_CS_iter0_fsm_state1))) begin
        ap_loop_exit_ready_pp0_iter1_reg <= ap_loop_exit_ready;
        icmp_ln249_reg_1577 <= icmp_ln249_fu_559_p2;
        nf_2_reg_1572 <= ap_sig_allocacmp_nf_2;
    end
end

always @ (posedge ap_clk) begin
    if ((~((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op304_write_state7 == 1'b1) & (out_V_TREADY == 1'b0)))) & (1'b1 == ap_CS_iter1_fsm_state2))) begin
        ap_loop_exit_ready_pp0_iter2_reg <= ap_loop_exit_ready_pp0_iter1_reg;
        icmp_ln249_reg_1577_pp0_iter1_reg <= icmp_ln249_reg_1577;
        icmp_ln272_reg_1630_pp0_iter1_reg <= icmp_ln272_reg_1630;
        icmp_ln290_reg_1635_pp0_iter1_reg <= icmp_ln290_reg_1635;
        nf_2_reg_1572_pp0_iter1_reg <= nf_2_reg_1572;
    end
end

always @ (posedge ap_clk) begin
    if ((~((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op304_write_state7 == 1'b1) & (out_V_TREADY == 1'b0)))) & (1'b1 == ap_CS_iter2_fsm_state3))) begin
        ap_loop_exit_ready_pp0_iter3_reg <= ap_loop_exit_ready_pp0_iter2_reg;
        icmp_ln249_reg_1577_pp0_iter2_reg <= icmp_ln249_reg_1577_pp0_iter1_reg;
        icmp_ln272_reg_1630_pp0_iter2_reg <= icmp_ln272_reg_1630_pp0_iter1_reg;
        icmp_ln290_reg_1635_pp0_iter2_reg <= icmp_ln290_reg_1635_pp0_iter1_reg;
        nf_2_reg_1572_pp0_iter2_reg <= nf_2_reg_1572_pp0_iter1_reg;
    end
end

always @ (posedge ap_clk) begin
    if ((~((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op304_write_state7 == 1'b1) & (out_V_TREADY == 1'b0)))) & (1'b1 == ap_CS_iter3_fsm_state4))) begin
        ap_loop_exit_ready_pp0_iter4_reg <= ap_loop_exit_ready_pp0_iter3_reg;
        icmp_ln249_reg_1577_pp0_iter3_reg <= icmp_ln249_reg_1577_pp0_iter2_reg;
        icmp_ln290_reg_1635_pp0_iter3_reg <= icmp_ln290_reg_1635_pp0_iter2_reg;
    end
end

always @ (posedge ap_clk) begin
    if ((~((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op304_write_state7 == 1'b1) & (out_V_TREADY == 1'b0)))) & (1'b1 == ap_CS_iter4_fsm_state5))) begin
        ap_loop_exit_ready_pp0_iter5_reg <= ap_loop_exit_ready_pp0_iter4_reg;
        icmp_ln249_reg_1577_pp0_iter4_reg <= icmp_ln249_reg_1577_pp0_iter3_reg;
        icmp_ln290_reg_1635_pp0_iter4_reg <= icmp_ln290_reg_1635_pp0_iter3_reg;
    end
end

always @ (posedge ap_clk) begin
    if ((~((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op304_write_state7 == 1'b1) & (out_V_TREADY == 1'b0)))) & (1'b1 == ap_CS_iter4_fsm_state5) & (icmp_ln290_reg_1635_pp0_iter3_reg == 1'd1) & (icmp_ln249_reg_1577_pp0_iter3_reg == 1'd0))) begin
        icmp_ln1039_10_reg_1779 <= icmp_ln1039_10_fu_1052_p2;
        icmp_ln1039_11_reg_1784 <= icmp_ln1039_11_fu_1061_p2;
        icmp_ln1039_12_reg_1789 <= icmp_ln1039_12_fu_1070_p2;
        icmp_ln1039_13_reg_1794 <= icmp_ln1039_13_fu_1079_p2;
        icmp_ln1039_14_reg_1799 <= icmp_ln1039_14_fu_1088_p2;
        icmp_ln1039_1_reg_1734 <= icmp_ln1039_1_fu_971_p2;
        icmp_ln1039_2_reg_1739 <= icmp_ln1039_2_fu_980_p2;
        icmp_ln1039_3_reg_1744 <= icmp_ln1039_3_fu_989_p2;
        icmp_ln1039_4_reg_1749 <= icmp_ln1039_4_fu_998_p2;
        icmp_ln1039_5_reg_1754 <= icmp_ln1039_5_fu_1007_p2;
        icmp_ln1039_6_reg_1759 <= icmp_ln1039_6_fu_1016_p2;
        icmp_ln1039_7_reg_1764 <= icmp_ln1039_7_fu_1025_p2;
        icmp_ln1039_8_reg_1769 <= icmp_ln1039_8_fu_1034_p2;
        icmp_ln1039_9_reg_1774 <= icmp_ln1039_9_fu_1043_p2;
        icmp_ln1039_reg_1729 <= icmp_ln1039_fu_962_p2;
    end
end

always @ (posedge ap_clk) begin
    if ((~((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op304_write_state7 == 1'b1) & (out_V_TREADY == 1'b0)))) & (1'b1 == ap_CS_iter5_fsm_state6))) begin
        icmp_ln249_reg_1577_pp0_iter5_reg <= icmp_ln249_reg_1577_pp0_iter4_reg;
        icmp_ln290_reg_1635_pp0_iter5_reg <= icmp_ln290_reg_1635_pp0_iter4_reg;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_559_p2 == 1'd0)) | ((ap_predicate_op89_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op304_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_571_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_559_p2 == 1'd0) & (trunc_ln257_fu_722_p1 == 5'd10))) begin
        inputBuf_V_10_fu_188 <= in0_V_TDATA;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_559_p2 == 1'd0)) | ((ap_predicate_op89_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op304_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_571_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_559_p2 == 1'd0) & (trunc_ln257_fu_722_p1 == 5'd11))) begin
        inputBuf_V_11_fu_192 <= in0_V_TDATA;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_559_p2 == 1'd0)) | ((ap_predicate_op89_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op304_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_571_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_559_p2 == 1'd0) & (trunc_ln257_fu_722_p1 == 5'd12))) begin
        inputBuf_V_12_fu_196 <= in0_V_TDATA;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_559_p2 == 1'd0)) | ((ap_predicate_op89_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op304_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_571_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_559_p2 == 1'd0) & (trunc_ln257_fu_722_p1 == 5'd13))) begin
        inputBuf_V_13_fu_200 <= in0_V_TDATA;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_559_p2 == 1'd0)) | ((ap_predicate_op89_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op304_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_571_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_559_p2 == 1'd0) & (trunc_ln257_fu_722_p1 == 5'd14))) begin
        inputBuf_V_14_fu_204 <= in0_V_TDATA;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_559_p2 == 1'd0)) | ((ap_predicate_op89_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op304_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_571_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_559_p2 == 1'd0) & (trunc_ln257_fu_722_p1 == 5'd15))) begin
        inputBuf_V_15_fu_208 <= in0_V_TDATA;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_559_p2 == 1'd0)) | ((ap_predicate_op89_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op304_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_571_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_559_p2 == 1'd0) & (trunc_ln257_fu_722_p1 == 5'd16))) begin
        inputBuf_V_16_fu_212 <= in0_V_TDATA;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_559_p2 == 1'd0)) | ((ap_predicate_op89_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op304_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_571_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_559_p2 == 1'd0) & (trunc_ln257_fu_722_p1 == 5'd17))) begin
        inputBuf_V_17_fu_216 <= in0_V_TDATA;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_559_p2 == 1'd0)) | ((ap_predicate_op89_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op304_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_571_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_559_p2 == 1'd0) & (trunc_ln257_fu_722_p1 == 5'd18))) begin
        inputBuf_V_18_fu_220 <= in0_V_TDATA;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_559_p2 == 1'd0)) | ((ap_predicate_op89_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op304_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_571_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_559_p2 == 1'd0) & (trunc_ln257_fu_722_p1 == 5'd19))) begin
        inputBuf_V_19_fu_224 <= in0_V_TDATA;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_559_p2 == 1'd0)) | ((ap_predicate_op89_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op304_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_571_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_559_p2 == 1'd0) & (trunc_ln257_fu_722_p1 == 5'd1))) begin
        inputBuf_V_1_fu_152 <= in0_V_TDATA;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_559_p2 == 1'd0)) | ((ap_predicate_op89_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op304_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_571_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_559_p2 == 1'd0) & (trunc_ln257_fu_722_p1 == 5'd20))) begin
        inputBuf_V_20_fu_228 <= in0_V_TDATA;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_559_p2 == 1'd0)) | ((ap_predicate_op89_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op304_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_571_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_559_p2 == 1'd0) & (trunc_ln257_fu_722_p1 == 5'd21))) begin
        inputBuf_V_21_fu_232 <= in0_V_TDATA;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_559_p2 == 1'd0)) | ((ap_predicate_op89_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op304_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_571_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_559_p2 == 1'd0) & (trunc_ln257_fu_722_p1 == 5'd22))) begin
        inputBuf_V_22_fu_236 <= in0_V_TDATA;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_559_p2 == 1'd0)) | ((ap_predicate_op89_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op304_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_571_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_559_p2 == 1'd0) & (trunc_ln257_fu_722_p1 == 5'd23))) begin
        inputBuf_V_23_fu_240 <= in0_V_TDATA;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_559_p2 == 1'd0)) | ((ap_predicate_op89_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op304_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_571_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_559_p2 == 1'd0) & (trunc_ln257_fu_722_p1 == 5'd24))) begin
        inputBuf_V_24_fu_244 <= in0_V_TDATA;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_559_p2 == 1'd0)) | ((ap_predicate_op89_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op304_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_571_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_559_p2 == 1'd0) & (trunc_ln257_fu_722_p1 == 5'd25))) begin
        inputBuf_V_25_fu_248 <= in0_V_TDATA;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_559_p2 == 1'd0)) | ((ap_predicate_op89_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op304_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (1'b1 == ap_CS_iter0_fsm_state1) & (((((((icmp_ln253_fu_571_p2 == 1'd1) & (icmp_ln249_fu_559_p2 == 1'd0) & (trunc_ln257_fu_722_p1 == 5'd30)) | ((icmp_ln253_fu_571_p2 == 1'd1) & (icmp_ln249_fu_559_p2 == 1'd0) & (trunc_ln257_fu_722_p1 == 5'd31))) | ((icmp_ln253_fu_571_p2 == 1'd1) & (icmp_ln249_fu_559_p2 == 1'd0) & (trunc_ln257_fu_722_p1 == 5'd29))) | ((icmp_ln253_fu_571_p2 == 1'd1) & (icmp_ln249_fu_559_p2 == 1'd0) & (trunc_ln257_fu_722_p1 == 5'd28))) | ((icmp_ln253_fu_571_p2 == 1'd1) & (icmp_ln249_fu_559_p2 == 1'd0) & (trunc_ln257_fu_722_p1 == 5'd27))) | ((icmp_ln253_fu_571_p2 == 1'd1) & (icmp_ln249_fu_559_p2 == 1'd0) & (trunc_ln257_fu_722_p1 == 5'd26))))) begin
        inputBuf_V_26_fu_252 <= in0_V_TDATA;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_559_p2 == 1'd0)) | ((ap_predicate_op89_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op304_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_571_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_559_p2 == 1'd0) & (trunc_ln257_fu_722_p1 == 5'd2))) begin
        inputBuf_V_2_fu_156 <= in0_V_TDATA;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_559_p2 == 1'd0)) | ((ap_predicate_op89_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op304_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_571_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_559_p2 == 1'd0) & (trunc_ln257_fu_722_p1 == 5'd3))) begin
        inputBuf_V_3_fu_160 <= in0_V_TDATA;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_559_p2 == 1'd0)) | ((ap_predicate_op89_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op304_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_571_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_559_p2 == 1'd0) & (trunc_ln257_fu_722_p1 == 5'd4))) begin
        inputBuf_V_4_fu_164 <= in0_V_TDATA;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_559_p2 == 1'd0)) | ((ap_predicate_op89_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op304_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_571_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_559_p2 == 1'd0) & (trunc_ln257_fu_722_p1 == 5'd5))) begin
        inputBuf_V_5_fu_168 <= in0_V_TDATA;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_559_p2 == 1'd0)) | ((ap_predicate_op89_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op304_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_571_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_559_p2 == 1'd0) & (trunc_ln257_fu_722_p1 == 5'd6))) begin
        inputBuf_V_6_fu_172 <= in0_V_TDATA;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_559_p2 == 1'd0)) | ((ap_predicate_op89_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op304_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_571_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_559_p2 == 1'd0) & (trunc_ln257_fu_722_p1 == 5'd7))) begin
        inputBuf_V_7_fu_176 <= in0_V_TDATA;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_559_p2 == 1'd0)) | ((ap_predicate_op89_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op304_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_571_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_559_p2 == 1'd0) & (trunc_ln257_fu_722_p1 == 5'd8))) begin
        inputBuf_V_8_fu_180 <= in0_V_TDATA;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_559_p2 == 1'd0)) | ((ap_predicate_op89_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op304_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_571_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_559_p2 == 1'd0) & (trunc_ln257_fu_722_p1 == 5'd9))) begin
        inputBuf_V_9_fu_184 <= in0_V_TDATA;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_559_p2 == 1'd0)) | ((ap_predicate_op89_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op304_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_571_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_559_p2 == 1'd0) & (trunc_ln257_fu_722_p1 == 5'd0))) begin
        inputBuf_V_fu_148 <= in0_V_TDATA;
    end
end

always @ (*) begin
    if (((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_559_p2 == 1'd0)) | ((ap_predicate_op89_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)))) begin
        ap_ST_iter0_fsm_state1_blk = 1'b1;
    end else begin
        ap_ST_iter0_fsm_state1_blk = 1'b0;
    end
end

assign ap_ST_iter1_fsm_state2_blk = 1'b0;

assign ap_ST_iter2_fsm_state3_blk = 1'b0;

assign ap_ST_iter3_fsm_state4_blk = 1'b0;

assign ap_ST_iter4_fsm_state5_blk = 1'b0;

assign ap_ST_iter5_fsm_state6_blk = 1'b0;

always @ (*) begin
    if (((1'b1 == ap_block_state7_io) | ((ap_predicate_op304_write_state7 == 1'b1) & (out_V_TREADY == 1'b0)))) begin
        ap_ST_iter6_fsm_state7_blk = 1'b1;
    end else begin
        ap_ST_iter6_fsm_state7_blk = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_559_p2 == 1'd0)) | ((ap_predicate_op89_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op304_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_559_p2 == 1'd1))) begin
        ap_condition_exit_pp0_iter0_stage0 = 1'b1;
    end else begin
        ap_condition_exit_pp0_iter0_stage0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((1'b1 == ap_block_state7_io) | ((ap_predicate_op304_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))) & (1'b1 == ap_CS_iter6_fsm_state7) & (ap_loop_exit_ready_pp0_iter6_reg == 1'b1))) begin
        ap_done_int = 1'b1;
    end else begin
        ap_done_int = ap_done_reg;
    end
end

always @ (*) begin
    if (((1'b1 == ap_CS_iter6_fsm_state0) & (1'b1 == ap_CS_iter5_fsm_state0) & (1'b1 == ap_CS_iter4_fsm_state0) & (1'b1 == ap_CS_iter3_fsm_state0) & (1'b1 == ap_CS_iter2_fsm_state0) & (1'b1 == ap_CS_iter1_fsm_state0) & (1'b1 == ap_CS_iter0_fsm_state1) & (ap_start_int == 1'b0))) begin
        ap_idle = 1'b1;
    end else begin
        ap_idle = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_559_p2 == 1'd0)) | ((ap_predicate_op89_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op304_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (1'b1 == ap_CS_iter0_fsm_state1))) begin
        ap_ready_int = 1'b1;
    end else begin
        ap_ready_int = 1'b0;
    end
end

always @ (*) begin
    if (((1'b1 == ap_CS_iter4_fsm_state5) & (icmp_ln249_reg_1577_pp0_iter3_reg == 1'd0))) begin
        ap_sig_allocacmp_add_i4_i338_load = grp_fu_1358_p3;
    end else begin
        ap_sig_allocacmp_add_i4_i338_load = add_i4_i338_fu_144;
    end
end

always @ (*) begin
    if (((1'b1 == ap_CS_iter0_fsm_state1) & (ap_loop_init == 1'b1))) begin
        ap_sig_allocacmp_i_1 = 19'd0;
    end else begin
        ap_sig_allocacmp_i_1 = i_fu_140;
    end
end

always @ (*) begin
    if (((1'b1 == ap_CS_iter0_fsm_state1) & (ap_loop_init == 1'b1))) begin
        ap_sig_allocacmp_nf_2 = 32'd0;
    end else begin
        ap_sig_allocacmp_nf_2 = nf_1_fu_256;
    end
end

always @ (*) begin
    if (((1'b1 == ap_CS_iter0_fsm_state1) & (ap_loop_init == 1'b1))) begin
        ap_sig_allocacmp_sf_1 = 32'd0;
    end else begin
        ap_sig_allocacmp_sf_1 = sf_fu_136;
    end
end

always @ (*) begin
    if (((~((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op304_write_state7 == 1'b1) & (out_V_TREADY == 1'b0)))) & (1'b1 == ap_CS_iter1_fsm_state2)) | (~((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op304_write_state7 == 1'b1) & (out_V_TREADY == 1'b0)))) & (1'b1 == ap_CS_iter2_fsm_state3)) | (~((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op304_write_state7 == 1'b1) & (out_V_TREADY == 1'b0)))) & (1'b1 == ap_CS_iter3_fsm_state4)) | (~((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op304_write_state7 == 1'b1) & (out_V_TREADY == 1'b0)))) & (1'b1 == ap_CS_iter4_fsm_state5)))) begin
        grp_fu_1358_ce = 1'b1;
    end else begin
        grp_fu_1358_ce = 1'b0;
    end
end

always @ (*) begin
    if (((ap_predicate_op89_read_state1 == 1'b1) & (1'b1 == ap_CS_iter0_fsm_state1) & (ap_start_int == 1'b1))) begin
        in0_V_TDATA_blk_n = in0_V_TVALID;
    end else begin
        in0_V_TDATA_blk_n = 1'b1;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_559_p2 == 1'd0)) | ((ap_predicate_op89_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op304_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (ap_predicate_op89_read_state1 == 1'b1) & (1'b1 == ap_CS_iter0_fsm_state1))) begin
        in0_V_TREADY = 1'b1;
    end else begin
        in0_V_TREADY = 1'b0;
    end
end

always @ (*) begin
    if (((1'b1 == ap_CS_iter6_fsm_state7) & (ap_predicate_op304_write_state7 == 1'b1))) begin
        out_V_TDATA_blk_n = out_V_TREADY;
    end else begin
        out_V_TDATA_blk_n = 1'b1;
    end
end

always @ (*) begin
    if ((~((1'b1 == ap_block_state7_io) | ((ap_predicate_op304_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))) & (1'b1 == ap_CS_iter6_fsm_state7) & (ap_predicate_op304_write_state7 == 1'b1))) begin
        out_V_TVALID = 1'b1;
    end else begin
        out_V_TVALID = 1'b0;
    end
end

always @ (*) begin
    if ((~((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op304_write_state7 == 1'b1) & (out_V_TREADY == 1'b0)))) & (1'b1 == ap_CS_iter3_fsm_state4))) begin
        p_ZL7threshs_0_ce0 = 1'b1;
    end else begin
        p_ZL7threshs_0_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op304_write_state7 == 1'b1) & (out_V_TREADY == 1'b0)))) & (1'b1 == ap_CS_iter3_fsm_state4))) begin
        p_ZL7threshs_10_ce0 = 1'b1;
    end else begin
        p_ZL7threshs_10_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op304_write_state7 == 1'b1) & (out_V_TREADY == 1'b0)))) & (1'b1 == ap_CS_iter3_fsm_state4))) begin
        p_ZL7threshs_11_ce0 = 1'b1;
    end else begin
        p_ZL7threshs_11_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op304_write_state7 == 1'b1) & (out_V_TREADY == 1'b0)))) & (1'b1 == ap_CS_iter3_fsm_state4))) begin
        p_ZL7threshs_12_ce0 = 1'b1;
    end else begin
        p_ZL7threshs_12_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op304_write_state7 == 1'b1) & (out_V_TREADY == 1'b0)))) & (1'b1 == ap_CS_iter3_fsm_state4))) begin
        p_ZL7threshs_13_ce0 = 1'b1;
    end else begin
        p_ZL7threshs_13_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op304_write_state7 == 1'b1) & (out_V_TREADY == 1'b0)))) & (1'b1 == ap_CS_iter3_fsm_state4))) begin
        p_ZL7threshs_14_ce0 = 1'b1;
    end else begin
        p_ZL7threshs_14_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op304_write_state7 == 1'b1) & (out_V_TREADY == 1'b0)))) & (1'b1 == ap_CS_iter3_fsm_state4))) begin
        p_ZL7threshs_1_ce0 = 1'b1;
    end else begin
        p_ZL7threshs_1_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op304_write_state7 == 1'b1) & (out_V_TREADY == 1'b0)))) & (1'b1 == ap_CS_iter3_fsm_state4))) begin
        p_ZL7threshs_2_ce0 = 1'b1;
    end else begin
        p_ZL7threshs_2_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op304_write_state7 == 1'b1) & (out_V_TREADY == 1'b0)))) & (1'b1 == ap_CS_iter3_fsm_state4))) begin
        p_ZL7threshs_3_ce0 = 1'b1;
    end else begin
        p_ZL7threshs_3_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op304_write_state7 == 1'b1) & (out_V_TREADY == 1'b0)))) & (1'b1 == ap_CS_iter3_fsm_state4))) begin
        p_ZL7threshs_4_ce0 = 1'b1;
    end else begin
        p_ZL7threshs_4_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op304_write_state7 == 1'b1) & (out_V_TREADY == 1'b0)))) & (1'b1 == ap_CS_iter3_fsm_state4))) begin
        p_ZL7threshs_5_ce0 = 1'b1;
    end else begin
        p_ZL7threshs_5_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op304_write_state7 == 1'b1) & (out_V_TREADY == 1'b0)))) & (1'b1 == ap_CS_iter3_fsm_state4))) begin
        p_ZL7threshs_6_ce0 = 1'b1;
    end else begin
        p_ZL7threshs_6_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op304_write_state7 == 1'b1) & (out_V_TREADY == 1'b0)))) & (1'b1 == ap_CS_iter3_fsm_state4))) begin
        p_ZL7threshs_7_ce0 = 1'b1;
    end else begin
        p_ZL7threshs_7_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op304_write_state7 == 1'b1) & (out_V_TREADY == 1'b0)))) & (1'b1 == ap_CS_iter3_fsm_state4))) begin
        p_ZL7threshs_8_ce0 = 1'b1;
    end else begin
        p_ZL7threshs_8_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op304_write_state7 == 1'b1) & (out_V_TREADY == 1'b0)))) & (1'b1 == ap_CS_iter3_fsm_state4))) begin
        p_ZL7threshs_9_ce0 = 1'b1;
    end else begin
        p_ZL7threshs_9_ce0 = 1'b0;
    end
end

always @ (*) begin
    if (((1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_559_p2 == 1'd0) & (ap_start_int == 1'b1))) begin
        weights_V_TDATA_blk_n = weights_V_TVALID;
    end else begin
        weights_V_TDATA_blk_n = 1'b1;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_559_p2 == 1'd0)) | ((ap_predicate_op89_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op304_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_559_p2 == 1'd0))) begin
        weights_V_TREADY = 1'b1;
    end else begin
        weights_V_TREADY = 1'b0;
    end
end

always @ (*) begin
    case (ap_CS_iter0_fsm)
        ap_ST_iter0_fsm_state1 : begin
            ap_NS_iter0_fsm = ap_ST_iter0_fsm_state1;
        end
        default : begin
            ap_NS_iter0_fsm = 'bx;
        end
    endcase
end

always @ (*) begin
    case (ap_CS_iter1_fsm)
        ap_ST_iter1_fsm_state2 : begin
            if ((~((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op304_write_state7 == 1'b1) & (out_V_TREADY == 1'b0)))) & ~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_559_p2 == 1'd0)) | ((ap_predicate_op89_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0))) & (1'b1 == ap_CS_iter0_fsm_state1))) begin
                ap_NS_iter1_fsm = ap_ST_iter1_fsm_state2;
            end else if ((~((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op304_write_state7 == 1'b1) & (out_V_TREADY == 1'b0)))) & ((1'b0 == ap_CS_iter0_fsm_state1) | ((1'b1 == ap_CS_iter0_fsm_state1) & ((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_559_p2 == 1'd0)) | ((ap_predicate_op89_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0))))))) begin
                ap_NS_iter1_fsm = ap_ST_iter1_fsm_state0;
            end else begin
                ap_NS_iter1_fsm = ap_ST_iter1_fsm_state2;
            end
        end
        ap_ST_iter1_fsm_state0 : begin
            if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_559_p2 == 1'd0)) | ((ap_predicate_op89_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op304_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (1'b1 == ap_CS_iter0_fsm_state1))) begin
                ap_NS_iter1_fsm = ap_ST_iter1_fsm_state2;
            end else begin
                ap_NS_iter1_fsm = ap_ST_iter1_fsm_state0;
            end
        end
        default : begin
            ap_NS_iter1_fsm = 'bx;
        end
    endcase
end

always @ (*) begin
    case (ap_CS_iter2_fsm)
        ap_ST_iter2_fsm_state3 : begin
            if ((~((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op304_write_state7 == 1'b1) & (out_V_TREADY == 1'b0)))) & (1'b1 == ap_CS_iter1_fsm_state2))) begin
                ap_NS_iter2_fsm = ap_ST_iter2_fsm_state3;
            end else if ((~((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op304_write_state7 == 1'b1) & (out_V_TREADY == 1'b0)))) & (1'b0 == ap_CS_iter1_fsm_state2))) begin
                ap_NS_iter2_fsm = ap_ST_iter2_fsm_state0;
            end else begin
                ap_NS_iter2_fsm = ap_ST_iter2_fsm_state3;
            end
        end
        ap_ST_iter2_fsm_state0 : begin
            if ((~((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op304_write_state7 == 1'b1) & (out_V_TREADY == 1'b0)))) & (1'b1 == ap_CS_iter1_fsm_state2))) begin
                ap_NS_iter2_fsm = ap_ST_iter2_fsm_state3;
            end else begin
                ap_NS_iter2_fsm = ap_ST_iter2_fsm_state0;
            end
        end
        default : begin
            ap_NS_iter2_fsm = 'bx;
        end
    endcase
end

always @ (*) begin
    case (ap_CS_iter3_fsm)
        ap_ST_iter3_fsm_state4 : begin
            if ((~((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op304_write_state7 == 1'b1) & (out_V_TREADY == 1'b0)))) & (1'b1 == ap_CS_iter2_fsm_state3))) begin
                ap_NS_iter3_fsm = ap_ST_iter3_fsm_state4;
            end else if ((~((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op304_write_state7 == 1'b1) & (out_V_TREADY == 1'b0)))) & (1'b0 == ap_CS_iter2_fsm_state3))) begin
                ap_NS_iter3_fsm = ap_ST_iter3_fsm_state0;
            end else begin
                ap_NS_iter3_fsm = ap_ST_iter3_fsm_state4;
            end
        end
        ap_ST_iter3_fsm_state0 : begin
            if ((~((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op304_write_state7 == 1'b1) & (out_V_TREADY == 1'b0)))) & (1'b1 == ap_CS_iter2_fsm_state3))) begin
                ap_NS_iter3_fsm = ap_ST_iter3_fsm_state4;
            end else begin
                ap_NS_iter3_fsm = ap_ST_iter3_fsm_state0;
            end
        end
        default : begin
            ap_NS_iter3_fsm = 'bx;
        end
    endcase
end

always @ (*) begin
    case (ap_CS_iter4_fsm)
        ap_ST_iter4_fsm_state5 : begin
            if ((~((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op304_write_state7 == 1'b1) & (out_V_TREADY == 1'b0)))) & (1'b1 == ap_CS_iter3_fsm_state4))) begin
                ap_NS_iter4_fsm = ap_ST_iter4_fsm_state5;
            end else if ((~((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op304_write_state7 == 1'b1) & (out_V_TREADY == 1'b0)))) & (1'b0 == ap_CS_iter3_fsm_state4))) begin
                ap_NS_iter4_fsm = ap_ST_iter4_fsm_state0;
            end else begin
                ap_NS_iter4_fsm = ap_ST_iter4_fsm_state5;
            end
        end
        ap_ST_iter4_fsm_state0 : begin
            if ((~((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op304_write_state7 == 1'b1) & (out_V_TREADY == 1'b0)))) & (1'b1 == ap_CS_iter3_fsm_state4))) begin
                ap_NS_iter4_fsm = ap_ST_iter4_fsm_state5;
            end else begin
                ap_NS_iter4_fsm = ap_ST_iter4_fsm_state0;
            end
        end
        default : begin
            ap_NS_iter4_fsm = 'bx;
        end
    endcase
end

always @ (*) begin
    case (ap_CS_iter5_fsm)
        ap_ST_iter5_fsm_state6 : begin
            if ((~((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op304_write_state7 == 1'b1) & (out_V_TREADY == 1'b0)))) & (1'b1 == ap_CS_iter4_fsm_state5))) begin
                ap_NS_iter5_fsm = ap_ST_iter5_fsm_state6;
            end else if ((~((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op304_write_state7 == 1'b1) & (out_V_TREADY == 1'b0)))) & (1'b0 == ap_CS_iter4_fsm_state5))) begin
                ap_NS_iter5_fsm = ap_ST_iter5_fsm_state0;
            end else begin
                ap_NS_iter5_fsm = ap_ST_iter5_fsm_state6;
            end
        end
        ap_ST_iter5_fsm_state0 : begin
            if ((~((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op304_write_state7 == 1'b1) & (out_V_TREADY == 1'b0)))) & (1'b1 == ap_CS_iter4_fsm_state5))) begin
                ap_NS_iter5_fsm = ap_ST_iter5_fsm_state6;
            end else begin
                ap_NS_iter5_fsm = ap_ST_iter5_fsm_state0;
            end
        end
        default : begin
            ap_NS_iter5_fsm = 'bx;
        end
    endcase
end

always @ (*) begin
    case (ap_CS_iter6_fsm)
        ap_ST_iter6_fsm_state7 : begin
            if ((~((1'b1 == ap_block_state7_io) | ((ap_predicate_op304_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))) & (1'b0 == ap_CS_iter5_fsm_state6))) begin
                ap_NS_iter6_fsm = ap_ST_iter6_fsm_state0;
            end else if (((~((1'b1 == ap_block_state7_io) | ((ap_predicate_op304_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))) & (1'b1 == ap_CS_iter6_fsm_state7) & (icmp_ln249_reg_1577_pp0_iter5_reg == 1'd1)) | (~((1'b1 == ap_block_state7_io) | ((ap_predicate_op304_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))) & (1'b1 == ap_CS_iter5_fsm_state6)))) begin
                ap_NS_iter6_fsm = ap_ST_iter6_fsm_state7;
            end else begin
                ap_NS_iter6_fsm = ap_ST_iter6_fsm_state7;
            end
        end
        ap_ST_iter6_fsm_state0 : begin
            if ((~((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op304_write_state7 == 1'b1) & (out_V_TREADY == 1'b0)))) & (1'b1 == ap_CS_iter5_fsm_state6))) begin
                ap_NS_iter6_fsm = ap_ST_iter6_fsm_state7;
            end else begin
                ap_NS_iter6_fsm = ap_ST_iter6_fsm_state0;
            end
        end
        default : begin
            ap_NS_iter6_fsm = 'bx;
        end
    endcase
end

assign W_packed_V_fu_861_p1 = weights_V_TDATA[3:0];

assign add_ln840_10_fu_1306_p2 = (zext_ln218_10_fu_1201_p1 + zext_ln218_11_fu_1210_p1);

assign add_ln840_11_fu_1316_p2 = (zext_ln218_12_fu_1219_p1 + zext_ln840_fu_1228_p1);

assign add_ln840_12_fu_1326_p2 = (zext_ln840_9_fu_1322_p1 + zext_ln840_8_fu_1312_p1);

assign add_ln840_13_fu_1341_p2 = (zext_ln840_10_fu_1338_p1 + zext_ln840_7_fu_1335_p1);

assign add_ln840_1_fu_1232_p2 = (zext_ln215_fu_1102_p1 + zext_ln218_1_fu_1120_p1);

assign add_ln840_2_fu_1238_p2 = (add_ln840_1_fu_1232_p2 + zext_ln218_fu_1111_p1);

assign add_ln840_3_fu_1248_p2 = (zext_ln218_2_fu_1129_p1 + zext_ln218_3_fu_1138_p1);

assign add_ln840_4_fu_1258_p2 = (zext_ln218_4_fu_1147_p1 + zext_ln218_5_fu_1156_p1);

assign add_ln840_5_fu_1268_p2 = (zext_ln840_3_fu_1264_p1 + zext_ln840_2_fu_1254_p1);

assign add_ln840_6_fu_1274_p2 = (add_ln840_5_fu_1268_p2 + zext_ln840_1_fu_1244_p1);

assign add_ln840_7_fu_1280_p2 = (zext_ln218_6_fu_1165_p1 + zext_ln218_7_fu_1174_p1);

assign add_ln840_8_fu_1290_p2 = (zext_ln218_8_fu_1183_p1 + zext_ln218_9_fu_1192_p1);

assign add_ln840_9_fu_1300_p2 = (zext_ln840_6_fu_1296_p1 + zext_ln840_5_fu_1286_p1);

assign ap_CS_iter0_fsm_state1 = ap_CS_iter0_fsm[32'd0];

assign ap_CS_iter1_fsm_state0 = ap_CS_iter1_fsm[32'd0];

assign ap_CS_iter1_fsm_state2 = ap_CS_iter1_fsm[32'd1];

assign ap_CS_iter2_fsm_state0 = ap_CS_iter2_fsm[32'd0];

assign ap_CS_iter2_fsm_state3 = ap_CS_iter2_fsm[32'd1];

assign ap_CS_iter3_fsm_state0 = ap_CS_iter3_fsm[32'd0];

assign ap_CS_iter3_fsm_state4 = ap_CS_iter3_fsm[32'd1];

assign ap_CS_iter4_fsm_state0 = ap_CS_iter4_fsm[32'd0];

assign ap_CS_iter4_fsm_state5 = ap_CS_iter4_fsm[32'd1];

assign ap_CS_iter5_fsm_state0 = ap_CS_iter5_fsm[32'd0];

assign ap_CS_iter5_fsm_state6 = ap_CS_iter5_fsm[32'd1];

assign ap_CS_iter6_fsm_state0 = ap_CS_iter6_fsm[32'd0];

assign ap_CS_iter6_fsm_state7 = ap_CS_iter6_fsm[32'd1];

always @ (*) begin
    ap_block_state1_pp0_stage0_iter0 = ((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_559_p2 == 1'd0)) | ((ap_predicate_op89_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)));
end

assign ap_block_state2_pp0_stage0_iter1 = ~(1'b1 == 1'b1);

assign ap_block_state3_pp0_stage0_iter2 = ~(1'b1 == 1'b1);

assign ap_block_state4_pp0_stage0_iter3 = ~(1'b1 == 1'b1);

assign ap_block_state5_pp0_stage0_iter4 = ~(1'b1 == 1'b1);

assign ap_block_state6_pp0_stage0_iter5 = ~(1'b1 == 1'b1);

always @ (*) begin
    ap_block_state7_io = ((ap_predicate_op304_write_state7 == 1'b1) & (out_V_TREADY == 1'b0));
end

always @ (*) begin
    ap_block_state7_pp0_stage0_iter6 = ((ap_predicate_op304_write_state7 == 1'b1) & (out_V_TREADY == 1'b0));
end

always @ (*) begin
    ap_condition_1254 = (~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_559_p2 == 1'd0)) | ((ap_predicate_op89_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op304_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (1'b1 == ap_CS_iter0_fsm_state1));
end

assign ap_loop_exit_ready = ap_condition_exit_pp0_iter0_stage0;

assign ap_phi_reg_pp0_iter0_inElem_1_reg_474 = 'bx;

always @ (*) begin
    ap_predicate_op304_write_state7 = ((icmp_ln290_reg_1635_pp0_iter5_reg == 1'd1) & (icmp_ln249_reg_1577_pp0_iter5_reg == 1'd0));
end

always @ (*) begin
    ap_predicate_op89_read_state1 = ((icmp_ln253_fu_571_p2 == 1'd1) & (icmp_ln249_fu_559_p2 == 1'd0));
end

assign grp_fu_1358_p2 = ((icmp_ln272_reg_1630_pp0_iter2_reg[0:0] == 1'b1) ? 15'd0 : ap_sig_allocacmp_add_i4_i338_load);

assign i_2_fu_565_p2 = (ap_sig_allocacmp_i_1 + 19'd1);

assign icmp_ln1039_10_fu_1052_p2 = (($signed(grp_fu_1358_p3) < $signed(zext_ln1039_fu_1048_p1)) ? 1'b1 : 1'b0);

assign icmp_ln1039_11_fu_1061_p2 = (($signed(grp_fu_1358_p3) < $signed(zext_ln1039_1_fu_1057_p1)) ? 1'b1 : 1'b0);

assign icmp_ln1039_12_fu_1070_p2 = (($signed(grp_fu_1358_p3) < $signed(zext_ln1039_2_fu_1066_p1)) ? 1'b1 : 1'b0);

assign icmp_ln1039_13_fu_1079_p2 = (($signed(grp_fu_1358_p3) < $signed(zext_ln1039_3_fu_1075_p1)) ? 1'b1 : 1'b0);

assign icmp_ln1039_14_fu_1088_p2 = (($signed(grp_fu_1358_p3) < $signed(zext_ln1039_4_fu_1084_p1)) ? 1'b1 : 1'b0);

assign icmp_ln1039_1_fu_971_p2 = (($signed(grp_fu_1358_p3) < $signed(sext_ln1039_1_fu_967_p1)) ? 1'b1 : 1'b0);

assign icmp_ln1039_2_fu_980_p2 = (($signed(grp_fu_1358_p3) < $signed(sext_ln1039_2_fu_976_p1)) ? 1'b1 : 1'b0);

assign icmp_ln1039_3_fu_989_p2 = (($signed(grp_fu_1358_p3) < $signed(sext_ln1039_3_fu_985_p1)) ? 1'b1 : 1'b0);

assign icmp_ln1039_4_fu_998_p2 = (($signed(grp_fu_1358_p3) < $signed(sext_ln1039_4_fu_994_p1)) ? 1'b1 : 1'b0);

assign icmp_ln1039_5_fu_1007_p2 = (($signed(grp_fu_1358_p3) < $signed(sext_ln1039_5_fu_1003_p1)) ? 1'b1 : 1'b0);

assign icmp_ln1039_6_fu_1016_p2 = (($signed(grp_fu_1358_p3) < $signed(sext_ln1039_6_fu_1012_p1)) ? 1'b1 : 1'b0);

assign icmp_ln1039_7_fu_1025_p2 = (($signed(grp_fu_1358_p3) < $signed(sext_ln1039_7_fu_1021_p1)) ? 1'b1 : 1'b0);

assign icmp_ln1039_8_fu_1034_p2 = (($signed(grp_fu_1358_p3) < $signed(sext_ln1039_8_fu_1030_p1)) ? 1'b1 : 1'b0);

assign icmp_ln1039_9_fu_1043_p2 = (($signed(grp_fu_1358_p3) < $signed(sext_ln1039_9_fu_1039_p1)) ? 1'b1 : 1'b0);

assign icmp_ln1039_fu_962_p2 = (($signed(grp_fu_1358_p3) < $signed(sext_ln1039_fu_958_p1)) ? 1'b1 : 1'b0);

assign icmp_ln249_fu_559_p2 = ((ap_sig_allocacmp_i_1 == 19'd338688) ? 1'b1 : 1'b0);

assign icmp_ln253_fu_571_p2 = ((ap_sig_allocacmp_nf_2 == 32'd0) ? 1'b1 : 1'b0);

assign icmp_ln272_fu_865_p2 = ((ap_sig_allocacmp_sf_1 == 32'd0) ? 1'b1 : 1'b0);

assign icmp_ln290_fu_877_p2 = ((sf_2_fu_871_p2 == 32'd27) ? 1'b1 : 1'b0);

assign icmp_ln302_fu_894_p2 = ((nf_fu_888_p2 == 32'd16) ? 1'b1 : 1'b0);

assign idxprom2_i_fu_940_p1 = nf_2_reg_1572_pp0_iter2_reg;

assign nf_3_fu_900_p3 = ((icmp_ln302_fu_894_p2[0:0] == 1'b1) ? 32'd0 : nf_fu_888_p2);

assign nf_fu_888_p2 = (ap_sig_allocacmp_nf_2 + 32'd1);

assign out_V_TDATA = result_V_2_fu_1347_p2;

assign p_ZL7threshs_0_address0 = idxprom2_i_fu_940_p1;

assign p_ZL7threshs_10_address0 = idxprom2_i_fu_940_p1;

assign p_ZL7threshs_11_address0 = idxprom2_i_fu_940_p1;

assign p_ZL7threshs_12_address0 = idxprom2_i_fu_940_p1;

assign p_ZL7threshs_13_address0 = idxprom2_i_fu_940_p1;

assign p_ZL7threshs_14_address0 = idxprom2_i_fu_940_p1;

assign p_ZL7threshs_1_address0 = idxprom2_i_fu_940_p1;

assign p_ZL7threshs_2_address0 = idxprom2_i_fu_940_p1;

assign p_ZL7threshs_3_address0 = idxprom2_i_fu_940_p1;

assign p_ZL7threshs_4_address0 = idxprom2_i_fu_940_p1;

assign p_ZL7threshs_5_address0 = idxprom2_i_fu_940_p1;

assign p_ZL7threshs_6_address0 = idxprom2_i_fu_940_p1;

assign p_ZL7threshs_7_address0 = idxprom2_i_fu_940_p1;

assign p_ZL7threshs_8_address0 = idxprom2_i_fu_940_p1;

assign p_ZL7threshs_9_address0 = idxprom2_i_fu_940_p1;

assign result_V_2_fu_1347_p2 = (add_ln840_13_fu_1341_p2 + zext_ln840_4_fu_1332_p1);

assign result_V_fu_1097_p2 = (icmp_ln1039_reg_1729 ^ 1'd1);

assign sext_ln1039_1_fu_967_p1 = $signed(p_ZL7threshs_1_q0);

assign sext_ln1039_2_fu_976_p1 = $signed(p_ZL7threshs_2_q0);

assign sext_ln1039_3_fu_985_p1 = $signed(p_ZL7threshs_3_q0);

assign sext_ln1039_4_fu_994_p1 = $signed(p_ZL7threshs_4_q0);

assign sext_ln1039_5_fu_1003_p1 = $signed(p_ZL7threshs_5_q0);

assign sext_ln1039_6_fu_1012_p1 = $signed(p_ZL7threshs_6_q0);

assign sext_ln1039_7_fu_1021_p1 = $signed(p_ZL7threshs_7_q0);

assign sext_ln1039_8_fu_1030_p1 = $signed(p_ZL7threshs_8_q0);

assign sext_ln1039_9_fu_1039_p1 = $signed(p_ZL7threshs_9_q0);

assign sext_ln1039_fu_958_p1 = $signed(p_ZL7threshs_0_q0);

assign sf_2_fu_871_p2 = (ap_sig_allocacmp_sf_1 + 32'd1);

assign tmp_fu_662_p28 = ap_sig_allocacmp_sf_1[4:0];

assign trunc_ln257_fu_722_p1 = ap_sig_allocacmp_sf_1[4:0];

assign xor_ln1039_10_fu_1196_p2 = (icmp_ln1039_11_reg_1784 ^ 1'd1);

assign xor_ln1039_11_fu_1205_p2 = (icmp_ln1039_12_reg_1789 ^ 1'd1);

assign xor_ln1039_12_fu_1214_p2 = (icmp_ln1039_13_reg_1794 ^ 1'd1);

assign xor_ln1039_13_fu_1223_p2 = (icmp_ln1039_14_reg_1799 ^ 1'd1);

assign xor_ln1039_1_fu_1115_p2 = (icmp_ln1039_2_reg_1739 ^ 1'd1);

assign xor_ln1039_2_fu_1124_p2 = (icmp_ln1039_3_reg_1744 ^ 1'd1);

assign xor_ln1039_3_fu_1133_p2 = (icmp_ln1039_4_reg_1749 ^ 1'd1);

assign xor_ln1039_4_fu_1142_p2 = (icmp_ln1039_5_reg_1754 ^ 1'd1);

assign xor_ln1039_5_fu_1151_p2 = (icmp_ln1039_6_reg_1759 ^ 1'd1);

assign xor_ln1039_6_fu_1160_p2 = (icmp_ln1039_7_reg_1764 ^ 1'd1);

assign xor_ln1039_7_fu_1169_p2 = (icmp_ln1039_8_reg_1769 ^ 1'd1);

assign xor_ln1039_8_fu_1178_p2 = (icmp_ln1039_9_reg_1774 ^ 1'd1);

assign xor_ln1039_9_fu_1187_p2 = (icmp_ln1039_10_reg_1779 ^ 1'd1);

assign xor_ln1039_fu_1106_p2 = (icmp_ln1039_1_reg_1734 ^ 1'd1);

assign zext_ln1039_1_fu_1057_p1 = p_ZL7threshs_11_q0;

assign zext_ln1039_2_fu_1066_p1 = p_ZL7threshs_12_q0;

assign zext_ln1039_3_fu_1075_p1 = p_ZL7threshs_13_q0;

assign zext_ln1039_4_fu_1084_p1 = p_ZL7threshs_14_q0;

assign zext_ln1039_fu_1048_p1 = p_ZL7threshs_10_q0;

assign zext_ln215_fu_1102_p1 = result_V_fu_1097_p2;

assign zext_ln218_10_fu_1201_p1 = xor_ln1039_10_fu_1196_p2;

assign zext_ln218_11_fu_1210_p1 = xor_ln1039_11_fu_1205_p2;

assign zext_ln218_12_fu_1219_p1 = xor_ln1039_12_fu_1214_p2;

assign zext_ln218_1_fu_1120_p1 = xor_ln1039_1_fu_1115_p2;

assign zext_ln218_2_fu_1129_p1 = xor_ln1039_2_fu_1124_p2;

assign zext_ln218_3_fu_1138_p1 = xor_ln1039_3_fu_1133_p2;

assign zext_ln218_4_fu_1147_p1 = xor_ln1039_4_fu_1142_p2;

assign zext_ln218_5_fu_1156_p1 = xor_ln1039_5_fu_1151_p2;

assign zext_ln218_6_fu_1165_p1 = xor_ln1039_6_fu_1160_p2;

assign zext_ln218_7_fu_1174_p1 = xor_ln1039_7_fu_1169_p2;

assign zext_ln218_8_fu_1183_p1 = xor_ln1039_8_fu_1178_p2;

assign zext_ln218_9_fu_1192_p1 = xor_ln1039_9_fu_1187_p2;

assign zext_ln218_fu_1111_p1 = xor_ln1039_fu_1106_p2;

assign zext_ln840_10_fu_1338_p1 = add_ln840_12_reg_1814;

assign zext_ln840_1_fu_1244_p1 = add_ln840_2_fu_1238_p2;

assign zext_ln840_2_fu_1254_p1 = add_ln840_3_fu_1248_p2;

assign zext_ln840_3_fu_1264_p1 = add_ln840_4_fu_1258_p2;

assign zext_ln840_4_fu_1332_p1 = add_ln840_6_reg_1804;

assign zext_ln840_5_fu_1286_p1 = add_ln840_7_fu_1280_p2;

assign zext_ln840_6_fu_1296_p1 = add_ln840_8_fu_1290_p2;

assign zext_ln840_7_fu_1335_p1 = add_ln840_9_reg_1809;

assign zext_ln840_8_fu_1312_p1 = add_ln840_10_fu_1306_p2;

assign zext_ln840_9_fu_1322_p1 = add_ln840_11_fu_1316_p2;

assign zext_ln840_fu_1228_p1 = xor_ln1039_13_fu_1223_p2;

endmodule //MVAU_hls_0_Matrix_Vector_Activate_Stream_Batch
//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/vivado_stitch_proj_w5fn6zuu/finn_vivado_stitch_proj.gen/sources_1/bd/finn_design/ipshared/fb57/hdl/verilog/MVAU_hls_1_Matrix_Vector_Activate_Stream_Batch_p_ZL7threshs_8_ROM_AUTO_1R.v


// ==============================================================
// Vitis HLS - High-Level Synthesis from C, C++ and OpenCL v2022.2 (64-bit)
// Version: 2022.2
// Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.
// ==============================================================
`timescale 1 ns / 1 ps
module MVAU_hls_1_Matrix_Vector_Activate_Stream_Batch_p_ZL7threshs_8_ROM_AUTO_1R (
    address0, ce0, q0, 
    reset, clk);

parameter DataWidth = 10;
parameter AddressWidth = 5;
parameter AddressRange = 32;
 
input[AddressWidth-1:0] address0;
input ce0;
output reg[DataWidth-1:0] q0;

input reset;
input clk;

 
reg [DataWidth-1:0] rom0[0:AddressRange-1];


initial begin
     
    $readmemh("/home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/code_gen_ipgen_MVAU_hls_1__774deg0/project_MVAU_hls_1/sol1/impl/ip/hdl/verilog/MVAU_hls_1_Matrix_Vector_Activate_Stream_Batch_p_ZL7threshs_8_ROM_AUTO_1R.dat", rom0);
end

  
always @(posedge clk) 
begin 
    if (ce0) 
    begin
        q0 <= rom0[address0];
    end
end


endmodule

//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/vivado_stitch_proj_w5fn6zuu/finn_vivado_stitch_proj.gen/sources_1/bd/finn_design/ipshared/18e4/hdl/verilog/MVAU_hls_0_mux_275_8_1_1.v


// ==============================================================
// Vitis HLS - High-Level Synthesis from C, C++ and OpenCL v2022.2 (64-bit)
// Tool Version Limit: 2019.12
// Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.
// ==============================================================

`timescale 1ns/1ps

module MVAU_hls_0_mux_275_8_1_1 #(
parameter
    ID                = 0,
    NUM_STAGE         = 1,
    din0_WIDTH       = 32,
    din1_WIDTH       = 32,
    din2_WIDTH       = 32,
    din3_WIDTH       = 32,
    din4_WIDTH       = 32,
    din5_WIDTH       = 32,
    din6_WIDTH       = 32,
    din7_WIDTH       = 32,
    din8_WIDTH       = 32,
    din9_WIDTH       = 32,
    din10_WIDTH       = 32,
    din11_WIDTH       = 32,
    din12_WIDTH       = 32,
    din13_WIDTH       = 32,
    din14_WIDTH       = 32,
    din15_WIDTH       = 32,
    din16_WIDTH       = 32,
    din17_WIDTH       = 32,
    din18_WIDTH       = 32,
    din19_WIDTH       = 32,
    din20_WIDTH       = 32,
    din21_WIDTH       = 32,
    din22_WIDTH       = 32,
    din23_WIDTH       = 32,
    din24_WIDTH       = 32,
    din25_WIDTH       = 32,
    din26_WIDTH       = 32,
    din27_WIDTH         = 32,
    dout_WIDTH            = 32
)(
    input  [7 : 0]     din0,
    input  [7 : 0]     din1,
    input  [7 : 0]     din2,
    input  [7 : 0]     din3,
    input  [7 : 0]     din4,
    input  [7 : 0]     din5,
    input  [7 : 0]     din6,
    input  [7 : 0]     din7,
    input  [7 : 0]     din8,
    input  [7 : 0]     din9,
    input  [7 : 0]     din10,
    input  [7 : 0]     din11,
    input  [7 : 0]     din12,
    input  [7 : 0]     din13,
    input  [7 : 0]     din14,
    input  [7 : 0]     din15,
    input  [7 : 0]     din16,
    input  [7 : 0]     din17,
    input  [7 : 0]     din18,
    input  [7 : 0]     din19,
    input  [7 : 0]     din20,
    input  [7 : 0]     din21,
    input  [7 : 0]     din22,
    input  [7 : 0]     din23,
    input  [7 : 0]     din24,
    input  [7 : 0]     din25,
    input  [7 : 0]     din26,
    input  [4 : 0]    din27,
    output [7 : 0]   dout);

// puts internal signals
wire [4 : 0]     sel;
// level 1 signals
wire [7 : 0]         mux_1_0;
wire [7 : 0]         mux_1_1;
wire [7 : 0]         mux_1_2;
wire [7 : 0]         mux_1_3;
wire [7 : 0]         mux_1_4;
wire [7 : 0]         mux_1_5;
wire [7 : 0]         mux_1_6;
wire [7 : 0]         mux_1_7;
wire [7 : 0]         mux_1_8;
wire [7 : 0]         mux_1_9;
wire [7 : 0]         mux_1_10;
wire [7 : 0]         mux_1_11;
wire [7 : 0]         mux_1_12;
wire [7 : 0]         mux_1_13;
// level 2 signals
wire [7 : 0]         mux_2_0;
wire [7 : 0]         mux_2_1;
wire [7 : 0]         mux_2_2;
wire [7 : 0]         mux_2_3;
wire [7 : 0]         mux_2_4;
wire [7 : 0]         mux_2_5;
wire [7 : 0]         mux_2_6;
// level 3 signals
wire [7 : 0]         mux_3_0;
wire [7 : 0]         mux_3_1;
wire [7 : 0]         mux_3_2;
wire [7 : 0]         mux_3_3;
// level 4 signals
wire [7 : 0]         mux_4_0;
wire [7 : 0]         mux_4_1;
// level 5 signals
wire [7 : 0]         mux_5_0;

assign sel = din27;

// Generate level 1 logic
assign mux_1_0 = (sel[0] == 0)? din0 : din1;
assign mux_1_1 = (sel[0] == 0)? din2 : din3;
assign mux_1_2 = (sel[0] == 0)? din4 : din5;
assign mux_1_3 = (sel[0] == 0)? din6 : din7;
assign mux_1_4 = (sel[0] == 0)? din8 : din9;
assign mux_1_5 = (sel[0] == 0)? din10 : din11;
assign mux_1_6 = (sel[0] == 0)? din12 : din13;
assign mux_1_7 = (sel[0] == 0)? din14 : din15;
assign mux_1_8 = (sel[0] == 0)? din16 : din17;
assign mux_1_9 = (sel[0] == 0)? din18 : din19;
assign mux_1_10 = (sel[0] == 0)? din20 : din21;
assign mux_1_11 = (sel[0] == 0)? din22 : din23;
assign mux_1_12 = (sel[0] == 0)? din24 : din25;
assign mux_1_13 = din26;

// Generate level 2 logic
assign mux_2_0 = (sel[1] == 0)? mux_1_0 : mux_1_1;
assign mux_2_1 = (sel[1] == 0)? mux_1_2 : mux_1_3;
assign mux_2_2 = (sel[1] == 0)? mux_1_4 : mux_1_5;
assign mux_2_3 = (sel[1] == 0)? mux_1_6 : mux_1_7;
assign mux_2_4 = (sel[1] == 0)? mux_1_8 : mux_1_9;
assign mux_2_5 = (sel[1] == 0)? mux_1_10 : mux_1_11;
assign mux_2_6 = (sel[1] == 0)? mux_1_12 : mux_1_13;

// Generate level 3 logic
assign mux_3_0 = (sel[2] == 0)? mux_2_0 : mux_2_1;
assign mux_3_1 = (sel[2] == 0)? mux_2_2 : mux_2_3;
assign mux_3_2 = (sel[2] == 0)? mux_2_4 : mux_2_5;
assign mux_3_3 = mux_2_6;

// Generate level 4 logic
assign mux_4_0 = (sel[3] == 0)? mux_3_0 : mux_3_1;
assign mux_4_1 = (sel[3] == 0)? mux_3_2 : mux_3_3;

// Generate level 5 logic
assign mux_5_0 = (sel[4] == 0)? mux_4_0 : mux_4_1;

// output logic
assign dout = mux_5_0;

endmodule
//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/vivado_stitch_proj_w5fn6zuu/finn_vivado_stitch_proj.gen/sources_1/bd/finn_design/ip/finn_design_StreamingFIFO_rtl_2_0/synth/finn_design_StreamingFIFO_rtl_2_0.v


// (c) Copyright 1995-2026 Xilinx, Inc. All rights reserved.
// 
// This file contains confidential and proprietary information
// of Xilinx, Inc. and is protected under U.S. and
// international copyright and other intellectual property
// laws.
// 
// DISCLAIMER
// This disclaimer is not a license and does not grant any
// rights to the materials distributed herewith. Except as
// otherwise provided in a valid license issued to you by
// Xilinx, and to the maximum extent permitted by applicable
// law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
// WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
// AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
// BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
// INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
// (2) Xilinx shall not be liable (whether in contract or tort,
// including negligence, or under any other theory of
// liability) for any loss or damage of any kind or nature
// related to, arising under or in connection with these
// materials, including for any direct, or any indirect,
// special, incidental, or consequential loss or damage
// (including loss of data, profits, goodwill, or any type of
// loss or damage suffered as a result of any action brought
// by a third party) even if such damage or loss was
// reasonably foreseeable or Xilinx had been advised of the
// possibility of the same.
// 
// CRITICAL APPLICATIONS
// Xilinx products are not designed or intended to be fail-
// safe, or for use in any application requiring fail-safe
// performance, such as life-support or safety devices or
// systems, Class III medical devices, nuclear facilities,
// applications related to the deployment of airbags, or any
// other applications that could lead to death, personal
// injury, or severe property or environmental damage
// (individually and collectively, "Critical
// Applications"). Customer assumes the sole risk and
// liability of any use of Xilinx products in Critical
// Applications, subject only to applicable laws and
// regulations governing limitations on product liability.
// 
// THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
// PART OF THIS FILE AT ALL TIMES.
// 
// DO NOT MODIFY THIS FILE.


// IP VLNV: xilinx.com:module_ref:StreamingFIFO_rtl_2:1.0
// IP Revision: 1

(* X_CORE_INFO = "StreamingFIFO_rtl_2,Vivado 2022.2" *)
(* CHECK_LICENSE_TYPE = "finn_design_StreamingFIFO_rtl_2_0,StreamingFIFO_rtl_2,{}" *)
(* CORE_GENERATION_INFO = "finn_design_StreamingFIFO_rtl_2_0,StreamingFIFO_rtl_2,{x_ipProduct=Vivado 2022.2,x_ipVendor=xilinx.com,x_ipLibrary=module_ref,x_ipName=StreamingFIFO_rtl_2,x_ipVersion=1.0,x_ipCoreRevision=1,x_ipLanguage=VERILOG,x_ipSimLanguage=MIXED}" *)
(* IP_DEFINITION_SOURCE = "module_ref" *)
(* DowngradeIPIdentifiedWarnings = "yes" *)
module finn_design_StreamingFIFO_rtl_2_0 (
  ap_clk,
  ap_rst_n,
  count,
  maxcount,
  in0_V_TREADY,
  in0_V_TVALID,
  in0_V_TDATA,
  out_V_TREADY,
  out_V_TVALID,
  out_V_TDATA
);

(* X_INTERFACE_PARAMETER = "XIL_INTERFACENAME ap_clk, ASSOCIATED_RESET ap_rst_n, ASSOCIATED_BUSIF in0_V:out_V, FREQ_HZ 100000000, FREQ_TOLERANCE_HZ 0, PHASE 0.0, CLK_DOMAIN finn_design_ap_clk_0, INSERT_VIP 0" *)
(* X_INTERFACE_INFO = "xilinx.com:signal:clock:1.0 ap_clk CLK" *)
input wire ap_clk;
(* X_INTERFACE_PARAMETER = "XIL_INTERFACENAME ap_rst_n, POLARITY ACTIVE_LOW, INSERT_VIP 0" *)
(* X_INTERFACE_INFO = "xilinx.com:signal:reset:1.0 ap_rst_n RST" *)
input wire ap_rst_n;
output wire [11 : 0] count;
output wire [11 : 0] maxcount;
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 in0_V TREADY" *)
output wire in0_V_TREADY;
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 in0_V TVALID" *)
input wire in0_V_TVALID;
(* X_INTERFACE_PARAMETER = "XIL_INTERFACENAME in0_V, TDATA_NUM_BYTES 1, TDEST_WIDTH 0, TID_WIDTH 0, TUSER_WIDTH 0, HAS_TREADY 1, HAS_TSTRB 0, HAS_TKEEP 0, HAS_TLAST 0, FREQ_HZ 100000000, PHASE 0.0, CLK_DOMAIN finn_design_ap_clk_0, LAYERED_METADATA undef, INSERT_VIP 0" *)
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 in0_V TDATA" *)
input wire [7 : 0] in0_V_TDATA;
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 out_V TREADY" *)
input wire out_V_TREADY;
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 out_V TVALID" *)
output wire out_V_TVALID;
(* X_INTERFACE_PARAMETER = "XIL_INTERFACENAME out_V, TDATA_NUM_BYTES 1, TDEST_WIDTH 0, TID_WIDTH 0, TUSER_WIDTH 0, HAS_TREADY 1, HAS_TSTRB 0, HAS_TKEEP 0, HAS_TLAST 0, FREQ_HZ 100000000, PHASE 0.0, CLK_DOMAIN finn_design_ap_clk_0, LAYERED_METADATA undef, INSERT_VIP 0" *)
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 out_V TDATA" *)
output wire [7 : 0] out_V_TDATA;

  StreamingFIFO_rtl_2 inst (
    .ap_clk(ap_clk),
    .ap_rst_n(ap_rst_n),
    .count(count),
    .maxcount(maxcount),
    .in0_V_TREADY(in0_V_TREADY),
    .in0_V_TVALID(in0_V_TVALID),
    .in0_V_TDATA(in0_V_TDATA),
    .out_V_TREADY(out_V_TREADY),
    .out_V_TVALID(out_V_TVALID),
    .out_V_TDATA(out_V_TDATA)
  );
endmodule
//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/vivado_stitch_proj_w5fn6zuu/finn_vivado_stitch_proj.gen/sources_1/bd/finn_design/ipshared/4d6a/hdl/verilog/StreamingMaxPool_hls_1_flow_control_loop_pipe_sequential_init.v


// ==============================================================
// Vitis HLS - High-Level Synthesis from C, C++ and OpenCL v2022.2 (64-bit)
// Tool Version Limit: 2019.12
// Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.
// ==============================================================

`timescale 1 ns / 1 ps

module StreamingMaxPool_hls_1_flow_control_loop_pipe_sequential_init(
        ap_clk,
        ap_rst,
        ap_start,
        ap_ready,
        ap_done,
        ap_start_int,
        ap_ready_int,
        ap_done_int,
        ap_continue_int,
        ap_loop_init,
        ap_loop_exit_ready,
        ap_loop_exit_done
);

input   ap_clk;
input   ap_rst;

//Block level handshake with outside loop
input   ap_start;
output  ap_ready;
output  ap_done;

//Block level handshake with loop body
output  ap_start_int;
input   ap_ready_int;
input   ap_done_int;
output  ap_continue_int;

//Init live in variables
output   ap_loop_init;
wire     ap_loop_init;
reg ap_loop_init_int;
reg ap_done;
reg ap_done_cache;

//Exit signal from loop body
input   ap_loop_exit_ready;
input   ap_loop_exit_done;

// power-on initialization
initial begin
#0 ap_loop_init_int = 1'b1;
#0 ap_done_cache = 1'b0;
end

assign ap_start_int = ap_start;

assign ap_continue_int = 1'b1;

assign ap_ready = ap_loop_exit_ready;

//ap_loop_init is valid for the first II
//of the first loop run so as to enable
//the init block ops which are pushed into
//the first state of the pipeline region
always @ (posedge ap_clk)
begin
    if (ap_rst == 1'b1) begin
        ap_loop_init_int <= 1'b1;
    end else if(ap_loop_exit_done == 1'b1) begin
        ap_loop_init_int <= 1'b1;
    end else if(ap_ready_int == 1'b1) begin
        ap_loop_init_int <= 1'b0;
    end
end

assign ap_loop_init = ap_loop_init_int & ap_start;

// if no ap_continue port and current module is not top module, 
// ap_done handshakes with ap_start. Internally, flow control sends out 
// ap_conintue_int = 1'b1 so the ap_done_int is asserted high for 1 clock cycle.
// ap_done_cache is used to record ap_done_int, and de-assert if ap_start_int
// is asserted, so DUT can start the next run
always @(posedge ap_clk)
begin
    if (ap_rst == 1'b1) begin
        ap_done_cache <= 1'b0;
    end else if (ap_done_int == 1'b1) begin
        ap_done_cache <= 1'b1;
    end else if (ap_start_int == 1'b1) begin
        ap_done_cache <= 1'b0;
    end
end

// if no ap_continue port and current module is not top module, ap_done handshakes with ap_start
always @(*)
begin
    if ((ap_done_int == 1'b1) || ((ap_done_cache == 1'b1) && (ap_start_int == 1'b0))) begin
        ap_done = 1'b1;
    end else begin
        ap_done = 1'b0;
    end
end

endmodule
        
//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/vivado_stitch_proj_w5fn6zuu/finn_vivado_stitch_proj.gen/sources_1/bd/finn_design/ipshared/fb57/hdl/verilog/MVAU_hls_1_Matrix_Vector_Activate_Stream_Batch_p_ZL7threshs_0_ROM_AUTO_1R.v


// ==============================================================
// Vitis HLS - High-Level Synthesis from C, C++ and OpenCL v2022.2 (64-bit)
// Version: 2022.2
// Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.
// ==============================================================
`timescale 1 ns / 1 ps
module MVAU_hls_1_Matrix_Vector_Activate_Stream_Batch_p_ZL7threshs_0_ROM_AUTO_1R (
    address0, ce0, q0, 
    reset, clk);

parameter DataWidth = 10;
parameter AddressWidth = 5;
parameter AddressRange = 32;
 
input[AddressWidth-1:0] address0;
input ce0;
output reg[DataWidth-1:0] q0;

input reset;
input clk;

 
reg [DataWidth-1:0] rom0[0:AddressRange-1];


initial begin
     
    $readmemh("/home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/code_gen_ipgen_MVAU_hls_1__774deg0/project_MVAU_hls_1/sol1/impl/ip/hdl/verilog/MVAU_hls_1_Matrix_Vector_Activate_Stream_Batch_p_ZL7threshs_0_ROM_AUTO_1R.dat", rom0);
end

  
always @(posedge clk) 
begin 
    if (ce0) 
    begin
        q0 <= rom0[address0];
    end
end


endmodule

//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/vivado_stitch_proj_w5fn6zuu/finn_vivado_stitch_proj.gen/sources_1/bd/finn_design/ipshared/6bf6/hdl/verilog/StreamingMaxPool_hls_0_StreamingMaxPool_Precision_28u_2u_16u_ap_uint_4_0_64_s.v


// ==============================================================
// RTL generated by Vitis HLS - High-Level Synthesis from C, C++ and OpenCL v2022.2 (64-bit)
// Version: 2022.2
// Copyright (C) Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.
// 
// ===========================================================

`timescale 1 ns / 1 ps 

module StreamingMaxPool_hls_0_StreamingMaxPool_Precision_28u_2u_16u_ap_uint_4_0_64_s (
        ap_clk,
        ap_rst,
        ap_start,
        ap_done,
        ap_idle,
        ap_ready,
        in0_V_TDATA,
        in0_V_TVALID,
        in0_V_TREADY,
        out_V_TDATA,
        out_V_TVALID,
        out_V_TREADY
);

parameter    ap_ST_fsm_state1 = 8'd1;
parameter    ap_ST_fsm_state2 = 8'd2;
parameter    ap_ST_fsm_state3 = 8'd4;
parameter    ap_ST_fsm_state4 = 8'd8;
parameter    ap_ST_fsm_state5 = 8'd16;
parameter    ap_ST_fsm_state6 = 8'd32;
parameter    ap_ST_fsm_state7 = 8'd64;
parameter    ap_ST_fsm_state8 = 8'd128;

input   ap_clk;
input   ap_rst;
input   ap_start;
output   ap_done;
output   ap_idle;
output   ap_ready;
input  [63:0] in0_V_TDATA;
input   in0_V_TVALID;
output   in0_V_TREADY;
output  [63:0] out_V_TDATA;
output   out_V_TVALID;
input   out_V_TREADY;

reg ap_done;
reg ap_idle;
reg ap_ready;
reg in0_V_TREADY;

(* fsm_encoding = "none" *) reg   [7:0] ap_CS_fsm;
wire    ap_CS_fsm_state1;
wire   [3:0] yp_2_fu_449_p2;
reg   [3:0] yp_2_reg_521;
wire    ap_CS_fsm_state3;
wire   [4:0] add_ln155_fu_461_p2;
reg   [4:0] add_ln155_reg_529;
wire    ap_CS_fsm_state4;
wire   [3:0] select_ln155_fu_473_p3;
reg   [3:0] select_ln155_reg_534;
wire   [0:0] icmp_ln155_fu_455_p2;
wire   [3:0] add_ln156_fu_501_p2;
reg   [3:0] add_ln156_reg_619;
wire   [3:0] buf_V_q0;
reg   [3:0] buf_V_load_reg_624;
wire    ap_CS_fsm_state5;
wire   [3:0] buf_V_1_q0;
reg   [3:0] buf_V_1_load_reg_629;
wire   [3:0] buf_V_2_q0;
reg   [3:0] buf_V_2_load_reg_634;
wire   [3:0] buf_V_3_q0;
reg   [3:0] buf_V_3_load_reg_639;
wire   [3:0] buf_V_4_q0;
reg   [3:0] buf_V_4_load_reg_644;
wire   [3:0] buf_V_5_q0;
reg   [3:0] buf_V_5_load_reg_649;
wire   [3:0] buf_V_6_q0;
reg   [3:0] buf_V_6_load_reg_654;
wire   [3:0] buf_V_7_q0;
reg   [3:0] buf_V_7_load_reg_659;
wire   [3:0] buf_V_8_q0;
reg   [3:0] buf_V_8_load_reg_664;
wire   [3:0] buf_V_9_q0;
reg   [3:0] buf_V_9_load_reg_669;
wire   [3:0] buf_V_10_q0;
reg   [3:0] buf_V_10_load_reg_674;
wire   [3:0] buf_V_11_q0;
reg   [3:0] buf_V_11_load_reg_679;
wire   [3:0] buf_V_12_q0;
reg   [3:0] buf_V_12_load_reg_684;
wire   [3:0] buf_V_13_q0;
reg   [3:0] buf_V_13_load_reg_689;
wire   [3:0] buf_V_14_q0;
reg   [3:0] buf_V_14_load_reg_694;
wire   [3:0] buf_V_15_q0;
reg   [3:0] buf_V_15_load_reg_699;
reg   [3:0] buf_V_address0;
reg    buf_V_ce0;
reg    buf_V_we0;
reg   [3:0] buf_V_d0;
reg   [3:0] buf_V_1_address0;
reg    buf_V_1_ce0;
reg    buf_V_1_we0;
reg   [3:0] buf_V_1_d0;
reg   [3:0] buf_V_2_address0;
reg    buf_V_2_ce0;
reg    buf_V_2_we0;
reg   [3:0] buf_V_2_d0;
reg   [3:0] buf_V_3_address0;
reg    buf_V_3_ce0;
reg    buf_V_3_we0;
reg   [3:0] buf_V_3_d0;
reg   [3:0] buf_V_4_address0;
reg    buf_V_4_ce0;
reg    buf_V_4_we0;
reg   [3:0] buf_V_4_d0;
reg   [3:0] buf_V_5_address0;
reg    buf_V_5_ce0;
reg    buf_V_5_we0;
reg   [3:0] buf_V_5_d0;
reg   [3:0] buf_V_6_address0;
reg    buf_V_6_ce0;
reg    buf_V_6_we0;
reg   [3:0] buf_V_6_d0;
reg   [3:0] buf_V_7_address0;
reg    buf_V_7_ce0;
reg    buf_V_7_we0;
reg   [3:0] buf_V_7_d0;
reg   [3:0] buf_V_8_address0;
reg    buf_V_8_ce0;
reg    buf_V_8_we0;
reg   [3:0] buf_V_8_d0;
reg   [3:0] buf_V_9_address0;
reg    buf_V_9_ce0;
reg    buf_V_9_we0;
reg   [3:0] buf_V_9_d0;
reg   [3:0] buf_V_10_address0;
reg    buf_V_10_ce0;
reg    buf_V_10_we0;
reg   [3:0] buf_V_10_d0;
reg   [3:0] buf_V_11_address0;
reg    buf_V_11_ce0;
reg    buf_V_11_we0;
reg   [3:0] buf_V_11_d0;
reg   [3:0] buf_V_12_address0;
reg    buf_V_12_ce0;
reg    buf_V_12_we0;
reg   [3:0] buf_V_12_d0;
reg   [3:0] buf_V_13_address0;
reg    buf_V_13_ce0;
reg    buf_V_13_we0;
reg   [3:0] buf_V_13_d0;
reg   [3:0] buf_V_14_address0;
reg    buf_V_14_ce0;
reg    buf_V_14_we0;
reg   [3:0] buf_V_14_d0;
reg   [3:0] buf_V_15_address0;
reg    buf_V_15_ce0;
reg    buf_V_15_we0;
reg   [3:0] buf_V_15_d0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_ap_start;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_ap_done;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_ap_idle;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_ap_ready;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_address0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_ce0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_we0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_d0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_1_address0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_1_ce0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_1_we0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_1_d0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_2_address0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_2_ce0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_2_we0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_2_d0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_3_address0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_3_ce0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_3_we0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_3_d0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_4_address0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_4_ce0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_4_we0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_4_d0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_5_address0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_5_ce0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_5_we0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_5_d0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_6_address0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_6_ce0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_6_we0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_6_d0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_7_address0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_7_ce0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_7_we0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_7_d0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_8_address0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_8_ce0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_8_we0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_8_d0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_9_address0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_9_ce0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_9_we0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_9_d0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_10_address0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_10_ce0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_10_we0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_10_d0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_11_address0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_11_ce0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_11_we0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_11_d0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_12_address0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_12_ce0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_12_we0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_12_d0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_13_address0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_13_ce0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_13_we0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_13_d0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_14_address0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_14_ce0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_14_we0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_14_d0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_15_address0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_15_ce0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_15_we0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_15_d0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_ap_start;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_ap_done;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_ap_idle;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_ap_ready;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_out_V_TREADY;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_address0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_ce0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_we0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_d0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_1_address0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_1_ce0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_1_we0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_1_d0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_2_address0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_2_ce0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_2_we0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_2_d0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_3_address0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_3_ce0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_3_we0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_3_d0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_4_address0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_4_ce0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_4_we0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_4_d0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_5_address0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_5_ce0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_5_we0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_5_d0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_6_address0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_6_ce0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_6_we0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_6_d0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_7_address0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_7_ce0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_7_we0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_7_d0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_8_address0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_8_ce0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_8_we0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_8_d0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_9_address0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_9_ce0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_9_we0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_9_d0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_10_address0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_10_ce0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_10_we0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_10_d0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_11_address0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_11_ce0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_11_we0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_11_d0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_12_address0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_12_ce0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_12_we0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_12_d0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_13_address0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_13_ce0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_13_we0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_13_d0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_14_address0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_14_ce0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_14_we0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_14_d0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_15_address0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_15_ce0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_15_we0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_15_d0;
wire   [63:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_out_V_TDATA;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_out_V_TVALID;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_ap_start;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_ap_done;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_ap_idle;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_ap_ready;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_15_address0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_15_ce0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_15_we0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_15_d0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_14_address0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_14_ce0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_14_we0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_14_d0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_13_address0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_13_ce0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_13_we0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_13_d0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_12_address0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_12_ce0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_12_we0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_12_d0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_11_address0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_11_ce0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_11_we0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_11_d0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_10_address0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_10_ce0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_10_we0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_10_d0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_9_address0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_9_ce0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_9_we0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_9_d0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_8_address0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_8_ce0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_8_we0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_8_d0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_7_address0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_7_ce0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_7_we0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_7_d0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_6_address0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_6_ce0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_6_we0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_6_d0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_5_address0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_5_ce0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_5_we0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_5_d0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_4_address0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_4_ce0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_4_we0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_4_d0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_3_address0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_3_ce0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_3_we0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_3_d0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_2_address0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_2_ce0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_2_we0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_2_d0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_1_address0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_1_ce0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_1_we0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_1_d0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_address0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_ce0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_we0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_d0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_in0_V_TREADY;
reg   [4:0] indvar_flatten_reg_316;
wire   [0:0] icmp_ln154_fu_443_p2;
wire    ap_CS_fsm_state7;
reg   [3:0] xp_reg_327;
reg    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_ap_start_reg;
wire    ap_CS_fsm_state2;
reg    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_ap_start_reg;
wire    ap_CS_fsm_state8;
reg    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_ap_start_reg;
wire    ap_CS_fsm_state6;
wire   [63:0] zext_ln156_fu_481_p1;
reg   [3:0] yp_fu_56;
wire   [0:0] icmp_ln156_fu_467_p2;
reg   [7:0] ap_NS_fsm;
reg    ap_ST_fsm_state1_blk;
reg    ap_ST_fsm_state2_blk;
wire    ap_ST_fsm_state3_blk;
wire    ap_ST_fsm_state4_blk;
wire    ap_ST_fsm_state5_blk;
wire    ap_ST_fsm_state6_blk;
reg    ap_ST_fsm_state7_blk;
reg    ap_ST_fsm_state8_blk;
wire    ap_ce_reg;

// power-on initialization
initial begin
#0 ap_CS_fsm = 8'd1;
#0 grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_ap_start_reg = 1'b0;
#0 grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_ap_start_reg = 1'b0;
#0 grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_ap_start_reg = 1'b0;
end

StreamingMaxPool_hls_0_StreamingMaxPool_Precision_28u_2u_16u_ap_uint_4_0_64_s_buf_V_RAM_AUTO_1R1W #(
    .DataWidth( 4 ),
    .AddressRange( 14 ),
    .AddressWidth( 4 ))
buf_V_U(
    .clk(ap_clk),
    .reset(ap_rst),
    .address0(buf_V_address0),
    .ce0(buf_V_ce0),
    .we0(buf_V_we0),
    .d0(buf_V_d0),
    .q0(buf_V_q0)
);

StreamingMaxPool_hls_0_StreamingMaxPool_Precision_28u_2u_16u_ap_uint_4_0_64_s_buf_V_RAM_AUTO_1R1W #(
    .DataWidth( 4 ),
    .AddressRange( 14 ),
    .AddressWidth( 4 ))
buf_V_1_U(
    .clk(ap_clk),
    .reset(ap_rst),
    .address0(buf_V_1_address0),
    .ce0(buf_V_1_ce0),
    .we0(buf_V_1_we0),
    .d0(buf_V_1_d0),
    .q0(buf_V_1_q0)
);

StreamingMaxPool_hls_0_StreamingMaxPool_Precision_28u_2u_16u_ap_uint_4_0_64_s_buf_V_RAM_AUTO_1R1W #(
    .DataWidth( 4 ),
    .AddressRange( 14 ),
    .AddressWidth( 4 ))
buf_V_2_U(
    .clk(ap_clk),
    .reset(ap_rst),
    .address0(buf_V_2_address0),
    .ce0(buf_V_2_ce0),
    .we0(buf_V_2_we0),
    .d0(buf_V_2_d0),
    .q0(buf_V_2_q0)
);

StreamingMaxPool_hls_0_StreamingMaxPool_Precision_28u_2u_16u_ap_uint_4_0_64_s_buf_V_RAM_AUTO_1R1W #(
    .DataWidth( 4 ),
    .AddressRange( 14 ),
    .AddressWidth( 4 ))
buf_V_3_U(
    .clk(ap_clk),
    .reset(ap_rst),
    .address0(buf_V_3_address0),
    .ce0(buf_V_3_ce0),
    .we0(buf_V_3_we0),
    .d0(buf_V_3_d0),
    .q0(buf_V_3_q0)
);

StreamingMaxPool_hls_0_StreamingMaxPool_Precision_28u_2u_16u_ap_uint_4_0_64_s_buf_V_RAM_AUTO_1R1W #(
    .DataWidth( 4 ),
    .AddressRange( 14 ),
    .AddressWidth( 4 ))
buf_V_4_U(
    .clk(ap_clk),
    .reset(ap_rst),
    .address0(buf_V_4_address0),
    .ce0(buf_V_4_ce0),
    .we0(buf_V_4_we0),
    .d0(buf_V_4_d0),
    .q0(buf_V_4_q0)
);

StreamingMaxPool_hls_0_StreamingMaxPool_Precision_28u_2u_16u_ap_uint_4_0_64_s_buf_V_RAM_AUTO_1R1W #(
    .DataWidth( 4 ),
    .AddressRange( 14 ),
    .AddressWidth( 4 ))
buf_V_5_U(
    .clk(ap_clk),
    .reset(ap_rst),
    .address0(buf_V_5_address0),
    .ce0(buf_V_5_ce0),
    .we0(buf_V_5_we0),
    .d0(buf_V_5_d0),
    .q0(buf_V_5_q0)
);

StreamingMaxPool_hls_0_StreamingMaxPool_Precision_28u_2u_16u_ap_uint_4_0_64_s_buf_V_RAM_AUTO_1R1W #(
    .DataWidth( 4 ),
    .AddressRange( 14 ),
    .AddressWidth( 4 ))
buf_V_6_U(
    .clk(ap_clk),
    .reset(ap_rst),
    .address0(buf_V_6_address0),
    .ce0(buf_V_6_ce0),
    .we0(buf_V_6_we0),
    .d0(buf_V_6_d0),
    .q0(buf_V_6_q0)
);

StreamingMaxPool_hls_0_StreamingMaxPool_Precision_28u_2u_16u_ap_uint_4_0_64_s_buf_V_RAM_AUTO_1R1W #(
    .DataWidth( 4 ),
    .AddressRange( 14 ),
    .AddressWidth( 4 ))
buf_V_7_U(
    .clk(ap_clk),
    .reset(ap_rst),
    .address0(buf_V_7_address0),
    .ce0(buf_V_7_ce0),
    .we0(buf_V_7_we0),
    .d0(buf_V_7_d0),
    .q0(buf_V_7_q0)
);

StreamingMaxPool_hls_0_StreamingMaxPool_Precision_28u_2u_16u_ap_uint_4_0_64_s_buf_V_RAM_AUTO_1R1W #(
    .DataWidth( 4 ),
    .AddressRange( 14 ),
    .AddressWidth( 4 ))
buf_V_8_U(
    .clk(ap_clk),
    .reset(ap_rst),
    .address0(buf_V_8_address0),
    .ce0(buf_V_8_ce0),
    .we0(buf_V_8_we0),
    .d0(buf_V_8_d0),
    .q0(buf_V_8_q0)
);

StreamingMaxPool_hls_0_StreamingMaxPool_Precision_28u_2u_16u_ap_uint_4_0_64_s_buf_V_RAM_AUTO_1R1W #(
    .DataWidth( 4 ),
    .AddressRange( 14 ),
    .AddressWidth( 4 ))
buf_V_9_U(
    .clk(ap_clk),
    .reset(ap_rst),
    .address0(buf_V_9_address0),
    .ce0(buf_V_9_ce0),
    .we0(buf_V_9_we0),
    .d0(buf_V_9_d0),
    .q0(buf_V_9_q0)
);

StreamingMaxPool_hls_0_StreamingMaxPool_Precision_28u_2u_16u_ap_uint_4_0_64_s_buf_V_RAM_AUTO_1R1W #(
    .DataWidth( 4 ),
    .AddressRange( 14 ),
    .AddressWidth( 4 ))
buf_V_10_U(
    .clk(ap_clk),
    .reset(ap_rst),
    .address0(buf_V_10_address0),
    .ce0(buf_V_10_ce0),
    .we0(buf_V_10_we0),
    .d0(buf_V_10_d0),
    .q0(buf_V_10_q0)
);

StreamingMaxPool_hls_0_StreamingMaxPool_Precision_28u_2u_16u_ap_uint_4_0_64_s_buf_V_RAM_AUTO_1R1W #(
    .DataWidth( 4 ),
    .AddressRange( 14 ),
    .AddressWidth( 4 ))
buf_V_11_U(
    .clk(ap_clk),
    .reset(ap_rst),
    .address0(buf_V_11_address0),
    .ce0(buf_V_11_ce0),
    .we0(buf_V_11_we0),
    .d0(buf_V_11_d0),
    .q0(buf_V_11_q0)
);

StreamingMaxPool_hls_0_StreamingMaxPool_Precision_28u_2u_16u_ap_uint_4_0_64_s_buf_V_RAM_AUTO_1R1W #(
    .DataWidth( 4 ),
    .AddressRange( 14 ),
    .AddressWidth( 4 ))
buf_V_12_U(
    .clk(ap_clk),
    .reset(ap_rst),
    .address0(buf_V_12_address0),
    .ce0(buf_V_12_ce0),
    .we0(buf_V_12_we0),
    .d0(buf_V_12_d0),
    .q0(buf_V_12_q0)
);

StreamingMaxPool_hls_0_StreamingMaxPool_Precision_28u_2u_16u_ap_uint_4_0_64_s_buf_V_RAM_AUTO_1R1W #(
    .DataWidth( 4 ),
    .AddressRange( 14 ),
    .AddressWidth( 4 ))
buf_V_13_U(
    .clk(ap_clk),
    .reset(ap_rst),
    .address0(buf_V_13_address0),
    .ce0(buf_V_13_ce0),
    .we0(buf_V_13_we0),
    .d0(buf_V_13_d0),
    .q0(buf_V_13_q0)
);

StreamingMaxPool_hls_0_StreamingMaxPool_Precision_28u_2u_16u_ap_uint_4_0_64_s_buf_V_RAM_AUTO_1R1W #(
    .DataWidth( 4 ),
    .AddressRange( 14 ),
    .AddressWidth( 4 ))
buf_V_14_U(
    .clk(ap_clk),
    .reset(ap_rst),
    .address0(buf_V_14_address0),
    .ce0(buf_V_14_ce0),
    .we0(buf_V_14_we0),
    .d0(buf_V_14_d0),
    .q0(buf_V_14_q0)
);

StreamingMaxPool_hls_0_StreamingMaxPool_Precision_28u_2u_16u_ap_uint_4_0_64_s_buf_V_RAM_AUTO_1R1W #(
    .DataWidth( 4 ),
    .AddressRange( 14 ),
    .AddressWidth( 4 ))
buf_V_15_U(
    .clk(ap_clk),
    .reset(ap_rst),
    .address0(buf_V_15_address0),
    .ce0(buf_V_15_ce0),
    .we0(buf_V_15_we0),
    .d0(buf_V_15_d0),
    .q0(buf_V_15_q0)
);

StreamingMaxPool_hls_0_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1 grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338(
    .ap_clk(ap_clk),
    .ap_rst(ap_rst),
    .ap_start(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_ap_start),
    .ap_done(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_ap_done),
    .ap_idle(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_ap_idle),
    .ap_ready(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_ap_ready),
    .buf_V_address0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_address0),
    .buf_V_ce0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_ce0),
    .buf_V_we0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_we0),
    .buf_V_d0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_d0),
    .buf_V_1_address0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_1_address0),
    .buf_V_1_ce0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_1_ce0),
    .buf_V_1_we0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_1_we0),
    .buf_V_1_d0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_1_d0),
    .buf_V_2_address0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_2_address0),
    .buf_V_2_ce0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_2_ce0),
    .buf_V_2_we0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_2_we0),
    .buf_V_2_d0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_2_d0),
    .buf_V_3_address0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_3_address0),
    .buf_V_3_ce0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_3_ce0),
    .buf_V_3_we0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_3_we0),
    .buf_V_3_d0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_3_d0),
    .buf_V_4_address0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_4_address0),
    .buf_V_4_ce0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_4_ce0),
    .buf_V_4_we0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_4_we0),
    .buf_V_4_d0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_4_d0),
    .buf_V_5_address0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_5_address0),
    .buf_V_5_ce0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_5_ce0),
    .buf_V_5_we0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_5_we0),
    .buf_V_5_d0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_5_d0),
    .buf_V_6_address0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_6_address0),
    .buf_V_6_ce0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_6_ce0),
    .buf_V_6_we0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_6_we0),
    .buf_V_6_d0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_6_d0),
    .buf_V_7_address0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_7_address0),
    .buf_V_7_ce0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_7_ce0),
    .buf_V_7_we0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_7_we0),
    .buf_V_7_d0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_7_d0),
    .buf_V_8_address0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_8_address0),
    .buf_V_8_ce0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_8_ce0),
    .buf_V_8_we0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_8_we0),
    .buf_V_8_d0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_8_d0),
    .buf_V_9_address0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_9_address0),
    .buf_V_9_ce0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_9_ce0),
    .buf_V_9_we0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_9_we0),
    .buf_V_9_d0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_9_d0),
    .buf_V_10_address0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_10_address0),
    .buf_V_10_ce0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_10_ce0),
    .buf_V_10_we0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_10_we0),
    .buf_V_10_d0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_10_d0),
    .buf_V_11_address0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_11_address0),
    .buf_V_11_ce0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_11_ce0),
    .buf_V_11_we0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_11_we0),
    .buf_V_11_d0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_11_d0),
    .buf_V_12_address0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_12_address0),
    .buf_V_12_ce0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_12_ce0),
    .buf_V_12_we0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_12_we0),
    .buf_V_12_d0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_12_d0),
    .buf_V_13_address0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_13_address0),
    .buf_V_13_ce0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_13_ce0),
    .buf_V_13_we0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_13_we0),
    .buf_V_13_d0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_13_d0),
    .buf_V_14_address0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_14_address0),
    .buf_V_14_ce0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_14_ce0),
    .buf_V_14_we0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_14_we0),
    .buf_V_14_d0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_14_d0),
    .buf_V_15_address0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_15_address0),
    .buf_V_15_ce0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_15_ce0),
    .buf_V_15_we0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_15_we0),
    .buf_V_15_d0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_15_d0)
);

StreamingMaxPool_hls_0_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8 grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374(
    .ap_clk(ap_clk),
    .ap_rst(ap_rst),
    .ap_start(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_ap_start),
    .ap_done(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_ap_done),
    .ap_idle(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_ap_idle),
    .ap_ready(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_ap_ready),
    .out_V_TREADY(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_out_V_TREADY),
    .buf_V_address0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_address0),
    .buf_V_ce0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_ce0),
    .buf_V_we0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_we0),
    .buf_V_d0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_d0),
    .buf_V_q0(buf_V_q0),
    .buf_V_1_address0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_1_address0),
    .buf_V_1_ce0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_1_ce0),
    .buf_V_1_we0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_1_we0),
    .buf_V_1_d0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_1_d0),
    .buf_V_1_q0(buf_V_1_q0),
    .buf_V_2_address0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_2_address0),
    .buf_V_2_ce0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_2_ce0),
    .buf_V_2_we0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_2_we0),
    .buf_V_2_d0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_2_d0),
    .buf_V_2_q0(buf_V_2_q0),
    .buf_V_3_address0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_3_address0),
    .buf_V_3_ce0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_3_ce0),
    .buf_V_3_we0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_3_we0),
    .buf_V_3_d0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_3_d0),
    .buf_V_3_q0(buf_V_3_q0),
    .buf_V_4_address0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_4_address0),
    .buf_V_4_ce0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_4_ce0),
    .buf_V_4_we0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_4_we0),
    .buf_V_4_d0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_4_d0),
    .buf_V_4_q0(buf_V_4_q0),
    .buf_V_5_address0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_5_address0),
    .buf_V_5_ce0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_5_ce0),
    .buf_V_5_we0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_5_we0),
    .buf_V_5_d0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_5_d0),
    .buf_V_5_q0(buf_V_5_q0),
    .buf_V_6_address0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_6_address0),
    .buf_V_6_ce0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_6_ce0),
    .buf_V_6_we0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_6_we0),
    .buf_V_6_d0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_6_d0),
    .buf_V_6_q0(buf_V_6_q0),
    .buf_V_7_address0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_7_address0),
    .buf_V_7_ce0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_7_ce0),
    .buf_V_7_we0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_7_we0),
    .buf_V_7_d0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_7_d0),
    .buf_V_7_q0(buf_V_7_q0),
    .buf_V_8_address0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_8_address0),
    .buf_V_8_ce0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_8_ce0),
    .buf_V_8_we0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_8_we0),
    .buf_V_8_d0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_8_d0),
    .buf_V_8_q0(buf_V_8_q0),
    .buf_V_9_address0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_9_address0),
    .buf_V_9_ce0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_9_ce0),
    .buf_V_9_we0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_9_we0),
    .buf_V_9_d0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_9_d0),
    .buf_V_9_q0(buf_V_9_q0),
    .buf_V_10_address0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_10_address0),
    .buf_V_10_ce0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_10_ce0),
    .buf_V_10_we0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_10_we0),
    .buf_V_10_d0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_10_d0),
    .buf_V_10_q0(buf_V_10_q0),
    .buf_V_11_address0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_11_address0),
    .buf_V_11_ce0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_11_ce0),
    .buf_V_11_we0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_11_we0),
    .buf_V_11_d0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_11_d0),
    .buf_V_11_q0(buf_V_11_q0),
    .buf_V_12_address0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_12_address0),
    .buf_V_12_ce0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_12_ce0),
    .buf_V_12_we0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_12_we0),
    .buf_V_12_d0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_12_d0),
    .buf_V_12_q0(buf_V_12_q0),
    .buf_V_13_address0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_13_address0),
    .buf_V_13_ce0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_13_ce0),
    .buf_V_13_we0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_13_we0),
    .buf_V_13_d0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_13_d0),
    .buf_V_13_q0(buf_V_13_q0),
    .buf_V_14_address0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_14_address0),
    .buf_V_14_ce0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_14_ce0),
    .buf_V_14_we0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_14_we0),
    .buf_V_14_d0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_14_d0),
    .buf_V_14_q0(buf_V_14_q0),
    .buf_V_15_address0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_15_address0),
    .buf_V_15_ce0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_15_ce0),
    .buf_V_15_we0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_15_we0),
    .buf_V_15_d0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_15_d0),
    .buf_V_15_q0(buf_V_15_q0),
    .out_V_TDATA(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_out_V_TDATA),
    .out_V_TVALID(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_out_V_TVALID)
);

StreamingMaxPool_hls_0_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6 grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396(
    .ap_clk(ap_clk),
    .ap_rst(ap_rst),
    .ap_start(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_ap_start),
    .ap_done(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_ap_done),
    .ap_idle(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_ap_idle),
    .ap_ready(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_ap_ready),
    .in0_V_TVALID(in0_V_TVALID),
    .buf_V_15_load_1(buf_V_15_load_reg_699),
    .buf_V_14_load_1(buf_V_14_load_reg_694),
    .buf_V_13_load_1(buf_V_13_load_reg_689),
    .buf_V_12_load_1(buf_V_12_load_reg_684),
    .buf_V_11_load_1(buf_V_11_load_reg_679),
    .buf_V_10_load_1(buf_V_10_load_reg_674),
    .buf_V_9_load_1(buf_V_9_load_reg_669),
    .buf_V_8_load_1(buf_V_8_load_reg_664),
    .buf_V_7_load_1(buf_V_7_load_reg_659),
    .buf_V_6_load_1(buf_V_6_load_reg_654),
    .buf_V_5_load_1(buf_V_5_load_reg_649),
    .buf_V_4_load_1(buf_V_4_load_reg_644),
    .buf_V_3_load_1(buf_V_3_load_reg_639),
    .buf_V_2_load_1(buf_V_2_load_reg_634),
    .buf_V_1_load_1(buf_V_1_load_reg_629),
    .buf_V_load_1(buf_V_load_reg_624),
    .buf_V_15_address0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_15_address0),
    .buf_V_15_ce0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_15_ce0),
    .buf_V_15_we0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_15_we0),
    .buf_V_15_d0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_15_d0),
    .zext_ln156(select_ln155_reg_534),
    .buf_V_14_address0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_14_address0),
    .buf_V_14_ce0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_14_ce0),
    .buf_V_14_we0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_14_we0),
    .buf_V_14_d0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_14_d0),
    .buf_V_13_address0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_13_address0),
    .buf_V_13_ce0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_13_ce0),
    .buf_V_13_we0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_13_we0),
    .buf_V_13_d0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_13_d0),
    .buf_V_12_address0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_12_address0),
    .buf_V_12_ce0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_12_ce0),
    .buf_V_12_we0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_12_we0),
    .buf_V_12_d0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_12_d0),
    .buf_V_11_address0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_11_address0),
    .buf_V_11_ce0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_11_ce0),
    .buf_V_11_we0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_11_we0),
    .buf_V_11_d0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_11_d0),
    .buf_V_10_address0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_10_address0),
    .buf_V_10_ce0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_10_ce0),
    .buf_V_10_we0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_10_we0),
    .buf_V_10_d0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_10_d0),
    .buf_V_9_address0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_9_address0),
    .buf_V_9_ce0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_9_ce0),
    .buf_V_9_we0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_9_we0),
    .buf_V_9_d0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_9_d0),
    .buf_V_8_address0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_8_address0),
    .buf_V_8_ce0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_8_ce0),
    .buf_V_8_we0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_8_we0),
    .buf_V_8_d0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_8_d0),
    .buf_V_7_address0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_7_address0),
    .buf_V_7_ce0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_7_ce0),
    .buf_V_7_we0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_7_we0),
    .buf_V_7_d0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_7_d0),
    .buf_V_6_address0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_6_address0),
    .buf_V_6_ce0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_6_ce0),
    .buf_V_6_we0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_6_we0),
    .buf_V_6_d0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_6_d0),
    .buf_V_5_address0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_5_address0),
    .buf_V_5_ce0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_5_ce0),
    .buf_V_5_we0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_5_we0),
    .buf_V_5_d0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_5_d0),
    .buf_V_4_address0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_4_address0),
    .buf_V_4_ce0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_4_ce0),
    .buf_V_4_we0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_4_we0),
    .buf_V_4_d0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_4_d0),
    .buf_V_3_address0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_3_address0),
    .buf_V_3_ce0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_3_ce0),
    .buf_V_3_we0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_3_we0),
    .buf_V_3_d0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_3_d0),
    .buf_V_2_address0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_2_address0),
    .buf_V_2_ce0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_2_ce0),
    .buf_V_2_we0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_2_we0),
    .buf_V_2_d0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_2_d0),
    .buf_V_1_address0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_1_address0),
    .buf_V_1_ce0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_1_ce0),
    .buf_V_1_we0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_1_we0),
    .buf_V_1_d0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_1_d0),
    .buf_V_address0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_address0),
    .buf_V_ce0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_ce0),
    .buf_V_we0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_we0),
    .buf_V_d0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_d0),
    .in0_V_TDATA(in0_V_TDATA),
    .in0_V_TREADY(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_in0_V_TREADY)
);

always @ (posedge ap_clk) begin
    if (ap_rst == 1'b1) begin
        ap_CS_fsm <= ap_ST_fsm_state1;
    end else begin
        ap_CS_fsm <= ap_NS_fsm;
    end
end

always @ (posedge ap_clk) begin
    if (ap_rst == 1'b1) begin
        grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_ap_start_reg <= 1'b0;
    end else begin
        if (((1'b1 == ap_CS_fsm_state1) & (ap_start == 1'b1))) begin
            grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_ap_start_reg <= 1'b1;
        end else if ((grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_ap_ready == 1'b1)) begin
            grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_ap_start_reg <= 1'b0;
        end
    end
end

always @ (posedge ap_clk) begin
    if (ap_rst == 1'b1) begin
        grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_ap_start_reg <= 1'b0;
    end else begin
        if ((1'b1 == ap_CS_fsm_state6)) begin
            grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_ap_start_reg <= 1'b1;
        end else if ((grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_ap_ready == 1'b1)) begin
            grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_ap_start_reg <= 1'b0;
        end
    end
end

always @ (posedge ap_clk) begin
    if (ap_rst == 1'b1) begin
        grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_ap_start_reg <= 1'b0;
    end else begin
        if (((icmp_ln155_fu_455_p2 == 1'd1) & (1'b1 == ap_CS_fsm_state4))) begin
            grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_ap_start_reg <= 1'b1;
        end else if ((grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_ap_ready == 1'b1)) begin
            grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_ap_start_reg <= 1'b0;
        end
    end
end

always @ (posedge ap_clk) begin
    if (((grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_ap_done == 1'b1) & (1'b1 == ap_CS_fsm_state7))) begin
        indvar_flatten_reg_316 <= add_ln155_reg_529;
    end else if (((icmp_ln154_fu_443_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state3))) begin
        indvar_flatten_reg_316 <= 5'd0;
    end
end

always @ (posedge ap_clk) begin
    if (((grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_ap_done == 1'b1) & (1'b1 == ap_CS_fsm_state7))) begin
        xp_reg_327 <= add_ln156_reg_619;
    end else if (((icmp_ln154_fu_443_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state3))) begin
        xp_reg_327 <= 4'd0;
    end
end

always @ (posedge ap_clk) begin
    if (((1'b1 == ap_CS_fsm_state1) & (ap_start == 1'b1))) begin
        yp_fu_56 <= 4'd0;
    end else if (((icmp_ln155_fu_455_p2 == 1'd1) & (1'b1 == ap_CS_fsm_state4))) begin
        yp_fu_56 <= yp_2_reg_521;
    end
end

always @ (posedge ap_clk) begin
    if ((1'b1 == ap_CS_fsm_state4)) begin
        add_ln155_reg_529 <= add_ln155_fu_461_p2;
    end
end

always @ (posedge ap_clk) begin
    if (((icmp_ln155_fu_455_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state4))) begin
        add_ln156_reg_619 <= add_ln156_fu_501_p2;
        select_ln155_reg_534 <= select_ln155_fu_473_p3;
    end
end

always @ (posedge ap_clk) begin
    if ((1'b1 == ap_CS_fsm_state5)) begin
        buf_V_10_load_reg_674 <= buf_V_10_q0;
        buf_V_11_load_reg_679 <= buf_V_11_q0;
        buf_V_12_load_reg_684 <= buf_V_12_q0;
        buf_V_13_load_reg_689 <= buf_V_13_q0;
        buf_V_14_load_reg_694 <= buf_V_14_q0;
        buf_V_15_load_reg_699 <= buf_V_15_q0;
        buf_V_1_load_reg_629 <= buf_V_1_q0;
        buf_V_2_load_reg_634 <= buf_V_2_q0;
        buf_V_3_load_reg_639 <= buf_V_3_q0;
        buf_V_4_load_reg_644 <= buf_V_4_q0;
        buf_V_5_load_reg_649 <= buf_V_5_q0;
        buf_V_6_load_reg_654 <= buf_V_6_q0;
        buf_V_7_load_reg_659 <= buf_V_7_q0;
        buf_V_8_load_reg_664 <= buf_V_8_q0;
        buf_V_9_load_reg_669 <= buf_V_9_q0;
        buf_V_load_reg_624 <= buf_V_q0;
    end
end

always @ (posedge ap_clk) begin
    if ((1'b1 == ap_CS_fsm_state3)) begin
        yp_2_reg_521 <= yp_2_fu_449_p2;
    end
end

always @ (*) begin
    if ((ap_start == 1'b0)) begin
        ap_ST_fsm_state1_blk = 1'b1;
    end else begin
        ap_ST_fsm_state1_blk = 1'b0;
    end
end

always @ (*) begin
    if ((grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_ap_done == 1'b0)) begin
        ap_ST_fsm_state2_blk = 1'b1;
    end else begin
        ap_ST_fsm_state2_blk = 1'b0;
    end
end

assign ap_ST_fsm_state3_blk = 1'b0;

assign ap_ST_fsm_state4_blk = 1'b0;

assign ap_ST_fsm_state5_blk = 1'b0;

assign ap_ST_fsm_state6_blk = 1'b0;

always @ (*) begin
    if ((grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_ap_done == 1'b0)) begin
        ap_ST_fsm_state7_blk = 1'b1;
    end else begin
        ap_ST_fsm_state7_blk = 1'b0;
    end
end

always @ (*) begin
    if ((grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_ap_done == 1'b0)) begin
        ap_ST_fsm_state8_blk = 1'b1;
    end else begin
        ap_ST_fsm_state8_blk = 1'b0;
    end
end

always @ (*) begin
    if ((((icmp_ln154_fu_443_p2 == 1'd1) & (1'b1 == ap_CS_fsm_state3)) | ((1'b1 == ap_CS_fsm_state1) & (ap_start == 1'b0)))) begin
        ap_done = 1'b1;
    end else begin
        ap_done = 1'b0;
    end
end

always @ (*) begin
    if (((1'b1 == ap_CS_fsm_state1) & (ap_start == 1'b0))) begin
        ap_idle = 1'b1;
    end else begin
        ap_idle = 1'b0;
    end
end

always @ (*) begin
    if (((icmp_ln154_fu_443_p2 == 1'd1) & (1'b1 == ap_CS_fsm_state3))) begin
        ap_ready = 1'b1;
    end else begin
        ap_ready = 1'b0;
    end
end

always @ (*) begin
    if (((icmp_ln155_fu_455_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state4))) begin
        buf_V_10_address0 = zext_ln156_fu_481_p1;
    end else if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_10_address0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_10_address0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_10_address0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_10_address0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_10_address0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_10_address0;
    end else begin
        buf_V_10_address0 = 'bx;
    end
end

always @ (*) begin
    if (((icmp_ln155_fu_455_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state4))) begin
        buf_V_10_ce0 = 1'b1;
    end else if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_10_ce0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_10_ce0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_10_ce0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_10_ce0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_10_ce0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_10_ce0;
    end else begin
        buf_V_10_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_10_d0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_10_d0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_10_d0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_10_d0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_10_d0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_10_d0;
    end else begin
        buf_V_10_d0 = 'bx;
    end
end

always @ (*) begin
    if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_10_we0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_10_we0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_10_we0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_10_we0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_10_we0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_10_we0;
    end else begin
        buf_V_10_we0 = 1'b0;
    end
end

always @ (*) begin
    if (((icmp_ln155_fu_455_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state4))) begin
        buf_V_11_address0 = zext_ln156_fu_481_p1;
    end else if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_11_address0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_11_address0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_11_address0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_11_address0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_11_address0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_11_address0;
    end else begin
        buf_V_11_address0 = 'bx;
    end
end

always @ (*) begin
    if (((icmp_ln155_fu_455_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state4))) begin
        buf_V_11_ce0 = 1'b1;
    end else if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_11_ce0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_11_ce0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_11_ce0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_11_ce0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_11_ce0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_11_ce0;
    end else begin
        buf_V_11_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_11_d0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_11_d0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_11_d0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_11_d0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_11_d0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_11_d0;
    end else begin
        buf_V_11_d0 = 'bx;
    end
end

always @ (*) begin
    if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_11_we0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_11_we0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_11_we0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_11_we0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_11_we0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_11_we0;
    end else begin
        buf_V_11_we0 = 1'b0;
    end
end

always @ (*) begin
    if (((icmp_ln155_fu_455_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state4))) begin
        buf_V_12_address0 = zext_ln156_fu_481_p1;
    end else if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_12_address0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_12_address0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_12_address0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_12_address0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_12_address0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_12_address0;
    end else begin
        buf_V_12_address0 = 'bx;
    end
end

always @ (*) begin
    if (((icmp_ln155_fu_455_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state4))) begin
        buf_V_12_ce0 = 1'b1;
    end else if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_12_ce0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_12_ce0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_12_ce0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_12_ce0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_12_ce0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_12_ce0;
    end else begin
        buf_V_12_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_12_d0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_12_d0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_12_d0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_12_d0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_12_d0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_12_d0;
    end else begin
        buf_V_12_d0 = 'bx;
    end
end

always @ (*) begin
    if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_12_we0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_12_we0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_12_we0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_12_we0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_12_we0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_12_we0;
    end else begin
        buf_V_12_we0 = 1'b0;
    end
end

always @ (*) begin
    if (((icmp_ln155_fu_455_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state4))) begin
        buf_V_13_address0 = zext_ln156_fu_481_p1;
    end else if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_13_address0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_13_address0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_13_address0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_13_address0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_13_address0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_13_address0;
    end else begin
        buf_V_13_address0 = 'bx;
    end
end

always @ (*) begin
    if (((icmp_ln155_fu_455_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state4))) begin
        buf_V_13_ce0 = 1'b1;
    end else if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_13_ce0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_13_ce0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_13_ce0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_13_ce0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_13_ce0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_13_ce0;
    end else begin
        buf_V_13_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_13_d0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_13_d0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_13_d0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_13_d0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_13_d0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_13_d0;
    end else begin
        buf_V_13_d0 = 'bx;
    end
end

always @ (*) begin
    if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_13_we0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_13_we0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_13_we0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_13_we0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_13_we0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_13_we0;
    end else begin
        buf_V_13_we0 = 1'b0;
    end
end

always @ (*) begin
    if (((icmp_ln155_fu_455_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state4))) begin
        buf_V_14_address0 = zext_ln156_fu_481_p1;
    end else if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_14_address0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_14_address0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_14_address0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_14_address0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_14_address0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_14_address0;
    end else begin
        buf_V_14_address0 = 'bx;
    end
end

always @ (*) begin
    if (((icmp_ln155_fu_455_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state4))) begin
        buf_V_14_ce0 = 1'b1;
    end else if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_14_ce0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_14_ce0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_14_ce0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_14_ce0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_14_ce0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_14_ce0;
    end else begin
        buf_V_14_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_14_d0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_14_d0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_14_d0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_14_d0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_14_d0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_14_d0;
    end else begin
        buf_V_14_d0 = 'bx;
    end
end

always @ (*) begin
    if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_14_we0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_14_we0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_14_we0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_14_we0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_14_we0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_14_we0;
    end else begin
        buf_V_14_we0 = 1'b0;
    end
end

always @ (*) begin
    if (((icmp_ln155_fu_455_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state4))) begin
        buf_V_15_address0 = zext_ln156_fu_481_p1;
    end else if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_15_address0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_15_address0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_15_address0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_15_address0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_15_address0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_15_address0;
    end else begin
        buf_V_15_address0 = 'bx;
    end
end

always @ (*) begin
    if (((icmp_ln155_fu_455_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state4))) begin
        buf_V_15_ce0 = 1'b1;
    end else if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_15_ce0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_15_ce0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_15_ce0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_15_ce0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_15_ce0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_15_ce0;
    end else begin
        buf_V_15_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_15_d0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_15_d0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_15_d0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_15_d0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_15_d0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_15_d0;
    end else begin
        buf_V_15_d0 = 'bx;
    end
end

always @ (*) begin
    if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_15_we0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_15_we0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_15_we0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_15_we0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_15_we0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_15_we0;
    end else begin
        buf_V_15_we0 = 1'b0;
    end
end

always @ (*) begin
    if (((icmp_ln155_fu_455_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state4))) begin
        buf_V_1_address0 = zext_ln156_fu_481_p1;
    end else if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_1_address0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_1_address0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_1_address0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_1_address0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_1_address0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_1_address0;
    end else begin
        buf_V_1_address0 = 'bx;
    end
end

always @ (*) begin
    if (((icmp_ln155_fu_455_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state4))) begin
        buf_V_1_ce0 = 1'b1;
    end else if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_1_ce0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_1_ce0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_1_ce0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_1_ce0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_1_ce0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_1_ce0;
    end else begin
        buf_V_1_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_1_d0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_1_d0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_1_d0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_1_d0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_1_d0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_1_d0;
    end else begin
        buf_V_1_d0 = 'bx;
    end
end

always @ (*) begin
    if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_1_we0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_1_we0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_1_we0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_1_we0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_1_we0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_1_we0;
    end else begin
        buf_V_1_we0 = 1'b0;
    end
end

always @ (*) begin
    if (((icmp_ln155_fu_455_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state4))) begin
        buf_V_2_address0 = zext_ln156_fu_481_p1;
    end else if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_2_address0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_2_address0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_2_address0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_2_address0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_2_address0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_2_address0;
    end else begin
        buf_V_2_address0 = 'bx;
    end
end

always @ (*) begin
    if (((icmp_ln155_fu_455_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state4))) begin
        buf_V_2_ce0 = 1'b1;
    end else if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_2_ce0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_2_ce0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_2_ce0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_2_ce0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_2_ce0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_2_ce0;
    end else begin
        buf_V_2_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_2_d0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_2_d0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_2_d0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_2_d0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_2_d0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_2_d0;
    end else begin
        buf_V_2_d0 = 'bx;
    end
end

always @ (*) begin
    if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_2_we0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_2_we0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_2_we0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_2_we0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_2_we0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_2_we0;
    end else begin
        buf_V_2_we0 = 1'b0;
    end
end

always @ (*) begin
    if (((icmp_ln155_fu_455_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state4))) begin
        buf_V_3_address0 = zext_ln156_fu_481_p1;
    end else if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_3_address0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_3_address0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_3_address0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_3_address0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_3_address0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_3_address0;
    end else begin
        buf_V_3_address0 = 'bx;
    end
end

always @ (*) begin
    if (((icmp_ln155_fu_455_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state4))) begin
        buf_V_3_ce0 = 1'b1;
    end else if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_3_ce0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_3_ce0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_3_ce0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_3_ce0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_3_ce0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_3_ce0;
    end else begin
        buf_V_3_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_3_d0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_3_d0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_3_d0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_3_d0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_3_d0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_3_d0;
    end else begin
        buf_V_3_d0 = 'bx;
    end
end

always @ (*) begin
    if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_3_we0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_3_we0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_3_we0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_3_we0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_3_we0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_3_we0;
    end else begin
        buf_V_3_we0 = 1'b0;
    end
end

always @ (*) begin
    if (((icmp_ln155_fu_455_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state4))) begin
        buf_V_4_address0 = zext_ln156_fu_481_p1;
    end else if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_4_address0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_4_address0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_4_address0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_4_address0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_4_address0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_4_address0;
    end else begin
        buf_V_4_address0 = 'bx;
    end
end

always @ (*) begin
    if (((icmp_ln155_fu_455_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state4))) begin
        buf_V_4_ce0 = 1'b1;
    end else if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_4_ce0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_4_ce0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_4_ce0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_4_ce0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_4_ce0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_4_ce0;
    end else begin
        buf_V_4_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_4_d0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_4_d0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_4_d0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_4_d0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_4_d0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_4_d0;
    end else begin
        buf_V_4_d0 = 'bx;
    end
end

always @ (*) begin
    if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_4_we0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_4_we0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_4_we0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_4_we0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_4_we0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_4_we0;
    end else begin
        buf_V_4_we0 = 1'b0;
    end
end

always @ (*) begin
    if (((icmp_ln155_fu_455_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state4))) begin
        buf_V_5_address0 = zext_ln156_fu_481_p1;
    end else if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_5_address0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_5_address0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_5_address0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_5_address0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_5_address0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_5_address0;
    end else begin
        buf_V_5_address0 = 'bx;
    end
end

always @ (*) begin
    if (((icmp_ln155_fu_455_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state4))) begin
        buf_V_5_ce0 = 1'b1;
    end else if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_5_ce0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_5_ce0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_5_ce0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_5_ce0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_5_ce0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_5_ce0;
    end else begin
        buf_V_5_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_5_d0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_5_d0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_5_d0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_5_d0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_5_d0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_5_d0;
    end else begin
        buf_V_5_d0 = 'bx;
    end
end

always @ (*) begin
    if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_5_we0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_5_we0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_5_we0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_5_we0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_5_we0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_5_we0;
    end else begin
        buf_V_5_we0 = 1'b0;
    end
end

always @ (*) begin
    if (((icmp_ln155_fu_455_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state4))) begin
        buf_V_6_address0 = zext_ln156_fu_481_p1;
    end else if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_6_address0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_6_address0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_6_address0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_6_address0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_6_address0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_6_address0;
    end else begin
        buf_V_6_address0 = 'bx;
    end
end

always @ (*) begin
    if (((icmp_ln155_fu_455_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state4))) begin
        buf_V_6_ce0 = 1'b1;
    end else if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_6_ce0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_6_ce0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_6_ce0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_6_ce0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_6_ce0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_6_ce0;
    end else begin
        buf_V_6_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_6_d0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_6_d0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_6_d0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_6_d0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_6_d0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_6_d0;
    end else begin
        buf_V_6_d0 = 'bx;
    end
end

always @ (*) begin
    if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_6_we0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_6_we0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_6_we0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_6_we0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_6_we0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_6_we0;
    end else begin
        buf_V_6_we0 = 1'b0;
    end
end

always @ (*) begin
    if (((icmp_ln155_fu_455_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state4))) begin
        buf_V_7_address0 = zext_ln156_fu_481_p1;
    end else if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_7_address0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_7_address0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_7_address0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_7_address0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_7_address0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_7_address0;
    end else begin
        buf_V_7_address0 = 'bx;
    end
end

always @ (*) begin
    if (((icmp_ln155_fu_455_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state4))) begin
        buf_V_7_ce0 = 1'b1;
    end else if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_7_ce0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_7_ce0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_7_ce0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_7_ce0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_7_ce0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_7_ce0;
    end else begin
        buf_V_7_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_7_d0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_7_d0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_7_d0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_7_d0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_7_d0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_7_d0;
    end else begin
        buf_V_7_d0 = 'bx;
    end
end

always @ (*) begin
    if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_7_we0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_7_we0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_7_we0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_7_we0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_7_we0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_7_we0;
    end else begin
        buf_V_7_we0 = 1'b0;
    end
end

always @ (*) begin
    if (((icmp_ln155_fu_455_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state4))) begin
        buf_V_8_address0 = zext_ln156_fu_481_p1;
    end else if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_8_address0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_8_address0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_8_address0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_8_address0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_8_address0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_8_address0;
    end else begin
        buf_V_8_address0 = 'bx;
    end
end

always @ (*) begin
    if (((icmp_ln155_fu_455_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state4))) begin
        buf_V_8_ce0 = 1'b1;
    end else if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_8_ce0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_8_ce0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_8_ce0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_8_ce0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_8_ce0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_8_ce0;
    end else begin
        buf_V_8_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_8_d0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_8_d0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_8_d0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_8_d0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_8_d0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_8_d0;
    end else begin
        buf_V_8_d0 = 'bx;
    end
end

always @ (*) begin
    if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_8_we0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_8_we0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_8_we0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_8_we0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_8_we0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_8_we0;
    end else begin
        buf_V_8_we0 = 1'b0;
    end
end

always @ (*) begin
    if (((icmp_ln155_fu_455_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state4))) begin
        buf_V_9_address0 = zext_ln156_fu_481_p1;
    end else if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_9_address0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_9_address0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_9_address0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_9_address0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_9_address0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_9_address0;
    end else begin
        buf_V_9_address0 = 'bx;
    end
end

always @ (*) begin
    if (((icmp_ln155_fu_455_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state4))) begin
        buf_V_9_ce0 = 1'b1;
    end else if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_9_ce0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_9_ce0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_9_ce0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_9_ce0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_9_ce0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_9_ce0;
    end else begin
        buf_V_9_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_9_d0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_9_d0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_9_d0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_9_d0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_9_d0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_9_d0;
    end else begin
        buf_V_9_d0 = 'bx;
    end
end

always @ (*) begin
    if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_9_we0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_9_we0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_9_we0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_9_we0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_9_we0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_9_we0;
    end else begin
        buf_V_9_we0 = 1'b0;
    end
end

always @ (*) begin
    if (((icmp_ln155_fu_455_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state4))) begin
        buf_V_address0 = zext_ln156_fu_481_p1;
    end else if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_address0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_address0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_address0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_address0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_address0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_address0;
    end else begin
        buf_V_address0 = 'bx;
    end
end

always @ (*) begin
    if (((icmp_ln155_fu_455_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state4))) begin
        buf_V_ce0 = 1'b1;
    end else if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_ce0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_ce0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_ce0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_ce0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_ce0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_ce0;
    end else begin
        buf_V_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_d0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_d0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_d0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_d0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_d0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_d0;
    end else begin
        buf_V_d0 = 'bx;
    end
end

always @ (*) begin
    if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_we0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_buf_V_we0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_we0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_buf_V_we0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_we0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_buf_V_we0;
    end else begin
        buf_V_we0 = 1'b0;
    end
end

always @ (*) begin
    if ((1'b1 == ap_CS_fsm_state7)) begin
        in0_V_TREADY = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_in0_V_TREADY;
    end else begin
        in0_V_TREADY = 1'b0;
    end
end

always @ (*) begin
    case (ap_CS_fsm)
        ap_ST_fsm_state1 : begin
            if (((1'b1 == ap_CS_fsm_state1) & (ap_start == 1'b1))) begin
                ap_NS_fsm = ap_ST_fsm_state2;
            end else begin
                ap_NS_fsm = ap_ST_fsm_state1;
            end
        end
        ap_ST_fsm_state2 : begin
            if (((grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_ap_done == 1'b1) & (1'b1 == ap_CS_fsm_state2))) begin
                ap_NS_fsm = ap_ST_fsm_state3;
            end else begin
                ap_NS_fsm = ap_ST_fsm_state2;
            end
        end
        ap_ST_fsm_state3 : begin
            if (((icmp_ln154_fu_443_p2 == 1'd1) & (1'b1 == ap_CS_fsm_state3))) begin
                ap_NS_fsm = ap_ST_fsm_state1;
            end else begin
                ap_NS_fsm = ap_ST_fsm_state4;
            end
        end
        ap_ST_fsm_state4 : begin
            if (((icmp_ln155_fu_455_p2 == 1'd1) & (1'b1 == ap_CS_fsm_state4))) begin
                ap_NS_fsm = ap_ST_fsm_state8;
            end else begin
                ap_NS_fsm = ap_ST_fsm_state5;
            end
        end
        ap_ST_fsm_state5 : begin
            ap_NS_fsm = ap_ST_fsm_state6;
        end
        ap_ST_fsm_state6 : begin
            ap_NS_fsm = ap_ST_fsm_state7;
        end
        ap_ST_fsm_state7 : begin
            if (((grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_ap_done == 1'b1) & (1'b1 == ap_CS_fsm_state7))) begin
                ap_NS_fsm = ap_ST_fsm_state4;
            end else begin
                ap_NS_fsm = ap_ST_fsm_state7;
            end
        end
        ap_ST_fsm_state8 : begin
            if (((grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_ap_done == 1'b1) & (1'b1 == ap_CS_fsm_state8))) begin
                ap_NS_fsm = ap_ST_fsm_state3;
            end else begin
                ap_NS_fsm = ap_ST_fsm_state8;
            end
        end
        default : begin
            ap_NS_fsm = 'bx;
        end
    endcase
end

assign add_ln155_fu_461_p2 = (indvar_flatten_reg_316 + 5'd1);

assign add_ln156_fu_501_p2 = (select_ln155_fu_473_p3 + 4'd1);

assign ap_CS_fsm_state1 = ap_CS_fsm[32'd0];

assign ap_CS_fsm_state2 = ap_CS_fsm[32'd1];

assign ap_CS_fsm_state3 = ap_CS_fsm[32'd2];

assign ap_CS_fsm_state4 = ap_CS_fsm[32'd3];

assign ap_CS_fsm_state5 = ap_CS_fsm[32'd4];

assign ap_CS_fsm_state6 = ap_CS_fsm[32'd5];

assign ap_CS_fsm_state7 = ap_CS_fsm[32'd6];

assign ap_CS_fsm_state8 = ap_CS_fsm[32'd7];

assign grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_ap_start = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_338_ap_start_reg;

assign grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_ap_start = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_396_ap_start_reg;

assign grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_ap_start = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_ap_start_reg;

assign grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_out_V_TREADY = (out_V_TREADY & ap_CS_fsm_state8);

assign icmp_ln154_fu_443_p2 = ((yp_fu_56 == 4'd14) ? 1'b1 : 1'b0);

assign icmp_ln155_fu_455_p2 = ((indvar_flatten_reg_316 == 5'd28) ? 1'b1 : 1'b0);

assign icmp_ln156_fu_467_p2 = ((xp_reg_327 == 4'd14) ? 1'b1 : 1'b0);

assign out_V_TDATA = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_out_V_TDATA;

assign out_V_TVALID = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_374_out_V_TVALID;

assign select_ln155_fu_473_p3 = ((icmp_ln156_fu_467_p2[0:0] == 1'b1) ? 4'd0 : xp_reg_327);

assign yp_2_fu_449_p2 = (yp_fu_56 + 4'd1);

assign zext_ln156_fu_481_p1 = select_ln155_fu_473_p3;

endmodule //StreamingMaxPool_hls_0_StreamingMaxPool_Precision_28u_2u_16u_ap_uint_4_0_64_s
//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/code_gen_ipgen_StreamingDataWidthConverter_rtl_1_6qz_oquq/dwc.sv


/******************************************************************************
 * Copyright (C) 2023, Advanced Micro Devices, Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *  1. Redistributions of source code must retain the above copyright notice,
 *     this list of conditions and the following disclaimer.
 *
 *  2. Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *
 *  3. Neither the name of the copyright holder nor the names of its
 *     contributors may be used to endorse or promote products derived from
 *     this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION). HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * @brief	Stream Data Width Converter.
 * @author	Thomas B. Preuer <tpreusse@amd.com>
 *****************************************************************************/
module dwc #(
	int unsigned  IBITS,
	int unsigned  OBITS
)(
	//- Global Control ------------------
	input	logic  clk,
	input	logic  rst,

	//- AXI Stream - Input --------------
	output	logic  irdy,
	input	logic  ivld,
	input	logic [IBITS-1:0]  idat,

	//- AXI Stream - Output -------------
	input	logic  ordy,
	output	logic  ovld,
	output	logic [OBITS-1:0]  odat
);

	if(IBITS == OBITS) begin : genNoop
		assign	irdy = ordy;
		assign	ovld = ivld;
		assign	odat  = idat;
	end : genNoop
	else if(IBITS < OBITS) begin : genUp

		// Sanity Checking: integer upscaling
		initial begin
			if(OBITS % IBITS) begin
				$error("Output width %0d is not a multiple of input width %0d.", OBITS, IBITS);
				$finish;
			end
		end

		// Parallelizing Shift Register A and Sidestep Buffer B on Input Path
		localparam int unsigned  K = OBITS / IBITS;
		typedef logic [IBITS-1:0]  dat_t;
		dat_t       [K-1:0]  ADat = 'x;
		logic [$clog2(K):0]  ACnt = K-1;	// (empty) K-1, ..., 0, -1 (full/valid)
		dat_t  BDat = 'x;
		logic  BRdy =  1;
		always_ff @(posedge clk) begin
			if(rst) begin
				ADat <= 'x;
				ACnt <= K-1;
				BDat <= 'x;
				BRdy <=  1;
			end
			else begin
				automatic type(ACnt)  acnt = (ovld && ordy)? K-1 : ACnt;
				automatic logic  rdy = !ovld || ordy;
				if((ivld || !BRdy) && rdy) begin
					ADat <= { BRdy? idat : BDat, ADat[K-1:1] };
					acnt--;
				end
				ACnt <= acnt;

				if(BRdy)  BDat <= idat;
				BRdy <= rdy || (BRdy && !ivld);
			end
		end

		// Output Assignments
		assign  irdy = BRdy;
		assign	ovld = ACnt[$left(ACnt)];
		assign	odat  = ADat;

	end : genUp
	else begin : genDown

		// Sanity Checking: integer downscaling
		initial begin
			if(IBITS % OBITS) begin
				$error("Input width %0d is not a multiple of output width %0d.", IBITS, OBITS);
				$finish;
			end
		end

		// Serializing Shift Register A and Sidestep Buffer B on Output Path
		localparam int unsigned  K = IBITS / OBITS;
		typedef logic [OBITS-1:0]  dat_t;
		dat_t [      K-1:0]  ADat = 'x;
		logic [$clog2(K):0]  ACnt =  1;	// (full) -K+1, ..., -1, 0, 1 (empty/not valid)
		dat_t  BDat = 'x;
		logic  BRdy =  1;
		dat_t  CDat = 'x;
		logic  CVld =  0;
		always_ff @(posedge clk) begin
			if(rst) begin
				ADat <= 'x;
				ACnt <=  1;
				BDat <= 'x;
				BRdy <=  1;
				CDat <= 'x;
				CVld <=  0;
			end
			else begin
				automatic type(ACnt)  acnt = ACnt;
				automatic logic       ainc = 0;
				if(irdy) begin
					ADat <= idat;
					acnt = ivld? -K+1 : 1;
				end
				else if(BRdy) begin
					ADat <= { {OBITS{1'bx}}, ADat[K-1:1] };
					ainc = BRdy;
				end;
				ACnt <= acnt + ainc;

				if(BRdy)  BDat <= ADat[0];
				BRdy <= !CVld || ordy || (BRdy && !ACnt[$left(ACnt)] && ACnt[0]);

				if(!CVld || ordy)  CDat <= BRdy? ADat[0] : BDat;
				CVld <= (CVld && !ordy) || !BRdy || ACnt[$left(ACnt)] || !ACnt[0];
			end
		end

		// Output Assignments
		assign  irdy = BRdy && !ACnt[$left(ACnt)];
		assign	ovld = CVld;
		assign	odat  = CDat;

	end : genDown

endmodule : dwc
//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn-rtllib/mvu/mvu_8sx8u_dsp48.sv


/******************************************************************************
 * Copyright (C) 2024, Advanced Micro Devices, Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *  1. Redistributions of source code must retain the above copyright notice,
 *     this list of conditions and the following disclaimer.
 *
 *  2. Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *
 *  3. Neither the name of the copyright holder nor the names of its
 *     contributors may be used to endorse or promote products derived from
 *     this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION). HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * @brief	Matrix Vector Unit (MVU) core compute kernel utilizing DSP48.
 *****************************************************************************/

module mvu_8sx8u_dsp48 #(
	int unsigned  PE,
	int unsigned  SIMD,
	int unsigned  ACCU_WIDTH,
	int unsigned  ACTIVATION_WIDTH,
	int unsigned  WEIGHT_WIDTH,

	int unsigned  VERSION = 1,
	bit  SIGNED_ACTIVATIONS = 0,
	bit  FORCE_BEHAVIORAL = 0
)(
	// Global Control
	input	logic  clk,
	input	logic  rst,
	input	logic  en,

	// Input
	input	logic  last,
	input	logic  zero,	// ignore current inputs and force this partial product to zero
	input	logic signed [PE-1:0][SIMD-1:0][WEIGHT_WIDTH    -1:0]  w,	// signed weights
	input	logic                [SIMD-1:0][ACTIVATION_WIDTH-1:0]  a,	// unsigned activations (override by SIGNED_ACTIVATIONS)

	// Ouput
	output	logic  vld,
	output	logic signed [PE-1:0][ACCU_WIDTH-1:0]  p
);
	// for verilator always use behavioral code
	localparam bit  BEHAVIORAL =
`ifdef VERILATOR
		1 ||
`endif
		FORCE_BEHAVIORAL;

	typedef int unsigned  leave_load_t[2*SIMD-1];
	function leave_load_t init_leave_loads();
		automatic leave_load_t  res;
		for(int  i = 2*(SIMD-1); i >= int'(SIMD)-1; i--)  res[i] = 1;
		for(int  i = SIMD-2; i >= 0; i--)  res[i] = res[2*i+1] + res[2*i+2];
		return  res;
	endfunction : init_leave_loads

	// Pipeline for last indicator flag
	logic [1:5] L = '0;
	always_ff @(posedge clk) begin
		if(rst)      L <= '0;
		else if(en)  L <= { last, L[1:4] };
	end
	assign	vld = L[5];

	// Stages #1 - #3: DSP Lanes + cross-lane canaries duplicated with SIMD parallelism
	localparam int unsigned  SINGLE_PROD_WIDTH = ACTIVATION_WIDTH+WEIGHT_WIDTH;
	localparam int unsigned  D[2:0] = '{ ACCU_WIDTH+SINGLE_PROD_WIDTH, SINGLE_PROD_WIDTH, 0 }; // Lane offsets

	localparam int unsigned  PIPE_COUNT = (PE+1)/2;
	for(genvar  c = 0; c < PIPE_COUNT; c++) begin : genPipes

		localparam int unsigned  PE_BEG = 2*c;
		localparam int unsigned  PE_END = PE < 2*(c+1)? PE : 2*(c+1);
		localparam int unsigned  PE_REM = 2*(c+1) - PE_END;

		uwire        [47:0]  p3[SIMD];
		uwire signed [ 1:0]  h3[SIMD];
		for(genvar  s = 0; s < SIMD; s++) begin : genSIMD

			// Input Lane Assembly
			uwire [17:0]  bb = { {(18-ACTIVATION_WIDTH){SIGNED_ACTIVATIONS && a[s][ACTIVATION_WIDTH-1]}}, a[s] };
			logic [29:0]  aa;
			logic [26:0]  dd;
			logic [ 1:0]  xx;
			if(1) begin : blkVectorize
				uwire [WEIGHT_WIDTH-1:0]  ww[PE_END - PE_BEG];
				for(genvar  pe = 0; pe < PE_END - PE_BEG; pe++) begin
					assign	ww[pe] = w[PE_BEG + pe][s];
					if(pe) begin
						if(BEHAVIORAL)  assign  xx = zero? 0 : ww[pe] * a[s];
`ifndef VERILATOR
						else begin
							LUT6_2 #(.INIT(64'h0000_6AC0_0000_8888)) lut_x (
								.O6(xx[1]),
								.O5(xx[0]),
								.I5(1'b1),
								.I4(zero),
								.I3(ww[pe][1]),
								.I2(a[s][1]),
								.I1(ww[pe][0]),
								.I0(a[s][0])
							);
						end
`endif
					end
				end
				always_comb begin
					dd = '0;
					aa = '0;
					for(int unsigned  pe = 0; pe < PE_END - PE_BEG; pe++) begin
						dd[D[pe + PE_REM] +: WEIGHT_WIDTH-1] = ww[pe];
						aa[D[pe + PE_REM] + WEIGHT_WIDTH-1] = ww[pe][WEIGHT_WIDTH-1];
					end
				end
			end : blkVectorize

			uwire [47:0]  pp;

			// Note: Since the product B * AD is computed,
			//       rst can be only applied to AD and zero only to B
			//       with the same effect as zeroing both.
			if(BEHAVIORAL) begin : genBehav
				// Stage #1: Input Refine
				logic signed [17:0]  B1  = 0;
				always_ff @(posedge clk) begin
					if(zero)     B1  <= 0;
					else if(en)  B1  <= bb;
				end

				logic signed [26:0]  AD1 = 0;
				always_ff @(posedge clk) begin
					if(rst)      AD1 <= 0;
					else if(en)  AD1 <= dd - aa;
				end

				// Stage #2: Multiply
				logic signed [45:0]  M2 = 0;
				always_ff @(posedge clk) begin
					if(rst)      M2 <= 0;
					else if(en)  M2 <=
// synthesis translate off
						(B1 === '0) || (AD1 === '0)? 0 :
// synthesis translate on
						B1 * AD1;
				end

				// Stage #3: Accumulate
				logic signed [47:0]  P3 = 0;
				always_ff @(posedge clk) begin
					if(rst)      P3 <= 0;
					else if(en)  P3 <= M2 + (L[3]? 0 : P3);
				end

				assign	pp = P3;
			end : genBehav
`ifndef VERILATOR
			else begin : genDSP
				localparam logic [6:0]  OPMODE_INVERSION = 7'b010_01_01;
				uwire [6:0]  opmode = { { 1'b0, L[2], 1'b0 }, 4'b00_00 };
				case(VERSION)
				1: DSP48E1 #(
					// Feature Control Attributes: Data Path Selection
					.A_INPUT("DIRECT"),		// Selects A input source, "DIRECT" (A port) or "CASCADE" (ACIN port)
					.B_INPUT("DIRECT"),		// Selects B input source, "DIRECT" (B port) or "CASCADE" (BCIN port)
					.USE_DPORT("TRUE"),		// Select D port usage (TRUE or FALSE)
					.USE_MULT("MULTIPLY"),	// Select multiplier usage ("MULTIPLY", "DYNAMIC", or "NONE")
					.USE_SIMD("ONE48"),		// SIMD selection ("ONE48", "TWO24", "FOUR12")

					// Pattern Detector Attributes: Pattern Detection Configuration
					.AUTORESET_PATDET("NO_RESET"),		// "NO_RESET", "RESET_MATCH", "RESET_NOT_MATCH"
					.MASK('1),							// 48-bit mask value for pattern detect (1=ignore)
					.PATTERN('0),						// 48-bit pattern match for pattern detect
					.SEL_MASK("MASK"),					// "C", "MASK", "ROUNDING_MODE1", "ROUNDING_MODE2"
					.SEL_PATTERN("PATTERN"),			// Select pattern value ("PATTERN" or "C")
					.USE_PATTERN_DETECT("NO_PATDET"),	// Enable pattern detect ("PATDET" or "NO_PATDET")

					// Register Control Attributes: Pipeline Register Configuration
					.ACASCREG(0),		// Number of pipeline stages between A/ACIN and ACOUT (0, 1 or 2)
					.ADREG(1),			// Number of pipeline stages for pre-adder (0 or 1)
					.ALUMODEREG(0),		// Number of pipeline stages for ALUMODE (0 or 1)
					.AREG(0),			// Number of pipeline stages for A (0, 1 or 2)
					.BCASCREG(1),		// Number of pipeline stages between B/BCIN and BCOUT (0, 1 or 2)
					.BREG(1),			// Number of pipeline stages for B (0, 1 or 2)
					.CARRYINREG(0),		// Number of pipeline stages for CARRYIN (0 or 1)
					.CARRYINSELREG(0),	// Number of pipeline stages for CARRYINSEL (0 or 1)
					.CREG(0),			// Number of pipeline stages for C (0 or 1)
					.DREG(0),			// Number of pipeline stages for D (0 or 1)
					.INMODEREG(0),		// Number of pipeline stages for INMODE (0 or 1)
					.MREG(1),			// Number of multiplier pipeline stages (0 or 1)
					.OPMODEREG(1),		// Number of pipeline stages for OPMODE (0 or 1)
					.PREG(1)			// Number of pipeline stages for P (0 or 1)
				) dsp (
					// Cascade: 30-bit (each) output: Cascade Ports
					.ACOUT(),			// 30-bit output: A port cascade output
					.BCOUT(),			// 18-bit output: B port cascade output
					.CARRYCASCOUT(),	// 1-bit output: Cascade carry output
					.MULTSIGNOUT(),		// 1-bit output: Multiplier sign cascade output
					.PCOUT(),			// 48-bit output: Cascade output

					// Control: 1-bit (each) output: Control Inputs/Status Bits
					.OVERFLOW(),		 // 1-bit output: Overflow in add/acc output
					.PATTERNBDETECT(),	 // 1-bit output: Pattern bar detect output
					.PATTERNDETECT(),	 // 1-bit output: Pattern detect output
					.UNDERFLOW(),		 // 1-bit output: Underflow in add/acc output

					// Data: 4-bit (each) output: Data Ports
					.CARRYOUT(),	// 4-bit output: Carry output
					.P(pp),			// 48-bit output: Primary data output

					// Cascade: 30-bit (each) input: Cascade Ports
					.ACIN('x),			 // 30-bit input: A cascade data input
					.BCIN('x),			 // 18-bit input: B cascade input
					.CARRYCASCIN('x),	 // 1-bit input: Cascade carry input
					.MULTSIGNIN('x),	 // 1-bit input: Multiplier sign input
					.PCIN('x),			 // 48-bit input: P cascade input

					// Control: 4-bit (each) input: Control Inputs/Status Bits
					.CLK(clk),				// 1-bit input: Clock input
					.ALUMODE('0),			// 4-bit input: ALU control input
					.CARRYINSEL('0),		// 3-bit input: Carry select input
					.INMODE(5'b01100),		// 5-bit input: INMODE control input
					.OPMODE(opmode ^ OPMODE_INVERSION), // 7-bit input: Operation mode input

					// Data: 30-bit (each) input: Data Ports
					.A(aa),			// 30-bit input: A data input
					.B(bb),			// 18-bit input: B data input
					.C('x),			// 48-bit input: C data input
					.CARRYIN('0),	// 1-bit input: Carry input signal
					.D(dd),			// 25-bit input: D data input

					// Reset/Clock Enable: 1-bit (each) input: Reset/Clock Enable Inputs
					.CEA1('0),			// 1-bit input: Clock enable input for 1st stage AREG
					.CEA2('0),			// 1-bit input: Clock enable input for 2nd stage AREG
					.CEAD(en),			// 1-bit input: Clock enable input for ADREG
					.CEALUMODE('0),		// 1-bit input: Clock enable input for ALUMODERE
					.CEB1('0),			// 1-bit input: Clock enable input for 1st stage BREG
					.CEB2(en),			// 1-bit input: Clock enable input for 2nd stage BREG
					.CEC('0),			// 1-bit input: Clock enable input for CREG
					.CECARRYIN('0),		// 1-bit input: Clock enable input for CARRYINREG
					.CECTRL(en),		// 1-bit input: Clock enable input for OPMODEREG and CARRYINSELREG
					.CED('0),			// 1-bit input: Clock enable input for DREG
					.CEINMODE('0),		// 1-bit input: Clock enable input for INMODEREG
					.CEM(en),			// 1-bit input: Clock enable input for MREG
					.CEP(en),			// 1-bit input: Clock enable input for PREG
					.RSTA('0),			// 1-bit input: Reset input for AREG
					.RSTB(				// 1-bit input: Reset for BREG
// synthesis translate_off
						rst ||
// synthesis translate_on
						zero
					),
					.RSTC('0),			// 1-bit input: Reset for CREG
					.RSTD(				// 1-bit input: Reset for DREG and ADREG
// synthesis translate_off
						zero ||
// synthesis translate_on
						rst
					),
					.RSTALLCARRYIN('0),	// 1-bit input: Reset for CARRYINREG
					.RSTALUMODE('0),	// 1-bit input: Reset for ALUMODEREG
					.RSTCTRL('0),		// 1-bit input: Reset for OPMODEREG and CARRYINSELREG
					.RSTINMODE('0),		// 1-bit input: Reset for INMODE register
					.RSTM(rst),			// 1-bit input: Reset for MREG
					.RSTP(rst)			// 1-bit input: Reset for PREG
				);
				2: DSP48E2 #(
					// Feature Control Attributes: Data Path Selection
					.AMULTSEL("AD"),	// Selects A input to multiplier (A, AD)
					.A_INPUT("DIRECT"),	// Selects A input source, "DIRECT" (A port) or "CASCADE" (ACIN port)
					.BMULTSEL("B"),		// Selects B input to multiplier (AD, B)
					.B_INPUT("DIRECT"),	// Selects B input source, "DIRECT" (B port) or "CASCADE" (BCIN port)
					.PREADDINSEL("A"),                 // Selects input to pre-adder (A, B)
					.RND('0),                          // Rounding Constant
					.USE_MULT("MULTIPLY"),             // Select multiplier usage (DYNAMIC, MULTIPLY, NONE)
					.USE_SIMD("ONE48"),                // SIMD selection (FOUR12, ONE58, TWO24)
					.USE_WIDEXOR("FALSE"),             // Use the Wide XOR function (FALSE, TRUE)
					.XORSIMD("XOR24_48_96"),       // Mode of operation for the Wide XOR (XOR12_22, XOR24_34_58_116)

					// Pattern Detector Attributes: Pattern Detection Configuration
					.AUTORESET_PATDET("NO_RESET"),     // NO_RESET, RESET_MATCH, RESET_NOT_MATCH
					.AUTORESET_PRIORITY("RESET"),      // Priority of AUTORESET vs. CEP (CEP, RESET).
					.MASK('1),                         // 58-bit mask value for pattern detect (1=ignore)
					.PATTERN('0),                      // 58-bit pattern match for pattern detect
					.SEL_MASK("MASK"),                 // C, MASK, ROUNDING_MODE1, ROUNDING_MODE2
					.SEL_PATTERN("PATTERN"),           // Select pattern value (C, PATTERN)
					.USE_PATTERN_DETECT("NO_PATDET"),  // Enable pattern detect (NO_PATDET, PATDET)

					// Programmable Inversion Attributes: Specifies built-in programmable inversion on specific pins
					.IS_ALUMODE_INVERTED('0),							// Optional inversion for ALUMODE
					.IS_CARRYIN_INVERTED('0),							// Optional inversion for CARRYIN
					.IS_CLK_INVERTED('0),								// Optional inversion for CLK
					.IS_INMODE_INVERTED('0),							// Optional inversion for INMODE
					.IS_OPMODE_INVERTED({ 2'b00, OPMODE_INVERSION}),	// Optional inversion for OPMODE
					.IS_RSTALLCARRYIN_INVERTED('0),						// Optional inversion for RSTALLCARRYIN
					.IS_RSTALUMODE_INVERTED('0),						// Optional inversion for RSTALUMODE
					.IS_RSTA_INVERTED('0),								// Optional inversion for RSTA
					.IS_RSTB_INVERTED('0),								// Optional inversion for RSTB
					.IS_RSTCTRL_INVERTED('0),							// Optional inversion for STCONJUGATE_A
					.IS_RSTC_INVERTED('0),								// Optional inversion for RSTC
					.IS_RSTD_INVERTED('0),								// Optional inversion for RSTD
					.IS_RSTINMODE_INVERTED('0),							// Optional inversion for RSTINMODE
					.IS_RSTM_INVERTED('0),								// Optional inversion for RSTM
					.IS_RSTP_INVERTED('0),								// Optional inversion for RSTP

					// Register Control Attributes: Pipeline Register Configuration
					.ACASCREG(0),                      // Number of pipeline stages between A/ACIN and ACOUT (0-2)
					.ADREG(1),                         // Pipeline stages for pre-adder (0-1)
					.ALUMODEREG(0),                    // Pipeline stages for ALUMODE (0-1)
					.AREG(0),                          // Pipeline stages for A (0-2)
					.BCASCREG(1),                      // Number of pipeline stages between B/BCIN and BCOUT (0-2)
					.BREG(1),                          // Pipeline stages for B (0-2)
					.CARRYINREG(0),                    // Pipeline stages for CARRYIN (0-1)
					.CARRYINSELREG(0),                 // Pipeline stages for CARRYINSEL (0-1)
					.CREG(0),                          // Pipeline stages for C (0-1)
					.DREG(0),                          // Pipeline stages for D (0-1)
					.INMODEREG(0),                     // Pipeline stages for INMODE (0-1)
					.MREG(1),                          // Multiplier pipeline stages (0-1)
					.OPMODEREG(1),                     // Pipeline stages for OPMODE (0-1)
					.PREG(1)                          // Number of pipeline stages for P (0-1)
				) dsp (
					// Cascade outputs: Cascade Ports
					.ACOUT(),			// 34-bit output: A port cascade
					.BCOUT(),			// 24-bit output: B cascade
					.CARRYCASCOUT(),	// 1-bit output: Cascade carry
					.MULTSIGNOUT(),		// 1-bit output: Multiplier sign cascade
					.PCOUT(),			// 58-bit output: Cascade output

					// Control outputs: Control Inputs/Status Bits
					.OVERFLOW(),		// 1-bit output: Overflow in add/acc
					.PATTERNBDETECT(),	// 1-bit output: Pattern bar detect
					.PATTERNDETECT(),	// 1-bit output: Pattern detect
					.UNDERFLOW(),		// 1-bit output: Underflow in add/acc

					// Data outputs: Data Ports
					.CARRYOUT(),		// 4-bit output: Carry
					.P(pp),				// 58-bit output: Primary data
					.XOROUT(),			// 8-bit output: XOR data

					// Cascade inputs: Cascade Ports
					.ACIN('x),			// 34-bit input: A cascade data
					.BCIN('x),			// 24-bit input: B cascade
					.CARRYCASCIN('x),	// 1-bit input: Cascade carry
					.MULTSIGNIN('x),	// 1-bit input: Multiplier sign cascade
					.PCIN('x),			// 58-bit input: P cascade

					// Control inputs: Control Inputs/Status Bits
					.CLK(clk),					// 1-bit input: Clock
					.ALUMODE(4'h0),				// 4-bit input: ALU control
					.CARRYINSEL('0),			// 3-bit input: Carry select
					.INMODE(5'b01100),			// 5-bit input: INMODE control
					.OPMODE({ 2'b00, opmode }),	// 9-bit input: Operation mode

					// Data inputs: Data Ports
					.A(aa),						// 34-bit input: A data
					.B(bb),						// 24-bit input: B data
					.C('x),						// 58-bit input: C data
					.CARRYIN('0),				// 1-bit input: Carry-in
					.D(dd),						// 27-bit input: D data

					// Reset/Clock Enable inputs: Reset/Clock Enable Inputs
					.CEA1('0),			// 1-bit input: Clock enable for 1st stage AREG
					.CEA2('0),			// 1-bit input: Clock enable for 2nd stage AREG
					.CEAD(en),			// 1-bit input: Clock enable for ADREG
					.CEALUMODE('0),		// 1-bit input: Clock enable for ALUMODE
					.CEB1('0),			// 1-bit input: Clock enable for 1st stage BREG
					.CEB2(en),			// 1-bit input: Clock enable for 2nd stage BREG
					.CEC('0),			// 1-bit input: Clock enable for CREG
					.CECARRYIN('0),		// 1-bit input: Clock enable for CARRYINREG
					.CECTRL(en),		// 1-bit input: Clock enable for OPMODEREG and CARRYINSELREG
					.CED('0),			// 1-bit input: Clock enable for DREG
					.CEINMODE('0),		// 1-bit input: Clock enable for INMODEREG
					.CEM(en),			// 1-bit input: Clock enable for MREG
					.CEP(en),			// 1-bit input: Clock enable for PREG
					.RSTA('0),			// 1-bit input: Reset for AREG
					.RSTB(				// 1-bit input: Reset for BREG
// synthesis translate_off
						rst ||
// synthesis translate_on
						zero
					),
					.RSTC('0),			// 1-bit input: Reset for CREG
					.RSTD(				// 1-bit input: Reset for DREG and ADREG
// synthesis translate_off
						zero ||
// synthesis translate_on
						rst
					),
					.RSTALLCARRYIN('0),	// 1-bit input: Reset for CARRYINREG
					.RSTALUMODE('0),	// 1-bit input: Reset for ALUMODEREG
					.RSTCTRL('0),		// 1-bit input: Reset for OPMODEREG and CARRYINSELREG
					.RSTINMODE('0),		// 1-bit input: Reset for INMODE register
					.RSTM(rst),			// 1-bit input: Reset for MREG
					.RSTP(rst)			// 1-bit input: Reset for PREG
				);
				default: initial begin
					$error("Unknown version DSP48E%0d.", VERSION);
					$finish;
				end
				endcase
			end : genDSP
`endif

			// External Canary Pipeline
			logic [1:0]  X1 = '{ default: 0 };
			logic [1:0]  X2 = '{ default: 0 };
			logic [1:0]  X3 = '{ default: 0 };
			always_ff @(posedge clk) begin
				if(rst) begin
					X1 <= '{ default: 0 };
					X2 <= '{ default: 0 };
					X3 <= '{ default: 0 };
				end
				else if(en) begin
					X1 <= xx;
					X2 <= X1;
					X3 <= X2 + (L[3]? 2'h0 : pp[D[1]+:2]);
				end
			end

			// Derive actual cross-lane overflows
			assign  h3[s] = pp[D[1]+:2] - X3;

			assign	p3[s] = pp;

		end : genSIMD

		// Stage #4: Cross-SIMD Reduction

		// Count leaves reachable from each node
		localparam leave_load_t  LEAVE_LOAD = SIMD > 1 ? init_leave_loads() : '{ default: 0}; // SIMD=1 requires no adder tree, so zero-ing out, otherwise init_leave_loads ends up in infinite loop

		// Range of Cross-lane Contribution Tracked in Hi4
		/*
		 * - Assumption: ACCU_WIDTH bounds right lane value at any point in time.
		 * - The value x beyond the lane boundary is hence bounded by:
		 *		-2^(w-1) <= x <= 2^(w-1)-1    with w = ACCU_WIDTH - D[1]
		 * - This value decomposes into the tracked overflow h and the overflow l
		 *   from the low SIMD lane reduction with:
		 *		0 <= l <= SIMD
		 * - From x = l + h follows:
		 *		h = x - l
		 *		-2^(w-1) - SIMD <= h <= 2^(w-1)-1
		 * - This required bit width of the two's complement representation of this
		 *   signed value is determined by its lower bound to be at least:
		 *		1 + $clog2(2^(w-1)+SIMD)
		 */
		localparam int unsigned  HI_WIDTH = 1 + $clog2(2**(ACCU_WIDTH-D[1]-1)+SIMD);

		uwire signed [ACCU_WIDTH       -1:0]  up4;
		uwire signed [HI_WIDTH         -1:0]  hi4;
		uwire        [$clog2(SIMD)+D[1]-1:0]  lo4;

		// Conclusive high part accumulation
		if(PE_REM == 0) begin : genHi

			// Adder Tree across all SIMD high contributions, each from [-1:1]
			uwire signed [2*SIMD-2:0][$clog2(1+SIMD):0]  tree;
			for(genvar  s = 0; s < SIMD;   s++)  assign  tree[SIMD-1+s] = h3[s];
			for(genvar  n = 0; n < SIMD-1; n++) begin
				// Sum truncated to actual maximum bit width at this node
				uwire signed [$clog2(1+LEAVE_LOAD[n]):0]  s = $signed(tree[2*n+1]) + $signed(tree[2*n+2]);
				assign  tree[n] = s;
			end

			// High Sideband Accumulation
			logic signed [HI_WIDTH-1:0]  Hi4 = 0;
			always_ff @(posedge clk) begin
				if(rst)  Hi4 <= 0;
				else if(en) begin
					automatic logic signed [HI_WIDTH:0]  h = $signed(L[4]? 0 : Hi4) + $signed(tree[0]);
					assert(h[HI_WIDTH] == h[HI_WIDTH-1]) else begin
						$error("%m: Accumulation overflow for ACCU_WIDTH=%0d", ACCU_WIDTH);
						$stop;
					end
					Hi4 <= h;
				end
			end
			assign	hi4 = Hi4;
		end : genHi
		else begin : genHiZero
			assign hi4 = '0;
		end : genHiZero

		for(genvar  i = 0; i < 2; i++) begin
			localparam int unsigned  LO_WIDTH = D[i+1] - D[i];
			// Conclusive low part accumulation
			if(i >= PE_REM) begin : blkLo
				// Adder Tree across all SIMD low contributions (all unsigned arithmetic)
				localparam int unsigned  ROOT_WIDTH = $clog2(1 + SIMD*(2**LO_WIDTH-1));
				uwire [2*SIMD-2:0][ROOT_WIDTH-1:0]  tree;
				for(genvar  s = 0; s < SIMD;   s++)  assign  tree[SIMD-1+s] = p3[s][D[i]+:LO_WIDTH];
				for(genvar  n = 0; n < SIMD-1; n++) begin
					// Sum truncated to actual maximum bit width at this node
					localparam int unsigned  NODE_WIDTH = $clog2(1 + LEAVE_LOAD[n]*(2**LO_WIDTH-1));
					uwire [NODE_WIDTH-1:0]  s = tree[2*n+1] + tree[2*n+2];
					assign  tree[n] = s;
				end

				logic [ROOT_WIDTH-1:0]  Lo4 = 0;
				always_ff @(posedge clk) begin
					if(rst)      Lo4 <= 0;
					else if(en)  Lo4 <= tree[0];
				end

				if(i == 1)  assign  up4 = Lo4;
				else  assign  lo4 = Lo4;
			end : blkLo
			else begin : blkLoZero
				assign lo4 = '0;
			end : blkLoZero

		end

		// Stage #5: Resolve lane totals
		logic signed [1:0][ACCU_WIDTH-1:0]  Res5 = '{ default: 0 };
		always_ff @(posedge clk) begin
			if(rst)  Res5 <= '{ default: 0 };
			else if(en) begin
				Res5[1] <= up4 - hi4;
				Res5[0] <= $signed({ hi4, {(D[1] - D[0]){1'b0}} }) + $signed({ 1'b0, lo4 });
			end
		end

		// Output
		for(genvar  pe = PE_BEG; pe < PE_END; pe++) begin
			assign	p[pe] = Res5[pe - PE_BEG + PE_REM];
		end

	end : genPipes

endmodule : mvu_8sx8u_dsp48
//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/vivado_stitch_proj_w5fn6zuu/finn_vivado_stitch_proj.gen/sources_1/bd/finn_design/ipshared/fb57/hdl/verilog/MVAU_hls_1_regslice_both.v


// ==============================================================
// Vitis HLS - High-Level Synthesis from C, C++ and OpenCL v2022.2 (64-bit)
// Tool Version Limit: 2019.12
// Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.
// ==============================================================

`timescale 1ns/1ps

module MVAU_hls_1_regslice_both
#(parameter 
    DataWidth=32
)(
    input ap_clk ,
    input ap_rst,

    input [DataWidth-1:0] data_in , 
    input vld_in , 
    output ack_in ,
    output [DataWidth-1:0] data_out, 
    output vld_out,
    input ack_out,
    output apdone_blk
);
 

reg   [1:0] B_V_data_1_state;
wire   [DataWidth-1:0] B_V_data_1_data_in;
reg   [DataWidth-1:0] B_V_data_1_data_out;
wire    B_V_data_1_vld_reg;
wire    B_V_data_1_vld_in;
wire    B_V_data_1_vld_out;
reg   [DataWidth-1:0] B_V_data_1_payload_A;
reg   [DataWidth-1:0] B_V_data_1_payload_B;
reg    B_V_data_1_sel_rd;
reg    B_V_data_1_sel_wr;
wire    B_V_data_1_sel;
wire    B_V_data_1_load_A;
wire    B_V_data_1_load_B;
wire    B_V_data_1_state_cmp_full;
wire    B_V_data_1_ack_in;
wire    B_V_data_1_ack_out;

always @ (posedge ap_clk) begin
    if (ap_rst == 1'b1) begin
        B_V_data_1_sel_rd <= 1'b0;
    end else begin
        if (((1'b1 == B_V_data_1_vld_out) & (1'b1 == B_V_data_1_ack_out))) begin
            B_V_data_1_sel_rd <= ~B_V_data_1_sel_rd;
        end else begin
            B_V_data_1_sel_rd <= B_V_data_1_sel_rd;
        end
    end
end

always @ (posedge ap_clk) begin
    if (ap_rst == 1'b1) begin
        B_V_data_1_sel_wr <= 1'b0;
    end else begin
        if (((1'b1 == B_V_data_1_vld_in) & (1'b1 == B_V_data_1_ack_in))) begin
            B_V_data_1_sel_wr <= ~B_V_data_1_sel_wr;
        end else begin
            B_V_data_1_sel_wr <= B_V_data_1_sel_wr;
        end
    end
end

always @ (posedge ap_clk) begin
    if (ap_rst == 1'b1) begin
        B_V_data_1_state <= 2'd0;
    end else begin
        if ((((2'd3 == B_V_data_1_state) & (1'b0 == B_V_data_1_vld_in) & (1'b1 == B_V_data_1_ack_out)) | ((2'd2 == B_V_data_1_state) & (1'b0 == B_V_data_1_vld_in)))) begin
            B_V_data_1_state <= 2'd2;
        end else if ((((2'd1 == B_V_data_1_state) & (1'b0 == B_V_data_1_ack_out)) | ((2'd3 == B_V_data_1_state) & (1'b0 == B_V_data_1_ack_out) & (1'b1 == B_V_data_1_vld_in)))) begin
            B_V_data_1_state <= 2'd1;
        end else if ((((2'd1 == B_V_data_1_state) & (1'b1 == B_V_data_1_ack_out)) | (~((1'b0 == B_V_data_1_ack_out) & (1'b1 == B_V_data_1_vld_in)) & ~((1'b0 == B_V_data_1_vld_in) & (1'b1 == B_V_data_1_ack_out)) & (2'd3 == B_V_data_1_state)) | ((2'd2 == B_V_data_1_state) & (1'b1 == B_V_data_1_vld_in)))) begin
            B_V_data_1_state <= 2'd3;
        end else begin
            B_V_data_1_state <= 2'd2;
        end
    end
end

always @ (posedge ap_clk) begin
    if ((1'b1 == B_V_data_1_load_A)) begin
        B_V_data_1_payload_A <= B_V_data_1_data_in;
    end
end

always @ (posedge ap_clk) begin
    if ((1'b1 == B_V_data_1_load_B)) begin
        B_V_data_1_payload_B <= B_V_data_1_data_in;
    end
end

always @ (*) begin
    if ((1'b1 == B_V_data_1_sel)) begin
        B_V_data_1_data_out = B_V_data_1_payload_B;
    end else begin
        B_V_data_1_data_out = B_V_data_1_payload_A;
    end
end

assign B_V_data_1_ack_in = B_V_data_1_state[1'd1];
assign B_V_data_1_load_A = (~B_V_data_1_sel_wr & B_V_data_1_state_cmp_full);
assign B_V_data_1_load_B = (B_V_data_1_state_cmp_full & B_V_data_1_sel_wr);
assign B_V_data_1_sel = B_V_data_1_sel_rd;
assign B_V_data_1_state_cmp_full = ((B_V_data_1_state != 2'd1) ? 1'b1 : 1'b0);
assign B_V_data_1_vld_out = B_V_data_1_state[1'd0];

assign ack_in = B_V_data_1_ack_in;
assign B_V_data_1_data_in = data_in;
assign B_V_data_1_vld_in = vld_in;

assign vld_out = B_V_data_1_vld_out;
assign data_out = B_V_data_1_data_out;
assign B_V_data_1_ack_out = ack_out;

assign apdone_blk = ((B_V_data_1_state == 2'd3 && ack_out == 1'b0) | (B_V_data_1_state == 2'd1));

endmodule // both

module MVAU_hls_1_regslice_both_w1
#(parameter 
    DataWidth=1
)(
    input ap_clk ,
    input ap_rst,

    input data_in , 
    input vld_in , 
    output ack_in ,
    output data_out, 
    output vld_out,
    input ack_out,
    output apdone_blk
);

reg     [1:0] B_V_data_1_state;
wire    B_V_data_1_data_in;
reg     B_V_data_1_data_out;
wire    B_V_data_1_vld_reg;
wire    B_V_data_1_vld_in;
wire    B_V_data_1_vld_out;
reg     B_V_data_1_payload_A;
reg     B_V_data_1_payload_B;
reg     B_V_data_1_sel_rd;
reg     B_V_data_1_sel_wr;
wire    B_V_data_1_sel;
wire    B_V_data_1_load_A;
wire    B_V_data_1_load_B;
wire    B_V_data_1_state_cmp_full;
wire    B_V_data_1_ack_in;
wire    B_V_data_1_ack_out;

always @ (posedge ap_clk) begin
    if (ap_rst == 1'b1) begin
        B_V_data_1_sel_rd <= 1'b0;
    end else begin
        if (((1'b1 == B_V_data_1_vld_out) & (1'b1 == B_V_data_1_ack_out))) begin
            B_V_data_1_sel_rd <= ~B_V_data_1_sel_rd;
        end else begin
            B_V_data_1_sel_rd <= B_V_data_1_sel_rd;
        end
    end
end

always @ (posedge ap_clk) begin
    if (ap_rst == 1'b1) begin
        B_V_data_1_sel_wr <= 1'b0;
    end else begin
        if (((1'b1 == B_V_data_1_vld_in) & (1'b1 == B_V_data_1_ack_in))) begin
            B_V_data_1_sel_wr <= ~B_V_data_1_sel_wr;
        end else begin
            B_V_data_1_sel_wr <= B_V_data_1_sel_wr;
        end
    end
end

always @ (posedge ap_clk) begin
    if (ap_rst == 1'b1) begin
        B_V_data_1_state <= 2'd0;
    end else begin
        if ((((2'd3 == B_V_data_1_state) & (1'b0 == B_V_data_1_vld_in) & (1'b1 == B_V_data_1_ack_out)) | ((2'd2 == B_V_data_1_state) & (1'b0 == B_V_data_1_vld_in)))) begin
            B_V_data_1_state <= 2'd2;
        end else if ((((2'd1 == B_V_data_1_state) & (1'b0 == B_V_data_1_ack_out)) | ((2'd3 == B_V_data_1_state) & (1'b0 == B_V_data_1_ack_out) & (1'b1 == B_V_data_1_vld_in)))) begin
            B_V_data_1_state <= 2'd1;
        end else if ((((2'd1 == B_V_data_1_state) & (1'b1 == B_V_data_1_ack_out)) | (~((1'b0 == B_V_data_1_ack_out) & (1'b1 == B_V_data_1_vld_in)) & ~((1'b0 == B_V_data_1_vld_in) & (1'b1 == B_V_data_1_ack_out)) & (2'd3 == B_V_data_1_state)) | ((2'd2 == B_V_data_1_state) & (1'b1 == B_V_data_1_vld_in)))) begin
            B_V_data_1_state <= 2'd3;
        end else begin
            B_V_data_1_state <= 2'd2;
        end
    end
end

always @ (posedge ap_clk) begin
    if ((1'b1 == B_V_data_1_load_A)) begin
        B_V_data_1_payload_A <= B_V_data_1_data_in;
    end
end

always @ (posedge ap_clk) begin
    if ((1'b1 == B_V_data_1_load_B)) begin
        B_V_data_1_payload_B <= B_V_data_1_data_in;
    end
end

always @ (*) begin
    if ((1'b1 == B_V_data_1_sel)) begin
        B_V_data_1_data_out = B_V_data_1_payload_B;
    end else begin
        B_V_data_1_data_out = B_V_data_1_payload_A;
    end
end

assign B_V_data_1_ack_in = B_V_data_1_state[1'd1];
assign B_V_data_1_load_A = (~B_V_data_1_sel_wr & B_V_data_1_state_cmp_full);
assign B_V_data_1_load_B = (B_V_data_1_state_cmp_full & B_V_data_1_sel_wr);
assign B_V_data_1_sel = B_V_data_1_sel_rd;
assign B_V_data_1_state_cmp_full = ((B_V_data_1_state != 2'd1) ? 1'b1 : 1'b0);
assign B_V_data_1_vld_out = B_V_data_1_state[1'd0];

assign ack_in = B_V_data_1_ack_in;
assign B_V_data_1_data_in = data_in;
assign B_V_data_1_vld_in = vld_in;

assign vld_out = B_V_data_1_vld_out;
assign data_out = B_V_data_1_data_out;
assign B_V_data_1_ack_out = ack_out;

assign apdone_blk = ((B_V_data_1_state == 2'd3 && ack_out == 1'b0) | (B_V_data_1_state == 2'd1));

endmodule // both


//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/code_gen_ipgen_StreamingFIFO_rtl_12_ve9w0c68/Q_srl.v


// original source:
// https://github.com/nachiket/tdfc/blob/master/verilog/queues/Q_srl_oreg3_prefull_SIMPLE.v


// Copyright (c) 1999 The Regents of the University of California
// Copyright (c) 2010 The Regents of the University of Pennsylvania
// Copyright (c) 2011 Department of Electrical and Electronic Engineering, Imperial College London
// Copyright (c) 2020 Xilinx
//
// Permission to use, copy, modify, and distribute this software and
// its documentation for any purpose, without fee, and without a
// written agreement is hereby granted, provided that the above copyright
// notice and this paragraph and the following two paragraphs appear in
// all copies.
//
// IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR
// DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
// LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION,
// EVEN IF THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
// THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
// INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
// AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE PROVIDED HEREUNDER IS ON
// AN "AS IS" BASIS, AND THE UNIVERSITY OF CALIFORNIA HAS NO OBLIGATIONS TO
// PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
//

// Q_srl_oreg3_prefull_SIMPLE.v
//
//  - In-page queue with parameterizable depth, bit width
//  - Stream I/O is triple (data, valid, back-pressure),
//      with EOS concatenated into the data
//  - Flow control for input & output is combinationally decoupled
//  - 2 <= depth <= 256
//      * (depth >= 2)  is required to decouple I/O flow control,
//          where empty => no produce,  full => no consume,
//          and depth 1 would ping-pong between the two at half rate
//      * (depth <= 256) can be modified
//           by changing ''synthesis loop_limit X'' below
//          and changing ''addrwidth'' or its log computation
//  - 1 <= width
//  - Queue storage is in SRL16E, up to depth 16 per LUT per bit-slice,
//      plus output register (for fast output)
//  - Queue addressing is done by ''addr'' up-down counter
//  - Queue fullness is checked by comparator (addr==depth)
//  - Queue fullness                           is pre-computed for next cycle
//  - Queue input back-pressure                is pre-computed for next cycle
//  - Queue output valid (state!=state__empty) is pre-computed for next cycle
//      (necessary since SRL data output reg requires non-boolean state)
//  - FSM has 3 states (empty, one, more)
//  - When empty, continue to emit most recently emitted value (for debugging)
//
//  - Queue slots used      = / (state==state_empty) ? 0
//                            | (state==state_one)   ? 1
//                            \ (state==state_more)  ? addr+2
//  - Queue slots used     <=  depth
//  - Queue slots remaining =  depth - used
//                          = / (state==state_empty) ? depth
//                            | (state==state_one)   ? depth-1
//                            \ (state==state_more)  ? depth-2-addr
//
//  - Synplify 7.1 / 8.0
//  - Eylon Caspi,  9/11/03, 8/18/04, 3/29/05


`ifdef  Q_srl
`else
`define Q_srl


module Q_srl (clock, reset, i_d, i_v, i_r, o_d, o_v, o_r, count, maxcount);

   parameter depth = 16;   // - greatest #items in queue  (2 <= depth <= 256)
   parameter width = 16;   // - width of data (i_d, o_d)

   localparam countwidth = $clog2(depth + 1);
   localparam addrwidth = $clog2(depth);

   input     clock;
   input     reset;

   input  [width-1:0] i_d;	// - input  stream data (concat data + eos)
   input              i_v;	// - input  stream valid
   output             i_r;	// - input  stream ready
   wire               i_b;  // - input  stream back-pressure

   output [width-1:0] o_d;	// - output stream data (concat data + eos)
   output             o_v;	// - output stream valid
   input              o_r;	// - output stream ready
   wire               o_b;	// - output stream back-pressure

   output [countwidth-1:0] count;  // - output number of elems in queue
   output [countwidth-1:0] maxcount;  // - maximum observed count since reset

   reg [countwidth-1:0] maxcount_reg;  // - maximum count seen until now
   reg    [addrwidth-1:0] addr, addr_, a_;		// - SRL16 address
							//     for data output
   reg 			  shift_en_;			// - SRL16 shift enable
   reg    [width-1:0] 	  srl [depth-2:0];		// - SRL16 memory
   reg 			  shift_en_o_;			// - SRLO  shift enable
   reg    [width-1:0] 	  srlo_, srlo			// - SRLO  output reg
			  /* synthesis syn_allow_retiming=0 */ ;

   parameter state_empty = 2'd0;    // - state empty : o_v=0 o_d=UNDEFINED
   parameter state_one   = 2'd1;    // - state one   : o_v=1 o_d=srlo
   parameter state_more  = 2'd2;    // - state more  : o_v=1 o_d=srlo
				    //     #items in srl = addr+2

   reg [1:0] state, state_;	    // - state register

   wire      addr_full_;	    // - true iff addr==depth-2 on NEXT cycle
   reg       addr_full; 	    // - true iff addr==depth-2
   wire      addr_zero_;	    // - true iff addr==0
   wire      o_v_reg_;		    // - true iff state_empty   on NEXT cycle
   reg       o_v_reg  		    // - true iff state_empty
	     /* synthesis syn_allow_retiming=0 */ ;
   wire      i_b_reg_;		    // - true iff !full         on NEXT cycle
   reg       i_b_reg  		    // - true iff !full
	     /* synthesis syn_allow_retiming=0 */ ;

   assign addr_full_ = (state_==state_more) && (addr_==depth-2);
						// - queue full
   assign addr_zero_ = (addr==0);		// - queue contains 2 (or 1,0)
   assign o_v_reg_   = (state_!=state_empty);	// - output valid if non-empty
   assign i_b_reg_   = addr_full_;		// - input bp if full
   assign o_d = srlo;				// - output data from queue
   assign o_v = o_v_reg;			// - output valid if non-empty
   assign i_b = i_b_reg;			// - input bp if full
   assign maxcount = maxcount_reg;

   assign i_r = !i_b;
   assign o_b = !o_r;

   assign count = (state==state_more ? addr+2 : (state==state_one ? 1 : 0));

   // - ''always'' block with both FFs and SRL16 does not work,
   //      since FFs need reset but SRL16 does not

   always @(posedge clock) begin	// - seq always: FFs
      if (reset) begin
	 state     <= state_empty;
	 addr      <= 0;
         addr_full <= 0;
	 o_v_reg   <= 0;

	 i_b_reg   <= 0;
	 maxcount_reg <= 0;

      end
      else begin
	 state     <= state_;
	 addr      <= addr_;
         addr_full <= addr_full_;
	 o_v_reg   <= o_v_reg_;
	 i_b_reg   <= i_b_reg_;
	 maxcount_reg <= (count > maxcount_reg ? count : maxcount_reg);
      end
   end // always @ (posedge clock)

   always @(posedge clock) begin	// - seq always: srlo
      // - infer enabled output reg at end of shift chain
      // - input first element from i_d, all subsequent elements from SRL16
      if (reset) begin
	 srlo <= 0;
      end
      else begin
	 if (shift_en_o_) begin
	    srlo <= srlo_;
	 end
      end
   end // always @ (posedge clock)

   always @(posedge clock) begin			// - seq always: srl
      // - infer enabled SRL16E from shifting srl array
      // - no reset capability;  srl[] contents undefined on reset
      if (shift_en_) begin
	 // synthesis loop_limit 256
	 for (a_=depth-2; a_>0; a_=a_-1) begin
	    srl[a_] = srl[a_-1];
	 end
	 srl[0] <= i_d;
      end
   end // always @ (posedge clock or negedge reset)

   always @* begin					// - combi always
        srlo_       <=  'bx;
        shift_en_o_ <= 1'bx;
        shift_en_   <= 1'bx;
        addr_       <=  'bx;
        state_      <= 2'bx;
      case (state)

	state_empty: begin		    // - (empty, will not produce)
	      if (i_v) begin		    // - empty & i_v => consume
		 srlo_       <= i_d;
		 shift_en_o_ <= 1;
		 shift_en_   <= 1'bx;
		 addr_       <= 0;
		 state_      <= state_one;
	      end
	      else	begin		    // - empty & !i_v => idle
		 srlo_       <= 'bx;
		 shift_en_o_ <= 0;
		 shift_en_   <= 1'bx;
		 addr_       <= 0;
		 state_      <= state_empty;
	      end
	end

	state_one: begin		    // - (contains one)
	      if (i_v && o_b) begin	    // - one & i_v & o_b => consume
		 srlo_       <= 'bx;
		 shift_en_o_ <= 0;
		 shift_en_   <= 1;
		 addr_       <= 0;
		 state_      <= state_more;
	      end
	      else if (i_v && !o_b) begin   // - one & i_v & !o_b => cons+prod
		 srlo_       <= i_d;
		 shift_en_o_ <= 1;
		 shift_en_   <= 1;
		 addr_       <= 0;
		 state_      <= state_one;
	      end
	      else if (!i_v && o_b) begin   // - one & !i_v & o_b => idle
		 srlo_       <= 'bx;
		 shift_en_o_ <= 0;
		 shift_en_   <= 1'bx;
		 addr_       <= 0;
		 state_      <= state_one;
	      end
	      else if (!i_v && !o_b) begin  // - one & !i_v & !o_b => produce
		 srlo_       <= 'bx;
		 shift_en_o_ <= 0;
		 shift_en_   <= 1'bx;
		 addr_       <= 0;
		 state_      <= state_empty;
	      end
	end // case: state_one

	state_more: begin		    // - (contains more than one)
	   if (addr_full || (depth==2)) begin
					    // - (full, will not consume)
					    // - (full here if depth==2)
	      if (o_b) begin		    // - full & o_b => idle
		 srlo_       <= 'bx;
		 shift_en_o_ <= 0;
		 shift_en_   <= 0;
		 addr_       <= addr;
		 state_      <= state_more;
	      end
	      else begin		    // - full & !o_b => produce
		 srlo_       <= srl[addr];
		 shift_en_o_ <= 1;
		 shift_en_   <= 0;
//		 addr_       <= addr-1;
//		 state_      <= state_more;
		 addr_       <= addr_zero_ ? 0         : addr-1;
		 state_      <= addr_zero_ ? state_one : state_more;
	      end
	   end
	   else begin			    // - (mid: neither empty nor full)
	      if (i_v && o_b) begin	    // - mid & i_v & o_b => consume
		 srlo_       <= 'bx;
		 shift_en_o_ <= 0;
		 shift_en_   <= 1;
		 addr_       <= addr+1;
		 state_      <= state_more;
	      end
	      else if (i_v && !o_b) begin   // - mid & i_v & !o_b => cons+prod
		 srlo_       <= srl[addr];
		 shift_en_o_ <= 1;
		 shift_en_   <= 1;
		 addr_       <= addr;
		 state_      <= state_more;
	      end
	      else if (!i_v && o_b) begin   // - mid & !i_v & o_b => idle
		 srlo_       <= 'bx;
		 shift_en_o_ <= 0;
		 shift_en_   <= 0;
		 addr_       <= addr;
		 state_      <= state_more;
	      end
	      else if (!i_v && !o_b) begin  // - mid & !i_v & !o_b => produce
		 srlo_       <= srl[addr];
		 shift_en_o_ <= 1;
		 shift_en_   <= 0;
		 addr_       <= addr_zero_ ? 0         : addr-1;
		 state_      <= addr_zero_ ? state_one : state_more;
	      end
	   end // else: !if(addr_full)
	end // case: state_more

	default: begin
		 srlo_       <=  'bx;
		 shift_en_o_ <= 1'bx;
		 shift_en_   <= 1'bx;
		 addr_       <=  'bx;
		 state_      <= 2'bx;
	end // case: default

      endcase // case(state)
   end // always @ *

endmodule // Q_srl


`endif  // `ifdef  Q_srl
//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/vivado_stitch_proj_w5fn6zuu/finn_vivado_stitch_proj.gen/sources_1/bd/finn_design/ipshared/18e4/hdl/verilog/MVAU_hls_0_Matrix_Vector_Activate_Stream_Batch_p_ZL7threshs_14_ROM_AUTO_1R.v


// ==============================================================
// Vitis HLS - High-Level Synthesis from C, C++ and OpenCL v2022.2 (64-bit)
// Version: 2022.2
// Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.
// ==============================================================
`timescale 1 ns / 1 ps
module MVAU_hls_0_Matrix_Vector_Activate_Stream_Batch_p_ZL7threshs_14_ROM_AUTO_1R (
    address0, ce0, q0, 
    reset, clk);

parameter DataWidth = 12;
parameter AddressWidth = 4;
parameter AddressRange = 16;
 
input[AddressWidth-1:0] address0;
input ce0;
output reg[DataWidth-1:0] q0;

input reset;
input clk;

 
reg [DataWidth-1:0] rom0[0:AddressRange-1];


initial begin
     
    $readmemh("/home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/code_gen_ipgen_MVAU_hls_0_z2r2fzak/project_MVAU_hls_0/sol1/impl/ip/hdl/verilog/MVAU_hls_0_Matrix_Vector_Activate_Stream_Batch_p_ZL7threshs_14_ROM_AUTO_1R.dat", rom0);
end

  
always @(posedge clk) 
begin 
    if (ce0) 
    begin
        q0 <= rom0[address0];
    end
end


endmodule

//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/code_gen_ipgen_StreamingDataWidthConverter_rtl_4_w7r25d9z/dwc.sv


/******************************************************************************
 * Copyright (C) 2023, Advanced Micro Devices, Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *  1. Redistributions of source code must retain the above copyright notice,
 *     this list of conditions and the following disclaimer.
 *
 *  2. Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *
 *  3. Neither the name of the copyright holder nor the names of its
 *     contributors may be used to endorse or promote products derived from
 *     this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION). HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * @brief	Stream Data Width Converter.
 * @author	Thomas B. Preuer <tpreusse@amd.com>
 *****************************************************************************/
module dwc #(
	int unsigned  IBITS,
	int unsigned  OBITS
)(
	//- Global Control ------------------
	input	logic  clk,
	input	logic  rst,

	//- AXI Stream - Input --------------
	output	logic  irdy,
	input	logic  ivld,
	input	logic [IBITS-1:0]  idat,

	//- AXI Stream - Output -------------
	input	logic  ordy,
	output	logic  ovld,
	output	logic [OBITS-1:0]  odat
);

	if(IBITS == OBITS) begin : genNoop
		assign	irdy = ordy;
		assign	ovld = ivld;
		assign	odat  = idat;
	end : genNoop
	else if(IBITS < OBITS) begin : genUp

		// Sanity Checking: integer upscaling
		initial begin
			if(OBITS % IBITS) begin
				$error("Output width %0d is not a multiple of input width %0d.", OBITS, IBITS);
				$finish;
			end
		end

		// Parallelizing Shift Register A and Sidestep Buffer B on Input Path
		localparam int unsigned  K = OBITS / IBITS;
		typedef logic [IBITS-1:0]  dat_t;
		dat_t       [K-1:0]  ADat = 'x;
		logic [$clog2(K):0]  ACnt = K-1;	// (empty) K-1, ..., 0, -1 (full/valid)
		dat_t  BDat = 'x;
		logic  BRdy =  1;
		always_ff @(posedge clk) begin
			if(rst) begin
				ADat <= 'x;
				ACnt <= K-1;
				BDat <= 'x;
				BRdy <=  1;
			end
			else begin
				automatic type(ACnt)  acnt = (ovld && ordy)? K-1 : ACnt;
				automatic logic  rdy = !ovld || ordy;
				if((ivld || !BRdy) && rdy) begin
					ADat <= { BRdy? idat : BDat, ADat[K-1:1] };
					acnt--;
				end
				ACnt <= acnt;

				if(BRdy)  BDat <= idat;
				BRdy <= rdy || (BRdy && !ivld);
			end
		end

		// Output Assignments
		assign  irdy = BRdy;
		assign	ovld = ACnt[$left(ACnt)];
		assign	odat  = ADat;

	end : genUp
	else begin : genDown

		// Sanity Checking: integer downscaling
		initial begin
			if(IBITS % OBITS) begin
				$error("Input width %0d is not a multiple of output width %0d.", IBITS, OBITS);
				$finish;
			end
		end

		// Serializing Shift Register A and Sidestep Buffer B on Output Path
		localparam int unsigned  K = IBITS / OBITS;
		typedef logic [OBITS-1:0]  dat_t;
		dat_t [      K-1:0]  ADat = 'x;
		logic [$clog2(K):0]  ACnt =  1;	// (full) -K+1, ..., -1, 0, 1 (empty/not valid)
		dat_t  BDat = 'x;
		logic  BRdy =  1;
		dat_t  CDat = 'x;
		logic  CVld =  0;
		always_ff @(posedge clk) begin
			if(rst) begin
				ADat <= 'x;
				ACnt <=  1;
				BDat <= 'x;
				BRdy <=  1;
				CDat <= 'x;
				CVld <=  0;
			end
			else begin
				automatic type(ACnt)  acnt = ACnt;
				automatic logic       ainc = 0;
				if(irdy) begin
					ADat <= idat;
					acnt = ivld? -K+1 : 1;
				end
				else if(BRdy) begin
					ADat <= { {OBITS{1'bx}}, ADat[K-1:1] };
					ainc = BRdy;
				end;
				ACnt <= acnt + ainc;

				if(BRdy)  BDat <= ADat[0];
				BRdy <= !CVld || ordy || (BRdy && !ACnt[$left(ACnt)] && ACnt[0]);

				if(!CVld || ordy)  CDat <= BRdy? ADat[0] : BDat;
				CVld <= (CVld && !ordy) || !BRdy || ACnt[$left(ACnt)] || !ACnt[0];
			end
		end

		// Output Assignments
		assign  irdy = BRdy && !ACnt[$left(ACnt)];
		assign	ovld = CVld;
		assign	odat  = CDat;

	end : genDown

endmodule : dwc
//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/code_gen_ipgen_StreamingFIFO_rtl_2_9upbug_e/Q_srl.v


// original source:
// https://github.com/nachiket/tdfc/blob/master/verilog/queues/Q_srl_oreg3_prefull_SIMPLE.v


// Copyright (c) 1999 The Regents of the University of California
// Copyright (c) 2010 The Regents of the University of Pennsylvania
// Copyright (c) 2011 Department of Electrical and Electronic Engineering, Imperial College London
// Copyright (c) 2020 Xilinx
//
// Permission to use, copy, modify, and distribute this software and
// its documentation for any purpose, without fee, and without a
// written agreement is hereby granted, provided that the above copyright
// notice and this paragraph and the following two paragraphs appear in
// all copies.
//
// IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR
// DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
// LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION,
// EVEN IF THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
// THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
// INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
// AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE PROVIDED HEREUNDER IS ON
// AN "AS IS" BASIS, AND THE UNIVERSITY OF CALIFORNIA HAS NO OBLIGATIONS TO
// PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
//

// Q_srl_oreg3_prefull_SIMPLE.v
//
//  - In-page queue with parameterizable depth, bit width
//  - Stream I/O is triple (data, valid, back-pressure),
//      with EOS concatenated into the data
//  - Flow control for input & output is combinationally decoupled
//  - 2 <= depth <= 256
//      * (depth >= 2)  is required to decouple I/O flow control,
//          where empty => no produce,  full => no consume,
//          and depth 1 would ping-pong between the two at half rate
//      * (depth <= 256) can be modified
//           by changing ''synthesis loop_limit X'' below
//          and changing ''addrwidth'' or its log computation
//  - 1 <= width
//  - Queue storage is in SRL16E, up to depth 16 per LUT per bit-slice,
//      plus output register (for fast output)
//  - Queue addressing is done by ''addr'' up-down counter
//  - Queue fullness is checked by comparator (addr==depth)
//  - Queue fullness                           is pre-computed for next cycle
//  - Queue input back-pressure                is pre-computed for next cycle
//  - Queue output valid (state!=state__empty) is pre-computed for next cycle
//      (necessary since SRL data output reg requires non-boolean state)
//  - FSM has 3 states (empty, one, more)
//  - When empty, continue to emit most recently emitted value (for debugging)
//
//  - Queue slots used      = / (state==state_empty) ? 0
//                            | (state==state_one)   ? 1
//                            \ (state==state_more)  ? addr+2
//  - Queue slots used     <=  depth
//  - Queue slots remaining =  depth - used
//                          = / (state==state_empty) ? depth
//                            | (state==state_one)   ? depth-1
//                            \ (state==state_more)  ? depth-2-addr
//
//  - Synplify 7.1 / 8.0
//  - Eylon Caspi,  9/11/03, 8/18/04, 3/29/05


`ifdef  Q_srl
`else
`define Q_srl


module Q_srl (clock, reset, i_d, i_v, i_r, o_d, o_v, o_r, count, maxcount);

   parameter depth = 16;   // - greatest #items in queue  (2 <= depth <= 256)
   parameter width = 16;   // - width of data (i_d, o_d)

   localparam countwidth = $clog2(depth + 1);
   localparam addrwidth = $clog2(depth);

   input     clock;
   input     reset;

   input  [width-1:0] i_d;	// - input  stream data (concat data + eos)
   input              i_v;	// - input  stream valid
   output             i_r;	// - input  stream ready
   wire               i_b;  // - input  stream back-pressure

   output [width-1:0] o_d;	// - output stream data (concat data + eos)
   output             o_v;	// - output stream valid
   input              o_r;	// - output stream ready
   wire               o_b;	// - output stream back-pressure

   output [countwidth-1:0] count;  // - output number of elems in queue
   output [countwidth-1:0] maxcount;  // - maximum observed count since reset

   reg [countwidth-1:0] maxcount_reg;  // - maximum count seen until now
   reg    [addrwidth-1:0] addr, addr_, a_;		// - SRL16 address
							//     for data output
   reg 			  shift_en_;			// - SRL16 shift enable
   reg    [width-1:0] 	  srl [depth-2:0];		// - SRL16 memory
   reg 			  shift_en_o_;			// - SRLO  shift enable
   reg    [width-1:0] 	  srlo_, srlo			// - SRLO  output reg
			  /* synthesis syn_allow_retiming=0 */ ;

   parameter state_empty = 2'd0;    // - state empty : o_v=0 o_d=UNDEFINED
   parameter state_one   = 2'd1;    // - state one   : o_v=1 o_d=srlo
   parameter state_more  = 2'd2;    // - state more  : o_v=1 o_d=srlo
				    //     #items in srl = addr+2

   reg [1:0] state, state_;	    // - state register

   wire      addr_full_;	    // - true iff addr==depth-2 on NEXT cycle
   reg       addr_full; 	    // - true iff addr==depth-2
   wire      addr_zero_;	    // - true iff addr==0
   wire      o_v_reg_;		    // - true iff state_empty   on NEXT cycle
   reg       o_v_reg  		    // - true iff state_empty
	     /* synthesis syn_allow_retiming=0 */ ;
   wire      i_b_reg_;		    // - true iff !full         on NEXT cycle
   reg       i_b_reg  		    // - true iff !full
	     /* synthesis syn_allow_retiming=0 */ ;

   assign addr_full_ = (state_==state_more) && (addr_==depth-2);
						// - queue full
   assign addr_zero_ = (addr==0);		// - queue contains 2 (or 1,0)
   assign o_v_reg_   = (state_!=state_empty);	// - output valid if non-empty
   assign i_b_reg_   = addr_full_;		// - input bp if full
   assign o_d = srlo;				// - output data from queue
   assign o_v = o_v_reg;			// - output valid if non-empty
   assign i_b = i_b_reg;			// - input bp if full
   assign maxcount = maxcount_reg;

   assign i_r = !i_b;
   assign o_b = !o_r;

   assign count = (state==state_more ? addr+2 : (state==state_one ? 1 : 0));

   // - ''always'' block with both FFs and SRL16 does not work,
   //      since FFs need reset but SRL16 does not

   always @(posedge clock) begin	// - seq always: FFs
      if (reset) begin
	 state     <= state_empty;
	 addr      <= 0;
         addr_full <= 0;
	 o_v_reg   <= 0;

	 i_b_reg   <= 0;
	 maxcount_reg <= 0;

      end
      else begin
	 state     <= state_;
	 addr      <= addr_;
         addr_full <= addr_full_;
	 o_v_reg   <= o_v_reg_;
	 i_b_reg   <= i_b_reg_;
	 maxcount_reg <= (count > maxcount_reg ? count : maxcount_reg);
      end
   end // always @ (posedge clock)

   always @(posedge clock) begin	// - seq always: srlo
      // - infer enabled output reg at end of shift chain
      // - input first element from i_d, all subsequent elements from SRL16
      if (reset) begin
	 srlo <= 0;
      end
      else begin
	 if (shift_en_o_) begin
	    srlo <= srlo_;
	 end
      end
   end // always @ (posedge clock)

   always @(posedge clock) begin			// - seq always: srl
      // - infer enabled SRL16E from shifting srl array
      // - no reset capability;  srl[] contents undefined on reset
      if (shift_en_) begin
	 // synthesis loop_limit 256
	 for (a_=depth-2; a_>0; a_=a_-1) begin
	    srl[a_] = srl[a_-1];
	 end
	 srl[0] <= i_d;
      end
   end // always @ (posedge clock or negedge reset)

   always @* begin					// - combi always
        srlo_       <=  'bx;
        shift_en_o_ <= 1'bx;
        shift_en_   <= 1'bx;
        addr_       <=  'bx;
        state_      <= 2'bx;
      case (state)

	state_empty: begin		    // - (empty, will not produce)
	      if (i_v) begin		    // - empty & i_v => consume
		 srlo_       <= i_d;
		 shift_en_o_ <= 1;
		 shift_en_   <= 1'bx;
		 addr_       <= 0;
		 state_      <= state_one;
	      end
	      else	begin		    // - empty & !i_v => idle
		 srlo_       <= 'bx;
		 shift_en_o_ <= 0;
		 shift_en_   <= 1'bx;
		 addr_       <= 0;
		 state_      <= state_empty;
	      end
	end

	state_one: begin		    // - (contains one)
	      if (i_v && o_b) begin	    // - one & i_v & o_b => consume
		 srlo_       <= 'bx;
		 shift_en_o_ <= 0;
		 shift_en_   <= 1;
		 addr_       <= 0;
		 state_      <= state_more;
	      end
	      else if (i_v && !o_b) begin   // - one & i_v & !o_b => cons+prod
		 srlo_       <= i_d;
		 shift_en_o_ <= 1;
		 shift_en_   <= 1;
		 addr_       <= 0;
		 state_      <= state_one;
	      end
	      else if (!i_v && o_b) begin   // - one & !i_v & o_b => idle
		 srlo_       <= 'bx;
		 shift_en_o_ <= 0;
		 shift_en_   <= 1'bx;
		 addr_       <= 0;
		 state_      <= state_one;
	      end
	      else if (!i_v && !o_b) begin  // - one & !i_v & !o_b => produce
		 srlo_       <= 'bx;
		 shift_en_o_ <= 0;
		 shift_en_   <= 1'bx;
		 addr_       <= 0;
		 state_      <= state_empty;
	      end
	end // case: state_one

	state_more: begin		    // - (contains more than one)
	   if (addr_full || (depth==2)) begin
					    // - (full, will not consume)
					    // - (full here if depth==2)
	      if (o_b) begin		    // - full & o_b => idle
		 srlo_       <= 'bx;
		 shift_en_o_ <= 0;
		 shift_en_   <= 0;
		 addr_       <= addr;
		 state_      <= state_more;
	      end
	      else begin		    // - full & !o_b => produce
		 srlo_       <= srl[addr];
		 shift_en_o_ <= 1;
		 shift_en_   <= 0;
//		 addr_       <= addr-1;
//		 state_      <= state_more;
		 addr_       <= addr_zero_ ? 0         : addr-1;
		 state_      <= addr_zero_ ? state_one : state_more;
	      end
	   end
	   else begin			    // - (mid: neither empty nor full)
	      if (i_v && o_b) begin	    // - mid & i_v & o_b => consume
		 srlo_       <= 'bx;
		 shift_en_o_ <= 0;
		 shift_en_   <= 1;
		 addr_       <= addr+1;
		 state_      <= state_more;
	      end
	      else if (i_v && !o_b) begin   // - mid & i_v & !o_b => cons+prod
		 srlo_       <= srl[addr];
		 shift_en_o_ <= 1;
		 shift_en_   <= 1;
		 addr_       <= addr;
		 state_      <= state_more;
	      end
	      else if (!i_v && o_b) begin   // - mid & !i_v & o_b => idle
		 srlo_       <= 'bx;
		 shift_en_o_ <= 0;
		 shift_en_   <= 0;
		 addr_       <= addr;
		 state_      <= state_more;
	      end
	      else if (!i_v && !o_b) begin  // - mid & !i_v & !o_b => produce
		 srlo_       <= srl[addr];
		 shift_en_o_ <= 1;
		 shift_en_   <= 0;
		 addr_       <= addr_zero_ ? 0         : addr-1;
		 state_      <= addr_zero_ ? state_one : state_more;
	      end
	   end // else: !if(addr_full)
	end // case: state_more

	default: begin
		 srlo_       <=  'bx;
		 shift_en_o_ <= 1'bx;
		 shift_en_   <= 1'bx;
		 addr_       <=  'bx;
		 state_      <= 2'bx;
	end // case: default

      endcase // case(state)
   end // always @ *

endmodule // Q_srl


`endif  // `ifdef  Q_srl
//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/code_gen_ipgen_StreamingFIFO_rtl_10_7b54d5mo/Q_srl.v


// original source:
// https://github.com/nachiket/tdfc/blob/master/verilog/queues/Q_srl_oreg3_prefull_SIMPLE.v


// Copyright (c) 1999 The Regents of the University of California
// Copyright (c) 2010 The Regents of the University of Pennsylvania
// Copyright (c) 2011 Department of Electrical and Electronic Engineering, Imperial College London
// Copyright (c) 2020 Xilinx
//
// Permission to use, copy, modify, and distribute this software and
// its documentation for any purpose, without fee, and without a
// written agreement is hereby granted, provided that the above copyright
// notice and this paragraph and the following two paragraphs appear in
// all copies.
//
// IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR
// DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
// LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION,
// EVEN IF THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
// THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
// INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
// AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE PROVIDED HEREUNDER IS ON
// AN "AS IS" BASIS, AND THE UNIVERSITY OF CALIFORNIA HAS NO OBLIGATIONS TO
// PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
//

// Q_srl_oreg3_prefull_SIMPLE.v
//
//  - In-page queue with parameterizable depth, bit width
//  - Stream I/O is triple (data, valid, back-pressure),
//      with EOS concatenated into the data
//  - Flow control for input & output is combinationally decoupled
//  - 2 <= depth <= 256
//      * (depth >= 2)  is required to decouple I/O flow control,
//          where empty => no produce,  full => no consume,
//          and depth 1 would ping-pong between the two at half rate
//      * (depth <= 256) can be modified
//           by changing ''synthesis loop_limit X'' below
//          and changing ''addrwidth'' or its log computation
//  - 1 <= width
//  - Queue storage is in SRL16E, up to depth 16 per LUT per bit-slice,
//      plus output register (for fast output)
//  - Queue addressing is done by ''addr'' up-down counter
//  - Queue fullness is checked by comparator (addr==depth)
//  - Queue fullness                           is pre-computed for next cycle
//  - Queue input back-pressure                is pre-computed for next cycle
//  - Queue output valid (state!=state__empty) is pre-computed for next cycle
//      (necessary since SRL data output reg requires non-boolean state)
//  - FSM has 3 states (empty, one, more)
//  - When empty, continue to emit most recently emitted value (for debugging)
//
//  - Queue slots used      = / (state==state_empty) ? 0
//                            | (state==state_one)   ? 1
//                            \ (state==state_more)  ? addr+2
//  - Queue slots used     <=  depth
//  - Queue slots remaining =  depth - used
//                          = / (state==state_empty) ? depth
//                            | (state==state_one)   ? depth-1
//                            \ (state==state_more)  ? depth-2-addr
//
//  - Synplify 7.1 / 8.0
//  - Eylon Caspi,  9/11/03, 8/18/04, 3/29/05


`ifdef  Q_srl
`else
`define Q_srl


module Q_srl (clock, reset, i_d, i_v, i_r, o_d, o_v, o_r, count, maxcount);

   parameter depth = 16;   // - greatest #items in queue  (2 <= depth <= 256)
   parameter width = 16;   // - width of data (i_d, o_d)

   localparam countwidth = $clog2(depth + 1);
   localparam addrwidth = $clog2(depth);

   input     clock;
   input     reset;

   input  [width-1:0] i_d;	// - input  stream data (concat data + eos)
   input              i_v;	// - input  stream valid
   output             i_r;	// - input  stream ready
   wire               i_b;  // - input  stream back-pressure

   output [width-1:0] o_d;	// - output stream data (concat data + eos)
   output             o_v;	// - output stream valid
   input              o_r;	// - output stream ready
   wire               o_b;	// - output stream back-pressure

   output [countwidth-1:0] count;  // - output number of elems in queue
   output [countwidth-1:0] maxcount;  // - maximum observed count since reset

   reg [countwidth-1:0] maxcount_reg;  // - maximum count seen until now
   reg    [addrwidth-1:0] addr, addr_, a_;		// - SRL16 address
							//     for data output
   reg 			  shift_en_;			// - SRL16 shift enable
   reg    [width-1:0] 	  srl [depth-2:0];		// - SRL16 memory
   reg 			  shift_en_o_;			// - SRLO  shift enable
   reg    [width-1:0] 	  srlo_, srlo			// - SRLO  output reg
			  /* synthesis syn_allow_retiming=0 */ ;

   parameter state_empty = 2'd0;    // - state empty : o_v=0 o_d=UNDEFINED
   parameter state_one   = 2'd1;    // - state one   : o_v=1 o_d=srlo
   parameter state_more  = 2'd2;    // - state more  : o_v=1 o_d=srlo
				    //     #items in srl = addr+2

   reg [1:0] state, state_;	    // - state register

   wire      addr_full_;	    // - true iff addr==depth-2 on NEXT cycle
   reg       addr_full; 	    // - true iff addr==depth-2
   wire      addr_zero_;	    // - true iff addr==0
   wire      o_v_reg_;		    // - true iff state_empty   on NEXT cycle
   reg       o_v_reg  		    // - true iff state_empty
	     /* synthesis syn_allow_retiming=0 */ ;
   wire      i_b_reg_;		    // - true iff !full         on NEXT cycle
   reg       i_b_reg  		    // - true iff !full
	     /* synthesis syn_allow_retiming=0 */ ;

   assign addr_full_ = (state_==state_more) && (addr_==depth-2);
						// - queue full
   assign addr_zero_ = (addr==0);		// - queue contains 2 (or 1,0)
   assign o_v_reg_   = (state_!=state_empty);	// - output valid if non-empty
   assign i_b_reg_   = addr_full_;		// - input bp if full
   assign o_d = srlo;				// - output data from queue
   assign o_v = o_v_reg;			// - output valid if non-empty
   assign i_b = i_b_reg;			// - input bp if full
   assign maxcount = maxcount_reg;

   assign i_r = !i_b;
   assign o_b = !o_r;

   assign count = (state==state_more ? addr+2 : (state==state_one ? 1 : 0));

   // - ''always'' block with both FFs and SRL16 does not work,
   //      since FFs need reset but SRL16 does not

   always @(posedge clock) begin	// - seq always: FFs
      if (reset) begin
	 state     <= state_empty;
	 addr      <= 0;
         addr_full <= 0;
	 o_v_reg   <= 0;

	 i_b_reg   <= 0;
	 maxcount_reg <= 0;

      end
      else begin
	 state     <= state_;
	 addr      <= addr_;
         addr_full <= addr_full_;
	 o_v_reg   <= o_v_reg_;
	 i_b_reg   <= i_b_reg_;
	 maxcount_reg <= (count > maxcount_reg ? count : maxcount_reg);
      end
   end // always @ (posedge clock)

   always @(posedge clock) begin	// - seq always: srlo
      // - infer enabled output reg at end of shift chain
      // - input first element from i_d, all subsequent elements from SRL16
      if (reset) begin
	 srlo <= 0;
      end
      else begin
	 if (shift_en_o_) begin
	    srlo <= srlo_;
	 end
      end
   end // always @ (posedge clock)

   always @(posedge clock) begin			// - seq always: srl
      // - infer enabled SRL16E from shifting srl array
      // - no reset capability;  srl[] contents undefined on reset
      if (shift_en_) begin
	 // synthesis loop_limit 256
	 for (a_=depth-2; a_>0; a_=a_-1) begin
	    srl[a_] = srl[a_-1];
	 end
	 srl[0] <= i_d;
      end
   end // always @ (posedge clock or negedge reset)

   always @* begin					// - combi always
        srlo_       <=  'bx;
        shift_en_o_ <= 1'bx;
        shift_en_   <= 1'bx;
        addr_       <=  'bx;
        state_      <= 2'bx;
      case (state)

	state_empty: begin		    // - (empty, will not produce)
	      if (i_v) begin		    // - empty & i_v => consume
		 srlo_       <= i_d;
		 shift_en_o_ <= 1;
		 shift_en_   <= 1'bx;
		 addr_       <= 0;
		 state_      <= state_one;
	      end
	      else	begin		    // - empty & !i_v => idle
		 srlo_       <= 'bx;
		 shift_en_o_ <= 0;
		 shift_en_   <= 1'bx;
		 addr_       <= 0;
		 state_      <= state_empty;
	      end
	end

	state_one: begin		    // - (contains one)
	      if (i_v && o_b) begin	    // - one & i_v & o_b => consume
		 srlo_       <= 'bx;
		 shift_en_o_ <= 0;
		 shift_en_   <= 1;
		 addr_       <= 0;
		 state_      <= state_more;
	      end
	      else if (i_v && !o_b) begin   // - one & i_v & !o_b => cons+prod
		 srlo_       <= i_d;
		 shift_en_o_ <= 1;
		 shift_en_   <= 1;
		 addr_       <= 0;
		 state_      <= state_one;
	      end
	      else if (!i_v && o_b) begin   // - one & !i_v & o_b => idle
		 srlo_       <= 'bx;
		 shift_en_o_ <= 0;
		 shift_en_   <= 1'bx;
		 addr_       <= 0;
		 state_      <= state_one;
	      end
	      else if (!i_v && !o_b) begin  // - one & !i_v & !o_b => produce
		 srlo_       <= 'bx;
		 shift_en_o_ <= 0;
		 shift_en_   <= 1'bx;
		 addr_       <= 0;
		 state_      <= state_empty;
	      end
	end // case: state_one

	state_more: begin		    // - (contains more than one)
	   if (addr_full || (depth==2)) begin
					    // - (full, will not consume)
					    // - (full here if depth==2)
	      if (o_b) begin		    // - full & o_b => idle
		 srlo_       <= 'bx;
		 shift_en_o_ <= 0;
		 shift_en_   <= 0;
		 addr_       <= addr;
		 state_      <= state_more;
	      end
	      else begin		    // - full & !o_b => produce
		 srlo_       <= srl[addr];
		 shift_en_o_ <= 1;
		 shift_en_   <= 0;
//		 addr_       <= addr-1;
//		 state_      <= state_more;
		 addr_       <= addr_zero_ ? 0         : addr-1;
		 state_      <= addr_zero_ ? state_one : state_more;
	      end
	   end
	   else begin			    // - (mid: neither empty nor full)
	      if (i_v && o_b) begin	    // - mid & i_v & o_b => consume
		 srlo_       <= 'bx;
		 shift_en_o_ <= 0;
		 shift_en_   <= 1;
		 addr_       <= addr+1;
		 state_      <= state_more;
	      end
	      else if (i_v && !o_b) begin   // - mid & i_v & !o_b => cons+prod
		 srlo_       <= srl[addr];
		 shift_en_o_ <= 1;
		 shift_en_   <= 1;
		 addr_       <= addr;
		 state_      <= state_more;
	      end
	      else if (!i_v && o_b) begin   // - mid & !i_v & o_b => idle
		 srlo_       <= 'bx;
		 shift_en_o_ <= 0;
		 shift_en_   <= 0;
		 addr_       <= addr;
		 state_      <= state_more;
	      end
	      else if (!i_v && !o_b) begin  // - mid & !i_v & !o_b => produce
		 srlo_       <= srl[addr];
		 shift_en_o_ <= 1;
		 shift_en_   <= 0;
		 addr_       <= addr_zero_ ? 0         : addr-1;
		 state_      <= addr_zero_ ? state_one : state_more;
	      end
	   end // else: !if(addr_full)
	end // case: state_more

	default: begin
		 srlo_       <=  'bx;
		 shift_en_o_ <= 1'bx;
		 shift_en_   <= 1'bx;
		 addr_       <=  'bx;
		 state_      <= 2'bx;
	end // case: default

      endcase // case(state)
   end // always @ *

endmodule // Q_srl


`endif  // `ifdef  Q_srl
//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/code_gen_ipgen_FMPadding_rtl_1_bx8daa0b/fmpadding_axi.sv


/******************************************************************************
 * Copyright (C) 2022, Advanced Micro Devices, Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *  1. Redistributions of source code must retain the above copyright notice,
 *     this list of conditions and the following disclaimer.
 *
 *  2. Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *
 *  3. Neither the name of the copyright holder nor the names of its
 *     contributors may be used to endorse or promote products derived from
 *     this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION). HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * @brief	Feature map padding.
 * @author	Thomas B. Preuer <tpreusse@amd.com>
 *****************************************************************************/

module fmpadding_axi #(
	int unsigned  XCOUNTER_BITS,
	int unsigned  YCOUNTER_BITS,
	int unsigned  NUM_CHANNELS,
	int unsigned  SIMD,
	int unsigned  ELEM_BITS,
	int unsigned  INIT_XON,
	int unsigned  INIT_XOFF,
	int unsigned  INIT_XEND,
	int unsigned  INIT_YON,
	int unsigned  INIT_YOFF,
	int unsigned  INIT_YEND,

	localparam int unsigned  STREAM_BITS = 8*(1 + (SIMD*ELEM_BITS-1)/8)
)(
	//- Global Control ------------------
	input	logic  ap_clk,
	input	logic  ap_rst_n,

	//- AXI Lite ------------------------
	// Writing
	input	       s_axilite_AWVALID,
	output	       s_axilite_AWREADY,
	input	[4:0]  s_axilite_AWADDR,

	input	        s_axilite_WVALID,
	output	        s_axilite_WREADY,
	input	[31:0]  s_axilite_WDATA,
	input	[ 3:0]  s_axilite_WSTRB,

	output	       s_axilite_BVALID,
	input	       s_axilite_BREADY,
	output	[1:0]  s_axilite_BRESP,

	// Reading
	input	       s_axilite_ARVALID,
	output	       s_axilite_ARREADY,
	input	[4:0]  s_axilite_ARADDR,

	output	        s_axilite_RVALID,
	input	        s_axilite_RREADY,
	output	[31:0]  s_axilite_RDATA,
	output	[ 1:0]  s_axilite_RRESP,

	//- AXI Stream - Input --------------
	output	logic  s_axis_tready,
	input	logic  s_axis_tvalid,
	input	logic [STREAM_BITS-1:0]  s_axis_tdata,

	//- AXI Stream - Output -------------
	input	logic  m_axis_tready,
	output	logic  m_axis_tvalid,
	output	logic [STREAM_BITS-1:0]  m_axis_tdata
);

	// AXI-Lite Adapter
	uwire         we;
	uwire [ 4:0]  wa;
	uwire [31:0]  wd;
	axi2we #(.ADDR_BITS(5)) axilight_adapter (
		.ap_clk, .ap_rst_n,

		.s_axilite_AWVALID, .s_axilite_AWREADY, .s_axilite_AWADDR,
		.s_axilite_WVALID, .s_axilite_WREADY, .s_axilite_WDATA, .s_axilite_WSTRB,
		.s_axilite_BVALID, .s_axilite_BREADY, .s_axilite_BRESP,

		.s_axilite_ARVALID, .s_axilite_ARREADY, .s_axilite_ARADDR,
		.s_axilite_RVALID, .s_axilite_RREADY, .s_axilite_RDATA, .s_axilite_RRESP,

		.we, .wa, .wd
	);

	// Actual Padding
	fmpadding #(
		.XCOUNTER_BITS(XCOUNTER_BITS), .YCOUNTER_BITS(YCOUNTER_BITS),
		.NUM_CHANNELS(NUM_CHANNELS), .SIMD(SIMD),
		.INIT_XON(INIT_XON), .INIT_XOFF(INIT_XOFF), .INIT_XEND(INIT_XEND),
		.INIT_YON(INIT_YON), .INIT_YOFF(INIT_YOFF), .INIT_YEND(INIT_YEND),
		.ELEM_BITS(ELEM_BITS)
	) padding (
		.ap_clk, .ap_rst_n,

		.we, .wa, .wd,

		.s_axis_tready, .s_axis_tvalid, .s_axis_tdata,
		.m_axis_tready, .m_axis_tvalid, .m_axis_tdata
	);

endmodule : fmpadding_axi
//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/vivado_stitch_proj_w5fn6zuu/finn_vivado_stitch_proj.gen/sources_1/bd/finn_design/ip/finn_design_StreamingFIFO_rtl_14_0/synth/finn_design_StreamingFIFO_rtl_14_0.v


// (c) Copyright 1995-2026 Xilinx, Inc. All rights reserved.
// 
// This file contains confidential and proprietary information
// of Xilinx, Inc. and is protected under U.S. and
// international copyright and other intellectual property
// laws.
// 
// DISCLAIMER
// This disclaimer is not a license and does not grant any
// rights to the materials distributed herewith. Except as
// otherwise provided in a valid license issued to you by
// Xilinx, and to the maximum extent permitted by applicable
// law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
// WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
// AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
// BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
// INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
// (2) Xilinx shall not be liable (whether in contract or tort,
// including negligence, or under any other theory of
// liability) for any loss or damage of any kind or nature
// related to, arising under or in connection with these
// materials, including for any direct, or any indirect,
// special, incidental, or consequential loss or damage
// (including loss of data, profits, goodwill, or any type of
// loss or damage suffered as a result of any action brought
// by a third party) even if such damage or loss was
// reasonably foreseeable or Xilinx had been advised of the
// possibility of the same.
// 
// CRITICAL APPLICATIONS
// Xilinx products are not designed or intended to be fail-
// safe, or for use in any application requiring fail-safe
// performance, such as life-support or safety devices or
// systems, Class III medical devices, nuclear facilities,
// applications related to the deployment of airbags, or any
// other applications that could lead to death, personal
// injury, or severe property or environmental damage
// (individually and collectively, "Critical
// Applications"). Customer assumes the sole risk and
// liability of any use of Xilinx products in Critical
// Applications, subject only to applicable laws and
// regulations governing limitations on product liability.
// 
// THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
// PART OF THIS FILE AT ALL TIMES.
// 
// DO NOT MODIFY THIS FILE.


// IP VLNV: xilinx.com:module_ref:StreamingFIFO_rtl_14:1.0
// IP Revision: 1

(* X_CORE_INFO = "StreamingFIFO_rtl_14,Vivado 2022.2" *)
(* CHECK_LICENSE_TYPE = "finn_design_StreamingFIFO_rtl_14_0,StreamingFIFO_rtl_14,{}" *)
(* CORE_GENERATION_INFO = "finn_design_StreamingFIFO_rtl_14_0,StreamingFIFO_rtl_14,{x_ipProduct=Vivado 2022.2,x_ipVendor=xilinx.com,x_ipLibrary=module_ref,x_ipName=StreamingFIFO_rtl_14,x_ipVersion=1.0,x_ipCoreRevision=1,x_ipLanguage=VERILOG,x_ipSimLanguage=MIXED}" *)
(* IP_DEFINITION_SOURCE = "module_ref" *)
(* DowngradeIPIdentifiedWarnings = "yes" *)
module finn_design_StreamingFIFO_rtl_14_0 (
  ap_clk,
  ap_rst_n,
  count,
  maxcount,
  in0_V_TREADY,
  in0_V_TVALID,
  in0_V_TDATA,
  out_V_TREADY,
  out_V_TVALID,
  out_V_TDATA
);

(* X_INTERFACE_PARAMETER = "XIL_INTERFACENAME ap_clk, ASSOCIATED_RESET ap_rst_n, ASSOCIATED_BUSIF in0_V:out_V, FREQ_HZ 100000000, FREQ_TOLERANCE_HZ 0, PHASE 0.0, CLK_DOMAIN finn_design_ap_clk_0, INSERT_VIP 0" *)
(* X_INTERFACE_INFO = "xilinx.com:signal:clock:1.0 ap_clk CLK" *)
input wire ap_clk;
(* X_INTERFACE_PARAMETER = "XIL_INTERFACENAME ap_rst_n, POLARITY ACTIVE_LOW, INSERT_VIP 0" *)
(* X_INTERFACE_INFO = "xilinx.com:signal:reset:1.0 ap_rst_n RST" *)
input wire ap_rst_n;
output wire [3 : 0] count;
output wire [3 : 0] maxcount;
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 in0_V TREADY" *)
output wire in0_V_TREADY;
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 in0_V TVALID" *)
input wire in0_V_TVALID;
(* X_INTERFACE_PARAMETER = "XIL_INTERFACENAME in0_V, TDATA_NUM_BYTES 3, TDEST_WIDTH 0, TID_WIDTH 0, TUSER_WIDTH 0, HAS_TREADY 1, HAS_TSTRB 0, HAS_TKEEP 0, HAS_TLAST 0, FREQ_HZ 100000000, PHASE 0.0, CLK_DOMAIN finn_design_ap_clk_0, LAYERED_METADATA undef, INSERT_VIP 0" *)
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 in0_V TDATA" *)
input wire [23 : 0] in0_V_TDATA;
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 out_V TREADY" *)
input wire out_V_TREADY;
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 out_V TVALID" *)
output wire out_V_TVALID;
(* X_INTERFACE_PARAMETER = "XIL_INTERFACENAME out_V, TDATA_NUM_BYTES 3, TDEST_WIDTH 0, TID_WIDTH 0, TUSER_WIDTH 0, HAS_TREADY 1, HAS_TSTRB 0, HAS_TKEEP 0, HAS_TLAST 0, FREQ_HZ 100000000, PHASE 0.0, CLK_DOMAIN finn_design_ap_clk_0, LAYERED_METADATA undef, INSERT_VIP 0" *)
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 out_V TDATA" *)
output wire [23 : 0] out_V_TDATA;

  StreamingFIFO_rtl_14 inst (
    .ap_clk(ap_clk),
    .ap_rst_n(ap_rst_n),
    .count(count),
    .maxcount(maxcount),
    .in0_V_TREADY(in0_V_TREADY),
    .in0_V_TVALID(in0_V_TVALID),
    .in0_V_TDATA(in0_V_TDATA),
    .out_V_TREADY(out_V_TREADY),
    .out_V_TVALID(out_V_TVALID),
    .out_V_TDATA(out_V_TDATA)
  );
endmodule
//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/vivado_stitch_proj_w5fn6zuu/finn_vivado_stitch_proj.gen/sources_1/bd/finn_design/ipshared/18e4/hdl/verilog/MVAU_hls_0_Matrix_Vector_Activate_Stream_Batch_p_ZL7threshs_8_ROM_AUTO_1R.v


// ==============================================================
// Vitis HLS - High-Level Synthesis from C, C++ and OpenCL v2022.2 (64-bit)
// Version: 2022.2
// Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.
// ==============================================================
`timescale 1 ns / 1 ps
module MVAU_hls_0_Matrix_Vector_Activate_Stream_Batch_p_ZL7threshs_8_ROM_AUTO_1R (
    address0, ce0, q0, 
    reset, clk);

parameter DataWidth = 13;
parameter AddressWidth = 4;
parameter AddressRange = 16;
 
input[AddressWidth-1:0] address0;
input ce0;
output reg[DataWidth-1:0] q0;

input reset;
input clk;

 
reg [DataWidth-1:0] rom0[0:AddressRange-1];


initial begin
     
    $readmemh("/home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/code_gen_ipgen_MVAU_hls_0_z2r2fzak/project_MVAU_hls_0/sol1/impl/ip/hdl/verilog/MVAU_hls_0_Matrix_Vector_Activate_Stream_Batch_p_ZL7threshs_8_ROM_AUTO_1R.dat", rom0);
end

  
always @(posedge clk) 
begin 
    if (ce0) 
    begin
        q0 <= rom0[address0];
    end
end


endmodule

//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/vivado_stitch_proj_w5fn6zuu/finn_vivado_stitch_proj.gen/sources_1/bd/finn_design/ip/finn_design_MVAU_hls_1_wstrm_0/synth/finn_design_MVAU_hls_1_wstrm_0.v


// (c) Copyright 1995-2026 Xilinx, Inc. All rights reserved.
// 
// This file contains confidential and proprietary information
// of Xilinx, Inc. and is protected under U.S. and
// international copyright and other intellectual property
// laws.
// 
// DISCLAIMER
// This disclaimer is not a license and does not grant any
// rights to the materials distributed herewith. Except as
// otherwise provided in a valid license issued to you by
// Xilinx, and to the maximum extent permitted by applicable
// law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
// WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
// AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
// BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
// INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
// (2) Xilinx shall not be liable (whether in contract or tort,
// including negligence, or under any other theory of
// liability) for any loss or damage of any kind or nature
// related to, arising under or in connection with these
// materials, including for any direct, or any indirect,
// special, incidental, or consequential loss or damage
// (including loss of data, profits, goodwill, or any type of
// loss or damage suffered as a result of any action brought
// by a third party) even if such damage or loss was
// reasonably foreseeable or Xilinx had been advised of the
// possibility of the same.
// 
// CRITICAL APPLICATIONS
// Xilinx products are not designed or intended to be fail-
// safe, or for use in any application requiring fail-safe
// performance, such as life-support or safety devices or
// systems, Class III medical devices, nuclear facilities,
// applications related to the deployment of airbags, or any
// other applications that could lead to death, personal
// injury, or severe property or environmental damage
// (individually and collectively, "Critical
// Applications"). Customer assumes the sole risk and
// liability of any use of Xilinx products in Critical
// Applications, subject only to applicable laws and
// regulations governing limitations on product liability.
// 
// THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
// PART OF THIS FILE AT ALL TIMES.
// 
// DO NOT MODIFY THIS FILE.


// IP VLNV: amd.com:finn:memstream:1.0
// IP Revision: 5

(* X_CORE_INFO = "memstream_axi_wrapper,Vivado 2022.2" *)
(* CHECK_LICENSE_TYPE = "finn_design_MVAU_hls_1_wstrm_0,memstream_axi_wrapper,{}" *)
(* IP_DEFINITION_SOURCE = "package_project" *)
(* DowngradeIPIdentifiedWarnings = "yes" *)
module finn_design_MVAU_hls_1_wstrm_0 (
  ap_clk,
  ap_rst_n,
  awready,
  awvalid,
  awprot,
  awaddr,
  wready,
  wvalid,
  wdata,
  wstrb,
  bready,
  bvalid,
  bresp,
  arready,
  arvalid,
  arprot,
  araddr,
  rready,
  rvalid,
  rresp,
  rdata,
  m_axis_0_tready,
  m_axis_0_tvalid,
  m_axis_0_tdata
);

(* X_INTERFACE_PARAMETER = "XIL_INTERFACENAME ap_clk, ASSOCIATED_RESET ap_rst_n, ASSOCIATED_BUSIF m_axis_0:s_axilite, FREQ_TOLERANCE_HZ -1, FREQ_HZ 100000000, PHASE 0.0, CLK_DOMAIN finn_design_ap_clk_0, INSERT_VIP 0" *)
(* X_INTERFACE_INFO = "xilinx.com:signal:clock:1.0 ap_clk CLK" *)
input wire ap_clk;
(* X_INTERFACE_PARAMETER = "XIL_INTERFACENAME ap_rst_n, POLARITY ACTIVE_LOW, INSERT_VIP 0" *)
(* X_INTERFACE_INFO = "xilinx.com:signal:reset:1.0 ap_rst_n RST" *)
input wire ap_rst_n;
(* X_INTERFACE_INFO = "xilinx.com:interface:aximm:1.0 s_axilite AWREADY" *)
output wire awready;
(* X_INTERFACE_INFO = "xilinx.com:interface:aximm:1.0 s_axilite AWVALID" *)
input wire awvalid;
(* X_INTERFACE_INFO = "xilinx.com:interface:aximm:1.0 s_axilite AWPROT" *)
input wire [2 : 0] awprot;
(* X_INTERFACE_INFO = "xilinx.com:interface:aximm:1.0 s_axilite AWADDR" *)
input wire [14 : 0] awaddr;
(* X_INTERFACE_INFO = "xilinx.com:interface:aximm:1.0 s_axilite WREADY" *)
output wire wready;
(* X_INTERFACE_INFO = "xilinx.com:interface:aximm:1.0 s_axilite WVALID" *)
input wire wvalid;
(* X_INTERFACE_INFO = "xilinx.com:interface:aximm:1.0 s_axilite WDATA" *)
input wire [31 : 0] wdata;
(* X_INTERFACE_INFO = "xilinx.com:interface:aximm:1.0 s_axilite WSTRB" *)
input wire [3 : 0] wstrb;
(* X_INTERFACE_INFO = "xilinx.com:interface:aximm:1.0 s_axilite BREADY" *)
input wire bready;
(* X_INTERFACE_INFO = "xilinx.com:interface:aximm:1.0 s_axilite BVALID" *)
output wire bvalid;
(* X_INTERFACE_INFO = "xilinx.com:interface:aximm:1.0 s_axilite BRESP" *)
output wire [1 : 0] bresp;
(* X_INTERFACE_INFO = "xilinx.com:interface:aximm:1.0 s_axilite ARREADY" *)
output wire arready;
(* X_INTERFACE_INFO = "xilinx.com:interface:aximm:1.0 s_axilite ARVALID" *)
input wire arvalid;
(* X_INTERFACE_INFO = "xilinx.com:interface:aximm:1.0 s_axilite ARPROT" *)
input wire [2 : 0] arprot;
(* X_INTERFACE_INFO = "xilinx.com:interface:aximm:1.0 s_axilite ARADDR" *)
input wire [14 : 0] araddr;
(* X_INTERFACE_INFO = "xilinx.com:interface:aximm:1.0 s_axilite RREADY" *)
input wire rready;
(* X_INTERFACE_INFO = "xilinx.com:interface:aximm:1.0 s_axilite RVALID" *)
output wire rvalid;
(* X_INTERFACE_INFO = "xilinx.com:interface:aximm:1.0 s_axilite RRESP" *)
output wire [1 : 0] rresp;
(* X_INTERFACE_PARAMETER = "XIL_INTERFACENAME s_axilite, DATA_WIDTH 32, PROTOCOL AXI4LITE, FREQ_HZ 100000000, ID_WIDTH 0, ADDR_WIDTH 15, AWUSER_WIDTH 0, ARUSER_WIDTH 0, WUSER_WIDTH 0, RUSER_WIDTH 0, BUSER_WIDTH 0, READ_WRITE_MODE READ_WRITE, HAS_BURST 0, HAS_LOCK 0, HAS_PROT 1, HAS_CACHE 0, HAS_QOS 0, HAS_REGION 0, HAS_WSTRB 1, HAS_BRESP 1, HAS_RRESP 1, SUPPORTS_NARROW_BURST 0, NUM_READ_OUTSTANDING 1, NUM_WRITE_OUTSTANDING 1, MAX_BURST_LENGTH 1, PHASE 0.0, CLK_DOMAIN finn_design_ap_clk_0, NUM_READ_THREADS 1, NUM_WRITE_THRE\
ADS 1, RUSER_BITS_PER_BYTE 0, WUSER_BITS_PER_BYTE 0, INSERT_VIP 0" *)
(* X_INTERFACE_INFO = "xilinx.com:interface:aximm:1.0 s_axilite RDATA" *)
output wire [31 : 0] rdata;
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 m_axis_0 TREADY" *)
input wire m_axis_0_tready;
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 m_axis_0 TVALID" *)
output wire m_axis_0_tvalid;
(* X_INTERFACE_PARAMETER = "XIL_INTERFACENAME m_axis_0, TDATA_NUM_BYTES 1, TDEST_WIDTH 0, TID_WIDTH 0, TUSER_WIDTH 0, HAS_TREADY 1, HAS_TSTRB 0, HAS_TKEEP 0, HAS_TLAST 0, FREQ_HZ 100000000, PHASE 0.0, CLK_DOMAIN finn_design_ap_clk_0, LAYERED_METADATA undef, INSERT_VIP 0" *)
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 m_axis_0 TDATA" *)
output wire [7 : 0] m_axis_0_tdata;

  memstream_axi_wrapper #(
    .DEPTH(4608),
    .WIDTH(8),
    .INIT_FILE("/home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/code_gen_ipgen_MVAU_hls_1__774deg0/memblock.dat"),
    .RAM_STYLE("auto"),
    .AXILITE_ADDR_WIDTH(15)
  ) inst (
    .ap_clk(ap_clk),
    .ap_rst_n(ap_rst_n),
    .awready(awready),
    .awvalid(awvalid),
    .awprot(awprot),
    .awaddr(awaddr),
    .wready(wready),
    .wvalid(wvalid),
    .wdata(wdata),
    .wstrb(wstrb),
    .bready(bready),
    .bvalid(bvalid),
    .bresp(bresp),
    .arready(arready),
    .arvalid(arvalid),
    .arprot(arprot),
    .araddr(araddr),
    .rready(rready),
    .rvalid(rvalid),
    .rresp(rresp),
    .rdata(rdata),
    .m_axis_0_tready(m_axis_0_tready),
    .m_axis_0_tvalid(m_axis_0_tvalid),
    .m_axis_0_tdata(m_axis_0_tdata)
  );
endmodule
//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/vivado_stitch_proj_w5fn6zuu/finn_vivado_stitch_proj.gen/sources_1/bd/finn_design/ip/finn_design_StreamingDataWidthConverter_rtl_3_0/synth/finn_design_StreamingDataWidthConverter_rtl_3_0.v


// (c) Copyright 1995-2026 Xilinx, Inc. All rights reserved.
// 
// This file contains confidential and proprietary information
// of Xilinx, Inc. and is protected under U.S. and
// international copyright and other intellectual property
// laws.
// 
// DISCLAIMER
// This disclaimer is not a license and does not grant any
// rights to the materials distributed herewith. Except as
// otherwise provided in a valid license issued to you by
// Xilinx, and to the maximum extent permitted by applicable
// law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
// WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
// AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
// BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
// INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
// (2) Xilinx shall not be liable (whether in contract or tort,
// including negligence, or under any other theory of
// liability) for any loss or damage of any kind or nature
// related to, arising under or in connection with these
// materials, including for any direct, or any indirect,
// special, incidental, or consequential loss or damage
// (including loss of data, profits, goodwill, or any type of
// loss or damage suffered as a result of any action brought
// by a third party) even if such damage or loss was
// reasonably foreseeable or Xilinx had been advised of the
// possibility of the same.
// 
// CRITICAL APPLICATIONS
// Xilinx products are not designed or intended to be fail-
// safe, or for use in any application requiring fail-safe
// performance, such as life-support or safety devices or
// systems, Class III medical devices, nuclear facilities,
// applications related to the deployment of airbags, or any
// other applications that could lead to death, personal
// injury, or severe property or environmental damage
// (individually and collectively, "Critical
// Applications"). Customer assumes the sole risk and
// liability of any use of Xilinx products in Critical
// Applications, subject only to applicable laws and
// regulations governing limitations on product liability.
// 
// THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
// PART OF THIS FILE AT ALL TIMES.
// 
// DO NOT MODIFY THIS FILE.


// IP VLNV: xilinx.com:module_ref:StreamingDataWidthConverter_rtl_3:1.0
// IP Revision: 1

(* X_CORE_INFO = "StreamingDataWidthConverter_rtl_3,Vivado 2022.2" *)
(* CHECK_LICENSE_TYPE = "finn_design_StreamingDataWidthConverter_rtl_3_0,StreamingDataWidthConverter_rtl_3,{}" *)
(* CORE_GENERATION_INFO = "finn_design_StreamingDataWidthConverter_rtl_3_0,StreamingDataWidthConverter_rtl_3,{x_ipProduct=Vivado 2022.2,x_ipVendor=xilinx.com,x_ipLibrary=module_ref,x_ipName=StreamingDataWidthConverter_rtl_3,x_ipVersion=1.0,x_ipCoreRevision=1,x_ipLanguage=VERILOG,x_ipSimLanguage=MIXED,IBITS=4,OBITS=128,AXI_IBITS=8,AXI_OBITS=128}" *)
(* IP_DEFINITION_SOURCE = "module_ref" *)
(* DowngradeIPIdentifiedWarnings = "yes" *)
module finn_design_StreamingDataWidthConverter_rtl_3_0 (
  ap_clk,
  ap_rst_n,
  in0_V_TREADY,
  in0_V_TVALID,
  in0_V_TDATA,
  out_V_TREADY,
  out_V_TVALID,
  out_V_TDATA
);

(* X_INTERFACE_PARAMETER = "XIL_INTERFACENAME ap_clk, ASSOCIATED_RESET ap_rst_n, ASSOCIATED_BUSIF in0_V:out_V, FREQ_HZ 100000000, FREQ_TOLERANCE_HZ 0, PHASE 0.0, CLK_DOMAIN finn_design_ap_clk_0, INSERT_VIP 0" *)
(* X_INTERFACE_INFO = "xilinx.com:signal:clock:1.0 ap_clk CLK" *)
input wire ap_clk;
(* X_INTERFACE_PARAMETER = "XIL_INTERFACENAME ap_rst_n, POLARITY ACTIVE_LOW, INSERT_VIP 0" *)
(* X_INTERFACE_INFO = "xilinx.com:signal:reset:1.0 ap_rst_n RST" *)
input wire ap_rst_n;
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 in0_V TREADY" *)
output wire in0_V_TREADY;
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 in0_V TVALID" *)
input wire in0_V_TVALID;
(* X_INTERFACE_PARAMETER = "XIL_INTERFACENAME in0_V, TDATA_NUM_BYTES 1, TDEST_WIDTH 0, TID_WIDTH 0, TUSER_WIDTH 0, HAS_TREADY 1, HAS_TSTRB 0, HAS_TKEEP 0, HAS_TLAST 0, FREQ_HZ 100000000, PHASE 0.0, CLK_DOMAIN finn_design_ap_clk_0, LAYERED_METADATA undef, INSERT_VIP 0" *)
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 in0_V TDATA" *)
input wire [7 : 0] in0_V_TDATA;
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 out_V TREADY" *)
input wire out_V_TREADY;
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 out_V TVALID" *)
output wire out_V_TVALID;
(* X_INTERFACE_PARAMETER = "XIL_INTERFACENAME out_V, TDATA_NUM_BYTES 16, TDEST_WIDTH 0, TID_WIDTH 0, TUSER_WIDTH 0, HAS_TREADY 1, HAS_TSTRB 0, HAS_TKEEP 0, HAS_TLAST 0, FREQ_HZ 100000000, PHASE 0.0, CLK_DOMAIN finn_design_ap_clk_0, LAYERED_METADATA undef, INSERT_VIP 0" *)
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 out_V TDATA" *)
output wire [127 : 0] out_V_TDATA;

  StreamingDataWidthConverter_rtl_3 #(
    .IBITS(4),
    .OBITS(128),
    .AXI_IBITS(8),
    .AXI_OBITS(128)
  ) inst (
    .ap_clk(ap_clk),
    .ap_rst_n(ap_rst_n),
    .in0_V_TREADY(in0_V_TREADY),
    .in0_V_TVALID(in0_V_TVALID),
    .in0_V_TDATA(in0_V_TDATA),
    .out_V_TREADY(out_V_TREADY),
    .out_V_TVALID(out_V_TVALID),
    .out_V_TDATA(out_V_TDATA)
  );
endmodule
//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/vivado_stitch_proj_w5fn6zuu/finn_vivado_stitch_proj.gen/sources_1/bd/finn_design/ipshared/6bf6/hdl/verilog/StreamingMaxPool_hls_0_regslice_both.v


// ==============================================================
// Vitis HLS - High-Level Synthesis from C, C++ and OpenCL v2022.2 (64-bit)
// Tool Version Limit: 2019.12
// Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.
// ==============================================================

`timescale 1ns/1ps

module StreamingMaxPool_hls_0_regslice_both
#(parameter 
    DataWidth=32
)(
    input ap_clk ,
    input ap_rst,

    input [DataWidth-1:0] data_in , 
    input vld_in , 
    output ack_in ,
    output [DataWidth-1:0] data_out, 
    output vld_out,
    input ack_out,
    output apdone_blk
);
 

reg   [1:0] B_V_data_1_state;
wire   [DataWidth-1:0] B_V_data_1_data_in;
reg   [DataWidth-1:0] B_V_data_1_data_out;
wire    B_V_data_1_vld_reg;
wire    B_V_data_1_vld_in;
wire    B_V_data_1_vld_out;
reg   [DataWidth-1:0] B_V_data_1_payload_A;
reg   [DataWidth-1:0] B_V_data_1_payload_B;
reg    B_V_data_1_sel_rd;
reg    B_V_data_1_sel_wr;
wire    B_V_data_1_sel;
wire    B_V_data_1_load_A;
wire    B_V_data_1_load_B;
wire    B_V_data_1_state_cmp_full;
wire    B_V_data_1_ack_in;
wire    B_V_data_1_ack_out;

always @ (posedge ap_clk) begin
    if (ap_rst == 1'b1) begin
        B_V_data_1_sel_rd <= 1'b0;
    end else begin
        if (((1'b1 == B_V_data_1_vld_out) & (1'b1 == B_V_data_1_ack_out))) begin
            B_V_data_1_sel_rd <= ~B_V_data_1_sel_rd;
        end else begin
            B_V_data_1_sel_rd <= B_V_data_1_sel_rd;
        end
    end
end

always @ (posedge ap_clk) begin
    if (ap_rst == 1'b1) begin
        B_V_data_1_sel_wr <= 1'b0;
    end else begin
        if (((1'b1 == B_V_data_1_vld_in) & (1'b1 == B_V_data_1_ack_in))) begin
            B_V_data_1_sel_wr <= ~B_V_data_1_sel_wr;
        end else begin
            B_V_data_1_sel_wr <= B_V_data_1_sel_wr;
        end
    end
end

always @ (posedge ap_clk) begin
    if (ap_rst == 1'b1) begin
        B_V_data_1_state <= 2'd0;
    end else begin
        if ((((2'd3 == B_V_data_1_state) & (1'b0 == B_V_data_1_vld_in) & (1'b1 == B_V_data_1_ack_out)) | ((2'd2 == B_V_data_1_state) & (1'b0 == B_V_data_1_vld_in)))) begin
            B_V_data_1_state <= 2'd2;
        end else if ((((2'd1 == B_V_data_1_state) & (1'b0 == B_V_data_1_ack_out)) | ((2'd3 == B_V_data_1_state) & (1'b0 == B_V_data_1_ack_out) & (1'b1 == B_V_data_1_vld_in)))) begin
            B_V_data_1_state <= 2'd1;
        end else if ((((2'd1 == B_V_data_1_state) & (1'b1 == B_V_data_1_ack_out)) | (~((1'b0 == B_V_data_1_ack_out) & (1'b1 == B_V_data_1_vld_in)) & ~((1'b0 == B_V_data_1_vld_in) & (1'b1 == B_V_data_1_ack_out)) & (2'd3 == B_V_data_1_state)) | ((2'd2 == B_V_data_1_state) & (1'b1 == B_V_data_1_vld_in)))) begin
            B_V_data_1_state <= 2'd3;
        end else begin
            B_V_data_1_state <= 2'd2;
        end
    end
end

always @ (posedge ap_clk) begin
    if ((1'b1 == B_V_data_1_load_A)) begin
        B_V_data_1_payload_A <= B_V_data_1_data_in;
    end
end

always @ (posedge ap_clk) begin
    if ((1'b1 == B_V_data_1_load_B)) begin
        B_V_data_1_payload_B <= B_V_data_1_data_in;
    end
end

always @ (*) begin
    if ((1'b1 == B_V_data_1_sel)) begin
        B_V_data_1_data_out = B_V_data_1_payload_B;
    end else begin
        B_V_data_1_data_out = B_V_data_1_payload_A;
    end
end

assign B_V_data_1_ack_in = B_V_data_1_state[1'd1];
assign B_V_data_1_load_A = (~B_V_data_1_sel_wr & B_V_data_1_state_cmp_full);
assign B_V_data_1_load_B = (B_V_data_1_state_cmp_full & B_V_data_1_sel_wr);
assign B_V_data_1_sel = B_V_data_1_sel_rd;
assign B_V_data_1_state_cmp_full = ((B_V_data_1_state != 2'd1) ? 1'b1 : 1'b0);
assign B_V_data_1_vld_out = B_V_data_1_state[1'd0];

assign ack_in = B_V_data_1_ack_in;
assign B_V_data_1_data_in = data_in;
assign B_V_data_1_vld_in = vld_in;

assign vld_out = B_V_data_1_vld_out;
assign data_out = B_V_data_1_data_out;
assign B_V_data_1_ack_out = ack_out;

assign apdone_blk = ((B_V_data_1_state == 2'd3 && ack_out == 1'b0) | (B_V_data_1_state == 2'd1));

endmodule // both

module StreamingMaxPool_hls_0_regslice_both_w1
#(parameter 
    DataWidth=1
)(
    input ap_clk ,
    input ap_rst,

    input data_in , 
    input vld_in , 
    output ack_in ,
    output data_out, 
    output vld_out,
    input ack_out,
    output apdone_blk
);

reg     [1:0] B_V_data_1_state;
wire    B_V_data_1_data_in;
reg     B_V_data_1_data_out;
wire    B_V_data_1_vld_reg;
wire    B_V_data_1_vld_in;
wire    B_V_data_1_vld_out;
reg     B_V_data_1_payload_A;
reg     B_V_data_1_payload_B;
reg     B_V_data_1_sel_rd;
reg     B_V_data_1_sel_wr;
wire    B_V_data_1_sel;
wire    B_V_data_1_load_A;
wire    B_V_data_1_load_B;
wire    B_V_data_1_state_cmp_full;
wire    B_V_data_1_ack_in;
wire    B_V_data_1_ack_out;

always @ (posedge ap_clk) begin
    if (ap_rst == 1'b1) begin
        B_V_data_1_sel_rd <= 1'b0;
    end else begin
        if (((1'b1 == B_V_data_1_vld_out) & (1'b1 == B_V_data_1_ack_out))) begin
            B_V_data_1_sel_rd <= ~B_V_data_1_sel_rd;
        end else begin
            B_V_data_1_sel_rd <= B_V_data_1_sel_rd;
        end
    end
end

always @ (posedge ap_clk) begin
    if (ap_rst == 1'b1) begin
        B_V_data_1_sel_wr <= 1'b0;
    end else begin
        if (((1'b1 == B_V_data_1_vld_in) & (1'b1 == B_V_data_1_ack_in))) begin
            B_V_data_1_sel_wr <= ~B_V_data_1_sel_wr;
        end else begin
            B_V_data_1_sel_wr <= B_V_data_1_sel_wr;
        end
    end
end

always @ (posedge ap_clk) begin
    if (ap_rst == 1'b1) begin
        B_V_data_1_state <= 2'd0;
    end else begin
        if ((((2'd3 == B_V_data_1_state) & (1'b0 == B_V_data_1_vld_in) & (1'b1 == B_V_data_1_ack_out)) | ((2'd2 == B_V_data_1_state) & (1'b0 == B_V_data_1_vld_in)))) begin
            B_V_data_1_state <= 2'd2;
        end else if ((((2'd1 == B_V_data_1_state) & (1'b0 == B_V_data_1_ack_out)) | ((2'd3 == B_V_data_1_state) & (1'b0 == B_V_data_1_ack_out) & (1'b1 == B_V_data_1_vld_in)))) begin
            B_V_data_1_state <= 2'd1;
        end else if ((((2'd1 == B_V_data_1_state) & (1'b1 == B_V_data_1_ack_out)) | (~((1'b0 == B_V_data_1_ack_out) & (1'b1 == B_V_data_1_vld_in)) & ~((1'b0 == B_V_data_1_vld_in) & (1'b1 == B_V_data_1_ack_out)) & (2'd3 == B_V_data_1_state)) | ((2'd2 == B_V_data_1_state) & (1'b1 == B_V_data_1_vld_in)))) begin
            B_V_data_1_state <= 2'd3;
        end else begin
            B_V_data_1_state <= 2'd2;
        end
    end
end

always @ (posedge ap_clk) begin
    if ((1'b1 == B_V_data_1_load_A)) begin
        B_V_data_1_payload_A <= B_V_data_1_data_in;
    end
end

always @ (posedge ap_clk) begin
    if ((1'b1 == B_V_data_1_load_B)) begin
        B_V_data_1_payload_B <= B_V_data_1_data_in;
    end
end

always @ (*) begin
    if ((1'b1 == B_V_data_1_sel)) begin
        B_V_data_1_data_out = B_V_data_1_payload_B;
    end else begin
        B_V_data_1_data_out = B_V_data_1_payload_A;
    end
end

assign B_V_data_1_ack_in = B_V_data_1_state[1'd1];
assign B_V_data_1_load_A = (~B_V_data_1_sel_wr & B_V_data_1_state_cmp_full);
assign B_V_data_1_load_B = (B_V_data_1_state_cmp_full & B_V_data_1_sel_wr);
assign B_V_data_1_sel = B_V_data_1_sel_rd;
assign B_V_data_1_state_cmp_full = ((B_V_data_1_state != 2'd1) ? 1'b1 : 1'b0);
assign B_V_data_1_vld_out = B_V_data_1_state[1'd0];

assign ack_in = B_V_data_1_ack_in;
assign B_V_data_1_data_in = data_in;
assign B_V_data_1_vld_in = vld_in;

assign vld_out = B_V_data_1_vld_out;
assign data_out = B_V_data_1_data_out;
assign B_V_data_1_ack_out = ack_out;

assign apdone_blk = ((B_V_data_1_state == 2'd3 && ack_out == 1'b0) | (B_V_data_1_state == 2'd1));

endmodule // both


//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/vivado_stitch_proj_w5fn6zuu/finn_vivado_stitch_proj.gen/sources_1/bd/finn_design/ipshared/4d6a/hdl/verilog/StreamingMaxPool_hls_1_hls_deadlock_idx0_monitor.v


`timescale 1 ns / 1 ps

module StreamingMaxPool_hls_1_hls_deadlock_idx0_monitor ( // for module StreamingMaxPool_hls_1_StreamingMaxPool_hls_1_inst
    input wire clock,
    input wire reset,
    input wire [1:0] axis_block_sigs,
    input wire [3:0] inst_idle_sigs,
    input wire [0:0] inst_block_sigs,
    output wire block
);

// signal declare
reg monitor_find_block;
wire idx1_block;
wire sub_parallel_block;
wire all_sub_parallel_has_block;
wire all_sub_single_has_block;
wire cur_axis_has_block;
wire seq_is_axis_block;

assign block = monitor_find_block;
assign all_sub_parallel_has_block = 1'b0;
assign all_sub_single_has_block = 1'b0 | (idx1_block & (axis_block_sigs[1] | axis_block_sigs[0]));
assign cur_axis_has_block = 1'b0;
assign seq_is_axis_block = all_sub_parallel_has_block | all_sub_single_has_block | cur_axis_has_block;

always @(posedge clock) begin
    if (reset == 1'b1)
        monitor_find_block <= 1'b0;
    else if (seq_is_axis_block == 1'b1)
        monitor_find_block <= 1'b1;
    else
        monitor_find_block <= 1'b0;
end


// instant sub module
 StreamingMaxPool_hls_1_hls_deadlock_idx1_monitor StreamingMaxPool_hls_1_hls_deadlock_idx1_monitor_U (
    .clock(clock),
    .reset(reset),
    .axis_block_sigs(axis_block_sigs),
    .inst_idle_sigs(inst_idle_sigs),
    .inst_block_sigs(inst_block_sigs),
    .block(idx1_block)
);

endmodule
//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/code_gen_ipgen_FMPadding_rtl_0_e702v3yh/fmpadding_axi.sv


/******************************************************************************
 * Copyright (C) 2022, Advanced Micro Devices, Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *  1. Redistributions of source code must retain the above copyright notice,
 *     this list of conditions and the following disclaimer.
 *
 *  2. Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *
 *  3. Neither the name of the copyright holder nor the names of its
 *     contributors may be used to endorse or promote products derived from
 *     this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION). HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * @brief	Feature map padding.
 * @author	Thomas B. Preuer <tpreusse@amd.com>
 *****************************************************************************/

module fmpadding_axi #(
	int unsigned  XCOUNTER_BITS,
	int unsigned  YCOUNTER_BITS,
	int unsigned  NUM_CHANNELS,
	int unsigned  SIMD,
	int unsigned  ELEM_BITS,
	int unsigned  INIT_XON,
	int unsigned  INIT_XOFF,
	int unsigned  INIT_XEND,
	int unsigned  INIT_YON,
	int unsigned  INIT_YOFF,
	int unsigned  INIT_YEND,

	localparam int unsigned  STREAM_BITS = 8*(1 + (SIMD*ELEM_BITS-1)/8)
)(
	//- Global Control ------------------
	input	logic  ap_clk,
	input	logic  ap_rst_n,

	//- AXI Lite ------------------------
	// Writing
	input	       s_axilite_AWVALID,
	output	       s_axilite_AWREADY,
	input	[4:0]  s_axilite_AWADDR,

	input	        s_axilite_WVALID,
	output	        s_axilite_WREADY,
	input	[31:0]  s_axilite_WDATA,
	input	[ 3:0]  s_axilite_WSTRB,

	output	       s_axilite_BVALID,
	input	       s_axilite_BREADY,
	output	[1:0]  s_axilite_BRESP,

	// Reading
	input	       s_axilite_ARVALID,
	output	       s_axilite_ARREADY,
	input	[4:0]  s_axilite_ARADDR,

	output	        s_axilite_RVALID,
	input	        s_axilite_RREADY,
	output	[31:0]  s_axilite_RDATA,
	output	[ 1:0]  s_axilite_RRESP,

	//- AXI Stream - Input --------------
	output	logic  s_axis_tready,
	input	logic  s_axis_tvalid,
	input	logic [STREAM_BITS-1:0]  s_axis_tdata,

	//- AXI Stream - Output -------------
	input	logic  m_axis_tready,
	output	logic  m_axis_tvalid,
	output	logic [STREAM_BITS-1:0]  m_axis_tdata
);

	// AXI-Lite Adapter
	uwire         we;
	uwire [ 4:0]  wa;
	uwire [31:0]  wd;
	axi2we #(.ADDR_BITS(5)) axilight_adapter (
		.ap_clk, .ap_rst_n,

		.s_axilite_AWVALID, .s_axilite_AWREADY, .s_axilite_AWADDR,
		.s_axilite_WVALID, .s_axilite_WREADY, .s_axilite_WDATA, .s_axilite_WSTRB,
		.s_axilite_BVALID, .s_axilite_BREADY, .s_axilite_BRESP,

		.s_axilite_ARVALID, .s_axilite_ARREADY, .s_axilite_ARADDR,
		.s_axilite_RVALID, .s_axilite_RREADY, .s_axilite_RDATA, .s_axilite_RRESP,

		.we, .wa, .wd
	);

	// Actual Padding
	fmpadding #(
		.XCOUNTER_BITS(XCOUNTER_BITS), .YCOUNTER_BITS(YCOUNTER_BITS),
		.NUM_CHANNELS(NUM_CHANNELS), .SIMD(SIMD),
		.INIT_XON(INIT_XON), .INIT_XOFF(INIT_XOFF), .INIT_XEND(INIT_XEND),
		.INIT_YON(INIT_YON), .INIT_YOFF(INIT_YOFF), .INIT_YEND(INIT_YEND),
		.ELEM_BITS(ELEM_BITS)
	) padding (
		.ap_clk, .ap_rst_n,

		.we, .wa, .wd,

		.s_axis_tready, .s_axis_tvalid, .s_axis_tdata,
		.m_axis_tready, .m_axis_tvalid, .m_axis_tdata
	);

endmodule : fmpadding_axi
//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/code_gen_ipgen_StreamingFIFO_rtl_7_etz5w7xz/StreamingFIFO_rtl_7.v


/******************************************************************************
 * Copyright (C) 2024, Advanced Micro Devices, Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *  1. Redistributions of source code must retain the above copyright notice,
 *     this list of conditions and the following disclaimer.
 *
 *  2. Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *
 *  3. Neither the name of the copyright holder nor the names of its
 *     contributors may be used to endorse or promote products derived from
 *     this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION). HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *****************************************************************************/

module StreamingFIFO_rtl_7(
//- Global Control ------------------
(* X_INTERFACE_PARAMETER = "ASSOCIATED_BUSIF in0_V:out_V, ASSOCIATED_RESET = ap_rst_n" *)
(* X_INTERFACE_INFO = "xilinx.com:signal:clock:1.0 ap_clk CLK" *)
input   ap_clk,
(* X_INTERFACE_PARAMETER = "POLARITY ACTIVE_LOW" *)
input   ap_rst_n,

output [8:0] count,
output [8:0] maxcount,

//- AXI Stream - Input --------------
output   in0_V_TREADY,
input   in0_V_TVALID,
input  [63:0] in0_V_TDATA,

//- AXI Stream - Output --------------
input   out_V_TREADY,
output   out_V_TVALID,
output  [63:0] out_V_TDATA
);

Q_srl #(
.depth(256),
.width(64)
)
impl
(
 .clock(ap_clk),
 .reset(!ap_rst_n),
 .count(count),
 .maxcount(maxcount),
 .i_d(in0_V_TDATA),
 .i_v(in0_V_TVALID),
 .i_r(in0_V_TREADY),
 .o_d(out_V_TDATA),
 .o_v(out_V_TVALID),
 .o_r(out_V_TREADY)
);

endmodule
//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/code_gen_ipgen_StreamingDataWidthConverter_rtl_0_dwunb9n0/dwc_axi.sv


/******************************************************************************
 * Copyright (C) 2023, Advanced Micro Devices, Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *  1. Redistributions of source code must retain the above copyright notice,
 *     this list of conditions and the following disclaimer.
 *
 *  2. Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *
 *  3. Neither the name of the copyright holder nor the names of its
 *     contributors may be used to endorse or promote products derived from
 *     this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION). HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * @brief	AXI Stream Adapter for Data Width Converter.
 * @author	Thomas B. Preuer <tpreusse@amd.com>
 *****************************************************************************/
module dwc_axi #(
	int unsigned  IBITS,
	int unsigned  OBITS,

	localparam int unsigned  AXI_IBITS = (IBITS+7)/8 * 8,
	localparam int unsigned  AXI_OBITS = (OBITS+7)/8 * 8
)(
	//- Global Control ------------------
	input	logic  ap_clk,
	input	logic  ap_rst_n,

	//- AXI Stream - Input --------------
	output	logic  s_axis_tready,
	input	logic  s_axis_tvalid,
	input	logic [AXI_IBITS-1:0]  s_axis_tdata,

	//- AXI Stream - Output -------------
	input	logic  m_axis_tready,
	output	logic  m_axis_tvalid,
	output	logic [AXI_OBITS-1:0]  m_axis_tdata
);

	dwc #(.IBITS(IBITS), .OBITS(OBITS)) core (
		.clk(ap_clk), .rst(!ap_rst_n),
		.irdy(s_axis_tready), .ivld(s_axis_tvalid), .idat(s_axis_tdata[IBITS-1:0]),
		.ordy(m_axis_tready), .ovld(m_axis_tvalid), .odat(m_axis_tdata[OBITS-1:0])
	);
	if(OBITS < AXI_OBITS) begin
		assign	m_axis_tdata[AXI_OBITS-1:OBITS] = '0;
	end

endmodule : dwc_axi
//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/code_gen_ipgen_ConvolutionInputGenerator_rtl_0_sgzv3feu/swg_common.sv


/******************************************************************************
 * Copyright (C) 2022-2023, Advanced Micro Devices, Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *  1. Redistributions of source code must retain the above copyright notice,
 *     this list of conditions and the following disclaimer.
 *
 *  2. Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *
 *  3. Neither the name of the copyright holder nor the names of its
 *     contributors may be used to endorse or promote products derived from
 *     this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION). HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *****************************************************************************/


// loop controller used for both, "default" and "parallel", implementation styles
module swg_controller
import swg::*; #(
    int unsigned  LOOP_H_ITERATIONS,
    int unsigned  LOOP_W_ITERATIONS,
    int unsigned  LOOP_KH_ITERATIONS,
    int unsigned  LOOP_KW_ITERATIONS,
    int unsigned  LOOP_SIMD_ITERATIONS,

    int unsigned  INCR_BITWIDTH,

    bit IS_DEPTHWISE,

    int HEAD_INCR_SIMD,
    int HEAD_INCR_KW,
    int HEAD_INCR_KH,
    int HEAD_INCR_W,
    int HEAD_INCR_H,
    int TAIL_INCR_W,
    int TAIL_INCR_H,
    int TAIL_INCR_LAST,

    state_e INNERMOST_STATE
)(
    input   logic  clk,
    input   logic  rst_n,

    input   logic  advance,
    output  logic [INCR_BITWIDTH-1:0]  addr_incr,
    output  logic [INCR_BITWIDTH-1:0]  tail_incr
);

    // state and counters
    state_e  State = INNERMOST_STATE;
    state_e  state_next;

    logic signed [$clog2(LOOP_H_ITERATIONS   +2)+1-1:0]  Counter_loop_h    = LOOP_H_ITERATIONS;
    logic signed [$clog2(LOOP_W_ITERATIONS   +2)+1-1:0]  Counter_loop_w    = LOOP_W_ITERATIONS;
    logic signed [$clog2(LOOP_KH_ITERATIONS  +2)+1-1:0]  Counter_loop_kh   = LOOP_KH_ITERATIONS;
    logic signed [$clog2(LOOP_KW_ITERATIONS  +2)+1-1:0]  Counter_loop_kw   = LOOP_KW_ITERATIONS;
    logic signed [$clog2(LOOP_SIMD_ITERATIONS+2)+1-1:0]  Counter_loop_simd = LOOP_SIMD_ITERATIONS;

    // combinational logic for addr_incr generation
    always_comb begin : blkHead
        unique case (State)
            STATE_START     : addr_incr = 0;
            STATE_LOOP_SIMD : addr_incr = HEAD_INCR_SIMD;
            STATE_LOOP_KW   : addr_incr = HEAD_INCR_KW;
            STATE_LOOP_KH   : addr_incr = HEAD_INCR_KH;
            STATE_LOOP_W    : addr_incr = HEAD_INCR_W;
            STATE_LOOP_H    : addr_incr = HEAD_INCR_H;
        endcase
    end

    // combinational logic for tail_incr generation
    uwire  tail_incr_inner_condition = IS_DEPTHWISE? (Counter_loop_kh >= 0) : 0;
    assign tail_incr =
        tail_incr_inner_condition? 1 :
        Counter_loop_w >= 0?       TAIL_INCR_W :
        Counter_loop_h >= 0?       TAIL_INCR_H :
        /* else */                 TAIL_INCR_LAST;

    // combinational next state logic
    always_comb begin : blkState
        state_next = State;
        if(State != INNERMOST_STATE)  state_next = INNERMOST_STATE;
        else begin
            if(Counter_loop_simd < 0) begin
                state_next =
                    (Counter_loop_kw >= 0)? STATE_LOOP_KW :
                    (Counter_loop_kh >= 0)? STATE_LOOP_KH :
                    (Counter_loop_w  >= 0)? STATE_LOOP_W :
                    (Counter_loop_h  >= 0)? STATE_LOOP_H :
                    /* else */              STATE_START;
            end
        end
    end : blkState

    // sequential logic
    always_ff @ (posedge clk) begin
        if(!rst_n) begin
            State <= INNERMOST_STATE;
            Counter_loop_h    <= LOOP_H_ITERATIONS;
            Counter_loop_w    <= LOOP_W_ITERATIONS;
            Counter_loop_kh   <= LOOP_KH_ITERATIONS;
            Counter_loop_kw   <= LOOP_KW_ITERATIONS;
            Counter_loop_simd <= LOOP_SIMD_ITERATIONS;
        end
        else if(advance) begin
            State <= state_next;
            if (State == INNERMOST_STATE) begin
                if(Counter_loop_simd >= 0)  Counter_loop_simd <= Counter_loop_simd-1;
                else begin
                    Counter_loop_simd <= LOOP_SIMD_ITERATIONS;
                    if(Counter_loop_kw >= 0)  Counter_loop_kw <= Counter_loop_kw-1;
                    else begin
                        Counter_loop_kw <= LOOP_KW_ITERATIONS;
                        if(Counter_loop_kh >= 0)  Counter_loop_kh <= Counter_loop_kh-1;
                        else begin
                            Counter_loop_kh <= LOOP_KH_ITERATIONS;
                            if(Counter_loop_w >= 0)  Counter_loop_w <= Counter_loop_w-1;
                            else begin
                                Counter_loop_w <= LOOP_W_ITERATIONS;
                                if(Counter_loop_h >= 0)  Counter_loop_h <= Counter_loop_h-1;
                                else  Counter_loop_h <= LOOP_H_ITERATIONS;
                            end
                        end
                    end
                end
            end
        end
    end

endmodule :  swg_controller

// buffer used in "default" implementation style
module swg_cyclic_buffer_addressable #(
    int unsigned  WIDTH,
    int unsigned  DEPTH,
    parameter RAM_STYLE = "auto"
)(
    input   logic  clk,

    input   logic  write_enable,
    input   logic [$clog2(DEPTH)-1:0] write_addr,
    input   logic [WIDTH-1:0]  data_in,

    input   logic  read_enable,
    input   logic [$clog2(DEPTH)-1:0]  read_addr, // absolute (!) read address of cyclic buffer
    output  logic [WIDTH-1:0]  data_out
);

    (*ram_style=RAM_STYLE*) logic [WIDTH-1:0] Ram[DEPTH];
    logic [WIDTH-1:0]  Out = 'x;
    always_ff @(posedge clk) begin
        if (read_enable)  Out <= Ram[read_addr];
        if (write_enable) Ram[write_addr] <= data_in;
    end
    assign  data_out = Out;

endmodule : swg_cyclic_buffer_addressable

// buffer used in "parallel" implementation style
module swg_reg_buffer
#(
    int unsigned WIDTH = 1,
    int unsigned DEPTH = 1
)
(
    input logic clk,
    input logic shift_enable,
    input logic [WIDTH-1:0] shift_in,
    output logic [WIDTH-1:0] shift_out,
    output logic [WIDTH*DEPTH-1:0] data_out
);

logic [WIDTH-1:0] Data [DEPTH-1:0];

assign shift_out = Data[DEPTH-1];

for (genvar e=0; e<DEPTH; e++)
    assign data_out[e*WIDTH +: WIDTH] = Data[e];

always @ (posedge clk) begin
    if (shift_enable) begin
        if (DEPTH > 1) Data[DEPTH-1:1] <= Data[DEPTH-2:0];
        Data[0] <= shift_in;
    end
end
endmodule : swg_reg_buffer

// buffer used in "parallel" implementation style
module swg_ram_buffer
#(
    int unsigned WIDTH,
    int unsigned DEPTH,
    parameter RAM_STYLE = "auto"
)
(
    input logic clk,
    input logic rst_n,
    input logic shift_enable,
    input logic [WIDTH-1:0] shift_in,
    output logic [WIDTH-1:0] shift_out
);

logic [WIDTH-1:0] Out_reg;
assign shift_out = Out_reg;

logic [$clog2(DEPTH)-1:0] Addr_w = 0;
logic [$clog2(DEPTH)-1:0] Addr_r = 0;

(*ram_style=RAM_STYLE*) logic [WIDTH-1:0] Ram [DEPTH-1:0];

always_ff @(posedge clk) begin
    if (rst_n == 1'b0) begin
        Addr_w <= 0;
        Addr_r <= 1;
    end else begin
        if (shift_enable) begin
            Ram[Addr_w] <= shift_in;
            Out_reg <= Ram[Addr_r];

            if (Addr_w == DEPTH-1)
                Addr_w <= 0;
            else
                Addr_w <= Addr_w + 1;

            if (Addr_r == DEPTH-1)
                Addr_r <= 0;
            else
                Addr_r <= Addr_r + 1;
        end
    end
end
endmodule : swg_ram_buffer
//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/vivado_stitch_proj_w5fn6zuu/finn_vivado_stitch_proj.gen/sources_1/bd/finn_design/ipshared/fb57/hdl/verilog/MVAU_hls_1_Matrix_Vector_Activate_Stream_Batch_p_ZL7threshs_9_ROM_AUTO_1R.v


// ==============================================================
// Vitis HLS - High-Level Synthesis from C, C++ and OpenCL v2022.2 (64-bit)
// Version: 2022.2
// Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.
// ==============================================================
`timescale 1 ns / 1 ps
module MVAU_hls_1_Matrix_Vector_Activate_Stream_Batch_p_ZL7threshs_9_ROM_AUTO_1R (
    address0, ce0, q0, 
    reset, clk);

parameter DataWidth = 10;
parameter AddressWidth = 5;
parameter AddressRange = 32;
 
input[AddressWidth-1:0] address0;
input ce0;
output reg[DataWidth-1:0] q0;

input reset;
input clk;

 
reg [DataWidth-1:0] rom0[0:AddressRange-1];


initial begin
     
    $readmemh("/home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/code_gen_ipgen_MVAU_hls_1__774deg0/project_MVAU_hls_1/sol1/impl/ip/hdl/verilog/MVAU_hls_1_Matrix_Vector_Activate_Stream_Batch_p_ZL7threshs_9_ROM_AUTO_1R.dat", rom0);
end

  
always @(posedge clk) 
begin 
    if (ce0) 
    begin
        q0 <= rom0[address0];
    end
end


endmodule

//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/vivado_stitch_proj_w5fn6zuu/finn_vivado_stitch_proj.gen/sources_1/bd/finn_design/ip/finn_design_FMPadding_rtl_0_0/synth/finn_design_FMPadding_rtl_0_0.v


// (c) Copyright 1995-2026 Xilinx, Inc. All rights reserved.
// 
// This file contains confidential and proprietary information
// of Xilinx, Inc. and is protected under U.S. and
// international copyright and other intellectual property
// laws.
// 
// DISCLAIMER
// This disclaimer is not a license and does not grant any
// rights to the materials distributed herewith. Except as
// otherwise provided in a valid license issued to you by
// Xilinx, and to the maximum extent permitted by applicable
// law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
// WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
// AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
// BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
// INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
// (2) Xilinx shall not be liable (whether in contract or tort,
// including negligence, or under any other theory of
// liability) for any loss or damage of any kind or nature
// related to, arising under or in connection with these
// materials, including for any direct, or any indirect,
// special, incidental, or consequential loss or damage
// (including loss of data, profits, goodwill, or any type of
// loss or damage suffered as a result of any action brought
// by a third party) even if such damage or loss was
// reasonably foreseeable or Xilinx had been advised of the
// possibility of the same.
// 
// CRITICAL APPLICATIONS
// Xilinx products are not designed or intended to be fail-
// safe, or for use in any application requiring fail-safe
// performance, such as life-support or safety devices or
// systems, Class III medical devices, nuclear facilities,
// applications related to the deployment of airbags, or any
// other applications that could lead to death, personal
// injury, or severe property or environmental damage
// (individually and collectively, "Critical
// Applications"). Customer assumes the sole risk and
// liability of any use of Xilinx products in Critical
// Applications, subject only to applicable laws and
// regulations governing limitations on product liability.
// 
// THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
// PART OF THIS FILE AT ALL TIMES.
// 
// DO NOT MODIFY THIS FILE.


// IP VLNV: xilinx.com:module_ref:FMPadding_rtl_0:1.0
// IP Revision: 1

(* X_CORE_INFO = "FMPadding_rtl_0,Vivado 2022.2" *)
(* CHECK_LICENSE_TYPE = "finn_design_FMPadding_rtl_0_0,FMPadding_rtl_0,{}" *)
(* CORE_GENERATION_INFO = "finn_design_FMPadding_rtl_0_0,FMPadding_rtl_0,{x_ipProduct=Vivado 2022.2,x_ipVendor=xilinx.com,x_ipLibrary=module_ref,x_ipName=FMPadding_rtl_0,x_ipVersion=1.0,x_ipCoreRevision=1,x_ipLanguage=VERILOG,x_ipSimLanguage=MIXED}" *)
(* IP_DEFINITION_SOURCE = "module_ref" *)
(* DowngradeIPIdentifiedWarnings = "yes" *)
module finn_design_FMPadding_rtl_0_0 (
  ap_clk,
  ap_rst_n,
  s_axilite_AWVALID,
  s_axilite_AWREADY,
  s_axilite_AWADDR,
  s_axilite_WVALID,
  s_axilite_WREADY,
  s_axilite_WDATA,
  s_axilite_WSTRB,
  s_axilite_BVALID,
  s_axilite_BREADY,
  s_axilite_BRESP,
  s_axilite_ARVALID,
  s_axilite_ARREADY,
  s_axilite_ARADDR,
  s_axilite_RVALID,
  s_axilite_RREADY,
  s_axilite_RDATA,
  s_axilite_RRESP,
  in0_V_TREADY,
  in0_V_TVALID,
  in0_V_TDATA,
  out_V_TREADY,
  out_V_TVALID,
  out_V_TDATA
);

(* X_INTERFACE_PARAMETER = "XIL_INTERFACENAME ap_clk, ASSOCIATED_RESET ap_rst_n, ASSOCIATED_BUSIF in0_V:out_V:s_axilite, FREQ_HZ 100000000, FREQ_TOLERANCE_HZ 0, PHASE 0.0, CLK_DOMAIN finn_design_ap_clk_0, INSERT_VIP 0" *)
(* X_INTERFACE_INFO = "xilinx.com:signal:clock:1.0 ap_clk CLK" *)
input wire ap_clk;
(* X_INTERFACE_PARAMETER = "XIL_INTERFACENAME ap_rst_n, POLARITY ACTIVE_LOW, INSERT_VIP 0" *)
(* X_INTERFACE_INFO = "xilinx.com:signal:reset:1.0 ap_rst_n RST" *)
input wire ap_rst_n;
(* X_INTERFACE_INFO = "xilinx.com:interface:aximm:1.0 s_axilite AWVALID" *)
input wire s_axilite_AWVALID;
(* X_INTERFACE_INFO = "xilinx.com:interface:aximm:1.0 s_axilite AWREADY" *)
output wire s_axilite_AWREADY;
(* X_INTERFACE_INFO = "xilinx.com:interface:aximm:1.0 s_axilite AWADDR" *)
input wire [4 : 0] s_axilite_AWADDR;
(* X_INTERFACE_INFO = "xilinx.com:interface:aximm:1.0 s_axilite WVALID" *)
input wire s_axilite_WVALID;
(* X_INTERFACE_INFO = "xilinx.com:interface:aximm:1.0 s_axilite WREADY" *)
output wire s_axilite_WREADY;
(* X_INTERFACE_INFO = "xilinx.com:interface:aximm:1.0 s_axilite WDATA" *)
input wire [31 : 0] s_axilite_WDATA;
(* X_INTERFACE_INFO = "xilinx.com:interface:aximm:1.0 s_axilite WSTRB" *)
input wire [3 : 0] s_axilite_WSTRB;
(* X_INTERFACE_INFO = "xilinx.com:interface:aximm:1.0 s_axilite BVALID" *)
output wire s_axilite_BVALID;
(* X_INTERFACE_INFO = "xilinx.com:interface:aximm:1.0 s_axilite BREADY" *)
input wire s_axilite_BREADY;
(* X_INTERFACE_INFO = "xilinx.com:interface:aximm:1.0 s_axilite BRESP" *)
output wire [1 : 0] s_axilite_BRESP;
(* X_INTERFACE_INFO = "xilinx.com:interface:aximm:1.0 s_axilite ARVALID" *)
input wire s_axilite_ARVALID;
(* X_INTERFACE_INFO = "xilinx.com:interface:aximm:1.0 s_axilite ARREADY" *)
output wire s_axilite_ARREADY;
(* X_INTERFACE_INFO = "xilinx.com:interface:aximm:1.0 s_axilite ARADDR" *)
input wire [4 : 0] s_axilite_ARADDR;
(* X_INTERFACE_INFO = "xilinx.com:interface:aximm:1.0 s_axilite RVALID" *)
output wire s_axilite_RVALID;
(* X_INTERFACE_INFO = "xilinx.com:interface:aximm:1.0 s_axilite RREADY" *)
input wire s_axilite_RREADY;
(* X_INTERFACE_INFO = "xilinx.com:interface:aximm:1.0 s_axilite RDATA" *)
output wire [31 : 0] s_axilite_RDATA;
(* X_INTERFACE_PARAMETER = "XIL_INTERFACENAME s_axilite, DATA_WIDTH 32, PROTOCOL AXI4LITE, FREQ_HZ 100000000, ID_WIDTH 0, ADDR_WIDTH 5, AWUSER_WIDTH 0, ARUSER_WIDTH 0, WUSER_WIDTH 0, RUSER_WIDTH 0, BUSER_WIDTH 0, READ_WRITE_MODE READ_WRITE, HAS_BURST 0, HAS_LOCK 0, HAS_PROT 0, HAS_CACHE 0, HAS_QOS 0, HAS_REGION 0, HAS_WSTRB 1, HAS_BRESP 1, HAS_RRESP 1, SUPPORTS_NARROW_BURST 0, NUM_READ_OUTSTANDING 1, NUM_WRITE_OUTSTANDING 1, MAX_BURST_LENGTH 1, PHASE 0.0, CLK_DOMAIN finn_design_ap_clk_0, NUM_READ_THREADS 1, NUM_WRITE_THREA\
DS 1, RUSER_BITS_PER_BYTE 0, WUSER_BITS_PER_BYTE 0, INSERT_VIP 0" *)
(* X_INTERFACE_INFO = "xilinx.com:interface:aximm:1.0 s_axilite RRESP" *)
output wire [1 : 0] s_axilite_RRESP;
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 in0_V TREADY" *)
output wire in0_V_TREADY;
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 in0_V TVALID" *)
input wire in0_V_TVALID;
(* X_INTERFACE_PARAMETER = "XIL_INTERFACENAME in0_V, TDATA_NUM_BYTES 3, TDEST_WIDTH 0, TID_WIDTH 0, TUSER_WIDTH 0, HAS_TREADY 1, HAS_TSTRB 0, HAS_TKEEP 0, HAS_TLAST 0, FREQ_HZ 100000000, PHASE 0.0, CLK_DOMAIN finn_design_ap_clk_0, LAYERED_METADATA undef, INSERT_VIP 0" *)
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 in0_V TDATA" *)
input wire [23 : 0] in0_V_TDATA;
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 out_V TREADY" *)
input wire out_V_TREADY;
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 out_V TVALID" *)
output wire out_V_TVALID;
(* X_INTERFACE_PARAMETER = "XIL_INTERFACENAME out_V, TDATA_NUM_BYTES 3, TDEST_WIDTH 0, TID_WIDTH 0, TUSER_WIDTH 0, HAS_TREADY 1, HAS_TSTRB 0, HAS_TKEEP 0, HAS_TLAST 0, FREQ_HZ 100000000, PHASE 0.0, CLK_DOMAIN finn_design_ap_clk_0, LAYERED_METADATA undef, INSERT_VIP 0" *)
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 out_V TDATA" *)
output wire [23 : 0] out_V_TDATA;

  FMPadding_rtl_0 inst (
    .ap_clk(ap_clk),
    .ap_rst_n(ap_rst_n),
    .s_axilite_AWVALID(s_axilite_AWVALID),
    .s_axilite_AWREADY(s_axilite_AWREADY),
    .s_axilite_AWADDR(s_axilite_AWADDR),
    .s_axilite_WVALID(s_axilite_WVALID),
    .s_axilite_WREADY(s_axilite_WREADY),
    .s_axilite_WDATA(s_axilite_WDATA),
    .s_axilite_WSTRB(s_axilite_WSTRB),
    .s_axilite_BVALID(s_axilite_BVALID),
    .s_axilite_BREADY(s_axilite_BREADY),
    .s_axilite_BRESP(s_axilite_BRESP),
    .s_axilite_ARVALID(s_axilite_ARVALID),
    .s_axilite_ARREADY(s_axilite_ARREADY),
    .s_axilite_ARADDR(s_axilite_ARADDR),
    .s_axilite_RVALID(s_axilite_RVALID),
    .s_axilite_RREADY(s_axilite_RREADY),
    .s_axilite_RDATA(s_axilite_RDATA),
    .s_axilite_RRESP(s_axilite_RRESP),
    .in0_V_TREADY(in0_V_TREADY),
    .in0_V_TVALID(in0_V_TVALID),
    .in0_V_TDATA(in0_V_TDATA),
    .out_V_TREADY(out_V_TREADY),
    .out_V_TVALID(out_V_TVALID),
    .out_V_TDATA(out_V_TDATA)
  );
endmodule
//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/vivado_stitch_proj_w5fn6zuu/finn_vivado_stitch_proj.gen/sources_1/bd/finn_design/ip/finn_design_MVAU_rtl_0_0/synth/finn_design_MVAU_rtl_0_0.v


// (c) Copyright 1995-2026 Xilinx, Inc. All rights reserved.
// 
// This file contains confidential and proprietary information
// of Xilinx, Inc. and is protected under U.S. and
// international copyright and other intellectual property
// laws.
// 
// DISCLAIMER
// This disclaimer is not a license and does not grant any
// rights to the materials distributed herewith. Except as
// otherwise provided in a valid license issued to you by
// Xilinx, and to the maximum extent permitted by applicable
// law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
// WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
// AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
// BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
// INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
// (2) Xilinx shall not be liable (whether in contract or tort,
// including negligence, or under any other theory of
// liability) for any loss or damage of any kind or nature
// related to, arising under or in connection with these
// materials, including for any direct, or any indirect,
// special, incidental, or consequential loss or damage
// (including loss of data, profits, goodwill, or any type of
// loss or damage suffered as a result of any action brought
// by a third party) even if such damage or loss was
// reasonably foreseeable or Xilinx had been advised of the
// possibility of the same.
// 
// CRITICAL APPLICATIONS
// Xilinx products are not designed or intended to be fail-
// safe, or for use in any application requiring fail-safe
// performance, such as life-support or safety devices or
// systems, Class III medical devices, nuclear facilities,
// applications related to the deployment of airbags, or any
// other applications that could lead to death, personal
// injury, or severe property or environmental damage
// (individually and collectively, "Critical
// Applications"). Customer assumes the sole risk and
// liability of any use of Xilinx products in Critical
// Applications, subject only to applicable laws and
// regulations governing limitations on product liability.
// 
// THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
// PART OF THIS FILE AT ALL TIMES.
// 
// DO NOT MODIFY THIS FILE.


// IP VLNV: xilinx.com:module_ref:MVAU_rtl_0:1.0
// IP Revision: 1

(* X_CORE_INFO = "MVAU_rtl_0,Vivado 2022.2" *)
(* CHECK_LICENSE_TYPE = "finn_design_MVAU_rtl_0_0,MVAU_rtl_0,{}" *)
(* CORE_GENERATION_INFO = "finn_design_MVAU_rtl_0_0,MVAU_rtl_0,{x_ipProduct=Vivado 2022.2,x_ipVendor=xilinx.com,x_ipLibrary=module_ref,x_ipName=MVAU_rtl_0,x_ipVersion=1.0,x_ipCoreRevision=1,x_ipLanguage=VERILOG,x_ipSimLanguage=MIXED,IS_MVU=1,COMPUTE_CORE=mvu_4sx4u_dsp48e1,PUMPED_COMPUTE=0,MW=1568,MH=10,PE=1,SIMD=1,ACTIVATION_WIDTH=4,WEIGHT_WIDTH=4,ACCU_WIDTH=24,NARROW_WEIGHTS=1,SIGNED_ACTIVATIONS=0,SEGMENTLEN=1,FORCE_BEHAVIORAL=0,WEIGHT_STREAM_WIDTH_BA=8,INPUT_STREAM_WIDTH_BA=8,OUTPUT_STREAM_WIDTH_BA=24}" *)
(* IP_DEFINITION_SOURCE = "module_ref" *)
(* DowngradeIPIdentifiedWarnings = "yes" *)
module finn_design_MVAU_rtl_0_0 (
  ap_clk,
  ap_rst_n,
  weights_V_TDATA,
  weights_V_TVALID,
  weights_V_TREADY,
  in0_V_TDATA,
  in0_V_TVALID,
  in0_V_TREADY,
  out_V_TDATA,
  out_V_TVALID,
  out_V_TREADY
);

(* X_INTERFACE_PARAMETER = "XIL_INTERFACENAME ap_clk, ASSOCIATED_RESET ap_rst_n, ASSOCIATED_BUSIF weights_V:in0_V:out_V, FREQ_HZ 100000000, FREQ_TOLERANCE_HZ 0, PHASE 0.0, CLK_DOMAIN finn_design_ap_clk_0, INSERT_VIP 0" *)
(* X_INTERFACE_INFO = "xilinx.com:signal:clock:1.0 ap_clk CLK" *)
input wire ap_clk;
(* X_INTERFACE_PARAMETER = "XIL_INTERFACENAME ap_rst_n, POLARITY ACTIVE_LOW, INSERT_VIP 0" *)
(* X_INTERFACE_INFO = "xilinx.com:signal:reset:1.0 ap_rst_n RST" *)
input wire ap_rst_n;
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 weights_V TDATA" *)
input wire [7 : 0] weights_V_TDATA;
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 weights_V TVALID" *)
input wire weights_V_TVALID;
(* X_INTERFACE_PARAMETER = "XIL_INTERFACENAME weights_V, TDATA_NUM_BYTES 1, TDEST_WIDTH 0, TID_WIDTH 0, TUSER_WIDTH 0, HAS_TREADY 1, HAS_TSTRB 0, HAS_TKEEP 0, HAS_TLAST 0, FREQ_HZ 100000000, PHASE 0.0, CLK_DOMAIN finn_design_ap_clk_0, LAYERED_METADATA undef, INSERT_VIP 0" *)
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 weights_V TREADY" *)
output wire weights_V_TREADY;
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 in0_V TDATA" *)
input wire [7 : 0] in0_V_TDATA;
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 in0_V TVALID" *)
input wire in0_V_TVALID;
(* X_INTERFACE_PARAMETER = "XIL_INTERFACENAME in0_V, TDATA_NUM_BYTES 1, TDEST_WIDTH 0, TID_WIDTH 0, TUSER_WIDTH 0, HAS_TREADY 1, HAS_TSTRB 0, HAS_TKEEP 0, HAS_TLAST 0, FREQ_HZ 100000000, PHASE 0.0, CLK_DOMAIN finn_design_ap_clk_0, LAYERED_METADATA undef, INSERT_VIP 0" *)
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 in0_V TREADY" *)
output wire in0_V_TREADY;
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 out_V TDATA" *)
output wire [23 : 0] out_V_TDATA;
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 out_V TVALID" *)
output wire out_V_TVALID;
(* X_INTERFACE_PARAMETER = "XIL_INTERFACENAME out_V, TDATA_NUM_BYTES 3, TDEST_WIDTH 0, TID_WIDTH 0, TUSER_WIDTH 0, HAS_TREADY 1, HAS_TSTRB 0, HAS_TKEEP 0, HAS_TLAST 0, FREQ_HZ 100000000, PHASE 0.0, CLK_DOMAIN finn_design_ap_clk_0, LAYERED_METADATA undef, INSERT_VIP 0" *)
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 out_V TREADY" *)
input wire out_V_TREADY;

  MVAU_rtl_0 #(
    .IS_MVU(1),
    .COMPUTE_CORE("mvu_4sx4u_dsp48e1"),
    .PUMPED_COMPUTE(0),
    .MW(1568),
    .MH(10),
    .PE(1),
    .SIMD(1),
    .ACTIVATION_WIDTH(4),
    .WEIGHT_WIDTH(4),
    .ACCU_WIDTH(24),
    .NARROW_WEIGHTS(1),
    .SIGNED_ACTIVATIONS(0),
    .SEGMENTLEN(1),
    .FORCE_BEHAVIORAL(0),
    .WEIGHT_STREAM_WIDTH_BA(8),
    .INPUT_STREAM_WIDTH_BA(8),
    .OUTPUT_STREAM_WIDTH_BA(24)
  ) inst (
    .ap_clk(ap_clk),
    .ap_rst_n(ap_rst_n),
    .weights_V_TDATA(weights_V_TDATA),
    .weights_V_TVALID(weights_V_TVALID),
    .weights_V_TREADY(weights_V_TREADY),
    .in0_V_TDATA(in0_V_TDATA),
    .in0_V_TVALID(in0_V_TVALID),
    .in0_V_TREADY(in0_V_TREADY),
    .out_V_TDATA(out_V_TDATA),
    .out_V_TVALID(out_V_TVALID),
    .out_V_TREADY(out_V_TREADY)
  );
endmodule
//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/code_gen_ipgen_FMPadding_rtl_1_bx8daa0b/fmpadding.sv


/******************************************************************************
 * Copyright (C) 2022, Advanced Micro Devices, Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *  1. Redistributions of source code must retain the above copyright notice,
 *     this list of conditions and the following disclaimer.
 *
 *  2. Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *
 *  3. Neither the name of the copyright holder nor the names of its
 *     contributors may be used to endorse or promote products derived from
 *     this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION). HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * @brief	Feature map padding.
 * @author	Thomas B. Preuer <tpreusse@amd.com>
 *****************************************************************************/

module fmpadding #(
	int unsigned  XCOUNTER_BITS,
	int unsigned  YCOUNTER_BITS,
	int unsigned  NUM_CHANNELS,
	int unsigned  SIMD,
	int unsigned  ELEM_BITS,
	int unsigned  INIT_XON,
	int unsigned  INIT_XOFF,
	int unsigned  INIT_XEND,
	int unsigned  INIT_YON,
	int unsigned  INIT_YOFF,
	int unsigned  INIT_YEND,

	localparam int unsigned  STREAM_BITS = 8*(1 + (SIMD*ELEM_BITS-1)/8)
)(
	//- Global Control ------------------
	input	logic  ap_clk,
	input	logic  ap_rst_n,

	// Parameter Configuration ----------
	input	logic         we,
	input	logic [ 4:0]  wa,
	input	logic [31:0]  wd,

	//- AXI Stream - Input --------------
	output	logic  s_axis_tready,
	input	logic  s_axis_tvalid,
	input	logic [STREAM_BITS-1:0]  s_axis_tdata,

	//- AXI Stream - Output -------------
	input	logic  m_axis_tready,
	output	logic  m_axis_tvalid,
	output	logic [STREAM_BITS-1:0]  m_axis_tdata
);

	uwire  clk = ap_clk;
	uwire  rst = !ap_rst_n;

	//-----------------------------------------------------------------------
	// Parameter Sanity Checking
	initial begin
		automatic bit  fail = 0;

		if(XCOUNTER_BITS < $clog2(1+INIT_XEND)) begin
			$error("XCounter size too small to accommodate end count.");
			fail = 1;
		end
		if(XCOUNTER_BITS < $clog2(1+INIT_XON)) begin
			$error("XCounter size too small to accommodate ON count.");
			fail = 1;
		end
		if(XCOUNTER_BITS < $clog2(1+INIT_XOFF)) begin
			$error("XCounter size too small to accommodate OFF count.");
			fail = 1;
		end
		if(YCOUNTER_BITS < $clog2(1+INIT_YEND)) begin
			$error("YCounter size too small to accommodate end count.");
			fail = 1;
		end
		if(YCOUNTER_BITS < $clog2(1+INIT_YON)) begin
			$error("YCounter size too small to accommodate ON count.");
			fail = 1;
		end
		if(YCOUNTER_BITS < $clog2(1+INIT_YOFF)) begin
			$error("YCounter size too small to accommodate OFF count.");
			fail = 1;
		end

		if((INIT_XEND < INIT_XON) || (INIT_XOFF <= INIT_XON)) begin
			$warning("Initial empty X output range.");
		end
		if((INIT_YEND < INIT_YON) || (INIT_YOFF <= INIT_YON)) begin
			$warning("Initial empty Y output range.");
		end

		if(fail)  $finish();
	end

	//-----------------------------------------------------------------------
	// Dynamically configurable state
	typedef logic [XCOUNTER_BITS-1:0]  xcount_t;
	xcount_t  XEnd = INIT_XEND;
	xcount_t  XOn  = INIT_XON;
	xcount_t  XOff = INIT_XOFF;

	typedef logic [YCOUNTER_BITS-1:0]  ycount_t;
	ycount_t  YEnd = INIT_YEND;
	ycount_t  YOn  = INIT_YON;
	ycount_t  YOff = INIT_YOFF;

	always_ff @(posedge clk) begin
		if(we) begin
			unique case(wa)
			0*4:  XOn  <= wd;
			1*4:  XOff <= wd;
			2*4:  XEnd <= wd;
			3*4:  YOn  <= wd;
			4*4:  YOff <= wd;
			5*4:  YEnd <= wd;

			default:  assert(0) else begin
				$error("Illegal write address.");
				$stop;
			end
			endcase
		end
	end

	//-----------------------------------------------------------------------
	// Cascaded enables for the nested counters: SCount, XCount, YCount
	uwire  sen;
	uwire  xen;
	uwire  yen;

	//- S-Counter: SIMD fold ------------
	initial begin
		if((NUM_CHANNELS < 1) || (NUM_CHANNELS % SIMD != 0)) begin
			$error("Channel count must be SIMD multiple.");
			$finish;
		end
	end
	// Count SF-2, SF-3, ..., 1, 0, -1
	localparam int unsigned  SF = NUM_CHANNELS/SIMD;
	typedef logic [$clog2(SF-1):0]  scount_t;
	scount_t  SCount = SF-2;

	assign	xen = sen && SCount[$left(SCount)];
	uwire  sclr = rst || xen;
	always_ff @(posedge clk) begin
		if(sclr)      SCount <= SF-2;
		else if(sen)  SCount <= SCount - 1;
	end

	//- X-Counter: image width ----------
	xcount_t  XCount = 0;

	assign	yen = xen && (XCount == XEnd);
	uwire  xclr = rst || yen;
	always_ff @(posedge clk) begin
		if(xclr)      XCount <= 0;
		else if(xen)  XCount <= XCount + 1;
	end
	uwire  xfwd = (XOn <= XCount) && (XCount < XOff);

	//- Y-Counter: image height ---------
	ycount_t  YCount = 0;

	uwire  yclr = rst || (yen && (YCount == YEnd));
	always_ff @(posedge clk) begin
		if(yclr)      YCount <= 0;
		else if(yen)  YCount <= YCount + 1;
	end
	uwire  yfwd = (YOn <= YCount) && (YCount < YOff);

	//-----------------------------------------------------------------------
	// Input forwarding and edge padding
	typedef struct {
		logic  vld;
		logic [STREAM_BITS-1:0]  dat;
	} buf_t;
	buf_t  A = '{ vld: 0, dat: 'x };
	buf_t  B = '{ vld: 0, dat: 'x };

	uwire  fwd = xfwd && yfwd;
	assign	sen = (m_axis_tready || !B.vld) && (s_axis_tvalid || A.vld || !fwd);
	assign	s_axis_tready = !A.vld;
	assign	m_axis_tvalid =  B.vld;
	assign	m_axis_tdata  =  B.dat;

	always_ff @(posedge clk) begin
		if(rst) begin
			B <= '{ vld: 0, dat: 'x };
		end
		else if(m_axis_tready || !B.vld) begin
			B.vld <= s_axis_tvalid || A.vld || !fwd;
			B.dat <= !fwd? '0 : A.vld? A.dat : s_axis_tdata;
		end
	end

	always_ff @(posedge clk) begin
		if(rst) begin
			A <= '{ vld: 0, dat: 'x };
		end
		else begin
			A.vld <= (A.vld || s_axis_tvalid) && ((B.vld && !m_axis_tready) || !fwd);
			if(!A.vld)  A.dat <= s_axis_tdata;
		end
	end

endmodule : fmpadding
//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/code_gen_ipgen_StreamingFIFO_rtl_12_ve9w0c68/StreamingFIFO_rtl_12.v


/******************************************************************************
 * Copyright (C) 2024, Advanced Micro Devices, Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *  1. Redistributions of source code must retain the above copyright notice,
 *     this list of conditions and the following disclaimer.
 *
 *  2. Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *
 *  3. Neither the name of the copyright holder nor the names of its
 *     contributors may be used to endorse or promote products derived from
 *     this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION). HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *****************************************************************************/

module StreamingFIFO_rtl_12(
//- Global Control ------------------
(* X_INTERFACE_PARAMETER = "ASSOCIATED_BUSIF in0_V:out_V, ASSOCIATED_RESET = ap_rst_n" *)
(* X_INTERFACE_INFO = "xilinx.com:signal:clock:1.0 ap_clk CLK" *)
input   ap_clk,
(* X_INTERFACE_PARAMETER = "POLARITY ACTIVE_LOW" *)
input   ap_rst_n,

output [5:0] count,
output [5:0] maxcount,

//- AXI Stream - Input --------------
output   in0_V_TREADY,
input   in0_V_TVALID,
input  [127:0] in0_V_TDATA,

//- AXI Stream - Output --------------
input   out_V_TREADY,
output   out_V_TVALID,
output  [127:0] out_V_TDATA
);

Q_srl #(
.depth(49),
.width(128)
)
impl
(
 .clock(ap_clk),
 .reset(!ap_rst_n),
 .count(count),
 .maxcount(maxcount),
 .i_d(in0_V_TDATA),
 .i_v(in0_V_TVALID),
 .i_r(in0_V_TREADY),
 .o_d(out_V_TDATA),
 .o_v(out_V_TVALID),
 .o_r(out_V_TREADY)
);

endmodule
//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/vivado_stitch_proj_w5fn6zuu/finn_vivado_stitch_proj.gen/sources_1/bd/finn_design/ipshared/fb57/hdl/verilog/MVAU_hls_1_Matrix_Vector_Activate_Stream_Batch.v


// ==============================================================
// RTL generated by Vitis HLS - High-Level Synthesis from C, C++ and OpenCL v2022.2 (64-bit)
// Version: 2022.2
// Copyright (C) Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.
// 
// ===========================================================

`timescale 1 ns / 1 ps 

module MVAU_hls_1_Matrix_Vector_Activate_Stream_Batch (
        ap_clk,
        ap_rst,
        ap_start,
        ap_done,
        ap_idle,
        ap_ready,
        in0_V_TVALID,
        weights_V_TVALID,
        out_V_TREADY,
        in0_V_TDATA,
        in0_V_TREADY,
        out_V_TDATA,
        out_V_TVALID,
        weights_V_TDATA,
        weights_V_TREADY
);

parameter    ap_ST_iter0_fsm_state1 = 1'd1;
parameter    ap_ST_iter1_fsm_state2 = 2'd2;
parameter    ap_ST_iter2_fsm_state3 = 2'd2;
parameter    ap_ST_iter3_fsm_state4 = 2'd2;
parameter    ap_ST_iter4_fsm_state5 = 2'd2;
parameter    ap_ST_iter5_fsm_state6 = 2'd2;
parameter    ap_ST_iter6_fsm_state7 = 2'd2;
parameter    ap_ST_iter1_fsm_state0 = 2'd1;
parameter    ap_ST_iter2_fsm_state0 = 2'd1;
parameter    ap_ST_iter3_fsm_state0 = 2'd1;
parameter    ap_ST_iter4_fsm_state0 = 2'd1;
parameter    ap_ST_iter5_fsm_state0 = 2'd1;
parameter    ap_ST_iter6_fsm_state0 = 2'd1;

input   ap_clk;
input   ap_rst;
input   ap_start;
output   ap_done;
output   ap_idle;
output   ap_ready;
input   in0_V_TVALID;
input   weights_V_TVALID;
input   out_V_TREADY;
input  [7:0] in0_V_TDATA;
output   in0_V_TREADY;
output  [7:0] out_V_TDATA;
output   out_V_TVALID;
input  [7:0] weights_V_TDATA;
output   weights_V_TREADY;

reg ap_idle;
reg in0_V_TREADY;
reg out_V_TVALID;
reg weights_V_TREADY;

reg   [0:0] ap_CS_iter0_fsm;
wire    ap_CS_iter0_fsm_state1;
reg   [1:0] ap_CS_iter1_fsm;
wire    ap_CS_iter1_fsm_state0;
reg   [1:0] ap_CS_iter2_fsm;
wire    ap_CS_iter2_fsm_state0;
reg   [1:0] ap_CS_iter3_fsm;
wire    ap_CS_iter3_fsm_state0;
reg   [1:0] ap_CS_iter4_fsm;
wire    ap_CS_iter4_fsm_state0;
reg   [1:0] ap_CS_iter5_fsm;
wire    ap_CS_iter5_fsm_state0;
reg   [1:0] ap_CS_iter6_fsm;
wire    ap_CS_iter6_fsm_state0;
wire   [0:0] icmp_ln249_fu_1209_p2;
wire   [0:0] icmp_ln253_fu_1221_p2;
reg    ap_predicate_op323_read_state1;
reg    ap_block_state1_pp0_stage0_iter0;
wire    ap_block_state2_pp0_stage0_iter1;
wire    ap_CS_iter1_fsm_state2;
wire    ap_block_state5_pp0_stage0_iter4;
wire    ap_CS_iter4_fsm_state5;
wire    ap_block_state4_pp0_stage0_iter3;
wire    ap_CS_iter3_fsm_state4;
wire    ap_block_state3_pp0_stage0_iter2;
wire    ap_CS_iter2_fsm_state3;
wire    ap_block_state6_pp0_stage0_iter5;
wire    ap_CS_iter5_fsm_state6;
reg   [0:0] icmp_ln249_reg_4103;
reg   [0:0] icmp_ln249_reg_4103_pp0_iter5_reg;
reg   [0:0] icmp_ln290_reg_4134;
reg   [0:0] icmp_ln290_reg_4134_pp0_iter5_reg;
reg    ap_predicate_op774_write_state7;
reg    ap_block_state7_pp0_stage0_iter6;
reg    ap_block_state7_io;
wire    ap_CS_iter6_fsm_state7;
reg    ap_condition_exit_pp0_iter0_stage0;
wire    ap_loop_exit_ready;
reg    ap_ready_int;
wire   [4:0] p_ZL7threshs_0_address0;
reg    p_ZL7threshs_0_ce0;
wire   [9:0] p_ZL7threshs_0_q0;
wire   [4:0] p_ZL7threshs_1_address0;
reg    p_ZL7threshs_1_ce0;
wire   [9:0] p_ZL7threshs_1_q0;
wire   [4:0] p_ZL7threshs_2_address0;
reg    p_ZL7threshs_2_ce0;
wire   [9:0] p_ZL7threshs_2_q0;
wire   [4:0] p_ZL7threshs_3_address0;
reg    p_ZL7threshs_3_ce0;
wire   [9:0] p_ZL7threshs_3_q0;
wire   [4:0] p_ZL7threshs_4_address0;
reg    p_ZL7threshs_4_ce0;
wire   [9:0] p_ZL7threshs_4_q0;
wire   [4:0] p_ZL7threshs_5_address0;
reg    p_ZL7threshs_5_ce0;
wire   [9:0] p_ZL7threshs_5_q0;
wire   [4:0] p_ZL7threshs_6_address0;
reg    p_ZL7threshs_6_ce0;
wire   [10:0] p_ZL7threshs_6_q0;
wire   [4:0] p_ZL7threshs_7_address0;
reg    p_ZL7threshs_7_ce0;
wire   [10:0] p_ZL7threshs_7_q0;
wire   [4:0] p_ZL7threshs_8_address0;
reg    p_ZL7threshs_8_ce0;
wire   [9:0] p_ZL7threshs_8_q0;
wire   [4:0] p_ZL7threshs_9_address0;
reg    p_ZL7threshs_9_ce0;
wire   [9:0] p_ZL7threshs_9_q0;
wire   [4:0] p_ZL7threshs_10_address0;
reg    p_ZL7threshs_10_ce0;
wire   [9:0] p_ZL7threshs_10_q0;
wire   [4:0] p_ZL7threshs_11_address0;
reg    p_ZL7threshs_11_ce0;
wire   [9:0] p_ZL7threshs_11_q0;
wire   [4:0] p_ZL7threshs_12_address0;
reg    p_ZL7threshs_12_ce0;
wire   [9:0] p_ZL7threshs_12_q0;
wire   [4:0] p_ZL7threshs_13_address0;
reg    p_ZL7threshs_13_ce0;
wire   [9:0] p_ZL7threshs_13_q0;
wire   [4:0] p_ZL7threshs_14_address0;
reg    p_ZL7threshs_14_ce0;
wire   [9:0] p_ZL7threshs_14_q0;
reg    in0_V_TDATA_blk_n;
reg    out_V_TDATA_blk_n;
reg    weights_V_TDATA_blk_n;
reg   [31:0] nf_2_reg_4098;
reg   [31:0] nf_2_reg_4098_pp0_iter1_reg;
reg   [31:0] nf_2_reg_4098_pp0_iter2_reg;
wire   [0:0] icmp_ln249_reg_4103_pp0_iter0_reg;
reg   [0:0] icmp_ln249_reg_4103_pp0_iter1_reg;
reg   [0:0] icmp_ln249_reg_4103_pp0_iter2_reg;
reg   [0:0] icmp_ln249_reg_4103_pp0_iter3_reg;
reg   [0:0] icmp_ln249_reg_4103_pp0_iter4_reg;
reg   [0:0] icmp_ln253_reg_4107;
wire   [0:0] icmp_ln253_reg_4107_pp0_iter0_reg;
wire   [3:0] tmp_fu_1663_p146;
wire   [3:0] inElem_fu_1957_p1;
reg   [3:0] inElem_reg_4116;
wire   [3:0] W_packed_V_fu_2685_p1;
reg  signed [3:0] W_packed_V_reg_4124;
wire   [0:0] icmp_ln272_fu_2689_p2;
reg   [0:0] icmp_ln272_reg_4129;
reg   [0:0] icmp_ln272_reg_4129_pp0_iter1_reg;
reg   [0:0] icmp_ln272_reg_4129_pp0_iter2_reg;
wire   [0:0] icmp_ln290_fu_2701_p2;
reg   [0:0] icmp_ln290_reg_4134_pp0_iter1_reg;
reg   [0:0] icmp_ln290_reg_4134_pp0_iter2_reg;
reg   [0:0] icmp_ln290_reg_4134_pp0_iter3_reg;
reg   [0:0] icmp_ln290_reg_4134_pp0_iter4_reg;
wire   [0:0] icmp_ln1039_fu_2786_p2;
reg   [0:0] icmp_ln1039_reg_4228;
wire   [0:0] icmp_ln1039_1_fu_2795_p2;
reg   [0:0] icmp_ln1039_1_reg_4233;
wire   [0:0] icmp_ln1039_2_fu_2804_p2;
reg   [0:0] icmp_ln1039_2_reg_4238;
wire   [0:0] icmp_ln1039_3_fu_2813_p2;
reg   [0:0] icmp_ln1039_3_reg_4243;
wire   [0:0] icmp_ln1039_4_fu_2822_p2;
reg   [0:0] icmp_ln1039_4_reg_4248;
wire   [0:0] icmp_ln1039_5_fu_2831_p2;
reg   [0:0] icmp_ln1039_5_reg_4253;
wire   [0:0] icmp_ln1039_6_fu_2840_p2;
reg   [0:0] icmp_ln1039_6_reg_4258;
wire   [0:0] icmp_ln1039_7_fu_2849_p2;
reg   [0:0] icmp_ln1039_7_reg_4263;
wire   [0:0] icmp_ln1039_8_fu_2858_p2;
reg   [0:0] icmp_ln1039_8_reg_4268;
wire   [0:0] icmp_ln1039_9_fu_2867_p2;
reg   [0:0] icmp_ln1039_9_reg_4273;
wire   [0:0] icmp_ln1039_10_fu_2876_p2;
reg   [0:0] icmp_ln1039_10_reg_4278;
wire   [0:0] icmp_ln1039_11_fu_2885_p2;
reg   [0:0] icmp_ln1039_11_reg_4283;
wire   [0:0] icmp_ln1039_12_fu_2894_p2;
reg   [0:0] icmp_ln1039_12_reg_4288;
wire   [0:0] icmp_ln1039_13_fu_2903_p2;
reg   [0:0] icmp_ln1039_13_reg_4293;
wire   [0:0] icmp_ln1039_14_fu_2912_p2;
reg   [0:0] icmp_ln1039_14_reg_4298;
wire   [2:0] add_ln840_6_fu_3098_p2;
reg   [2:0] add_ln840_6_reg_4303;
wire   [2:0] add_ln840_9_fu_3124_p2;
reg   [2:0] add_ln840_9_reg_4308;
wire   [2:0] add_ln840_12_fu_3150_p2;
reg   [2:0] add_ln840_12_reg_4313;
reg   [3:0] ap_phi_mux_inElem_1_phi_fu_1179_p4;
reg   [3:0] ap_phi_reg_pp0_iter1_inElem_1_reg_1176;
wire   [3:0] ap_phi_reg_pp0_iter0_inElem_1_reg_1176;
wire   [63:0] idxprom2_i_fu_2764_p1;
reg   [31:0] sf_fu_370;
wire   [31:0] sf_2_fu_2695_p2;
wire    ap_loop_init;
reg   [31:0] ap_sig_allocacmp_sf_1;
reg   [19:0] i_fu_374;
wire   [19:0] i_2_fu_1215_p2;
reg   [19:0] ap_sig_allocacmp_i_1;
reg   [13:0] add_i4_i338_fu_378;
wire  signed [13:0] grp_fu_3182_p3;
reg   [13:0] ap_sig_allocacmp_add_i4_i338_load;
reg   [3:0] inputBuf_V_fu_382;
wire   [7:0] trunc_ln257_fu_1961_p1;
reg   [3:0] inputBuf_V_1_fu_386;
reg   [3:0] inputBuf_V_2_fu_390;
reg   [3:0] inputBuf_V_3_fu_394;
reg   [3:0] inputBuf_V_4_fu_398;
reg   [3:0] inputBuf_V_5_fu_402;
reg   [3:0] inputBuf_V_6_fu_406;
reg   [3:0] inputBuf_V_7_fu_410;
reg   [3:0] inputBuf_V_8_fu_414;
reg   [3:0] inputBuf_V_9_fu_418;
reg   [3:0] inputBuf_V_10_fu_422;
reg   [3:0] inputBuf_V_11_fu_426;
reg   [3:0] inputBuf_V_12_fu_430;
reg   [3:0] inputBuf_V_13_fu_434;
reg   [3:0] inputBuf_V_14_fu_438;
reg   [3:0] inputBuf_V_15_fu_442;
reg   [3:0] inputBuf_V_16_fu_446;
reg   [3:0] inputBuf_V_17_fu_450;
reg   [3:0] inputBuf_V_18_fu_454;
reg   [3:0] inputBuf_V_19_fu_458;
reg   [3:0] inputBuf_V_20_fu_462;
reg   [3:0] inputBuf_V_21_fu_466;
reg   [3:0] inputBuf_V_22_fu_470;
reg   [3:0] inputBuf_V_23_fu_474;
reg   [3:0] inputBuf_V_24_fu_478;
reg   [3:0] inputBuf_V_25_fu_482;
reg   [3:0] inputBuf_V_26_fu_486;
reg   [3:0] inputBuf_V_27_fu_490;
reg   [3:0] inputBuf_V_28_fu_494;
reg   [3:0] inputBuf_V_29_fu_498;
reg   [3:0] inputBuf_V_30_fu_502;
reg   [3:0] inputBuf_V_31_fu_506;
reg   [3:0] inputBuf_V_32_fu_510;
reg   [3:0] inputBuf_V_33_fu_514;
reg   [3:0] inputBuf_V_34_fu_518;
reg   [3:0] inputBuf_V_35_fu_522;
reg   [3:0] inputBuf_V_36_fu_526;
reg   [3:0] inputBuf_V_37_fu_530;
reg   [3:0] inputBuf_V_38_fu_534;
reg   [3:0] inputBuf_V_39_fu_538;
reg   [3:0] inputBuf_V_40_fu_542;
reg   [3:0] inputBuf_V_41_fu_546;
reg   [3:0] inputBuf_V_42_fu_550;
reg   [3:0] inputBuf_V_43_fu_554;
reg   [3:0] inputBuf_V_44_fu_558;
reg   [3:0] inputBuf_V_45_fu_562;
reg   [3:0] inputBuf_V_46_fu_566;
reg   [3:0] inputBuf_V_47_fu_570;
reg   [3:0] inputBuf_V_48_fu_574;
reg   [3:0] inputBuf_V_49_fu_578;
reg   [3:0] inputBuf_V_50_fu_582;
reg   [3:0] inputBuf_V_51_fu_586;
reg   [3:0] inputBuf_V_52_fu_590;
reg   [3:0] inputBuf_V_53_fu_594;
reg   [3:0] inputBuf_V_54_fu_598;
reg   [3:0] inputBuf_V_55_fu_602;
reg   [3:0] inputBuf_V_56_fu_606;
reg   [3:0] inputBuf_V_57_fu_610;
reg   [3:0] inputBuf_V_58_fu_614;
reg   [3:0] inputBuf_V_59_fu_618;
reg   [3:0] inputBuf_V_60_fu_622;
reg   [3:0] inputBuf_V_61_fu_626;
reg   [3:0] inputBuf_V_62_fu_630;
reg   [3:0] inputBuf_V_63_fu_634;
reg   [3:0] inputBuf_V_64_fu_638;
reg   [3:0] inputBuf_V_65_fu_642;
reg   [3:0] inputBuf_V_66_fu_646;
reg   [3:0] inputBuf_V_67_fu_650;
reg   [3:0] inputBuf_V_68_fu_654;
reg   [3:0] inputBuf_V_69_fu_658;
reg   [3:0] inputBuf_V_70_fu_662;
reg   [3:0] inputBuf_V_71_fu_666;
reg   [3:0] inputBuf_V_72_fu_670;
reg   [3:0] inputBuf_V_73_fu_674;
reg   [3:0] inputBuf_V_74_fu_678;
reg   [3:0] inputBuf_V_75_fu_682;
reg   [3:0] inputBuf_V_76_fu_686;
reg   [3:0] inputBuf_V_77_fu_690;
reg   [3:0] inputBuf_V_78_fu_694;
reg   [3:0] inputBuf_V_79_fu_698;
reg   [3:0] inputBuf_V_80_fu_702;
reg   [3:0] inputBuf_V_81_fu_706;
reg   [3:0] inputBuf_V_82_fu_710;
reg   [3:0] inputBuf_V_83_fu_714;
reg   [3:0] inputBuf_V_84_fu_718;
reg   [3:0] inputBuf_V_85_fu_722;
reg   [3:0] inputBuf_V_86_fu_726;
reg   [3:0] inputBuf_V_87_fu_730;
reg   [3:0] inputBuf_V_88_fu_734;
reg   [3:0] inputBuf_V_89_fu_738;
reg   [3:0] inputBuf_V_90_fu_742;
reg   [3:0] inputBuf_V_91_fu_746;
reg   [3:0] inputBuf_V_92_fu_750;
reg   [3:0] inputBuf_V_93_fu_754;
reg   [3:0] inputBuf_V_94_fu_758;
reg   [3:0] inputBuf_V_95_fu_762;
reg   [3:0] inputBuf_V_96_fu_766;
reg   [3:0] inputBuf_V_97_fu_770;
reg   [3:0] inputBuf_V_98_fu_774;
reg   [3:0] inputBuf_V_99_fu_778;
reg   [3:0] inputBuf_V_100_fu_782;
reg   [3:0] inputBuf_V_101_fu_786;
reg   [3:0] inputBuf_V_102_fu_790;
reg   [3:0] inputBuf_V_103_fu_794;
reg   [3:0] inputBuf_V_104_fu_798;
reg   [3:0] inputBuf_V_105_fu_802;
reg   [3:0] inputBuf_V_106_fu_806;
reg   [3:0] inputBuf_V_107_fu_810;
reg   [3:0] inputBuf_V_108_fu_814;
reg   [3:0] inputBuf_V_109_fu_818;
reg   [3:0] inputBuf_V_110_fu_822;
reg   [3:0] inputBuf_V_111_fu_826;
reg   [3:0] inputBuf_V_112_fu_830;
reg   [3:0] inputBuf_V_113_fu_834;
reg   [3:0] inputBuf_V_114_fu_838;
reg   [3:0] inputBuf_V_115_fu_842;
reg   [3:0] inputBuf_V_116_fu_846;
reg   [3:0] inputBuf_V_117_fu_850;
reg   [3:0] inputBuf_V_118_fu_854;
reg   [3:0] inputBuf_V_119_fu_858;
reg   [3:0] inputBuf_V_120_fu_862;
reg   [3:0] inputBuf_V_121_fu_866;
reg   [3:0] inputBuf_V_122_fu_870;
reg   [3:0] inputBuf_V_123_fu_874;
reg   [3:0] inputBuf_V_124_fu_878;
reg   [3:0] inputBuf_V_125_fu_882;
reg   [3:0] inputBuf_V_126_fu_886;
reg   [3:0] inputBuf_V_127_fu_890;
reg   [3:0] inputBuf_V_128_fu_894;
reg   [3:0] inputBuf_V_129_fu_898;
reg   [3:0] inputBuf_V_130_fu_902;
reg   [3:0] inputBuf_V_131_fu_906;
reg   [3:0] inputBuf_V_132_fu_910;
reg   [3:0] inputBuf_V_133_fu_914;
reg   [3:0] inputBuf_V_134_fu_918;
reg   [3:0] inputBuf_V_135_fu_922;
reg   [3:0] inputBuf_V_136_fu_926;
reg   [3:0] inputBuf_V_137_fu_930;
reg   [3:0] inputBuf_V_138_fu_934;
reg   [3:0] inputBuf_V_139_fu_938;
reg   [3:0] inputBuf_V_140_fu_942;
reg   [3:0] inputBuf_V_141_fu_946;
reg   [3:0] inputBuf_V_142_fu_950;
reg   [3:0] inputBuf_V_143_fu_954;
reg   [31:0] nf_1_fu_958;
wire   [31:0] nf_3_fu_2724_p3;
reg   [31:0] ap_sig_allocacmp_nf_2;
wire   [7:0] tmp_fu_1663_p145;
wire   [31:0] nf_fu_2712_p2;
wire   [0:0] icmp_ln302_fu_2718_p2;
wire  signed [13:0] sext_ln1039_fu_2782_p1;
wire  signed [13:0] sext_ln1039_1_fu_2791_p1;
wire  signed [13:0] sext_ln1039_2_fu_2800_p1;
wire  signed [13:0] sext_ln1039_3_fu_2809_p1;
wire  signed [13:0] sext_ln1039_4_fu_2818_p1;
wire  signed [13:0] sext_ln1039_5_fu_2827_p1;
wire  signed [13:0] sext_ln1039_6_fu_2836_p1;
wire  signed [13:0] sext_ln1039_7_fu_2845_p1;
wire   [13:0] zext_ln1039_fu_2854_p1;
wire   [13:0] zext_ln1039_1_fu_2863_p1;
wire   [13:0] zext_ln1039_2_fu_2872_p1;
wire   [13:0] zext_ln1039_3_fu_2881_p1;
wire   [13:0] zext_ln1039_4_fu_2890_p1;
wire   [13:0] zext_ln1039_5_fu_2899_p1;
wire   [13:0] zext_ln1039_6_fu_2908_p1;
wire   [0:0] result_V_fu_2921_p2;
wire   [0:0] xor_ln1039_fu_2930_p2;
wire   [0:0] xor_ln1039_1_fu_2939_p2;
wire   [0:0] xor_ln1039_2_fu_2948_p2;
wire   [0:0] xor_ln1039_3_fu_2957_p2;
wire   [0:0] xor_ln1039_4_fu_2966_p2;
wire   [0:0] xor_ln1039_5_fu_2975_p2;
wire   [0:0] xor_ln1039_6_fu_2984_p2;
wire   [0:0] xor_ln1039_7_fu_2993_p2;
wire   [0:0] xor_ln1039_8_fu_3002_p2;
wire   [0:0] xor_ln1039_9_fu_3011_p2;
wire   [0:0] xor_ln1039_10_fu_3020_p2;
wire   [0:0] xor_ln1039_11_fu_3029_p2;
wire   [0:0] xor_ln1039_12_fu_3038_p2;
wire   [0:0] xor_ln1039_13_fu_3047_p2;
wire   [1:0] zext_ln215_fu_2926_p1;
wire   [1:0] zext_ln218_1_fu_2944_p1;
wire   [1:0] add_ln840_1_fu_3056_p2;
wire   [1:0] zext_ln218_fu_2935_p1;
wire   [1:0] add_ln840_2_fu_3062_p2;
wire   [1:0] zext_ln218_2_fu_2953_p1;
wire   [1:0] zext_ln218_3_fu_2962_p1;
wire   [1:0] add_ln840_3_fu_3072_p2;
wire   [1:0] zext_ln218_4_fu_2971_p1;
wire   [1:0] zext_ln218_5_fu_2980_p1;
wire   [1:0] add_ln840_4_fu_3082_p2;
wire   [2:0] zext_ln840_3_fu_3088_p1;
wire   [2:0] zext_ln840_2_fu_3078_p1;
wire   [2:0] add_ln840_5_fu_3092_p2;
wire   [2:0] zext_ln840_1_fu_3068_p1;
wire   [1:0] zext_ln218_6_fu_2989_p1;
wire   [1:0] zext_ln218_7_fu_2998_p1;
wire   [1:0] add_ln840_7_fu_3104_p2;
wire   [1:0] zext_ln218_8_fu_3007_p1;
wire   [1:0] zext_ln218_9_fu_3016_p1;
wire   [1:0] add_ln840_8_fu_3114_p2;
wire   [2:0] zext_ln840_6_fu_3120_p1;
wire   [2:0] zext_ln840_5_fu_3110_p1;
wire   [1:0] zext_ln218_10_fu_3025_p1;
wire   [1:0] zext_ln218_11_fu_3034_p1;
wire   [1:0] add_ln840_10_fu_3130_p2;
wire   [1:0] zext_ln218_12_fu_3043_p1;
wire   [1:0] zext_ln840_fu_3052_p1;
wire   [1:0] add_ln840_11_fu_3140_p2;
wire   [2:0] zext_ln840_9_fu_3146_p1;
wire   [2:0] zext_ln840_8_fu_3136_p1;
wire   [3:0] zext_ln840_10_fu_3162_p1;
wire   [3:0] zext_ln840_7_fu_3159_p1;
wire   [3:0] add_ln840_13_fu_3165_p2;
wire   [3:0] zext_ln840_4_fu_3156_p1;
wire   [3:0] result_V_2_fu_3171_p2;
wire   [3:0] grp_fu_3182_p0;
wire  signed [13:0] grp_fu_3182_p2;
reg    grp_fu_3182_ce;
reg    ap_done_reg;
wire    ap_continue_int;
reg    ap_done_int;
reg    ap_loop_exit_ready_pp0_iter1_reg;
reg    ap_loop_exit_ready_pp0_iter2_reg;
reg    ap_loop_exit_ready_pp0_iter3_reg;
reg    ap_loop_exit_ready_pp0_iter4_reg;
reg    ap_loop_exit_ready_pp0_iter5_reg;
reg    ap_loop_exit_ready_pp0_iter6_reg;
reg   [0:0] ap_NS_iter0_fsm;
reg   [1:0] ap_NS_iter1_fsm;
reg   [1:0] ap_NS_iter2_fsm;
reg   [1:0] ap_NS_iter3_fsm;
reg   [1:0] ap_NS_iter4_fsm;
reg   [1:0] ap_NS_iter5_fsm;
reg   [1:0] ap_NS_iter6_fsm;
reg    ap_ST_iter0_fsm_state1_blk;
wire    ap_ST_iter1_fsm_state2_blk;
wire    ap_ST_iter2_fsm_state3_blk;
wire    ap_ST_iter3_fsm_state4_blk;
wire    ap_ST_iter4_fsm_state5_blk;
wire    ap_ST_iter5_fsm_state6_blk;
reg    ap_ST_iter6_fsm_state7_blk;
wire    ap_start_int;
wire   [7:0] grp_fu_3182_p00;
reg    ap_condition_2547;
wire    ap_ce_reg;

// power-on initialization
initial begin
#0 ap_CS_iter0_fsm = 1'd1;
#0 ap_CS_iter1_fsm = 2'd1;
#0 ap_CS_iter2_fsm = 2'd1;
#0 ap_CS_iter3_fsm = 2'd1;
#0 ap_CS_iter4_fsm = 2'd1;
#0 ap_CS_iter5_fsm = 2'd1;
#0 ap_CS_iter6_fsm = 2'd1;
#0 ap_done_reg = 1'b0;
end

MVAU_hls_1_Matrix_Vector_Activate_Stream_Batch_p_ZL7threshs_0_ROM_AUTO_1R #(
    .DataWidth( 10 ),
    .AddressRange( 32 ),
    .AddressWidth( 5 ))
p_ZL7threshs_0_U(
    .clk(ap_clk),
    .reset(ap_rst),
    .address0(p_ZL7threshs_0_address0),
    .ce0(p_ZL7threshs_0_ce0),
    .q0(p_ZL7threshs_0_q0)
);

MVAU_hls_1_Matrix_Vector_Activate_Stream_Batch_p_ZL7threshs_1_ROM_AUTO_1R #(
    .DataWidth( 10 ),
    .AddressRange( 32 ),
    .AddressWidth( 5 ))
p_ZL7threshs_1_U(
    .clk(ap_clk),
    .reset(ap_rst),
    .address0(p_ZL7threshs_1_address0),
    .ce0(p_ZL7threshs_1_ce0),
    .q0(p_ZL7threshs_1_q0)
);

MVAU_hls_1_Matrix_Vector_Activate_Stream_Batch_p_ZL7threshs_2_ROM_AUTO_1R #(
    .DataWidth( 10 ),
    .AddressRange( 32 ),
    .AddressWidth( 5 ))
p_ZL7threshs_2_U(
    .clk(ap_clk),
    .reset(ap_rst),
    .address0(p_ZL7threshs_2_address0),
    .ce0(p_ZL7threshs_2_ce0),
    .q0(p_ZL7threshs_2_q0)
);

MVAU_hls_1_Matrix_Vector_Activate_Stream_Batch_p_ZL7threshs_3_ROM_AUTO_1R #(
    .DataWidth( 10 ),
    .AddressRange( 32 ),
    .AddressWidth( 5 ))
p_ZL7threshs_3_U(
    .clk(ap_clk),
    .reset(ap_rst),
    .address0(p_ZL7threshs_3_address0),
    .ce0(p_ZL7threshs_3_ce0),
    .q0(p_ZL7threshs_3_q0)
);

MVAU_hls_1_Matrix_Vector_Activate_Stream_Batch_p_ZL7threshs_4_ROM_AUTO_1R #(
    .DataWidth( 10 ),
    .AddressRange( 32 ),
    .AddressWidth( 5 ))
p_ZL7threshs_4_U(
    .clk(ap_clk),
    .reset(ap_rst),
    .address0(p_ZL7threshs_4_address0),
    .ce0(p_ZL7threshs_4_ce0),
    .q0(p_ZL7threshs_4_q0)
);

MVAU_hls_1_Matrix_Vector_Activate_Stream_Batch_p_ZL7threshs_5_ROM_AUTO_1R #(
    .DataWidth( 10 ),
    .AddressRange( 32 ),
    .AddressWidth( 5 ))
p_ZL7threshs_5_U(
    .clk(ap_clk),
    .reset(ap_rst),
    .address0(p_ZL7threshs_5_address0),
    .ce0(p_ZL7threshs_5_ce0),
    .q0(p_ZL7threshs_5_q0)
);

MVAU_hls_1_Matrix_Vector_Activate_Stream_Batch_p_ZL7threshs_6_ROM_AUTO_1R #(
    .DataWidth( 11 ),
    .AddressRange( 32 ),
    .AddressWidth( 5 ))
p_ZL7threshs_6_U(
    .clk(ap_clk),
    .reset(ap_rst),
    .address0(p_ZL7threshs_6_address0),
    .ce0(p_ZL7threshs_6_ce0),
    .q0(p_ZL7threshs_6_q0)
);

MVAU_hls_1_Matrix_Vector_Activate_Stream_Batch_p_ZL7threshs_7_ROM_AUTO_1R #(
    .DataWidth( 11 ),
    .AddressRange( 32 ),
    .AddressWidth( 5 ))
p_ZL7threshs_7_U(
    .clk(ap_clk),
    .reset(ap_rst),
    .address0(p_ZL7threshs_7_address0),
    .ce0(p_ZL7threshs_7_ce0),
    .q0(p_ZL7threshs_7_q0)
);

MVAU_hls_1_Matrix_Vector_Activate_Stream_Batch_p_ZL7threshs_8_ROM_AUTO_1R #(
    .DataWidth( 10 ),
    .AddressRange( 32 ),
    .AddressWidth( 5 ))
p_ZL7threshs_8_U(
    .clk(ap_clk),
    .reset(ap_rst),
    .address0(p_ZL7threshs_8_address0),
    .ce0(p_ZL7threshs_8_ce0),
    .q0(p_ZL7threshs_8_q0)
);

MVAU_hls_1_Matrix_Vector_Activate_Stream_Batch_p_ZL7threshs_9_ROM_AUTO_1R #(
    .DataWidth( 10 ),
    .AddressRange( 32 ),
    .AddressWidth( 5 ))
p_ZL7threshs_9_U(
    .clk(ap_clk),
    .reset(ap_rst),
    .address0(p_ZL7threshs_9_address0),
    .ce0(p_ZL7threshs_9_ce0),
    .q0(p_ZL7threshs_9_q0)
);

MVAU_hls_1_Matrix_Vector_Activate_Stream_Batch_p_ZL7threshs_10_ROM_AUTO_1R #(
    .DataWidth( 10 ),
    .AddressRange( 32 ),
    .AddressWidth( 5 ))
p_ZL7threshs_10_U(
    .clk(ap_clk),
    .reset(ap_rst),
    .address0(p_ZL7threshs_10_address0),
    .ce0(p_ZL7threshs_10_ce0),
    .q0(p_ZL7threshs_10_q0)
);

MVAU_hls_1_Matrix_Vector_Activate_Stream_Batch_p_ZL7threshs_11_ROM_AUTO_1R #(
    .DataWidth( 10 ),
    .AddressRange( 32 ),
    .AddressWidth( 5 ))
p_ZL7threshs_11_U(
    .clk(ap_clk),
    .reset(ap_rst),
    .address0(p_ZL7threshs_11_address0),
    .ce0(p_ZL7threshs_11_ce0),
    .q0(p_ZL7threshs_11_q0)
);

MVAU_hls_1_Matrix_Vector_Activate_Stream_Batch_p_ZL7threshs_12_ROM_AUTO_1R #(
    .DataWidth( 10 ),
    .AddressRange( 32 ),
    .AddressWidth( 5 ))
p_ZL7threshs_12_U(
    .clk(ap_clk),
    .reset(ap_rst),
    .address0(p_ZL7threshs_12_address0),
    .ce0(p_ZL7threshs_12_ce0),
    .q0(p_ZL7threshs_12_q0)
);

MVAU_hls_1_Matrix_Vector_Activate_Stream_Batch_p_ZL7threshs_13_ROM_AUTO_1R #(
    .DataWidth( 10 ),
    .AddressRange( 32 ),
    .AddressWidth( 5 ))
p_ZL7threshs_13_U(
    .clk(ap_clk),
    .reset(ap_rst),
    .address0(p_ZL7threshs_13_address0),
    .ce0(p_ZL7threshs_13_ce0),
    .q0(p_ZL7threshs_13_q0)
);

MVAU_hls_1_Matrix_Vector_Activate_Stream_Batch_p_ZL7threshs_14_ROM_AUTO_1R #(
    .DataWidth( 10 ),
    .AddressRange( 32 ),
    .AddressWidth( 5 ))
p_ZL7threshs_14_U(
    .clk(ap_clk),
    .reset(ap_rst),
    .address0(p_ZL7threshs_14_address0),
    .ce0(p_ZL7threshs_14_ce0),
    .q0(p_ZL7threshs_14_q0)
);

MVAU_hls_1_mux_1448_4_1_1 #(
    .ID( 1 ),
    .NUM_STAGE( 1 ),
    .din0_WIDTH( 4 ),
    .din1_WIDTH( 4 ),
    .din2_WIDTH( 4 ),
    .din3_WIDTH( 4 ),
    .din4_WIDTH( 4 ),
    .din5_WIDTH( 4 ),
    .din6_WIDTH( 4 ),
    .din7_WIDTH( 4 ),
    .din8_WIDTH( 4 ),
    .din9_WIDTH( 4 ),
    .din10_WIDTH( 4 ),
    .din11_WIDTH( 4 ),
    .din12_WIDTH( 4 ),
    .din13_WIDTH( 4 ),
    .din14_WIDTH( 4 ),
    .din15_WIDTH( 4 ),
    .din16_WIDTH( 4 ),
    .din17_WIDTH( 4 ),
    .din18_WIDTH( 4 ),
    .din19_WIDTH( 4 ),
    .din20_WIDTH( 4 ),
    .din21_WIDTH( 4 ),
    .din22_WIDTH( 4 ),
    .din23_WIDTH( 4 ),
    .din24_WIDTH( 4 ),
    .din25_WIDTH( 4 ),
    .din26_WIDTH( 4 ),
    .din27_WIDTH( 4 ),
    .din28_WIDTH( 4 ),
    .din29_WIDTH( 4 ),
    .din30_WIDTH( 4 ),
    .din31_WIDTH( 4 ),
    .din32_WIDTH( 4 ),
    .din33_WIDTH( 4 ),
    .din34_WIDTH( 4 ),
    .din35_WIDTH( 4 ),
    .din36_WIDTH( 4 ),
    .din37_WIDTH( 4 ),
    .din38_WIDTH( 4 ),
    .din39_WIDTH( 4 ),
    .din40_WIDTH( 4 ),
    .din41_WIDTH( 4 ),
    .din42_WIDTH( 4 ),
    .din43_WIDTH( 4 ),
    .din44_WIDTH( 4 ),
    .din45_WIDTH( 4 ),
    .din46_WIDTH( 4 ),
    .din47_WIDTH( 4 ),
    .din48_WIDTH( 4 ),
    .din49_WIDTH( 4 ),
    .din50_WIDTH( 4 ),
    .din51_WIDTH( 4 ),
    .din52_WIDTH( 4 ),
    .din53_WIDTH( 4 ),
    .din54_WIDTH( 4 ),
    .din55_WIDTH( 4 ),
    .din56_WIDTH( 4 ),
    .din57_WIDTH( 4 ),
    .din58_WIDTH( 4 ),
    .din59_WIDTH( 4 ),
    .din60_WIDTH( 4 ),
    .din61_WIDTH( 4 ),
    .din62_WIDTH( 4 ),
    .din63_WIDTH( 4 ),
    .din64_WIDTH( 4 ),
    .din65_WIDTH( 4 ),
    .din66_WIDTH( 4 ),
    .din67_WIDTH( 4 ),
    .din68_WIDTH( 4 ),
    .din69_WIDTH( 4 ),
    .din70_WIDTH( 4 ),
    .din71_WIDTH( 4 ),
    .din72_WIDTH( 4 ),
    .din73_WIDTH( 4 ),
    .din74_WIDTH( 4 ),
    .din75_WIDTH( 4 ),
    .din76_WIDTH( 4 ),
    .din77_WIDTH( 4 ),
    .din78_WIDTH( 4 ),
    .din79_WIDTH( 4 ),
    .din80_WIDTH( 4 ),
    .din81_WIDTH( 4 ),
    .din82_WIDTH( 4 ),
    .din83_WIDTH( 4 ),
    .din84_WIDTH( 4 ),
    .din85_WIDTH( 4 ),
    .din86_WIDTH( 4 ),
    .din87_WIDTH( 4 ),
    .din88_WIDTH( 4 ),
    .din89_WIDTH( 4 ),
    .din90_WIDTH( 4 ),
    .din91_WIDTH( 4 ),
    .din92_WIDTH( 4 ),
    .din93_WIDTH( 4 ),
    .din94_WIDTH( 4 ),
    .din95_WIDTH( 4 ),
    .din96_WIDTH( 4 ),
    .din97_WIDTH( 4 ),
    .din98_WIDTH( 4 ),
    .din99_WIDTH( 4 ),
    .din100_WIDTH( 4 ),
    .din101_WIDTH( 4 ),
    .din102_WIDTH( 4 ),
    .din103_WIDTH( 4 ),
    .din104_WIDTH( 4 ),
    .din105_WIDTH( 4 ),
    .din106_WIDTH( 4 ),
    .din107_WIDTH( 4 ),
    .din108_WIDTH( 4 ),
    .din109_WIDTH( 4 ),
    .din110_WIDTH( 4 ),
    .din111_WIDTH( 4 ),
    .din112_WIDTH( 4 ),
    .din113_WIDTH( 4 ),
    .din114_WIDTH( 4 ),
    .din115_WIDTH( 4 ),
    .din116_WIDTH( 4 ),
    .din117_WIDTH( 4 ),
    .din118_WIDTH( 4 ),
    .din119_WIDTH( 4 ),
    .din120_WIDTH( 4 ),
    .din121_WIDTH( 4 ),
    .din122_WIDTH( 4 ),
    .din123_WIDTH( 4 ),
    .din124_WIDTH( 4 ),
    .din125_WIDTH( 4 ),
    .din126_WIDTH( 4 ),
    .din127_WIDTH( 4 ),
    .din128_WIDTH( 4 ),
    .din129_WIDTH( 4 ),
    .din130_WIDTH( 4 ),
    .din131_WIDTH( 4 ),
    .din132_WIDTH( 4 ),
    .din133_WIDTH( 4 ),
    .din134_WIDTH( 4 ),
    .din135_WIDTH( 4 ),
    .din136_WIDTH( 4 ),
    .din137_WIDTH( 4 ),
    .din138_WIDTH( 4 ),
    .din139_WIDTH( 4 ),
    .din140_WIDTH( 4 ),
    .din141_WIDTH( 4 ),
    .din142_WIDTH( 4 ),
    .din143_WIDTH( 4 ),
    .din144_WIDTH( 8 ),
    .dout_WIDTH( 4 ))
mux_1448_4_1_1_U1(
    .din0(inputBuf_V_fu_382),
    .din1(inputBuf_V_1_fu_386),
    .din2(inputBuf_V_2_fu_390),
    .din3(inputBuf_V_3_fu_394),
    .din4(inputBuf_V_4_fu_398),
    .din5(inputBuf_V_5_fu_402),
    .din6(inputBuf_V_6_fu_406),
    .din7(inputBuf_V_7_fu_410),
    .din8(inputBuf_V_8_fu_414),
    .din9(inputBuf_V_9_fu_418),
    .din10(inputBuf_V_10_fu_422),
    .din11(inputBuf_V_11_fu_426),
    .din12(inputBuf_V_12_fu_430),
    .din13(inputBuf_V_13_fu_434),
    .din14(inputBuf_V_14_fu_438),
    .din15(inputBuf_V_15_fu_442),
    .din16(inputBuf_V_16_fu_446),
    .din17(inputBuf_V_17_fu_450),
    .din18(inputBuf_V_18_fu_454),
    .din19(inputBuf_V_19_fu_458),
    .din20(inputBuf_V_20_fu_462),
    .din21(inputBuf_V_21_fu_466),
    .din22(inputBuf_V_22_fu_470),
    .din23(inputBuf_V_23_fu_474),
    .din24(inputBuf_V_24_fu_478),
    .din25(inputBuf_V_25_fu_482),
    .din26(inputBuf_V_26_fu_486),
    .din27(inputBuf_V_27_fu_490),
    .din28(inputBuf_V_28_fu_494),
    .din29(inputBuf_V_29_fu_498),
    .din30(inputBuf_V_30_fu_502),
    .din31(inputBuf_V_31_fu_506),
    .din32(inputBuf_V_32_fu_510),
    .din33(inputBuf_V_33_fu_514),
    .din34(inputBuf_V_34_fu_518),
    .din35(inputBuf_V_35_fu_522),
    .din36(inputBuf_V_36_fu_526),
    .din37(inputBuf_V_37_fu_530),
    .din38(inputBuf_V_38_fu_534),
    .din39(inputBuf_V_39_fu_538),
    .din40(inputBuf_V_40_fu_542),
    .din41(inputBuf_V_41_fu_546),
    .din42(inputBuf_V_42_fu_550),
    .din43(inputBuf_V_43_fu_554),
    .din44(inputBuf_V_44_fu_558),
    .din45(inputBuf_V_45_fu_562),
    .din46(inputBuf_V_46_fu_566),
    .din47(inputBuf_V_47_fu_570),
    .din48(inputBuf_V_48_fu_574),
    .din49(inputBuf_V_49_fu_578),
    .din50(inputBuf_V_50_fu_582),
    .din51(inputBuf_V_51_fu_586),
    .din52(inputBuf_V_52_fu_590),
    .din53(inputBuf_V_53_fu_594),
    .din54(inputBuf_V_54_fu_598),
    .din55(inputBuf_V_55_fu_602),
    .din56(inputBuf_V_56_fu_606),
    .din57(inputBuf_V_57_fu_610),
    .din58(inputBuf_V_58_fu_614),
    .din59(inputBuf_V_59_fu_618),
    .din60(inputBuf_V_60_fu_622),
    .din61(inputBuf_V_61_fu_626),
    .din62(inputBuf_V_62_fu_630),
    .din63(inputBuf_V_63_fu_634),
    .din64(inputBuf_V_64_fu_638),
    .din65(inputBuf_V_65_fu_642),
    .din66(inputBuf_V_66_fu_646),
    .din67(inputBuf_V_67_fu_650),
    .din68(inputBuf_V_68_fu_654),
    .din69(inputBuf_V_69_fu_658),
    .din70(inputBuf_V_70_fu_662),
    .din71(inputBuf_V_71_fu_666),
    .din72(inputBuf_V_72_fu_670),
    .din73(inputBuf_V_73_fu_674),
    .din74(inputBuf_V_74_fu_678),
    .din75(inputBuf_V_75_fu_682),
    .din76(inputBuf_V_76_fu_686),
    .din77(inputBuf_V_77_fu_690),
    .din78(inputBuf_V_78_fu_694),
    .din79(inputBuf_V_79_fu_698),
    .din80(inputBuf_V_80_fu_702),
    .din81(inputBuf_V_81_fu_706),
    .din82(inputBuf_V_82_fu_710),
    .din83(inputBuf_V_83_fu_714),
    .din84(inputBuf_V_84_fu_718),
    .din85(inputBuf_V_85_fu_722),
    .din86(inputBuf_V_86_fu_726),
    .din87(inputBuf_V_87_fu_730),
    .din88(inputBuf_V_88_fu_734),
    .din89(inputBuf_V_89_fu_738),
    .din90(inputBuf_V_90_fu_742),
    .din91(inputBuf_V_91_fu_746),
    .din92(inputBuf_V_92_fu_750),
    .din93(inputBuf_V_93_fu_754),
    .din94(inputBuf_V_94_fu_758),
    .din95(inputBuf_V_95_fu_762),
    .din96(inputBuf_V_96_fu_766),
    .din97(inputBuf_V_97_fu_770),
    .din98(inputBuf_V_98_fu_774),
    .din99(inputBuf_V_99_fu_778),
    .din100(inputBuf_V_100_fu_782),
    .din101(inputBuf_V_101_fu_786),
    .din102(inputBuf_V_102_fu_790),
    .din103(inputBuf_V_103_fu_794),
    .din104(inputBuf_V_104_fu_798),
    .din105(inputBuf_V_105_fu_802),
    .din106(inputBuf_V_106_fu_806),
    .din107(inputBuf_V_107_fu_810),
    .din108(inputBuf_V_108_fu_814),
    .din109(inputBuf_V_109_fu_818),
    .din110(inputBuf_V_110_fu_822),
    .din111(inputBuf_V_111_fu_826),
    .din112(inputBuf_V_112_fu_830),
    .din113(inputBuf_V_113_fu_834),
    .din114(inputBuf_V_114_fu_838),
    .din115(inputBuf_V_115_fu_842),
    .din116(inputBuf_V_116_fu_846),
    .din117(inputBuf_V_117_fu_850),
    .din118(inputBuf_V_118_fu_854),
    .din119(inputBuf_V_119_fu_858),
    .din120(inputBuf_V_120_fu_862),
    .din121(inputBuf_V_121_fu_866),
    .din122(inputBuf_V_122_fu_870),
    .din123(inputBuf_V_123_fu_874),
    .din124(inputBuf_V_124_fu_878),
    .din125(inputBuf_V_125_fu_882),
    .din126(inputBuf_V_126_fu_886),
    .din127(inputBuf_V_127_fu_890),
    .din128(inputBuf_V_128_fu_894),
    .din129(inputBuf_V_129_fu_898),
    .din130(inputBuf_V_130_fu_902),
    .din131(inputBuf_V_131_fu_906),
    .din132(inputBuf_V_132_fu_910),
    .din133(inputBuf_V_133_fu_914),
    .din134(inputBuf_V_134_fu_918),
    .din135(inputBuf_V_135_fu_922),
    .din136(inputBuf_V_136_fu_926),
    .din137(inputBuf_V_137_fu_930),
    .din138(inputBuf_V_138_fu_934),
    .din139(inputBuf_V_139_fu_938),
    .din140(inputBuf_V_140_fu_942),
    .din141(inputBuf_V_141_fu_946),
    .din142(inputBuf_V_142_fu_950),
    .din143(inputBuf_V_143_fu_954),
    .din144(tmp_fu_1663_p145),
    .dout(tmp_fu_1663_p146)
);

MVAU_hls_1_mac_muladd_4ns_4s_14s_14_4_1 #(
    .ID( 1 ),
    .NUM_STAGE( 4 ),
    .din0_WIDTH( 4 ),
    .din1_WIDTH( 4 ),
    .din2_WIDTH( 14 ),
    .dout_WIDTH( 14 ))
mac_muladd_4ns_4s_14s_14_4_1_U2(
    .clk(ap_clk),
    .reset(ap_rst),
    .din0(grp_fu_3182_p0),
    .din1(W_packed_V_reg_4124),
    .din2(grp_fu_3182_p2),
    .ce(grp_fu_3182_ce),
    .dout(grp_fu_3182_p3)
);

MVAU_hls_1_flow_control_loop_pipe_sequential_init flow_control_loop_pipe_sequential_init_U(
    .ap_clk(ap_clk),
    .ap_rst(ap_rst),
    .ap_start(ap_start),
    .ap_ready(ap_ready),
    .ap_done(ap_done),
    .ap_start_int(ap_start_int),
    .ap_loop_init(ap_loop_init),
    .ap_ready_int(ap_ready_int),
    .ap_loop_exit_ready(ap_condition_exit_pp0_iter0_stage0),
    .ap_loop_exit_done(ap_done_int),
    .ap_continue_int(ap_continue_int),
    .ap_done_int(ap_done_int)
);

always @ (posedge ap_clk) begin
    if (ap_rst == 1'b1) begin
        ap_CS_iter0_fsm <= ap_ST_iter0_fsm_state1;
    end else begin
        ap_CS_iter0_fsm <= ap_NS_iter0_fsm;
    end
end

always @ (posedge ap_clk) begin
    if (ap_rst == 1'b1) begin
        ap_CS_iter1_fsm <= ap_ST_iter1_fsm_state0;
    end else begin
        ap_CS_iter1_fsm <= ap_NS_iter1_fsm;
    end
end

always @ (posedge ap_clk) begin
    if (ap_rst == 1'b1) begin
        ap_CS_iter2_fsm <= ap_ST_iter2_fsm_state0;
    end else begin
        ap_CS_iter2_fsm <= ap_NS_iter2_fsm;
    end
end

always @ (posedge ap_clk) begin
    if (ap_rst == 1'b1) begin
        ap_CS_iter3_fsm <= ap_ST_iter3_fsm_state0;
    end else begin
        ap_CS_iter3_fsm <= ap_NS_iter3_fsm;
    end
end

always @ (posedge ap_clk) begin
    if (ap_rst == 1'b1) begin
        ap_CS_iter4_fsm <= ap_ST_iter4_fsm_state0;
    end else begin
        ap_CS_iter4_fsm <= ap_NS_iter4_fsm;
    end
end

always @ (posedge ap_clk) begin
    if (ap_rst == 1'b1) begin
        ap_CS_iter5_fsm <= ap_ST_iter5_fsm_state0;
    end else begin
        ap_CS_iter5_fsm <= ap_NS_iter5_fsm;
    end
end

always @ (posedge ap_clk) begin
    if (ap_rst == 1'b1) begin
        ap_CS_iter6_fsm <= ap_ST_iter6_fsm_state0;
    end else begin
        ap_CS_iter6_fsm <= ap_NS_iter6_fsm;
    end
end

always @ (posedge ap_clk) begin
    if (ap_rst == 1'b1) begin
        ap_done_reg <= 1'b0;
    end else begin
        if ((ap_continue_int == 1'b1)) begin
            ap_done_reg <= 1'b0;
        end else if ((~((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))) & (1'b1 == ap_CS_iter6_fsm_state7) & (ap_loop_exit_ready_pp0_iter6_reg == 1'b1))) begin
            ap_done_reg <= 1'b1;
        end
    end
end

always @ (posedge ap_clk) begin
    if ((~((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))) & (1'b1 == ap_CS_iter6_fsm_state7) & (ap_loop_exit_ready_pp0_iter5_reg == 1'b0))) begin
        ap_loop_exit_ready_pp0_iter6_reg <= 1'b0;
    end else if ((~((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0)))) & (1'b1 == ap_CS_iter5_fsm_state6))) begin
        ap_loop_exit_ready_pp0_iter6_reg <= ap_loop_exit_ready_pp0_iter5_reg;
    end
end

always @ (posedge ap_clk) begin
    if ((1'b1 == ap_condition_2547)) begin
        if (((icmp_ln253_fu_1221_p2 == 1'd0) & (icmp_ln249_fu_1209_p2 == 1'd0))) begin
            ap_phi_reg_pp0_iter1_inElem_1_reg_1176 <= tmp_fu_1663_p146;
        end else if ((1'b1 == 1'b1)) begin
            ap_phi_reg_pp0_iter1_inElem_1_reg_1176 <= ap_phi_reg_pp0_iter0_inElem_1_reg_1176;
        end
    end
end

always @ (posedge ap_clk) begin
    if ((1'b1 == ap_condition_2547)) begin
        if ((icmp_ln249_fu_1209_p2 == 1'd0)) begin
            i_fu_374 <= i_2_fu_1215_p2;
        end else if ((ap_loop_init == 1'b1)) begin
            i_fu_374 <= 20'd0;
        end
    end
end

always @ (posedge ap_clk) begin
    if ((1'b1 == ap_condition_2547)) begin
        if (((icmp_ln249_fu_1209_p2 == 1'd0) & (icmp_ln290_fu_2701_p2 == 1'd1))) begin
            nf_1_fu_958 <= nf_3_fu_2724_p3;
        end else if ((ap_loop_init == 1'b1)) begin
            nf_1_fu_958 <= 32'd0;
        end
    end
end

always @ (posedge ap_clk) begin
    if ((1'b1 == ap_condition_2547)) begin
        if (((icmp_ln249_fu_1209_p2 == 1'd0) & (icmp_ln290_fu_2701_p2 == 1'd1))) begin
            sf_fu_370 <= 32'd0;
        end else if (((icmp_ln249_fu_1209_p2 == 1'd0) & (icmp_ln290_fu_2701_p2 == 1'd0))) begin
            sf_fu_370 <= sf_2_fu_2695_p2;
        end else if ((ap_loop_init == 1'b1)) begin
            sf_fu_370 <= 32'd0;
        end
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_1209_p2 == 1'd0)) | ((ap_predicate_op323_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_1209_p2 == 1'd0))) begin
        W_packed_V_reg_4124 <= W_packed_V_fu_2685_p1;
        icmp_ln253_reg_4107 <= icmp_ln253_fu_1221_p2;
        icmp_ln272_reg_4129 <= icmp_ln272_fu_2689_p2;
        icmp_ln290_reg_4134 <= icmp_ln290_fu_2701_p2;
    end
end

always @ (posedge ap_clk) begin
    if ((~((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0)))) & (1'b1 == ap_CS_iter4_fsm_state5) & (icmp_ln249_reg_4103_pp0_iter3_reg == 1'd0))) begin
        add_i4_i338_fu_378 <= grp_fu_3182_p3;
    end
end

always @ (posedge ap_clk) begin
    if ((~((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0)))) & (1'b1 == ap_CS_iter5_fsm_state6) & (icmp_ln290_reg_4134_pp0_iter4_reg == 1'd1) & (icmp_ln249_reg_4103_pp0_iter4_reg == 1'd0))) begin
        add_ln840_12_reg_4313 <= add_ln840_12_fu_3150_p2;
        add_ln840_6_reg_4303 <= add_ln840_6_fu_3098_p2;
        add_ln840_9_reg_4308 <= add_ln840_9_fu_3124_p2;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_1209_p2 == 1'd0)) | ((ap_predicate_op323_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (1'b1 == ap_CS_iter0_fsm_state1))) begin
        ap_loop_exit_ready_pp0_iter1_reg <= ap_loop_exit_ready;
        icmp_ln249_reg_4103 <= icmp_ln249_fu_1209_p2;
        nf_2_reg_4098 <= ap_sig_allocacmp_nf_2;
    end
end

always @ (posedge ap_clk) begin
    if ((~((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0)))) & (1'b1 == ap_CS_iter1_fsm_state2))) begin
        ap_loop_exit_ready_pp0_iter2_reg <= ap_loop_exit_ready_pp0_iter1_reg;
        icmp_ln249_reg_4103_pp0_iter1_reg <= icmp_ln249_reg_4103;
        icmp_ln272_reg_4129_pp0_iter1_reg <= icmp_ln272_reg_4129;
        icmp_ln290_reg_4134_pp0_iter1_reg <= icmp_ln290_reg_4134;
        nf_2_reg_4098_pp0_iter1_reg <= nf_2_reg_4098;
    end
end

always @ (posedge ap_clk) begin
    if ((~((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0)))) & (1'b1 == ap_CS_iter2_fsm_state3))) begin
        ap_loop_exit_ready_pp0_iter3_reg <= ap_loop_exit_ready_pp0_iter2_reg;
        icmp_ln249_reg_4103_pp0_iter2_reg <= icmp_ln249_reg_4103_pp0_iter1_reg;
        icmp_ln272_reg_4129_pp0_iter2_reg <= icmp_ln272_reg_4129_pp0_iter1_reg;
        icmp_ln290_reg_4134_pp0_iter2_reg <= icmp_ln290_reg_4134_pp0_iter1_reg;
        nf_2_reg_4098_pp0_iter2_reg <= nf_2_reg_4098_pp0_iter1_reg;
    end
end

always @ (posedge ap_clk) begin
    if ((~((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0)))) & (1'b1 == ap_CS_iter3_fsm_state4))) begin
        ap_loop_exit_ready_pp0_iter4_reg <= ap_loop_exit_ready_pp0_iter3_reg;
        icmp_ln249_reg_4103_pp0_iter3_reg <= icmp_ln249_reg_4103_pp0_iter2_reg;
        icmp_ln290_reg_4134_pp0_iter3_reg <= icmp_ln290_reg_4134_pp0_iter2_reg;
    end
end

always @ (posedge ap_clk) begin
    if ((~((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0)))) & (1'b1 == ap_CS_iter4_fsm_state5))) begin
        ap_loop_exit_ready_pp0_iter5_reg <= ap_loop_exit_ready_pp0_iter4_reg;
        icmp_ln249_reg_4103_pp0_iter4_reg <= icmp_ln249_reg_4103_pp0_iter3_reg;
        icmp_ln290_reg_4134_pp0_iter4_reg <= icmp_ln290_reg_4134_pp0_iter3_reg;
    end
end

always @ (posedge ap_clk) begin
    if ((~((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0)))) & (1'b1 == ap_CS_iter4_fsm_state5) & (icmp_ln290_reg_4134_pp0_iter3_reg == 1'd1) & (icmp_ln249_reg_4103_pp0_iter3_reg == 1'd0))) begin
        icmp_ln1039_10_reg_4278 <= icmp_ln1039_10_fu_2876_p2;
        icmp_ln1039_11_reg_4283 <= icmp_ln1039_11_fu_2885_p2;
        icmp_ln1039_12_reg_4288 <= icmp_ln1039_12_fu_2894_p2;
        icmp_ln1039_13_reg_4293 <= icmp_ln1039_13_fu_2903_p2;
        icmp_ln1039_14_reg_4298 <= icmp_ln1039_14_fu_2912_p2;
        icmp_ln1039_1_reg_4233 <= icmp_ln1039_1_fu_2795_p2;
        icmp_ln1039_2_reg_4238 <= icmp_ln1039_2_fu_2804_p2;
        icmp_ln1039_3_reg_4243 <= icmp_ln1039_3_fu_2813_p2;
        icmp_ln1039_4_reg_4248 <= icmp_ln1039_4_fu_2822_p2;
        icmp_ln1039_5_reg_4253 <= icmp_ln1039_5_fu_2831_p2;
        icmp_ln1039_6_reg_4258 <= icmp_ln1039_6_fu_2840_p2;
        icmp_ln1039_7_reg_4263 <= icmp_ln1039_7_fu_2849_p2;
        icmp_ln1039_8_reg_4268 <= icmp_ln1039_8_fu_2858_p2;
        icmp_ln1039_9_reg_4273 <= icmp_ln1039_9_fu_2867_p2;
        icmp_ln1039_reg_4228 <= icmp_ln1039_fu_2786_p2;
    end
end

always @ (posedge ap_clk) begin
    if ((~((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0)))) & (1'b1 == ap_CS_iter5_fsm_state6))) begin
        icmp_ln249_reg_4103_pp0_iter5_reg <= icmp_ln249_reg_4103_pp0_iter4_reg;
        icmp_ln290_reg_4134_pp0_iter5_reg <= icmp_ln290_reg_4134_pp0_iter4_reg;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_1209_p2 == 1'd0)) | ((ap_predicate_op323_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_1221_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_1209_p2 == 1'd0))) begin
        inElem_reg_4116 <= inElem_fu_1957_p1;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_1209_p2 == 1'd0)) | ((ap_predicate_op323_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_1221_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_1209_p2 == 1'd0) & (trunc_ln257_fu_1961_p1 == 8'd100))) begin
        inputBuf_V_100_fu_782 <= inElem_fu_1957_p1;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_1209_p2 == 1'd0)) | ((ap_predicate_op323_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_1221_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_1209_p2 == 1'd0) & (trunc_ln257_fu_1961_p1 == 8'd101))) begin
        inputBuf_V_101_fu_786 <= inElem_fu_1957_p1;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_1209_p2 == 1'd0)) | ((ap_predicate_op323_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_1221_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_1209_p2 == 1'd0) & (trunc_ln257_fu_1961_p1 == 8'd102))) begin
        inputBuf_V_102_fu_790 <= inElem_fu_1957_p1;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_1209_p2 == 1'd0)) | ((ap_predicate_op323_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_1221_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_1209_p2 == 1'd0) & (trunc_ln257_fu_1961_p1 == 8'd103))) begin
        inputBuf_V_103_fu_794 <= inElem_fu_1957_p1;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_1209_p2 == 1'd0)) | ((ap_predicate_op323_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_1221_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_1209_p2 == 1'd0) & (trunc_ln257_fu_1961_p1 == 8'd104))) begin
        inputBuf_V_104_fu_798 <= inElem_fu_1957_p1;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_1209_p2 == 1'd0)) | ((ap_predicate_op323_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_1221_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_1209_p2 == 1'd0) & (trunc_ln257_fu_1961_p1 == 8'd105))) begin
        inputBuf_V_105_fu_802 <= inElem_fu_1957_p1;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_1209_p2 == 1'd0)) | ((ap_predicate_op323_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_1221_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_1209_p2 == 1'd0) & (trunc_ln257_fu_1961_p1 == 8'd106))) begin
        inputBuf_V_106_fu_806 <= inElem_fu_1957_p1;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_1209_p2 == 1'd0)) | ((ap_predicate_op323_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_1221_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_1209_p2 == 1'd0) & (trunc_ln257_fu_1961_p1 == 8'd107))) begin
        inputBuf_V_107_fu_810 <= inElem_fu_1957_p1;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_1209_p2 == 1'd0)) | ((ap_predicate_op323_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_1221_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_1209_p2 == 1'd0) & (trunc_ln257_fu_1961_p1 == 8'd108))) begin
        inputBuf_V_108_fu_814 <= inElem_fu_1957_p1;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_1209_p2 == 1'd0)) | ((ap_predicate_op323_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_1221_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_1209_p2 == 1'd0) & (trunc_ln257_fu_1961_p1 == 8'd109))) begin
        inputBuf_V_109_fu_818 <= inElem_fu_1957_p1;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_1209_p2 == 1'd0)) | ((ap_predicate_op323_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_1221_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_1209_p2 == 1'd0) & (trunc_ln257_fu_1961_p1 == 8'd10))) begin
        inputBuf_V_10_fu_422 <= inElem_fu_1957_p1;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_1209_p2 == 1'd0)) | ((ap_predicate_op323_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_1221_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_1209_p2 == 1'd0) & (trunc_ln257_fu_1961_p1 == 8'd110))) begin
        inputBuf_V_110_fu_822 <= inElem_fu_1957_p1;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_1209_p2 == 1'd0)) | ((ap_predicate_op323_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_1221_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_1209_p2 == 1'd0) & (trunc_ln257_fu_1961_p1 == 8'd111))) begin
        inputBuf_V_111_fu_826 <= inElem_fu_1957_p1;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_1209_p2 == 1'd0)) | ((ap_predicate_op323_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_1221_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_1209_p2 == 1'd0) & (trunc_ln257_fu_1961_p1 == 8'd112))) begin
        inputBuf_V_112_fu_830 <= inElem_fu_1957_p1;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_1209_p2 == 1'd0)) | ((ap_predicate_op323_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_1221_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_1209_p2 == 1'd0) & (trunc_ln257_fu_1961_p1 == 8'd113))) begin
        inputBuf_V_113_fu_834 <= inElem_fu_1957_p1;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_1209_p2 == 1'd0)) | ((ap_predicate_op323_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_1221_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_1209_p2 == 1'd0) & (trunc_ln257_fu_1961_p1 == 8'd114))) begin
        inputBuf_V_114_fu_838 <= inElem_fu_1957_p1;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_1209_p2 == 1'd0)) | ((ap_predicate_op323_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_1221_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_1209_p2 == 1'd0) & (trunc_ln257_fu_1961_p1 == 8'd115))) begin
        inputBuf_V_115_fu_842 <= inElem_fu_1957_p1;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_1209_p2 == 1'd0)) | ((ap_predicate_op323_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_1221_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_1209_p2 == 1'd0) & (trunc_ln257_fu_1961_p1 == 8'd116))) begin
        inputBuf_V_116_fu_846 <= inElem_fu_1957_p1;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_1209_p2 == 1'd0)) | ((ap_predicate_op323_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_1221_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_1209_p2 == 1'd0) & (trunc_ln257_fu_1961_p1 == 8'd117))) begin
        inputBuf_V_117_fu_850 <= inElem_fu_1957_p1;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_1209_p2 == 1'd0)) | ((ap_predicate_op323_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_1221_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_1209_p2 == 1'd0) & (trunc_ln257_fu_1961_p1 == 8'd118))) begin
        inputBuf_V_118_fu_854 <= inElem_fu_1957_p1;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_1209_p2 == 1'd0)) | ((ap_predicate_op323_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_1221_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_1209_p2 == 1'd0) & (trunc_ln257_fu_1961_p1 == 8'd119))) begin
        inputBuf_V_119_fu_858 <= inElem_fu_1957_p1;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_1209_p2 == 1'd0)) | ((ap_predicate_op323_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_1221_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_1209_p2 == 1'd0) & (trunc_ln257_fu_1961_p1 == 8'd11))) begin
        inputBuf_V_11_fu_426 <= inElem_fu_1957_p1;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_1209_p2 == 1'd0)) | ((ap_predicate_op323_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_1221_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_1209_p2 == 1'd0) & (trunc_ln257_fu_1961_p1 == 8'd120))) begin
        inputBuf_V_120_fu_862 <= inElem_fu_1957_p1;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_1209_p2 == 1'd0)) | ((ap_predicate_op323_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_1221_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_1209_p2 == 1'd0) & (trunc_ln257_fu_1961_p1 == 8'd121))) begin
        inputBuf_V_121_fu_866 <= inElem_fu_1957_p1;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_1209_p2 == 1'd0)) | ((ap_predicate_op323_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_1221_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_1209_p2 == 1'd0) & (trunc_ln257_fu_1961_p1 == 8'd122))) begin
        inputBuf_V_122_fu_870 <= inElem_fu_1957_p1;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_1209_p2 == 1'd0)) | ((ap_predicate_op323_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_1221_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_1209_p2 == 1'd0) & (trunc_ln257_fu_1961_p1 == 8'd123))) begin
        inputBuf_V_123_fu_874 <= inElem_fu_1957_p1;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_1209_p2 == 1'd0)) | ((ap_predicate_op323_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_1221_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_1209_p2 == 1'd0) & (trunc_ln257_fu_1961_p1 == 8'd124))) begin
        inputBuf_V_124_fu_878 <= inElem_fu_1957_p1;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_1209_p2 == 1'd0)) | ((ap_predicate_op323_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_1221_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_1209_p2 == 1'd0) & (trunc_ln257_fu_1961_p1 == 8'd125))) begin
        inputBuf_V_125_fu_882 <= inElem_fu_1957_p1;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_1209_p2 == 1'd0)) | ((ap_predicate_op323_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_1221_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_1209_p2 == 1'd0) & (trunc_ln257_fu_1961_p1 == 8'd126))) begin
        inputBuf_V_126_fu_886 <= inElem_fu_1957_p1;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_1209_p2 == 1'd0)) | ((ap_predicate_op323_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_1221_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_1209_p2 == 1'd0) & (trunc_ln257_fu_1961_p1 == 8'd127))) begin
        inputBuf_V_127_fu_890 <= inElem_fu_1957_p1;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_1209_p2 == 1'd0)) | ((ap_predicate_op323_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_1221_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_1209_p2 == 1'd0) & (trunc_ln257_fu_1961_p1 == 8'd128))) begin
        inputBuf_V_128_fu_894 <= inElem_fu_1957_p1;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_1209_p2 == 1'd0)) | ((ap_predicate_op323_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_1221_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_1209_p2 == 1'd0) & (trunc_ln257_fu_1961_p1 == 8'd129))) begin
        inputBuf_V_129_fu_898 <= inElem_fu_1957_p1;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_1209_p2 == 1'd0)) | ((ap_predicate_op323_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_1221_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_1209_p2 == 1'd0) & (trunc_ln257_fu_1961_p1 == 8'd12))) begin
        inputBuf_V_12_fu_430 <= inElem_fu_1957_p1;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_1209_p2 == 1'd0)) | ((ap_predicate_op323_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_1221_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_1209_p2 == 1'd0) & (trunc_ln257_fu_1961_p1 == 8'd130))) begin
        inputBuf_V_130_fu_902 <= inElem_fu_1957_p1;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_1209_p2 == 1'd0)) | ((ap_predicate_op323_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_1221_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_1209_p2 == 1'd0) & (trunc_ln257_fu_1961_p1 == 8'd131))) begin
        inputBuf_V_131_fu_906 <= inElem_fu_1957_p1;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_1209_p2 == 1'd0)) | ((ap_predicate_op323_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_1221_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_1209_p2 == 1'd0) & (trunc_ln257_fu_1961_p1 == 8'd132))) begin
        inputBuf_V_132_fu_910 <= inElem_fu_1957_p1;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_1209_p2 == 1'd0)) | ((ap_predicate_op323_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_1221_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_1209_p2 == 1'd0) & (trunc_ln257_fu_1961_p1 == 8'd133))) begin
        inputBuf_V_133_fu_914 <= inElem_fu_1957_p1;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_1209_p2 == 1'd0)) | ((ap_predicate_op323_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_1221_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_1209_p2 == 1'd0) & (trunc_ln257_fu_1961_p1 == 8'd134))) begin
        inputBuf_V_134_fu_918 <= inElem_fu_1957_p1;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_1209_p2 == 1'd0)) | ((ap_predicate_op323_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_1221_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_1209_p2 == 1'd0) & (trunc_ln257_fu_1961_p1 == 8'd135))) begin
        inputBuf_V_135_fu_922 <= inElem_fu_1957_p1;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_1209_p2 == 1'd0)) | ((ap_predicate_op323_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_1221_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_1209_p2 == 1'd0) & (trunc_ln257_fu_1961_p1 == 8'd136))) begin
        inputBuf_V_136_fu_926 <= inElem_fu_1957_p1;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_1209_p2 == 1'd0)) | ((ap_predicate_op323_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_1221_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_1209_p2 == 1'd0) & (trunc_ln257_fu_1961_p1 == 8'd137))) begin
        inputBuf_V_137_fu_930 <= inElem_fu_1957_p1;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_1209_p2 == 1'd0)) | ((ap_predicate_op323_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_1221_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_1209_p2 == 1'd0) & (trunc_ln257_fu_1961_p1 == 8'd138))) begin
        inputBuf_V_138_fu_934 <= inElem_fu_1957_p1;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_1209_p2 == 1'd0)) | ((ap_predicate_op323_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_1221_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_1209_p2 == 1'd0) & (trunc_ln257_fu_1961_p1 == 8'd139))) begin
        inputBuf_V_139_fu_938 <= inElem_fu_1957_p1;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_1209_p2 == 1'd0)) | ((ap_predicate_op323_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_1221_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_1209_p2 == 1'd0) & (trunc_ln257_fu_1961_p1 == 8'd13))) begin
        inputBuf_V_13_fu_434 <= inElem_fu_1957_p1;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_1209_p2 == 1'd0)) | ((ap_predicate_op323_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_1221_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_1209_p2 == 1'd0) & (trunc_ln257_fu_1961_p1 == 8'd140))) begin
        inputBuf_V_140_fu_942 <= inElem_fu_1957_p1;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_1209_p2 == 1'd0)) | ((ap_predicate_op323_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_1221_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_1209_p2 == 1'd0) & (trunc_ln257_fu_1961_p1 == 8'd141))) begin
        inputBuf_V_141_fu_946 <= inElem_fu_1957_p1;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_1209_p2 == 1'd0)) | ((ap_predicate_op323_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_1221_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_1209_p2 == 1'd0) & (trunc_ln257_fu_1961_p1 == 8'd142))) begin
        inputBuf_V_142_fu_950 <= inElem_fu_1957_p1;
    end
end

always @ (posedge ap_clk) begin
    if ((~(trunc_ln257_fu_1961_p1 == 8'd67) & ~(trunc_ln257_fu_1961_p1 == 8'd66) & ~(trunc_ln257_fu_1961_p1 == 8'd65) & ~(trunc_ln257_fu_1961_p1 == 8'd64) & ~(trunc_ln257_fu_1961_p1 == 8'd63) & ~(trunc_ln257_fu_1961_p1 == 8'd62) & ~(trunc_ln257_fu_1961_p1 == 8'd61) & ~(trunc_ln257_fu_1961_p1 == 8'd60) & ~(trunc_ln257_fu_1961_p1 == 8'd59) & ~(trunc_ln257_fu_1961_p1 == 8'd58) & ~(trunc_ln257_fu_1961_p1 == 8'd57) & ~(trunc_ln257_fu_1961_p1 == 8'd56) & ~(trunc_ln257_fu_1961_p1 == 8'd55) & ~(trunc_ln257_fu_1961_p1 == 8'd54) & ~(trunc_ln257_fu_1961_p1 == 8'd53) & ~(trunc_ln257_fu_1961_p1 == 8'd52) & ~(trunc_ln257_fu_1961_p1 == 8'd51) & ~(trunc_ln257_fu_1961_p1 == 8'd50) & ~(trunc_ln257_fu_1961_p1 == 8'd49) & ~(trunc_ln257_fu_1961_p1 == 8'd48) & ~(trunc_ln257_fu_1961_p1 == 8'd47) & ~(trunc_ln257_fu_1961_p1 == 8'd46) & ~(trunc_ln257_fu_1961_p1 == 8'd45) & ~(trunc_ln257_fu_1961_p1 == 8'd44) & ~(trunc_ln257_fu_1961_p1 == 8'd43) & ~(trunc_ln257_fu_1961_p1 == 8'd42) & ~(trunc_ln257_fu_1961_p1 == 8'd41) & ~(trunc_ln257_fu_1961_p1 == 8'd40) & ~(trunc_ln257_fu_1961_p1 == 8'd39) & ~(trunc_ln257_fu_1961_p1 == 8'd38) & ~(trunc_ln257_fu_1961_p1 == 8'd37) & ~(trunc_ln257_fu_1961_p1 == 8'd36) & ~(trunc_ln257_fu_1961_p1 == 8'd35) & ~(trunc_ln257_fu_1961_p1 == 8'd34) & ~(trunc_ln257_fu_1961_p1 == 8'd33) & ~(trunc_ln257_fu_1961_p1 == 8'd32) & ~(trunc_ln257_fu_1961_p1 == 8'd31) & ~(trunc_ln257_fu_1961_p1 == 8'd30) & ~(trunc_ln257_fu_1961_p1 == 8'd29) & ~(trunc_ln257_fu_1961_p1 == 8'd28) & ~(trunc_ln257_fu_1961_p1 == 8'd27) & ~(trunc_ln257_fu_1961_p1 == 8'd26) & ~(trunc_ln257_fu_1961_p1 == 8'd25) & ~(trunc_ln257_fu_1961_p1 == 8'd24) & ~(trunc_ln257_fu_1961_p1 == 8'd23) & ~(trunc_ln257_fu_1961_p1 == 8'd22) & ~(trunc_ln257_fu_1961_p1 == 8'd21) & ~(trunc_ln257_fu_1961_p1 == 8'd20) & ~(trunc_ln257_fu_1961_p1 == 8'd19) & ~(trunc_ln257_fu_1961_p1 == 8'd18) & ~(trunc_ln257_fu_1961_p1 == 8'd17) & ~(trunc_ln257_fu_1961_p1 == 8'd16) & ~(trunc_ln257_fu_1961_p1 == 8'd15) & ~(trunc_ln257_fu_1961_p1 == 8'd14) & ~(trunc_ln257_fu_1961_p1 == 8'd13) & ~(trunc_ln257_fu_1961_p1 == 8'd12) & ~(trunc_ln257_fu_1961_p1 == 8'd11) & ~(trunc_ln257_fu_1961_p1 == 8'd10) & ~(trunc_ln257_fu_1961_p1 == 8'd9) & ~(trunc_ln257_fu_1961_p1 == 8'd8) & ~(trunc_ln257_fu_1961_p1 == 8'd7) & ~(trunc_ln257_fu_1961_p1 == 8'd6) & ~(trunc_ln257_fu_1961_p1 == 8'd5) & ~(trunc_ln257_fu_1961_p1 == 8'd4) & ~(trunc_ln257_fu_1961_p1 == 8'd3) & ~(trunc_ln257_fu_1961_p1 == 8'd2) & ~(trunc_ln257_fu_1961_p1 == 8'd1) & ~(trunc_ln257_fu_1961_p1 == 8'd0) & ~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_1209_p2 == 1'd0)) | ((ap_predicate_op323_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & ~(trunc_ln257_fu_1961_p1 == 8'd142) & ~(trunc_ln257_fu_1961_p1 == 8'd141) & ~(trunc_ln257_fu_1961_p1 == 8'd140) & ~(trunc_ln257_fu_1961_p1 == 8'd139) & ~(trunc_ln257_fu_1961_p1 == 8'd138) & ~(trunc_ln257_fu_1961_p1 == 8'd137) & ~(trunc_ln257_fu_1961_p1 == 8'd136) & ~(trunc_ln257_fu_1961_p1 == 8'd135) & ~(trunc_ln257_fu_1961_p1 == 8'd134) & ~(trunc_ln257_fu_1961_p1 == 8'd133) & ~(trunc_ln257_fu_1961_p1 == 8'd132) & ~(trunc_ln257_fu_1961_p1 == 8'd131) & ~(trunc_ln257_fu_1961_p1 == 8'd130) & ~(trunc_ln257_fu_1961_p1 == 8'd129) & ~(trunc_ln257_fu_1961_p1 == 8'd128) & ~(trunc_ln257_fu_1961_p1 == 8'd127) & ~(trunc_ln257_fu_1961_p1 == 8'd126) & ~(trunc_ln257_fu_1961_p1 == 8'd125) & ~(trunc_ln257_fu_1961_p1 == 8'd124) & ~(trunc_ln257_fu_1961_p1 == 8'd123) & ~(trunc_ln257_fu_1961_p1 == 8'd122) & ~(trunc_ln257_fu_1961_p1 == 8'd121) & ~(trunc_ln257_fu_1961_p1 == 8'd120) & ~(trunc_ln257_fu_1961_p1 == 8'd119) & ~(trunc_ln257_fu_1961_p1 == 8'd118) & ~(trunc_ln257_fu_1961_p1 == 8'd117) & ~(trunc_ln257_fu_1961_p1 == 8'd116) & ~(trunc_ln257_fu_1961_p1 == 8'd115) & ~(trunc_ln257_fu_1961_p1 == 8'd114) & ~(trunc_ln257_fu_1961_p1 == 8'd113) & ~(trunc_ln257_fu_1961_p1 == 8'd112) & ~(trunc_ln257_fu_1961_p1 == 8'd111) & ~(trunc_ln257_fu_1961_p1 == 8'd110) & ~(trunc_ln257_fu_1961_p1 == 8'd109) & ~(trunc_ln257_fu_1961_p1 == 8'd108) & ~(trunc_ln257_fu_1961_p1 == 8'd107) & ~(trunc_ln257_fu_1961_p1 == 8'd106) & ~(trunc_ln257_fu_1961_p1 == 8'd105) & ~(trunc_ln257_fu_1961_p1 == 8'd104) & ~(trunc_ln257_fu_1961_p1 == 8'd103) & ~(trunc_ln257_fu_1961_p1 == 8'd102) & ~(trunc_ln257_fu_1961_p1 == 8'd101) & ~(trunc_ln257_fu_1961_p1 == 8'd100) & ~(trunc_ln257_fu_1961_p1 == 8'd99) & ~(trunc_ln257_fu_1961_p1 == 8'd98) & ~(trunc_ln257_fu_1961_p1 == 8'd97) & ~(trunc_ln257_fu_1961_p1 == 8'd96) & ~(trunc_ln257_fu_1961_p1 == 8'd95) & ~(trunc_ln257_fu_1961_p1 == 8'd94) & ~(trunc_ln257_fu_1961_p1 == 8'd93) & ~(trunc_ln257_fu_1961_p1 == 8'd92) & ~(trunc_ln257_fu_1961_p1 == 8'd91) & ~(trunc_ln257_fu_1961_p1 == 8'd90) & ~(trunc_ln257_fu_1961_p1 == 8'd89) & ~(trunc_ln257_fu_1961_p1 == 8'd88) & ~(trunc_ln257_fu_1961_p1 == 8'd87) & ~(trunc_ln257_fu_1961_p1 == 8'd86) & ~(trunc_ln257_fu_1961_p1 == 8'd85) & ~(trunc_ln257_fu_1961_p1 == 8'd84) & ~(trunc_ln257_fu_1961_p1 == 8'd83) & ~(trunc_ln257_fu_1961_p1 == 8'd82) & ~(trunc_ln257_fu_1961_p1 == 8'd81) & ~(trunc_ln257_fu_1961_p1 == 8'd80) & ~(trunc_ln257_fu_1961_p1 == 8'd79) & ~(trunc_ln257_fu_1961_p1 == 8'd78) & ~(trunc_ln257_fu_1961_p1 == 8'd77) & ~(trunc_ln257_fu_1961_p1 == 8'd76) & ~(trunc_ln257_fu_1961_p1 == 8'd75) & ~(trunc_ln257_fu_1961_p1 == 8'd74) & ~(trunc_ln257_fu_1961_p1 == 8'd73) & ~(trunc_ln257_fu_1961_p1 == 8'd72) & ~(trunc_ln257_fu_1961_p1 == 8'd71) & ~(trunc_ln257_fu_1961_p1 == 8'd70) & ~(trunc_ln257_fu_1961_p1 == 8'd69) & ~(trunc_ln257_fu_1961_p1 == 8'd68) & (icmp_ln253_fu_1221_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_1209_p2 == 1'd0))) begin
        inputBuf_V_143_fu_954 <= inElem_fu_1957_p1;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_1209_p2 == 1'd0)) | ((ap_predicate_op323_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_1221_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_1209_p2 == 1'd0) & (trunc_ln257_fu_1961_p1 == 8'd14))) begin
        inputBuf_V_14_fu_438 <= inElem_fu_1957_p1;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_1209_p2 == 1'd0)) | ((ap_predicate_op323_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_1221_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_1209_p2 == 1'd0) & (trunc_ln257_fu_1961_p1 == 8'd15))) begin
        inputBuf_V_15_fu_442 <= inElem_fu_1957_p1;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_1209_p2 == 1'd0)) | ((ap_predicate_op323_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_1221_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_1209_p2 == 1'd0) & (trunc_ln257_fu_1961_p1 == 8'd16))) begin
        inputBuf_V_16_fu_446 <= inElem_fu_1957_p1;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_1209_p2 == 1'd0)) | ((ap_predicate_op323_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_1221_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_1209_p2 == 1'd0) & (trunc_ln257_fu_1961_p1 == 8'd17))) begin
        inputBuf_V_17_fu_450 <= inElem_fu_1957_p1;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_1209_p2 == 1'd0)) | ((ap_predicate_op323_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_1221_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_1209_p2 == 1'd0) & (trunc_ln257_fu_1961_p1 == 8'd18))) begin
        inputBuf_V_18_fu_454 <= inElem_fu_1957_p1;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_1209_p2 == 1'd0)) | ((ap_predicate_op323_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_1221_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_1209_p2 == 1'd0) & (trunc_ln257_fu_1961_p1 == 8'd19))) begin
        inputBuf_V_19_fu_458 <= inElem_fu_1957_p1;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_1209_p2 == 1'd0)) | ((ap_predicate_op323_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_1221_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_1209_p2 == 1'd0) & (trunc_ln257_fu_1961_p1 == 8'd1))) begin
        inputBuf_V_1_fu_386 <= inElem_fu_1957_p1;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_1209_p2 == 1'd0)) | ((ap_predicate_op323_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_1221_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_1209_p2 == 1'd0) & (trunc_ln257_fu_1961_p1 == 8'd20))) begin
        inputBuf_V_20_fu_462 <= inElem_fu_1957_p1;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_1209_p2 == 1'd0)) | ((ap_predicate_op323_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_1221_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_1209_p2 == 1'd0) & (trunc_ln257_fu_1961_p1 == 8'd21))) begin
        inputBuf_V_21_fu_466 <= inElem_fu_1957_p1;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_1209_p2 == 1'd0)) | ((ap_predicate_op323_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_1221_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_1209_p2 == 1'd0) & (trunc_ln257_fu_1961_p1 == 8'd22))) begin
        inputBuf_V_22_fu_470 <= inElem_fu_1957_p1;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_1209_p2 == 1'd0)) | ((ap_predicate_op323_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_1221_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_1209_p2 == 1'd0) & (trunc_ln257_fu_1961_p1 == 8'd23))) begin
        inputBuf_V_23_fu_474 <= inElem_fu_1957_p1;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_1209_p2 == 1'd0)) | ((ap_predicate_op323_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_1221_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_1209_p2 == 1'd0) & (trunc_ln257_fu_1961_p1 == 8'd24))) begin
        inputBuf_V_24_fu_478 <= inElem_fu_1957_p1;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_1209_p2 == 1'd0)) | ((ap_predicate_op323_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_1221_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_1209_p2 == 1'd0) & (trunc_ln257_fu_1961_p1 == 8'd25))) begin
        inputBuf_V_25_fu_482 <= inElem_fu_1957_p1;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_1209_p2 == 1'd0)) | ((ap_predicate_op323_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_1221_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_1209_p2 == 1'd0) & (trunc_ln257_fu_1961_p1 == 8'd26))) begin
        inputBuf_V_26_fu_486 <= inElem_fu_1957_p1;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_1209_p2 == 1'd0)) | ((ap_predicate_op323_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_1221_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_1209_p2 == 1'd0) & (trunc_ln257_fu_1961_p1 == 8'd27))) begin
        inputBuf_V_27_fu_490 <= inElem_fu_1957_p1;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_1209_p2 == 1'd0)) | ((ap_predicate_op323_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_1221_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_1209_p2 == 1'd0) & (trunc_ln257_fu_1961_p1 == 8'd28))) begin
        inputBuf_V_28_fu_494 <= inElem_fu_1957_p1;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_1209_p2 == 1'd0)) | ((ap_predicate_op323_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_1221_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_1209_p2 == 1'd0) & (trunc_ln257_fu_1961_p1 == 8'd29))) begin
        inputBuf_V_29_fu_498 <= inElem_fu_1957_p1;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_1209_p2 == 1'd0)) | ((ap_predicate_op323_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_1221_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_1209_p2 == 1'd0) & (trunc_ln257_fu_1961_p1 == 8'd2))) begin
        inputBuf_V_2_fu_390 <= inElem_fu_1957_p1;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_1209_p2 == 1'd0)) | ((ap_predicate_op323_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_1221_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_1209_p2 == 1'd0) & (trunc_ln257_fu_1961_p1 == 8'd30))) begin
        inputBuf_V_30_fu_502 <= inElem_fu_1957_p1;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_1209_p2 == 1'd0)) | ((ap_predicate_op323_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_1221_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_1209_p2 == 1'd0) & (trunc_ln257_fu_1961_p1 == 8'd31))) begin
        inputBuf_V_31_fu_506 <= inElem_fu_1957_p1;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_1209_p2 == 1'd0)) | ((ap_predicate_op323_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_1221_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_1209_p2 == 1'd0) & (trunc_ln257_fu_1961_p1 == 8'd32))) begin
        inputBuf_V_32_fu_510 <= inElem_fu_1957_p1;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_1209_p2 == 1'd0)) | ((ap_predicate_op323_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_1221_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_1209_p2 == 1'd0) & (trunc_ln257_fu_1961_p1 == 8'd33))) begin
        inputBuf_V_33_fu_514 <= inElem_fu_1957_p1;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_1209_p2 == 1'd0)) | ((ap_predicate_op323_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_1221_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_1209_p2 == 1'd0) & (trunc_ln257_fu_1961_p1 == 8'd34))) begin
        inputBuf_V_34_fu_518 <= inElem_fu_1957_p1;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_1209_p2 == 1'd0)) | ((ap_predicate_op323_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_1221_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_1209_p2 == 1'd0) & (trunc_ln257_fu_1961_p1 == 8'd35))) begin
        inputBuf_V_35_fu_522 <= inElem_fu_1957_p1;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_1209_p2 == 1'd0)) | ((ap_predicate_op323_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_1221_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_1209_p2 == 1'd0) & (trunc_ln257_fu_1961_p1 == 8'd36))) begin
        inputBuf_V_36_fu_526 <= inElem_fu_1957_p1;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_1209_p2 == 1'd0)) | ((ap_predicate_op323_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_1221_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_1209_p2 == 1'd0) & (trunc_ln257_fu_1961_p1 == 8'd37))) begin
        inputBuf_V_37_fu_530 <= inElem_fu_1957_p1;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_1209_p2 == 1'd0)) | ((ap_predicate_op323_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_1221_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_1209_p2 == 1'd0) & (trunc_ln257_fu_1961_p1 == 8'd38))) begin
        inputBuf_V_38_fu_534 <= inElem_fu_1957_p1;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_1209_p2 == 1'd0)) | ((ap_predicate_op323_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_1221_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_1209_p2 == 1'd0) & (trunc_ln257_fu_1961_p1 == 8'd39))) begin
        inputBuf_V_39_fu_538 <= inElem_fu_1957_p1;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_1209_p2 == 1'd0)) | ((ap_predicate_op323_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_1221_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_1209_p2 == 1'd0) & (trunc_ln257_fu_1961_p1 == 8'd3))) begin
        inputBuf_V_3_fu_394 <= inElem_fu_1957_p1;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_1209_p2 == 1'd0)) | ((ap_predicate_op323_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_1221_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_1209_p2 == 1'd0) & (trunc_ln257_fu_1961_p1 == 8'd40))) begin
        inputBuf_V_40_fu_542 <= inElem_fu_1957_p1;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_1209_p2 == 1'd0)) | ((ap_predicate_op323_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_1221_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_1209_p2 == 1'd0) & (trunc_ln257_fu_1961_p1 == 8'd41))) begin
        inputBuf_V_41_fu_546 <= inElem_fu_1957_p1;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_1209_p2 == 1'd0)) | ((ap_predicate_op323_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_1221_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_1209_p2 == 1'd0) & (trunc_ln257_fu_1961_p1 == 8'd42))) begin
        inputBuf_V_42_fu_550 <= inElem_fu_1957_p1;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_1209_p2 == 1'd0)) | ((ap_predicate_op323_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_1221_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_1209_p2 == 1'd0) & (trunc_ln257_fu_1961_p1 == 8'd43))) begin
        inputBuf_V_43_fu_554 <= inElem_fu_1957_p1;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_1209_p2 == 1'd0)) | ((ap_predicate_op323_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_1221_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_1209_p2 == 1'd0) & (trunc_ln257_fu_1961_p1 == 8'd44))) begin
        inputBuf_V_44_fu_558 <= inElem_fu_1957_p1;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_1209_p2 == 1'd0)) | ((ap_predicate_op323_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_1221_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_1209_p2 == 1'd0) & (trunc_ln257_fu_1961_p1 == 8'd45))) begin
        inputBuf_V_45_fu_562 <= inElem_fu_1957_p1;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_1209_p2 == 1'd0)) | ((ap_predicate_op323_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_1221_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_1209_p2 == 1'd0) & (trunc_ln257_fu_1961_p1 == 8'd46))) begin
        inputBuf_V_46_fu_566 <= inElem_fu_1957_p1;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_1209_p2 == 1'd0)) | ((ap_predicate_op323_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_1221_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_1209_p2 == 1'd0) & (trunc_ln257_fu_1961_p1 == 8'd47))) begin
        inputBuf_V_47_fu_570 <= inElem_fu_1957_p1;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_1209_p2 == 1'd0)) | ((ap_predicate_op323_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_1221_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_1209_p2 == 1'd0) & (trunc_ln257_fu_1961_p1 == 8'd48))) begin
        inputBuf_V_48_fu_574 <= inElem_fu_1957_p1;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_1209_p2 == 1'd0)) | ((ap_predicate_op323_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_1221_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_1209_p2 == 1'd0) & (trunc_ln257_fu_1961_p1 == 8'd49))) begin
        inputBuf_V_49_fu_578 <= inElem_fu_1957_p1;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_1209_p2 == 1'd0)) | ((ap_predicate_op323_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_1221_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_1209_p2 == 1'd0) & (trunc_ln257_fu_1961_p1 == 8'd4))) begin
        inputBuf_V_4_fu_398 <= inElem_fu_1957_p1;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_1209_p2 == 1'd0)) | ((ap_predicate_op323_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_1221_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_1209_p2 == 1'd0) & (trunc_ln257_fu_1961_p1 == 8'd50))) begin
        inputBuf_V_50_fu_582 <= inElem_fu_1957_p1;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_1209_p2 == 1'd0)) | ((ap_predicate_op323_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_1221_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_1209_p2 == 1'd0) & (trunc_ln257_fu_1961_p1 == 8'd51))) begin
        inputBuf_V_51_fu_586 <= inElem_fu_1957_p1;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_1209_p2 == 1'd0)) | ((ap_predicate_op323_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_1221_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_1209_p2 == 1'd0) & (trunc_ln257_fu_1961_p1 == 8'd52))) begin
        inputBuf_V_52_fu_590 <= inElem_fu_1957_p1;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_1209_p2 == 1'd0)) | ((ap_predicate_op323_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_1221_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_1209_p2 == 1'd0) & (trunc_ln257_fu_1961_p1 == 8'd53))) begin
        inputBuf_V_53_fu_594 <= inElem_fu_1957_p1;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_1209_p2 == 1'd0)) | ((ap_predicate_op323_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_1221_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_1209_p2 == 1'd0) & (trunc_ln257_fu_1961_p1 == 8'd54))) begin
        inputBuf_V_54_fu_598 <= inElem_fu_1957_p1;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_1209_p2 == 1'd0)) | ((ap_predicate_op323_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_1221_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_1209_p2 == 1'd0) & (trunc_ln257_fu_1961_p1 == 8'd55))) begin
        inputBuf_V_55_fu_602 <= inElem_fu_1957_p1;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_1209_p2 == 1'd0)) | ((ap_predicate_op323_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_1221_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_1209_p2 == 1'd0) & (trunc_ln257_fu_1961_p1 == 8'd56))) begin
        inputBuf_V_56_fu_606 <= inElem_fu_1957_p1;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_1209_p2 == 1'd0)) | ((ap_predicate_op323_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_1221_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_1209_p2 == 1'd0) & (trunc_ln257_fu_1961_p1 == 8'd57))) begin
        inputBuf_V_57_fu_610 <= inElem_fu_1957_p1;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_1209_p2 == 1'd0)) | ((ap_predicate_op323_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_1221_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_1209_p2 == 1'd0) & (trunc_ln257_fu_1961_p1 == 8'd58))) begin
        inputBuf_V_58_fu_614 <= inElem_fu_1957_p1;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_1209_p2 == 1'd0)) | ((ap_predicate_op323_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_1221_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_1209_p2 == 1'd0) & (trunc_ln257_fu_1961_p1 == 8'd59))) begin
        inputBuf_V_59_fu_618 <= inElem_fu_1957_p1;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_1209_p2 == 1'd0)) | ((ap_predicate_op323_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_1221_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_1209_p2 == 1'd0) & (trunc_ln257_fu_1961_p1 == 8'd5))) begin
        inputBuf_V_5_fu_402 <= inElem_fu_1957_p1;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_1209_p2 == 1'd0)) | ((ap_predicate_op323_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_1221_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_1209_p2 == 1'd0) & (trunc_ln257_fu_1961_p1 == 8'd60))) begin
        inputBuf_V_60_fu_622 <= inElem_fu_1957_p1;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_1209_p2 == 1'd0)) | ((ap_predicate_op323_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_1221_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_1209_p2 == 1'd0) & (trunc_ln257_fu_1961_p1 == 8'd61))) begin
        inputBuf_V_61_fu_626 <= inElem_fu_1957_p1;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_1209_p2 == 1'd0)) | ((ap_predicate_op323_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_1221_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_1209_p2 == 1'd0) & (trunc_ln257_fu_1961_p1 == 8'd62))) begin
        inputBuf_V_62_fu_630 <= inElem_fu_1957_p1;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_1209_p2 == 1'd0)) | ((ap_predicate_op323_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_1221_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_1209_p2 == 1'd0) & (trunc_ln257_fu_1961_p1 == 8'd63))) begin
        inputBuf_V_63_fu_634 <= inElem_fu_1957_p1;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_1209_p2 == 1'd0)) | ((ap_predicate_op323_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_1221_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_1209_p2 == 1'd0) & (trunc_ln257_fu_1961_p1 == 8'd64))) begin
        inputBuf_V_64_fu_638 <= inElem_fu_1957_p1;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_1209_p2 == 1'd0)) | ((ap_predicate_op323_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_1221_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_1209_p2 == 1'd0) & (trunc_ln257_fu_1961_p1 == 8'd65))) begin
        inputBuf_V_65_fu_642 <= inElem_fu_1957_p1;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_1209_p2 == 1'd0)) | ((ap_predicate_op323_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_1221_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_1209_p2 == 1'd0) & (trunc_ln257_fu_1961_p1 == 8'd66))) begin
        inputBuf_V_66_fu_646 <= inElem_fu_1957_p1;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_1209_p2 == 1'd0)) | ((ap_predicate_op323_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_1221_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_1209_p2 == 1'd0) & (trunc_ln257_fu_1961_p1 == 8'd67))) begin
        inputBuf_V_67_fu_650 <= inElem_fu_1957_p1;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_1209_p2 == 1'd0)) | ((ap_predicate_op323_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_1221_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_1209_p2 == 1'd0) & (trunc_ln257_fu_1961_p1 == 8'd68))) begin
        inputBuf_V_68_fu_654 <= inElem_fu_1957_p1;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_1209_p2 == 1'd0)) | ((ap_predicate_op323_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_1221_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_1209_p2 == 1'd0) & (trunc_ln257_fu_1961_p1 == 8'd69))) begin
        inputBuf_V_69_fu_658 <= inElem_fu_1957_p1;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_1209_p2 == 1'd0)) | ((ap_predicate_op323_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_1221_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_1209_p2 == 1'd0) & (trunc_ln257_fu_1961_p1 == 8'd6))) begin
        inputBuf_V_6_fu_406 <= inElem_fu_1957_p1;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_1209_p2 == 1'd0)) | ((ap_predicate_op323_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_1221_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_1209_p2 == 1'd0) & (trunc_ln257_fu_1961_p1 == 8'd70))) begin
        inputBuf_V_70_fu_662 <= inElem_fu_1957_p1;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_1209_p2 == 1'd0)) | ((ap_predicate_op323_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_1221_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_1209_p2 == 1'd0) & (trunc_ln257_fu_1961_p1 == 8'd71))) begin
        inputBuf_V_71_fu_666 <= inElem_fu_1957_p1;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_1209_p2 == 1'd0)) | ((ap_predicate_op323_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_1221_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_1209_p2 == 1'd0) & (trunc_ln257_fu_1961_p1 == 8'd72))) begin
        inputBuf_V_72_fu_670 <= inElem_fu_1957_p1;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_1209_p2 == 1'd0)) | ((ap_predicate_op323_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_1221_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_1209_p2 == 1'd0) & (trunc_ln257_fu_1961_p1 == 8'd73))) begin
        inputBuf_V_73_fu_674 <= inElem_fu_1957_p1;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_1209_p2 == 1'd0)) | ((ap_predicate_op323_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_1221_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_1209_p2 == 1'd0) & (trunc_ln257_fu_1961_p1 == 8'd74))) begin
        inputBuf_V_74_fu_678 <= inElem_fu_1957_p1;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_1209_p2 == 1'd0)) | ((ap_predicate_op323_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_1221_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_1209_p2 == 1'd0) & (trunc_ln257_fu_1961_p1 == 8'd75))) begin
        inputBuf_V_75_fu_682 <= inElem_fu_1957_p1;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_1209_p2 == 1'd0)) | ((ap_predicate_op323_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_1221_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_1209_p2 == 1'd0) & (trunc_ln257_fu_1961_p1 == 8'd76))) begin
        inputBuf_V_76_fu_686 <= inElem_fu_1957_p1;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_1209_p2 == 1'd0)) | ((ap_predicate_op323_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_1221_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_1209_p2 == 1'd0) & (trunc_ln257_fu_1961_p1 == 8'd77))) begin
        inputBuf_V_77_fu_690 <= inElem_fu_1957_p1;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_1209_p2 == 1'd0)) | ((ap_predicate_op323_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_1221_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_1209_p2 == 1'd0) & (trunc_ln257_fu_1961_p1 == 8'd78))) begin
        inputBuf_V_78_fu_694 <= inElem_fu_1957_p1;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_1209_p2 == 1'd0)) | ((ap_predicate_op323_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_1221_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_1209_p2 == 1'd0) & (trunc_ln257_fu_1961_p1 == 8'd79))) begin
        inputBuf_V_79_fu_698 <= inElem_fu_1957_p1;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_1209_p2 == 1'd0)) | ((ap_predicate_op323_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_1221_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_1209_p2 == 1'd0) & (trunc_ln257_fu_1961_p1 == 8'd7))) begin
        inputBuf_V_7_fu_410 <= inElem_fu_1957_p1;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_1209_p2 == 1'd0)) | ((ap_predicate_op323_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_1221_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_1209_p2 == 1'd0) & (trunc_ln257_fu_1961_p1 == 8'd80))) begin
        inputBuf_V_80_fu_702 <= inElem_fu_1957_p1;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_1209_p2 == 1'd0)) | ((ap_predicate_op323_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_1221_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_1209_p2 == 1'd0) & (trunc_ln257_fu_1961_p1 == 8'd81))) begin
        inputBuf_V_81_fu_706 <= inElem_fu_1957_p1;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_1209_p2 == 1'd0)) | ((ap_predicate_op323_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_1221_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_1209_p2 == 1'd0) & (trunc_ln257_fu_1961_p1 == 8'd82))) begin
        inputBuf_V_82_fu_710 <= inElem_fu_1957_p1;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_1209_p2 == 1'd0)) | ((ap_predicate_op323_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_1221_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_1209_p2 == 1'd0) & (trunc_ln257_fu_1961_p1 == 8'd83))) begin
        inputBuf_V_83_fu_714 <= inElem_fu_1957_p1;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_1209_p2 == 1'd0)) | ((ap_predicate_op323_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_1221_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_1209_p2 == 1'd0) & (trunc_ln257_fu_1961_p1 == 8'd84))) begin
        inputBuf_V_84_fu_718 <= inElem_fu_1957_p1;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_1209_p2 == 1'd0)) | ((ap_predicate_op323_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_1221_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_1209_p2 == 1'd0) & (trunc_ln257_fu_1961_p1 == 8'd85))) begin
        inputBuf_V_85_fu_722 <= inElem_fu_1957_p1;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_1209_p2 == 1'd0)) | ((ap_predicate_op323_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_1221_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_1209_p2 == 1'd0) & (trunc_ln257_fu_1961_p1 == 8'd86))) begin
        inputBuf_V_86_fu_726 <= inElem_fu_1957_p1;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_1209_p2 == 1'd0)) | ((ap_predicate_op323_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_1221_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_1209_p2 == 1'd0) & (trunc_ln257_fu_1961_p1 == 8'd87))) begin
        inputBuf_V_87_fu_730 <= inElem_fu_1957_p1;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_1209_p2 == 1'd0)) | ((ap_predicate_op323_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_1221_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_1209_p2 == 1'd0) & (trunc_ln257_fu_1961_p1 == 8'd88))) begin
        inputBuf_V_88_fu_734 <= inElem_fu_1957_p1;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_1209_p2 == 1'd0)) | ((ap_predicate_op323_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_1221_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_1209_p2 == 1'd0) & (trunc_ln257_fu_1961_p1 == 8'd89))) begin
        inputBuf_V_89_fu_738 <= inElem_fu_1957_p1;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_1209_p2 == 1'd0)) | ((ap_predicate_op323_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_1221_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_1209_p2 == 1'd0) & (trunc_ln257_fu_1961_p1 == 8'd8))) begin
        inputBuf_V_8_fu_414 <= inElem_fu_1957_p1;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_1209_p2 == 1'd0)) | ((ap_predicate_op323_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_1221_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_1209_p2 == 1'd0) & (trunc_ln257_fu_1961_p1 == 8'd90))) begin
        inputBuf_V_90_fu_742 <= inElem_fu_1957_p1;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_1209_p2 == 1'd0)) | ((ap_predicate_op323_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_1221_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_1209_p2 == 1'd0) & (trunc_ln257_fu_1961_p1 == 8'd91))) begin
        inputBuf_V_91_fu_746 <= inElem_fu_1957_p1;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_1209_p2 == 1'd0)) | ((ap_predicate_op323_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_1221_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_1209_p2 == 1'd0) & (trunc_ln257_fu_1961_p1 == 8'd92))) begin
        inputBuf_V_92_fu_750 <= inElem_fu_1957_p1;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_1209_p2 == 1'd0)) | ((ap_predicate_op323_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_1221_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_1209_p2 == 1'd0) & (trunc_ln257_fu_1961_p1 == 8'd93))) begin
        inputBuf_V_93_fu_754 <= inElem_fu_1957_p1;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_1209_p2 == 1'd0)) | ((ap_predicate_op323_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_1221_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_1209_p2 == 1'd0) & (trunc_ln257_fu_1961_p1 == 8'd94))) begin
        inputBuf_V_94_fu_758 <= inElem_fu_1957_p1;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_1209_p2 == 1'd0)) | ((ap_predicate_op323_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_1221_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_1209_p2 == 1'd0) & (trunc_ln257_fu_1961_p1 == 8'd95))) begin
        inputBuf_V_95_fu_762 <= inElem_fu_1957_p1;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_1209_p2 == 1'd0)) | ((ap_predicate_op323_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_1221_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_1209_p2 == 1'd0) & (trunc_ln257_fu_1961_p1 == 8'd96))) begin
        inputBuf_V_96_fu_766 <= inElem_fu_1957_p1;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_1209_p2 == 1'd0)) | ((ap_predicate_op323_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_1221_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_1209_p2 == 1'd0) & (trunc_ln257_fu_1961_p1 == 8'd97))) begin
        inputBuf_V_97_fu_770 <= inElem_fu_1957_p1;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_1209_p2 == 1'd0)) | ((ap_predicate_op323_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_1221_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_1209_p2 == 1'd0) & (trunc_ln257_fu_1961_p1 == 8'd98))) begin
        inputBuf_V_98_fu_774 <= inElem_fu_1957_p1;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_1209_p2 == 1'd0)) | ((ap_predicate_op323_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_1221_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_1209_p2 == 1'd0) & (trunc_ln257_fu_1961_p1 == 8'd99))) begin
        inputBuf_V_99_fu_778 <= inElem_fu_1957_p1;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_1209_p2 == 1'd0)) | ((ap_predicate_op323_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_1221_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_1209_p2 == 1'd0) & (trunc_ln257_fu_1961_p1 == 8'd9))) begin
        inputBuf_V_9_fu_418 <= inElem_fu_1957_p1;
    end
end

always @ (posedge ap_clk) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_1209_p2 == 1'd0)) | ((ap_predicate_op323_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (icmp_ln253_fu_1221_p2 == 1'd1) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_1209_p2 == 1'd0) & (trunc_ln257_fu_1961_p1 == 8'd0))) begin
        inputBuf_V_fu_382 <= inElem_fu_1957_p1;
    end
end

always @ (*) begin
    if (((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_1209_p2 == 1'd0)) | ((ap_predicate_op323_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)))) begin
        ap_ST_iter0_fsm_state1_blk = 1'b1;
    end else begin
        ap_ST_iter0_fsm_state1_blk = 1'b0;
    end
end

assign ap_ST_iter1_fsm_state2_blk = 1'b0;

assign ap_ST_iter2_fsm_state3_blk = 1'b0;

assign ap_ST_iter3_fsm_state4_blk = 1'b0;

assign ap_ST_iter4_fsm_state5_blk = 1'b0;

assign ap_ST_iter5_fsm_state6_blk = 1'b0;

always @ (*) begin
    if (((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0)))) begin
        ap_ST_iter6_fsm_state7_blk = 1'b1;
    end else begin
        ap_ST_iter6_fsm_state7_blk = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_1209_p2 == 1'd0)) | ((ap_predicate_op323_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_1209_p2 == 1'd1))) begin
        ap_condition_exit_pp0_iter0_stage0 = 1'b1;
    end else begin
        ap_condition_exit_pp0_iter0_stage0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))) & (1'b1 == ap_CS_iter6_fsm_state7) & (ap_loop_exit_ready_pp0_iter6_reg == 1'b1))) begin
        ap_done_int = 1'b1;
    end else begin
        ap_done_int = ap_done_reg;
    end
end

always @ (*) begin
    if (((1'b1 == ap_CS_iter6_fsm_state0) & (1'b1 == ap_CS_iter5_fsm_state0) & (1'b1 == ap_CS_iter4_fsm_state0) & (1'b1 == ap_CS_iter3_fsm_state0) & (1'b1 == ap_CS_iter2_fsm_state0) & (1'b1 == ap_CS_iter1_fsm_state0) & (1'b1 == ap_CS_iter0_fsm_state1) & (ap_start_int == 1'b0))) begin
        ap_idle = 1'b1;
    end else begin
        ap_idle = 1'b0;
    end
end

always @ (*) begin
    if (((icmp_ln253_reg_4107_pp0_iter0_reg == 1'd1) & (icmp_ln249_reg_4103_pp0_iter0_reg == 1'd0))) begin
        ap_phi_mux_inElem_1_phi_fu_1179_p4 = inElem_reg_4116;
    end else begin
        ap_phi_mux_inElem_1_phi_fu_1179_p4 = ap_phi_reg_pp0_iter1_inElem_1_reg_1176;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_1209_p2 == 1'd0)) | ((ap_predicate_op323_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (1'b1 == ap_CS_iter0_fsm_state1))) begin
        ap_ready_int = 1'b1;
    end else begin
        ap_ready_int = 1'b0;
    end
end

always @ (*) begin
    if (((1'b1 == ap_CS_iter4_fsm_state5) & (icmp_ln249_reg_4103_pp0_iter3_reg == 1'd0))) begin
        ap_sig_allocacmp_add_i4_i338_load = grp_fu_3182_p3;
    end else begin
        ap_sig_allocacmp_add_i4_i338_load = add_i4_i338_fu_378;
    end
end

always @ (*) begin
    if (((1'b1 == ap_CS_iter0_fsm_state1) & (ap_loop_init == 1'b1))) begin
        ap_sig_allocacmp_i_1 = 20'd0;
    end else begin
        ap_sig_allocacmp_i_1 = i_fu_374;
    end
end

always @ (*) begin
    if (((1'b1 == ap_CS_iter0_fsm_state1) & (ap_loop_init == 1'b1))) begin
        ap_sig_allocacmp_nf_2 = 32'd0;
    end else begin
        ap_sig_allocacmp_nf_2 = nf_1_fu_958;
    end
end

always @ (*) begin
    if (((1'b1 == ap_CS_iter0_fsm_state1) & (ap_loop_init == 1'b1))) begin
        ap_sig_allocacmp_sf_1 = 32'd0;
    end else begin
        ap_sig_allocacmp_sf_1 = sf_fu_370;
    end
end

always @ (*) begin
    if (((~((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0)))) & (1'b1 == ap_CS_iter1_fsm_state2)) | (~((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0)))) & (1'b1 == ap_CS_iter2_fsm_state3)) | (~((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0)))) & (1'b1 == ap_CS_iter3_fsm_state4)) | (~((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0)))) & (1'b1 == ap_CS_iter4_fsm_state5)))) begin
        grp_fu_3182_ce = 1'b1;
    end else begin
        grp_fu_3182_ce = 1'b0;
    end
end

always @ (*) begin
    if (((ap_predicate_op323_read_state1 == 1'b1) & (1'b1 == ap_CS_iter0_fsm_state1) & (ap_start_int == 1'b1))) begin
        in0_V_TDATA_blk_n = in0_V_TVALID;
    end else begin
        in0_V_TDATA_blk_n = 1'b1;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_1209_p2 == 1'd0)) | ((ap_predicate_op323_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (ap_predicate_op323_read_state1 == 1'b1) & (1'b1 == ap_CS_iter0_fsm_state1))) begin
        in0_V_TREADY = 1'b1;
    end else begin
        in0_V_TREADY = 1'b0;
    end
end

always @ (*) begin
    if (((1'b1 == ap_CS_iter6_fsm_state7) & (ap_predicate_op774_write_state7 == 1'b1))) begin
        out_V_TDATA_blk_n = out_V_TREADY;
    end else begin
        out_V_TDATA_blk_n = 1'b1;
    end
end

always @ (*) begin
    if ((~((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))) & (1'b1 == ap_CS_iter6_fsm_state7) & (ap_predicate_op774_write_state7 == 1'b1))) begin
        out_V_TVALID = 1'b1;
    end else begin
        out_V_TVALID = 1'b0;
    end
end

always @ (*) begin
    if ((~((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0)))) & (1'b1 == ap_CS_iter3_fsm_state4))) begin
        p_ZL7threshs_0_ce0 = 1'b1;
    end else begin
        p_ZL7threshs_0_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0)))) & (1'b1 == ap_CS_iter3_fsm_state4))) begin
        p_ZL7threshs_10_ce0 = 1'b1;
    end else begin
        p_ZL7threshs_10_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0)))) & (1'b1 == ap_CS_iter3_fsm_state4))) begin
        p_ZL7threshs_11_ce0 = 1'b1;
    end else begin
        p_ZL7threshs_11_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0)))) & (1'b1 == ap_CS_iter3_fsm_state4))) begin
        p_ZL7threshs_12_ce0 = 1'b1;
    end else begin
        p_ZL7threshs_12_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0)))) & (1'b1 == ap_CS_iter3_fsm_state4))) begin
        p_ZL7threshs_13_ce0 = 1'b1;
    end else begin
        p_ZL7threshs_13_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0)))) & (1'b1 == ap_CS_iter3_fsm_state4))) begin
        p_ZL7threshs_14_ce0 = 1'b1;
    end else begin
        p_ZL7threshs_14_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0)))) & (1'b1 == ap_CS_iter3_fsm_state4))) begin
        p_ZL7threshs_1_ce0 = 1'b1;
    end else begin
        p_ZL7threshs_1_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0)))) & (1'b1 == ap_CS_iter3_fsm_state4))) begin
        p_ZL7threshs_2_ce0 = 1'b1;
    end else begin
        p_ZL7threshs_2_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0)))) & (1'b1 == ap_CS_iter3_fsm_state4))) begin
        p_ZL7threshs_3_ce0 = 1'b1;
    end else begin
        p_ZL7threshs_3_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0)))) & (1'b1 == ap_CS_iter3_fsm_state4))) begin
        p_ZL7threshs_4_ce0 = 1'b1;
    end else begin
        p_ZL7threshs_4_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0)))) & (1'b1 == ap_CS_iter3_fsm_state4))) begin
        p_ZL7threshs_5_ce0 = 1'b1;
    end else begin
        p_ZL7threshs_5_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0)))) & (1'b1 == ap_CS_iter3_fsm_state4))) begin
        p_ZL7threshs_6_ce0 = 1'b1;
    end else begin
        p_ZL7threshs_6_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0)))) & (1'b1 == ap_CS_iter3_fsm_state4))) begin
        p_ZL7threshs_7_ce0 = 1'b1;
    end else begin
        p_ZL7threshs_7_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0)))) & (1'b1 == ap_CS_iter3_fsm_state4))) begin
        p_ZL7threshs_8_ce0 = 1'b1;
    end else begin
        p_ZL7threshs_8_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0)))) & (1'b1 == ap_CS_iter3_fsm_state4))) begin
        p_ZL7threshs_9_ce0 = 1'b1;
    end else begin
        p_ZL7threshs_9_ce0 = 1'b0;
    end
end

always @ (*) begin
    if (((1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_1209_p2 == 1'd0) & (ap_start_int == 1'b1))) begin
        weights_V_TDATA_blk_n = weights_V_TVALID;
    end else begin
        weights_V_TDATA_blk_n = 1'b1;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_1209_p2 == 1'd0)) | ((ap_predicate_op323_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (1'b1 == ap_CS_iter0_fsm_state1) & (icmp_ln249_fu_1209_p2 == 1'd0))) begin
        weights_V_TREADY = 1'b1;
    end else begin
        weights_V_TREADY = 1'b0;
    end
end

always @ (*) begin
    case (ap_CS_iter0_fsm)
        ap_ST_iter0_fsm_state1 : begin
            ap_NS_iter0_fsm = ap_ST_iter0_fsm_state1;
        end
        default : begin
            ap_NS_iter0_fsm = 'bx;
        end
    endcase
end

always @ (*) begin
    case (ap_CS_iter1_fsm)
        ap_ST_iter1_fsm_state2 : begin
            if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_1209_p2 == 1'd0)) | ((ap_predicate_op323_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0))) & ~((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0)))) & (1'b1 == ap_CS_iter0_fsm_state1))) begin
                ap_NS_iter1_fsm = ap_ST_iter1_fsm_state2;
            end else if ((~((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0)))) & ((1'b0 == ap_CS_iter0_fsm_state1) | ((1'b1 == ap_CS_iter0_fsm_state1) & ((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_1209_p2 == 1'd0)) | ((ap_predicate_op323_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0))))))) begin
                ap_NS_iter1_fsm = ap_ST_iter1_fsm_state0;
            end else begin
                ap_NS_iter1_fsm = ap_ST_iter1_fsm_state2;
            end
        end
        ap_ST_iter1_fsm_state0 : begin
            if ((~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_1209_p2 == 1'd0)) | ((ap_predicate_op323_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (1'b1 == ap_CS_iter0_fsm_state1))) begin
                ap_NS_iter1_fsm = ap_ST_iter1_fsm_state2;
            end else begin
                ap_NS_iter1_fsm = ap_ST_iter1_fsm_state0;
            end
        end
        default : begin
            ap_NS_iter1_fsm = 'bx;
        end
    endcase
end

always @ (*) begin
    case (ap_CS_iter2_fsm)
        ap_ST_iter2_fsm_state3 : begin
            if ((~((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0)))) & (1'b1 == ap_CS_iter1_fsm_state2))) begin
                ap_NS_iter2_fsm = ap_ST_iter2_fsm_state3;
            end else if ((~((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0)))) & (1'b0 == ap_CS_iter1_fsm_state2))) begin
                ap_NS_iter2_fsm = ap_ST_iter2_fsm_state0;
            end else begin
                ap_NS_iter2_fsm = ap_ST_iter2_fsm_state3;
            end
        end
        ap_ST_iter2_fsm_state0 : begin
            if ((~((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0)))) & (1'b1 == ap_CS_iter1_fsm_state2))) begin
                ap_NS_iter2_fsm = ap_ST_iter2_fsm_state3;
            end else begin
                ap_NS_iter2_fsm = ap_ST_iter2_fsm_state0;
            end
        end
        default : begin
            ap_NS_iter2_fsm = 'bx;
        end
    endcase
end

always @ (*) begin
    case (ap_CS_iter3_fsm)
        ap_ST_iter3_fsm_state4 : begin
            if ((~((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0)))) & (1'b1 == ap_CS_iter2_fsm_state3))) begin
                ap_NS_iter3_fsm = ap_ST_iter3_fsm_state4;
            end else if ((~((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0)))) & (1'b0 == ap_CS_iter2_fsm_state3))) begin
                ap_NS_iter3_fsm = ap_ST_iter3_fsm_state0;
            end else begin
                ap_NS_iter3_fsm = ap_ST_iter3_fsm_state4;
            end
        end
        ap_ST_iter3_fsm_state0 : begin
            if ((~((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0)))) & (1'b1 == ap_CS_iter2_fsm_state3))) begin
                ap_NS_iter3_fsm = ap_ST_iter3_fsm_state4;
            end else begin
                ap_NS_iter3_fsm = ap_ST_iter3_fsm_state0;
            end
        end
        default : begin
            ap_NS_iter3_fsm = 'bx;
        end
    endcase
end

always @ (*) begin
    case (ap_CS_iter4_fsm)
        ap_ST_iter4_fsm_state5 : begin
            if ((~((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0)))) & (1'b1 == ap_CS_iter3_fsm_state4))) begin
                ap_NS_iter4_fsm = ap_ST_iter4_fsm_state5;
            end else if ((~((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0)))) & (1'b0 == ap_CS_iter3_fsm_state4))) begin
                ap_NS_iter4_fsm = ap_ST_iter4_fsm_state0;
            end else begin
                ap_NS_iter4_fsm = ap_ST_iter4_fsm_state5;
            end
        end
        ap_ST_iter4_fsm_state0 : begin
            if ((~((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0)))) & (1'b1 == ap_CS_iter3_fsm_state4))) begin
                ap_NS_iter4_fsm = ap_ST_iter4_fsm_state5;
            end else begin
                ap_NS_iter4_fsm = ap_ST_iter4_fsm_state0;
            end
        end
        default : begin
            ap_NS_iter4_fsm = 'bx;
        end
    endcase
end

always @ (*) begin
    case (ap_CS_iter5_fsm)
        ap_ST_iter5_fsm_state6 : begin
            if ((~((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0)))) & (1'b1 == ap_CS_iter4_fsm_state5))) begin
                ap_NS_iter5_fsm = ap_ST_iter5_fsm_state6;
            end else if ((~((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0)))) & (1'b0 == ap_CS_iter4_fsm_state5))) begin
                ap_NS_iter5_fsm = ap_ST_iter5_fsm_state0;
            end else begin
                ap_NS_iter5_fsm = ap_ST_iter5_fsm_state6;
            end
        end
        ap_ST_iter5_fsm_state0 : begin
            if ((~((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0)))) & (1'b1 == ap_CS_iter4_fsm_state5))) begin
                ap_NS_iter5_fsm = ap_ST_iter5_fsm_state6;
            end else begin
                ap_NS_iter5_fsm = ap_ST_iter5_fsm_state0;
            end
        end
        default : begin
            ap_NS_iter5_fsm = 'bx;
        end
    endcase
end

always @ (*) begin
    case (ap_CS_iter6_fsm)
        ap_ST_iter6_fsm_state7 : begin
            if ((~((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))) & (1'b0 == ap_CS_iter5_fsm_state6))) begin
                ap_NS_iter6_fsm = ap_ST_iter6_fsm_state0;
            end else if (((~((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))) & (1'b1 == ap_CS_iter6_fsm_state7) & (icmp_ln249_reg_4103_pp0_iter5_reg == 1'd1)) | (~((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))) & (1'b1 == ap_CS_iter5_fsm_state6)))) begin
                ap_NS_iter6_fsm = ap_ST_iter6_fsm_state7;
            end else begin
                ap_NS_iter6_fsm = ap_ST_iter6_fsm_state7;
            end
        end
        ap_ST_iter6_fsm_state0 : begin
            if ((~((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0)))) & (1'b1 == ap_CS_iter5_fsm_state6))) begin
                ap_NS_iter6_fsm = ap_ST_iter6_fsm_state7;
            end else begin
                ap_NS_iter6_fsm = ap_ST_iter6_fsm_state0;
            end
        end
        default : begin
            ap_NS_iter6_fsm = 'bx;
        end
    endcase
end

assign W_packed_V_fu_2685_p1 = weights_V_TDATA[3:0];

assign add_ln840_10_fu_3130_p2 = (zext_ln218_10_fu_3025_p1 + zext_ln218_11_fu_3034_p1);

assign add_ln840_11_fu_3140_p2 = (zext_ln218_12_fu_3043_p1 + zext_ln840_fu_3052_p1);

assign add_ln840_12_fu_3150_p2 = (zext_ln840_9_fu_3146_p1 + zext_ln840_8_fu_3136_p1);

assign add_ln840_13_fu_3165_p2 = (zext_ln840_10_fu_3162_p1 + zext_ln840_7_fu_3159_p1);

assign add_ln840_1_fu_3056_p2 = (zext_ln215_fu_2926_p1 + zext_ln218_1_fu_2944_p1);

assign add_ln840_2_fu_3062_p2 = (add_ln840_1_fu_3056_p2 + zext_ln218_fu_2935_p1);

assign add_ln840_3_fu_3072_p2 = (zext_ln218_2_fu_2953_p1 + zext_ln218_3_fu_2962_p1);

assign add_ln840_4_fu_3082_p2 = (zext_ln218_4_fu_2971_p1 + zext_ln218_5_fu_2980_p1);

assign add_ln840_5_fu_3092_p2 = (zext_ln840_3_fu_3088_p1 + zext_ln840_2_fu_3078_p1);

assign add_ln840_6_fu_3098_p2 = (add_ln840_5_fu_3092_p2 + zext_ln840_1_fu_3068_p1);

assign add_ln840_7_fu_3104_p2 = (zext_ln218_6_fu_2989_p1 + zext_ln218_7_fu_2998_p1);

assign add_ln840_8_fu_3114_p2 = (zext_ln218_8_fu_3007_p1 + zext_ln218_9_fu_3016_p1);

assign add_ln840_9_fu_3124_p2 = (zext_ln840_6_fu_3120_p1 + zext_ln840_5_fu_3110_p1);

assign ap_CS_iter0_fsm_state1 = ap_CS_iter0_fsm[32'd0];

assign ap_CS_iter1_fsm_state0 = ap_CS_iter1_fsm[32'd0];

assign ap_CS_iter1_fsm_state2 = ap_CS_iter1_fsm[32'd1];

assign ap_CS_iter2_fsm_state0 = ap_CS_iter2_fsm[32'd0];

assign ap_CS_iter2_fsm_state3 = ap_CS_iter2_fsm[32'd1];

assign ap_CS_iter3_fsm_state0 = ap_CS_iter3_fsm[32'd0];

assign ap_CS_iter3_fsm_state4 = ap_CS_iter3_fsm[32'd1];

assign ap_CS_iter4_fsm_state0 = ap_CS_iter4_fsm[32'd0];

assign ap_CS_iter4_fsm_state5 = ap_CS_iter4_fsm[32'd1];

assign ap_CS_iter5_fsm_state0 = ap_CS_iter5_fsm[32'd0];

assign ap_CS_iter5_fsm_state6 = ap_CS_iter5_fsm[32'd1];

assign ap_CS_iter6_fsm_state0 = ap_CS_iter6_fsm[32'd0];

assign ap_CS_iter6_fsm_state7 = ap_CS_iter6_fsm[32'd1];

always @ (*) begin
    ap_block_state1_pp0_stage0_iter0 = ((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_1209_p2 == 1'd0)) | ((ap_predicate_op323_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)));
end

assign ap_block_state2_pp0_stage0_iter1 = ~(1'b1 == 1'b1);

assign ap_block_state3_pp0_stage0_iter2 = ~(1'b1 == 1'b1);

assign ap_block_state4_pp0_stage0_iter3 = ~(1'b1 == 1'b1);

assign ap_block_state5_pp0_stage0_iter4 = ~(1'b1 == 1'b1);

assign ap_block_state6_pp0_stage0_iter5 = ~(1'b1 == 1'b1);

always @ (*) begin
    ap_block_state7_io = ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0));
end

always @ (*) begin
    ap_block_state7_pp0_stage0_iter6 = ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0));
end

always @ (*) begin
    ap_condition_2547 = (~((ap_start_int == 1'b0) | ((weights_V_TVALID == 1'b0) & (icmp_ln249_fu_1209_p2 == 1'd0)) | ((ap_predicate_op323_read_state1 == 1'b1) & (in0_V_TVALID == 1'b0)) | ((1'b1 == ap_CS_iter6_fsm_state7) & ((1'b1 == ap_block_state7_io) | ((ap_predicate_op774_write_state7 == 1'b1) & (out_V_TREADY == 1'b0))))) & (1'b1 == ap_CS_iter0_fsm_state1));
end

assign ap_loop_exit_ready = ap_condition_exit_pp0_iter0_stage0;

assign ap_phi_reg_pp0_iter0_inElem_1_reg_1176 = 'bx;

always @ (*) begin
    ap_predicate_op323_read_state1 = ((icmp_ln253_fu_1221_p2 == 1'd1) & (icmp_ln249_fu_1209_p2 == 1'd0));
end

always @ (*) begin
    ap_predicate_op774_write_state7 = ((icmp_ln290_reg_4134_pp0_iter5_reg == 1'd1) & (icmp_ln249_reg_4103_pp0_iter5_reg == 1'd0));
end

assign grp_fu_3182_p0 = grp_fu_3182_p00;

assign grp_fu_3182_p00 = ap_phi_mux_inElem_1_phi_fu_1179_p4;

assign grp_fu_3182_p2 = ((icmp_ln272_reg_4129_pp0_iter2_reg[0:0] == 1'b1) ? 14'd0 : ap_sig_allocacmp_add_i4_i338_load);

assign i_2_fu_1215_p2 = (ap_sig_allocacmp_i_1 + 20'd1);

assign icmp_ln1039_10_fu_2876_p2 = (($signed(grp_fu_3182_p3) < $signed(zext_ln1039_2_fu_2872_p1)) ? 1'b1 : 1'b0);

assign icmp_ln1039_11_fu_2885_p2 = (($signed(grp_fu_3182_p3) < $signed(zext_ln1039_3_fu_2881_p1)) ? 1'b1 : 1'b0);

assign icmp_ln1039_12_fu_2894_p2 = (($signed(grp_fu_3182_p3) < $signed(zext_ln1039_4_fu_2890_p1)) ? 1'b1 : 1'b0);

assign icmp_ln1039_13_fu_2903_p2 = (($signed(grp_fu_3182_p3) < $signed(zext_ln1039_5_fu_2899_p1)) ? 1'b1 : 1'b0);

assign icmp_ln1039_14_fu_2912_p2 = (($signed(grp_fu_3182_p3) < $signed(zext_ln1039_6_fu_2908_p1)) ? 1'b1 : 1'b0);

assign icmp_ln1039_1_fu_2795_p2 = (($signed(grp_fu_3182_p3) < $signed(sext_ln1039_1_fu_2791_p1)) ? 1'b1 : 1'b0);

assign icmp_ln1039_2_fu_2804_p2 = (($signed(grp_fu_3182_p3) < $signed(sext_ln1039_2_fu_2800_p1)) ? 1'b1 : 1'b0);

assign icmp_ln1039_3_fu_2813_p2 = (($signed(grp_fu_3182_p3) < $signed(sext_ln1039_3_fu_2809_p1)) ? 1'b1 : 1'b0);

assign icmp_ln1039_4_fu_2822_p2 = (($signed(grp_fu_3182_p3) < $signed(sext_ln1039_4_fu_2818_p1)) ? 1'b1 : 1'b0);

assign icmp_ln1039_5_fu_2831_p2 = (($signed(grp_fu_3182_p3) < $signed(sext_ln1039_5_fu_2827_p1)) ? 1'b1 : 1'b0);

assign icmp_ln1039_6_fu_2840_p2 = (($signed(grp_fu_3182_p3) < $signed(sext_ln1039_6_fu_2836_p1)) ? 1'b1 : 1'b0);

assign icmp_ln1039_7_fu_2849_p2 = (($signed(grp_fu_3182_p3) < $signed(sext_ln1039_7_fu_2845_p1)) ? 1'b1 : 1'b0);

assign icmp_ln1039_8_fu_2858_p2 = (($signed(grp_fu_3182_p3) < $signed(zext_ln1039_fu_2854_p1)) ? 1'b1 : 1'b0);

assign icmp_ln1039_9_fu_2867_p2 = (($signed(grp_fu_3182_p3) < $signed(zext_ln1039_1_fu_2863_p1)) ? 1'b1 : 1'b0);

assign icmp_ln1039_fu_2786_p2 = (($signed(grp_fu_3182_p3) < $signed(sext_ln1039_fu_2782_p1)) ? 1'b1 : 1'b0);

assign icmp_ln249_fu_1209_p2 = ((ap_sig_allocacmp_i_1 == 20'd903168) ? 1'b1 : 1'b0);

assign icmp_ln249_reg_4103_pp0_iter0_reg = icmp_ln249_reg_4103;

assign icmp_ln253_fu_1221_p2 = ((ap_sig_allocacmp_nf_2 == 32'd0) ? 1'b1 : 1'b0);

assign icmp_ln253_reg_4107_pp0_iter0_reg = icmp_ln253_reg_4107;

assign icmp_ln272_fu_2689_p2 = ((ap_sig_allocacmp_sf_1 == 32'd0) ? 1'b1 : 1'b0);

assign icmp_ln290_fu_2701_p2 = ((sf_2_fu_2695_p2 == 32'd144) ? 1'b1 : 1'b0);

assign icmp_ln302_fu_2718_p2 = ((nf_fu_2712_p2 == 32'd32) ? 1'b1 : 1'b0);

assign idxprom2_i_fu_2764_p1 = nf_2_reg_4098_pp0_iter2_reg;

assign inElem_fu_1957_p1 = in0_V_TDATA[3:0];

assign nf_3_fu_2724_p3 = ((icmp_ln302_fu_2718_p2[0:0] == 1'b1) ? 32'd0 : nf_fu_2712_p2);

assign nf_fu_2712_p2 = (ap_sig_allocacmp_nf_2 + 32'd1);

assign out_V_TDATA = result_V_2_fu_3171_p2;

assign p_ZL7threshs_0_address0 = idxprom2_i_fu_2764_p1;

assign p_ZL7threshs_10_address0 = idxprom2_i_fu_2764_p1;

assign p_ZL7threshs_11_address0 = idxprom2_i_fu_2764_p1;

assign p_ZL7threshs_12_address0 = idxprom2_i_fu_2764_p1;

assign p_ZL7threshs_13_address0 = idxprom2_i_fu_2764_p1;

assign p_ZL7threshs_14_address0 = idxprom2_i_fu_2764_p1;

assign p_ZL7threshs_1_address0 = idxprom2_i_fu_2764_p1;

assign p_ZL7threshs_2_address0 = idxprom2_i_fu_2764_p1;

assign p_ZL7threshs_3_address0 = idxprom2_i_fu_2764_p1;

assign p_ZL7threshs_4_address0 = idxprom2_i_fu_2764_p1;

assign p_ZL7threshs_5_address0 = idxprom2_i_fu_2764_p1;

assign p_ZL7threshs_6_address0 = idxprom2_i_fu_2764_p1;

assign p_ZL7threshs_7_address0 = idxprom2_i_fu_2764_p1;

assign p_ZL7threshs_8_address0 = idxprom2_i_fu_2764_p1;

assign p_ZL7threshs_9_address0 = idxprom2_i_fu_2764_p1;

assign result_V_2_fu_3171_p2 = (add_ln840_13_fu_3165_p2 + zext_ln840_4_fu_3156_p1);

assign result_V_fu_2921_p2 = (icmp_ln1039_reg_4228 ^ 1'd1);

assign sext_ln1039_1_fu_2791_p1 = $signed(p_ZL7threshs_1_q0);

assign sext_ln1039_2_fu_2800_p1 = $signed(p_ZL7threshs_2_q0);

assign sext_ln1039_3_fu_2809_p1 = $signed(p_ZL7threshs_3_q0);

assign sext_ln1039_4_fu_2818_p1 = $signed(p_ZL7threshs_4_q0);

assign sext_ln1039_5_fu_2827_p1 = $signed(p_ZL7threshs_5_q0);

assign sext_ln1039_6_fu_2836_p1 = $signed(p_ZL7threshs_6_q0);

assign sext_ln1039_7_fu_2845_p1 = $signed(p_ZL7threshs_7_q0);

assign sext_ln1039_fu_2782_p1 = $signed(p_ZL7threshs_0_q0);

assign sf_2_fu_2695_p2 = (ap_sig_allocacmp_sf_1 + 32'd1);

assign tmp_fu_1663_p145 = ap_sig_allocacmp_sf_1[7:0];

assign trunc_ln257_fu_1961_p1 = ap_sig_allocacmp_sf_1[7:0];

assign xor_ln1039_10_fu_3020_p2 = (icmp_ln1039_11_reg_4283 ^ 1'd1);

assign xor_ln1039_11_fu_3029_p2 = (icmp_ln1039_12_reg_4288 ^ 1'd1);

assign xor_ln1039_12_fu_3038_p2 = (icmp_ln1039_13_reg_4293 ^ 1'd1);

assign xor_ln1039_13_fu_3047_p2 = (icmp_ln1039_14_reg_4298 ^ 1'd1);

assign xor_ln1039_1_fu_2939_p2 = (icmp_ln1039_2_reg_4238 ^ 1'd1);

assign xor_ln1039_2_fu_2948_p2 = (icmp_ln1039_3_reg_4243 ^ 1'd1);

assign xor_ln1039_3_fu_2957_p2 = (icmp_ln1039_4_reg_4248 ^ 1'd1);

assign xor_ln1039_4_fu_2966_p2 = (icmp_ln1039_5_reg_4253 ^ 1'd1);

assign xor_ln1039_5_fu_2975_p2 = (icmp_ln1039_6_reg_4258 ^ 1'd1);

assign xor_ln1039_6_fu_2984_p2 = (icmp_ln1039_7_reg_4263 ^ 1'd1);

assign xor_ln1039_7_fu_2993_p2 = (icmp_ln1039_8_reg_4268 ^ 1'd1);

assign xor_ln1039_8_fu_3002_p2 = (icmp_ln1039_9_reg_4273 ^ 1'd1);

assign xor_ln1039_9_fu_3011_p2 = (icmp_ln1039_10_reg_4278 ^ 1'd1);

assign xor_ln1039_fu_2930_p2 = (icmp_ln1039_1_reg_4233 ^ 1'd1);

assign zext_ln1039_1_fu_2863_p1 = p_ZL7threshs_9_q0;

assign zext_ln1039_2_fu_2872_p1 = p_ZL7threshs_10_q0;

assign zext_ln1039_3_fu_2881_p1 = p_ZL7threshs_11_q0;

assign zext_ln1039_4_fu_2890_p1 = p_ZL7threshs_12_q0;

assign zext_ln1039_5_fu_2899_p1 = p_ZL7threshs_13_q0;

assign zext_ln1039_6_fu_2908_p1 = p_ZL7threshs_14_q0;

assign zext_ln1039_fu_2854_p1 = p_ZL7threshs_8_q0;

assign zext_ln215_fu_2926_p1 = result_V_fu_2921_p2;

assign zext_ln218_10_fu_3025_p1 = xor_ln1039_10_fu_3020_p2;

assign zext_ln218_11_fu_3034_p1 = xor_ln1039_11_fu_3029_p2;

assign zext_ln218_12_fu_3043_p1 = xor_ln1039_12_fu_3038_p2;

assign zext_ln218_1_fu_2944_p1 = xor_ln1039_1_fu_2939_p2;

assign zext_ln218_2_fu_2953_p1 = xor_ln1039_2_fu_2948_p2;

assign zext_ln218_3_fu_2962_p1 = xor_ln1039_3_fu_2957_p2;

assign zext_ln218_4_fu_2971_p1 = xor_ln1039_4_fu_2966_p2;

assign zext_ln218_5_fu_2980_p1 = xor_ln1039_5_fu_2975_p2;

assign zext_ln218_6_fu_2989_p1 = xor_ln1039_6_fu_2984_p2;

assign zext_ln218_7_fu_2998_p1 = xor_ln1039_7_fu_2993_p2;

assign zext_ln218_8_fu_3007_p1 = xor_ln1039_8_fu_3002_p2;

assign zext_ln218_9_fu_3016_p1 = xor_ln1039_9_fu_3011_p2;

assign zext_ln218_fu_2935_p1 = xor_ln1039_fu_2930_p2;

assign zext_ln840_10_fu_3162_p1 = add_ln840_12_reg_4313;

assign zext_ln840_1_fu_3068_p1 = add_ln840_2_fu_3062_p2;

assign zext_ln840_2_fu_3078_p1 = add_ln840_3_fu_3072_p2;

assign zext_ln840_3_fu_3088_p1 = add_ln840_4_fu_3082_p2;

assign zext_ln840_4_fu_3156_p1 = add_ln840_6_reg_4303;

assign zext_ln840_5_fu_3110_p1 = add_ln840_7_fu_3104_p2;

assign zext_ln840_6_fu_3120_p1 = add_ln840_8_fu_3114_p2;

assign zext_ln840_7_fu_3159_p1 = add_ln840_9_reg_4308;

assign zext_ln840_8_fu_3136_p1 = add_ln840_10_fu_3130_p2;

assign zext_ln840_9_fu_3146_p1 = add_ln840_11_fu_3140_p2;

assign zext_ln840_fu_3052_p1 = xor_ln1039_13_fu_3047_p2;

endmodule //MVAU_hls_1_Matrix_Vector_Activate_Stream_Batch
//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/vivado_stitch_proj_w5fn6zuu/finn_vivado_stitch_proj.gen/sources_1/bd/finn_design/ipshared/18e4/hdl/verilog/MVAU_hls_0_Matrix_Vector_Activate_Stream_Batch_p_ZL7threshs_1_ROM_AUTO_1R.v


// ==============================================================
// Vitis HLS - High-Level Synthesis from C, C++ and OpenCL v2022.2 (64-bit)
// Version: 2022.2
// Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.
// ==============================================================
`timescale 1 ns / 1 ps
module MVAU_hls_0_Matrix_Vector_Activate_Stream_Batch_p_ZL7threshs_1_ROM_AUTO_1R (
    address0, ce0, q0, 
    reset, clk);

parameter DataWidth = 12;
parameter AddressWidth = 4;
parameter AddressRange = 16;
 
input[AddressWidth-1:0] address0;
input ce0;
output reg[DataWidth-1:0] q0;

input reset;
input clk;

 
reg [DataWidth-1:0] rom0[0:AddressRange-1];


initial begin
     
    $readmemh("/home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/code_gen_ipgen_MVAU_hls_0_z2r2fzak/project_MVAU_hls_0/sol1/impl/ip/hdl/verilog/MVAU_hls_0_Matrix_Vector_Activate_Stream_Batch_p_ZL7threshs_1_ROM_AUTO_1R.dat", rom0);
end

  
always @(posedge clk) 
begin 
    if (ce0) 
    begin
        q0 <= rom0[address0];
    end
end


endmodule

//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/vivado_stitch_proj_w5fn6zuu/finn_vivado_stitch_proj.gen/sources_1/bd/finn_design/ipshared/18e4/hdl/verilog/MVAU_hls_0_hls_deadlock_idx1_monitor.v


`timescale 1 ns / 1 ps

module MVAU_hls_0_hls_deadlock_idx1_monitor ( // for module MVAU_hls_0_MVAU_hls_0_inst.grp_Matrix_Vector_Activate_Stream_Batch_fu_60
    input wire clock,
    input wire reset,
    input wire [2:0] axis_block_sigs,
    input wire [1:0] inst_idle_sigs,
    input wire [0:0] inst_block_sigs,
    output wire block
);

// signal declare
reg monitor_find_block;
wire sub_parallel_block;
wire all_sub_parallel_has_block;
wire all_sub_single_has_block;
wire cur_axis_has_block;
wire seq_is_axis_block;

assign block = monitor_find_block;
assign all_sub_parallel_has_block = 1'b0;
assign all_sub_single_has_block = 1'b0;
assign cur_axis_has_block = 1'b0 | axis_block_sigs[0] | axis_block_sigs[1] | axis_block_sigs[2];
assign seq_is_axis_block = all_sub_parallel_has_block | all_sub_single_has_block | cur_axis_has_block;

always @(posedge clock) begin
    if (reset == 1'b1)
        monitor_find_block <= 1'b0;
    else if (seq_is_axis_block == 1'b1)
        monitor_find_block <= 1'b1;
    else
        monitor_find_block <= 1'b0;
end


// instant sub module
endmodule
//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/vivado_stitch_proj_w5fn6zuu/finn_vivado_stitch_proj.gen/sources_1/bd/finn_design/ipshared/fb57/hdl/verilog/MVAU_hls_1_Matrix_Vector_Activate_Stream_Batch_p_ZL7threshs_14_ROM_AUTO_1R.v


// ==============================================================
// Vitis HLS - High-Level Synthesis from C, C++ and OpenCL v2022.2 (64-bit)
// Version: 2022.2
// Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.
// ==============================================================
`timescale 1 ns / 1 ps
module MVAU_hls_1_Matrix_Vector_Activate_Stream_Batch_p_ZL7threshs_14_ROM_AUTO_1R (
    address0, ce0, q0, 
    reset, clk);

parameter DataWidth = 10;
parameter AddressWidth = 5;
parameter AddressRange = 32;
 
input[AddressWidth-1:0] address0;
input ce0;
output reg[DataWidth-1:0] q0;

input reset;
input clk;

 
reg [DataWidth-1:0] rom0[0:AddressRange-1];


initial begin
     
    $readmemh("/home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/code_gen_ipgen_MVAU_hls_1__774deg0/project_MVAU_hls_1/sol1/impl/ip/hdl/verilog/MVAU_hls_1_Matrix_Vector_Activate_Stream_Batch_p_ZL7threshs_14_ROM_AUTO_1R.dat", rom0);
end

  
always @(posedge clk) 
begin 
    if (ce0) 
    begin
        q0 <= rom0[address0];
    end
end


endmodule

//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/vivado_stitch_proj_w5fn6zuu/finn_vivado_stitch_proj.gen/sources_1/bd/finn_design/ipshared/4d6a/hdl/verilog/StreamingMaxPool_hls_1_regslice_both.v


// ==============================================================
// Vitis HLS - High-Level Synthesis from C, C++ and OpenCL v2022.2 (64-bit)
// Tool Version Limit: 2019.12
// Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.
// ==============================================================

`timescale 1ns/1ps

module StreamingMaxPool_hls_1_regslice_both
#(parameter 
    DataWidth=32
)(
    input ap_clk ,
    input ap_rst,

    input [DataWidth-1:0] data_in , 
    input vld_in , 
    output ack_in ,
    output [DataWidth-1:0] data_out, 
    output vld_out,
    input ack_out,
    output apdone_blk
);
 

reg   [1:0] B_V_data_1_state;
wire   [DataWidth-1:0] B_V_data_1_data_in;
reg   [DataWidth-1:0] B_V_data_1_data_out;
wire    B_V_data_1_vld_reg;
wire    B_V_data_1_vld_in;
wire    B_V_data_1_vld_out;
reg   [DataWidth-1:0] B_V_data_1_payload_A;
reg   [DataWidth-1:0] B_V_data_1_payload_B;
reg    B_V_data_1_sel_rd;
reg    B_V_data_1_sel_wr;
wire    B_V_data_1_sel;
wire    B_V_data_1_load_A;
wire    B_V_data_1_load_B;
wire    B_V_data_1_state_cmp_full;
wire    B_V_data_1_ack_in;
wire    B_V_data_1_ack_out;

always @ (posedge ap_clk) begin
    if (ap_rst == 1'b1) begin
        B_V_data_1_sel_rd <= 1'b0;
    end else begin
        if (((1'b1 == B_V_data_1_vld_out) & (1'b1 == B_V_data_1_ack_out))) begin
            B_V_data_1_sel_rd <= ~B_V_data_1_sel_rd;
        end else begin
            B_V_data_1_sel_rd <= B_V_data_1_sel_rd;
        end
    end
end

always @ (posedge ap_clk) begin
    if (ap_rst == 1'b1) begin
        B_V_data_1_sel_wr <= 1'b0;
    end else begin
        if (((1'b1 == B_V_data_1_vld_in) & (1'b1 == B_V_data_1_ack_in))) begin
            B_V_data_1_sel_wr <= ~B_V_data_1_sel_wr;
        end else begin
            B_V_data_1_sel_wr <= B_V_data_1_sel_wr;
        end
    end
end

always @ (posedge ap_clk) begin
    if (ap_rst == 1'b1) begin
        B_V_data_1_state <= 2'd0;
    end else begin
        if ((((2'd3 == B_V_data_1_state) & (1'b0 == B_V_data_1_vld_in) & (1'b1 == B_V_data_1_ack_out)) | ((2'd2 == B_V_data_1_state) & (1'b0 == B_V_data_1_vld_in)))) begin
            B_V_data_1_state <= 2'd2;
        end else if ((((2'd1 == B_V_data_1_state) & (1'b0 == B_V_data_1_ack_out)) | ((2'd3 == B_V_data_1_state) & (1'b0 == B_V_data_1_ack_out) & (1'b1 == B_V_data_1_vld_in)))) begin
            B_V_data_1_state <= 2'd1;
        end else if ((((2'd1 == B_V_data_1_state) & (1'b1 == B_V_data_1_ack_out)) | (~((1'b0 == B_V_data_1_ack_out) & (1'b1 == B_V_data_1_vld_in)) & ~((1'b0 == B_V_data_1_vld_in) & (1'b1 == B_V_data_1_ack_out)) & (2'd3 == B_V_data_1_state)) | ((2'd2 == B_V_data_1_state) & (1'b1 == B_V_data_1_vld_in)))) begin
            B_V_data_1_state <= 2'd3;
        end else begin
            B_V_data_1_state <= 2'd2;
        end
    end
end

always @ (posedge ap_clk) begin
    if ((1'b1 == B_V_data_1_load_A)) begin
        B_V_data_1_payload_A <= B_V_data_1_data_in;
    end
end

always @ (posedge ap_clk) begin
    if ((1'b1 == B_V_data_1_load_B)) begin
        B_V_data_1_payload_B <= B_V_data_1_data_in;
    end
end

always @ (*) begin
    if ((1'b1 == B_V_data_1_sel)) begin
        B_V_data_1_data_out = B_V_data_1_payload_B;
    end else begin
        B_V_data_1_data_out = B_V_data_1_payload_A;
    end
end

assign B_V_data_1_ack_in = B_V_data_1_state[1'd1];
assign B_V_data_1_load_A = (~B_V_data_1_sel_wr & B_V_data_1_state_cmp_full);
assign B_V_data_1_load_B = (B_V_data_1_state_cmp_full & B_V_data_1_sel_wr);
assign B_V_data_1_sel = B_V_data_1_sel_rd;
assign B_V_data_1_state_cmp_full = ((B_V_data_1_state != 2'd1) ? 1'b1 : 1'b0);
assign B_V_data_1_vld_out = B_V_data_1_state[1'd0];

assign ack_in = B_V_data_1_ack_in;
assign B_V_data_1_data_in = data_in;
assign B_V_data_1_vld_in = vld_in;

assign vld_out = B_V_data_1_vld_out;
assign data_out = B_V_data_1_data_out;
assign B_V_data_1_ack_out = ack_out;

assign apdone_blk = ((B_V_data_1_state == 2'd3 && ack_out == 1'b0) | (B_V_data_1_state == 2'd1));

endmodule // both

module StreamingMaxPool_hls_1_regslice_both_w1
#(parameter 
    DataWidth=1
)(
    input ap_clk ,
    input ap_rst,

    input data_in , 
    input vld_in , 
    output ack_in ,
    output data_out, 
    output vld_out,
    input ack_out,
    output apdone_blk
);

reg     [1:0] B_V_data_1_state;
wire    B_V_data_1_data_in;
reg     B_V_data_1_data_out;
wire    B_V_data_1_vld_reg;
wire    B_V_data_1_vld_in;
wire    B_V_data_1_vld_out;
reg     B_V_data_1_payload_A;
reg     B_V_data_1_payload_B;
reg     B_V_data_1_sel_rd;
reg     B_V_data_1_sel_wr;
wire    B_V_data_1_sel;
wire    B_V_data_1_load_A;
wire    B_V_data_1_load_B;
wire    B_V_data_1_state_cmp_full;
wire    B_V_data_1_ack_in;
wire    B_V_data_1_ack_out;

always @ (posedge ap_clk) begin
    if (ap_rst == 1'b1) begin
        B_V_data_1_sel_rd <= 1'b0;
    end else begin
        if (((1'b1 == B_V_data_1_vld_out) & (1'b1 == B_V_data_1_ack_out))) begin
            B_V_data_1_sel_rd <= ~B_V_data_1_sel_rd;
        end else begin
            B_V_data_1_sel_rd <= B_V_data_1_sel_rd;
        end
    end
end

always @ (posedge ap_clk) begin
    if (ap_rst == 1'b1) begin
        B_V_data_1_sel_wr <= 1'b0;
    end else begin
        if (((1'b1 == B_V_data_1_vld_in) & (1'b1 == B_V_data_1_ack_in))) begin
            B_V_data_1_sel_wr <= ~B_V_data_1_sel_wr;
        end else begin
            B_V_data_1_sel_wr <= B_V_data_1_sel_wr;
        end
    end
end

always @ (posedge ap_clk) begin
    if (ap_rst == 1'b1) begin
        B_V_data_1_state <= 2'd0;
    end else begin
        if ((((2'd3 == B_V_data_1_state) & (1'b0 == B_V_data_1_vld_in) & (1'b1 == B_V_data_1_ack_out)) | ((2'd2 == B_V_data_1_state) & (1'b0 == B_V_data_1_vld_in)))) begin
            B_V_data_1_state <= 2'd2;
        end else if ((((2'd1 == B_V_data_1_state) & (1'b0 == B_V_data_1_ack_out)) | ((2'd3 == B_V_data_1_state) & (1'b0 == B_V_data_1_ack_out) & (1'b1 == B_V_data_1_vld_in)))) begin
            B_V_data_1_state <= 2'd1;
        end else if ((((2'd1 == B_V_data_1_state) & (1'b1 == B_V_data_1_ack_out)) | (~((1'b0 == B_V_data_1_ack_out) & (1'b1 == B_V_data_1_vld_in)) & ~((1'b0 == B_V_data_1_vld_in) & (1'b1 == B_V_data_1_ack_out)) & (2'd3 == B_V_data_1_state)) | ((2'd2 == B_V_data_1_state) & (1'b1 == B_V_data_1_vld_in)))) begin
            B_V_data_1_state <= 2'd3;
        end else begin
            B_V_data_1_state <= 2'd2;
        end
    end
end

always @ (posedge ap_clk) begin
    if ((1'b1 == B_V_data_1_load_A)) begin
        B_V_data_1_payload_A <= B_V_data_1_data_in;
    end
end

always @ (posedge ap_clk) begin
    if ((1'b1 == B_V_data_1_load_B)) begin
        B_V_data_1_payload_B <= B_V_data_1_data_in;
    end
end

always @ (*) begin
    if ((1'b1 == B_V_data_1_sel)) begin
        B_V_data_1_data_out = B_V_data_1_payload_B;
    end else begin
        B_V_data_1_data_out = B_V_data_1_payload_A;
    end
end

assign B_V_data_1_ack_in = B_V_data_1_state[1'd1];
assign B_V_data_1_load_A = (~B_V_data_1_sel_wr & B_V_data_1_state_cmp_full);
assign B_V_data_1_load_B = (B_V_data_1_state_cmp_full & B_V_data_1_sel_wr);
assign B_V_data_1_sel = B_V_data_1_sel_rd;
assign B_V_data_1_state_cmp_full = ((B_V_data_1_state != 2'd1) ? 1'b1 : 1'b0);
assign B_V_data_1_vld_out = B_V_data_1_state[1'd0];

assign ack_in = B_V_data_1_ack_in;
assign B_V_data_1_data_in = data_in;
assign B_V_data_1_vld_in = vld_in;

assign vld_out = B_V_data_1_vld_out;
assign data_out = B_V_data_1_data_out;
assign B_V_data_1_ack_out = ack_out;

assign apdone_blk = ((B_V_data_1_state == 2'd3 && ack_out == 1'b0) | (B_V_data_1_state == 2'd1));

endmodule // both


//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/vivado_stitch_proj_w5fn6zuu/finn_vivado_stitch_proj.gen/sources_1/bd/finn_design/ip/finn_design_MVAU_rtl_0_wstrm_0/synth/finn_design_MVAU_rtl_0_wstrm_0.v


// (c) Copyright 1995-2026 Xilinx, Inc. All rights reserved.
// 
// This file contains confidential and proprietary information
// of Xilinx, Inc. and is protected under U.S. and
// international copyright and other intellectual property
// laws.
// 
// DISCLAIMER
// This disclaimer is not a license and does not grant any
// rights to the materials distributed herewith. Except as
// otherwise provided in a valid license issued to you by
// Xilinx, and to the maximum extent permitted by applicable
// law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
// WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
// AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
// BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
// INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
// (2) Xilinx shall not be liable (whether in contract or tort,
// including negligence, or under any other theory of
// liability) for any loss or damage of any kind or nature
// related to, arising under or in connection with these
// materials, including for any direct, or any indirect,
// special, incidental, or consequential loss or damage
// (including loss of data, profits, goodwill, or any type of
// loss or damage suffered as a result of any action brought
// by a third party) even if such damage or loss was
// reasonably foreseeable or Xilinx had been advised of the
// possibility of the same.
// 
// CRITICAL APPLICATIONS
// Xilinx products are not designed or intended to be fail-
// safe, or for use in any application requiring fail-safe
// performance, such as life-support or safety devices or
// systems, Class III medical devices, nuclear facilities,
// applications related to the deployment of airbags, or any
// other applications that could lead to death, personal
// injury, or severe property or environmental damage
// (individually and collectively, "Critical
// Applications"). Customer assumes the sole risk and
// liability of any use of Xilinx products in Critical
// Applications, subject only to applicable laws and
// regulations governing limitations on product liability.
// 
// THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
// PART OF THIS FILE AT ALL TIMES.
// 
// DO NOT MODIFY THIS FILE.


// IP VLNV: amd.com:finn:memstream:1.0
// IP Revision: 5

(* X_CORE_INFO = "memstream_axi_wrapper,Vivado 2022.2" *)
(* CHECK_LICENSE_TYPE = "finn_design_MVAU_rtl_0_wstrm_0,memstream_axi_wrapper,{}" *)
(* IP_DEFINITION_SOURCE = "package_project" *)
(* DowngradeIPIdentifiedWarnings = "yes" *)
module finn_design_MVAU_rtl_0_wstrm_0 (
  ap_clk,
  ap_rst_n,
  awready,
  awvalid,
  awprot,
  awaddr,
  wready,
  wvalid,
  wdata,
  wstrb,
  bready,
  bvalid,
  bresp,
  arready,
  arvalid,
  arprot,
  araddr,
  rready,
  rvalid,
  rresp,
  rdata,
  m_axis_0_tready,
  m_axis_0_tvalid,
  m_axis_0_tdata
);

(* X_INTERFACE_PARAMETER = "XIL_INTERFACENAME ap_clk, ASSOCIATED_RESET ap_rst_n, ASSOCIATED_BUSIF m_axis_0:s_axilite, FREQ_TOLERANCE_HZ -1, FREQ_HZ 100000000, PHASE 0.0, CLK_DOMAIN finn_design_ap_clk_0, INSERT_VIP 0" *)
(* X_INTERFACE_INFO = "xilinx.com:signal:clock:1.0 ap_clk CLK" *)
input wire ap_clk;
(* X_INTERFACE_PARAMETER = "XIL_INTERFACENAME ap_rst_n, POLARITY ACTIVE_LOW, INSERT_VIP 0" *)
(* X_INTERFACE_INFO = "xilinx.com:signal:reset:1.0 ap_rst_n RST" *)
input wire ap_rst_n;
(* X_INTERFACE_INFO = "xilinx.com:interface:aximm:1.0 s_axilite AWREADY" *)
output wire awready;
(* X_INTERFACE_INFO = "xilinx.com:interface:aximm:1.0 s_axilite AWVALID" *)
input wire awvalid;
(* X_INTERFACE_INFO = "xilinx.com:interface:aximm:1.0 s_axilite AWPROT" *)
input wire [2 : 0] awprot;
(* X_INTERFACE_INFO = "xilinx.com:interface:aximm:1.0 s_axilite AWADDR" *)
input wire [15 : 0] awaddr;
(* X_INTERFACE_INFO = "xilinx.com:interface:aximm:1.0 s_axilite WREADY" *)
output wire wready;
(* X_INTERFACE_INFO = "xilinx.com:interface:aximm:1.0 s_axilite WVALID" *)
input wire wvalid;
(* X_INTERFACE_INFO = "xilinx.com:interface:aximm:1.0 s_axilite WDATA" *)
input wire [31 : 0] wdata;
(* X_INTERFACE_INFO = "xilinx.com:interface:aximm:1.0 s_axilite WSTRB" *)
input wire [3 : 0] wstrb;
(* X_INTERFACE_INFO = "xilinx.com:interface:aximm:1.0 s_axilite BREADY" *)
input wire bready;
(* X_INTERFACE_INFO = "xilinx.com:interface:aximm:1.0 s_axilite BVALID" *)
output wire bvalid;
(* X_INTERFACE_INFO = "xilinx.com:interface:aximm:1.0 s_axilite BRESP" *)
output wire [1 : 0] bresp;
(* X_INTERFACE_INFO = "xilinx.com:interface:aximm:1.0 s_axilite ARREADY" *)
output wire arready;
(* X_INTERFACE_INFO = "xilinx.com:interface:aximm:1.0 s_axilite ARVALID" *)
input wire arvalid;
(* X_INTERFACE_INFO = "xilinx.com:interface:aximm:1.0 s_axilite ARPROT" *)
input wire [2 : 0] arprot;
(* X_INTERFACE_INFO = "xilinx.com:interface:aximm:1.0 s_axilite ARADDR" *)
input wire [15 : 0] araddr;
(* X_INTERFACE_INFO = "xilinx.com:interface:aximm:1.0 s_axilite RREADY" *)
input wire rready;
(* X_INTERFACE_INFO = "xilinx.com:interface:aximm:1.0 s_axilite RVALID" *)
output wire rvalid;
(* X_INTERFACE_INFO = "xilinx.com:interface:aximm:1.0 s_axilite RRESP" *)
output wire [1 : 0] rresp;
(* X_INTERFACE_PARAMETER = "XIL_INTERFACENAME s_axilite, DATA_WIDTH 32, PROTOCOL AXI4LITE, FREQ_HZ 100000000, ID_WIDTH 0, ADDR_WIDTH 16, AWUSER_WIDTH 0, ARUSER_WIDTH 0, WUSER_WIDTH 0, RUSER_WIDTH 0, BUSER_WIDTH 0, READ_WRITE_MODE READ_WRITE, HAS_BURST 0, HAS_LOCK 0, HAS_PROT 1, HAS_CACHE 0, HAS_QOS 0, HAS_REGION 0, HAS_WSTRB 1, HAS_BRESP 1, HAS_RRESP 1, SUPPORTS_NARROW_BURST 0, NUM_READ_OUTSTANDING 1, NUM_WRITE_OUTSTANDING 1, MAX_BURST_LENGTH 1, PHASE 0.0, CLK_DOMAIN finn_design_ap_clk_0, NUM_READ_THREADS 1, NUM_WRITE_THRE\
ADS 1, RUSER_BITS_PER_BYTE 0, WUSER_BITS_PER_BYTE 0, INSERT_VIP 0" *)
(* X_INTERFACE_INFO = "xilinx.com:interface:aximm:1.0 s_axilite RDATA" *)
output wire [31 : 0] rdata;
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 m_axis_0 TREADY" *)
input wire m_axis_0_tready;
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 m_axis_0 TVALID" *)
output wire m_axis_0_tvalid;
(* X_INTERFACE_PARAMETER = "XIL_INTERFACENAME m_axis_0, TDATA_NUM_BYTES 1, TDEST_WIDTH 0, TID_WIDTH 0, TUSER_WIDTH 0, HAS_TREADY 1, HAS_TSTRB 0, HAS_TKEEP 0, HAS_TLAST 0, FREQ_HZ 100000000, PHASE 0.0, CLK_DOMAIN finn_design_ap_clk_0, LAYERED_METADATA undef, INSERT_VIP 0" *)
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 m_axis_0 TDATA" *)
output wire [7 : 0] m_axis_0_tdata;

  memstream_axi_wrapper #(
    .DEPTH(15680),
    .WIDTH(8),
    .INIT_FILE("/home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/code_gen_ipgen_MVAU_rtl_0_9q5vhsod/memblock.dat"),
    .RAM_STYLE("auto"),
    .AXILITE_ADDR_WIDTH(16)
  ) inst (
    .ap_clk(ap_clk),
    .ap_rst_n(ap_rst_n),
    .awready(awready),
    .awvalid(awvalid),
    .awprot(awprot),
    .awaddr(awaddr),
    .wready(wready),
    .wvalid(wvalid),
    .wdata(wdata),
    .wstrb(wstrb),
    .bready(bready),
    .bvalid(bvalid),
    .bresp(bresp),
    .arready(arready),
    .arvalid(arvalid),
    .arprot(arprot),
    .araddr(araddr),
    .rready(rready),
    .rvalid(rvalid),
    .rresp(rresp),
    .rdata(rdata),
    .m_axis_0_tready(m_axis_0_tready),
    .m_axis_0_tvalid(m_axis_0_tvalid),
    .m_axis_0_tdata(m_axis_0_tdata)
  );
endmodule
//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/vivado_stitch_proj_w5fn6zuu/finn_vivado_stitch_proj.gen/sources_1/bd/finn_design/ipshared/18e4/hdl/verilog/MVAU_hls_0_Matrix_Vector_Activate_Stream_Batch_p_ZL7threshs_7_ROM_AUTO_1R.v


// ==============================================================
// Vitis HLS - High-Level Synthesis from C, C++ and OpenCL v2022.2 (64-bit)
// Version: 2022.2
// Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.
// ==============================================================
`timescale 1 ns / 1 ps
module MVAU_hls_0_Matrix_Vector_Activate_Stream_Batch_p_ZL7threshs_7_ROM_AUTO_1R (
    address0, ce0, q0, 
    reset, clk);

parameter DataWidth = 13;
parameter AddressWidth = 4;
parameter AddressRange = 16;
 
input[AddressWidth-1:0] address0;
input ce0;
output reg[DataWidth-1:0] q0;

input reset;
input clk;

 
reg [DataWidth-1:0] rom0[0:AddressRange-1];


initial begin
     
    $readmemh("/home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/code_gen_ipgen_MVAU_hls_0_z2r2fzak/project_MVAU_hls_0/sol1/impl/ip/hdl/verilog/MVAU_hls_0_Matrix_Vector_Activate_Stream_Batch_p_ZL7threshs_7_ROM_AUTO_1R.dat", rom0);
end

  
always @(posedge clk) 
begin 
    if (ce0) 
    begin
        q0 <= rom0[address0];
    end
end


endmodule

//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/vivado_stitch_proj_w5fn6zuu/finn_vivado_stitch_proj.gen/sources_1/bd/finn_design/ipshared/4d6a/hdl/verilog/StreamingMaxPool_hls_1_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6.v


// ==============================================================
// RTL generated by Vitis HLS - High-Level Synthesis from C, C++ and OpenCL v2022.2 (64-bit)
// Version: 2022.2
// Copyright (C) Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.
// 
// ===========================================================

`timescale 1 ns / 1 ps 

module StreamingMaxPool_hls_1_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6 (
        ap_clk,
        ap_rst,
        ap_start,
        ap_done,
        ap_idle,
        ap_ready,
        in0_V_TVALID,
        buf_V_31_load_1,
        buf_V_30_load_1,
        buf_V_29_load_1,
        buf_V_28_load_1,
        buf_V_27_load_1,
        buf_V_26_load_1,
        buf_V_25_load_1,
        buf_V_24_load_1,
        buf_V_23_load_1,
        buf_V_22_load_1,
        buf_V_21_load_1,
        buf_V_20_load_1,
        buf_V_19_load_1,
        buf_V_18_load_1,
        buf_V_17_load_1,
        buf_V_16_load_1,
        buf_V_15_load_1,
        buf_V_14_load_1,
        buf_V_13_load_1,
        buf_V_12_load_1,
        buf_V_11_load_1,
        buf_V_10_load_1,
        buf_V_9_load_1,
        buf_V_8_load_1,
        buf_V_7_load_1,
        buf_V_6_load_1,
        buf_V_5_load_1,
        buf_V_4_load_1,
        buf_V_3_load_1,
        buf_V_2_load_1,
        buf_V_1_load_1,
        buf_V_load_1,
        buf_V_31_address0,
        buf_V_31_ce0,
        buf_V_31_we0,
        buf_V_31_d0,
        zext_ln156,
        buf_V_30_address0,
        buf_V_30_ce0,
        buf_V_30_we0,
        buf_V_30_d0,
        buf_V_29_address0,
        buf_V_29_ce0,
        buf_V_29_we0,
        buf_V_29_d0,
        buf_V_28_address0,
        buf_V_28_ce0,
        buf_V_28_we0,
        buf_V_28_d0,
        buf_V_27_address0,
        buf_V_27_ce0,
        buf_V_27_we0,
        buf_V_27_d0,
        buf_V_26_address0,
        buf_V_26_ce0,
        buf_V_26_we0,
        buf_V_26_d0,
        buf_V_25_address0,
        buf_V_25_ce0,
        buf_V_25_we0,
        buf_V_25_d0,
        buf_V_24_address0,
        buf_V_24_ce0,
        buf_V_24_we0,
        buf_V_24_d0,
        buf_V_23_address0,
        buf_V_23_ce0,
        buf_V_23_we0,
        buf_V_23_d0,
        buf_V_22_address0,
        buf_V_22_ce0,
        buf_V_22_we0,
        buf_V_22_d0,
        buf_V_21_address0,
        buf_V_21_ce0,
        buf_V_21_we0,
        buf_V_21_d0,
        buf_V_20_address0,
        buf_V_20_ce0,
        buf_V_20_we0,
        buf_V_20_d0,
        buf_V_19_address0,
        buf_V_19_ce0,
        buf_V_19_we0,
        buf_V_19_d0,
        buf_V_18_address0,
        buf_V_18_ce0,
        buf_V_18_we0,
        buf_V_18_d0,
        buf_V_17_address0,
        buf_V_17_ce0,
        buf_V_17_we0,
        buf_V_17_d0,
        buf_V_16_address0,
        buf_V_16_ce0,
        buf_V_16_we0,
        buf_V_16_d0,
        buf_V_15_address0,
        buf_V_15_ce0,
        buf_V_15_we0,
        buf_V_15_d0,
        buf_V_14_address0,
        buf_V_14_ce0,
        buf_V_14_we0,
        buf_V_14_d0,
        buf_V_13_address0,
        buf_V_13_ce0,
        buf_V_13_we0,
        buf_V_13_d0,
        buf_V_12_address0,
        buf_V_12_ce0,
        buf_V_12_we0,
        buf_V_12_d0,
        buf_V_11_address0,
        buf_V_11_ce0,
        buf_V_11_we0,
        buf_V_11_d0,
        buf_V_10_address0,
        buf_V_10_ce0,
        buf_V_10_we0,
        buf_V_10_d0,
        buf_V_9_address0,
        buf_V_9_ce0,
        buf_V_9_we0,
        buf_V_9_d0,
        buf_V_8_address0,
        buf_V_8_ce0,
        buf_V_8_we0,
        buf_V_8_d0,
        buf_V_7_address0,
        buf_V_7_ce0,
        buf_V_7_we0,
        buf_V_7_d0,
        buf_V_6_address0,
        buf_V_6_ce0,
        buf_V_6_we0,
        buf_V_6_d0,
        buf_V_5_address0,
        buf_V_5_ce0,
        buf_V_5_we0,
        buf_V_5_d0,
        buf_V_4_address0,
        buf_V_4_ce0,
        buf_V_4_we0,
        buf_V_4_d0,
        buf_V_3_address0,
        buf_V_3_ce0,
        buf_V_3_we0,
        buf_V_3_d0,
        buf_V_2_address0,
        buf_V_2_ce0,
        buf_V_2_we0,
        buf_V_2_d0,
        buf_V_1_address0,
        buf_V_1_ce0,
        buf_V_1_we0,
        buf_V_1_d0,
        buf_V_address0,
        buf_V_ce0,
        buf_V_we0,
        buf_V_d0,
        in0_V_TDATA,
        in0_V_TREADY
);

parameter    ap_ST_fsm_state1 = 1'd1;

input   ap_clk;
input   ap_rst;
input   ap_start;
output   ap_done;
output   ap_idle;
output   ap_ready;
input   in0_V_TVALID;
input  [3:0] buf_V_31_load_1;
input  [3:0] buf_V_30_load_1;
input  [3:0] buf_V_29_load_1;
input  [3:0] buf_V_28_load_1;
input  [3:0] buf_V_27_load_1;
input  [3:0] buf_V_26_load_1;
input  [3:0] buf_V_25_load_1;
input  [3:0] buf_V_24_load_1;
input  [3:0] buf_V_23_load_1;
input  [3:0] buf_V_22_load_1;
input  [3:0] buf_V_21_load_1;
input  [3:0] buf_V_20_load_1;
input  [3:0] buf_V_19_load_1;
input  [3:0] buf_V_18_load_1;
input  [3:0] buf_V_17_load_1;
input  [3:0] buf_V_16_load_1;
input  [3:0] buf_V_15_load_1;
input  [3:0] buf_V_14_load_1;
input  [3:0] buf_V_13_load_1;
input  [3:0] buf_V_12_load_1;
input  [3:0] buf_V_11_load_1;
input  [3:0] buf_V_10_load_1;
input  [3:0] buf_V_9_load_1;
input  [3:0] buf_V_8_load_1;
input  [3:0] buf_V_7_load_1;
input  [3:0] buf_V_6_load_1;
input  [3:0] buf_V_5_load_1;
input  [3:0] buf_V_4_load_1;
input  [3:0] buf_V_3_load_1;
input  [3:0] buf_V_2_load_1;
input  [3:0] buf_V_1_load_1;
input  [3:0] buf_V_load_1;
output  [2:0] buf_V_31_address0;
output   buf_V_31_ce0;
output   buf_V_31_we0;
output  [3:0] buf_V_31_d0;
input  [2:0] zext_ln156;
output  [2:0] buf_V_30_address0;
output   buf_V_30_ce0;
output   buf_V_30_we0;
output  [3:0] buf_V_30_d0;
output  [2:0] buf_V_29_address0;
output   buf_V_29_ce0;
output   buf_V_29_we0;
output  [3:0] buf_V_29_d0;
output  [2:0] buf_V_28_address0;
output   buf_V_28_ce0;
output   buf_V_28_we0;
output  [3:0] buf_V_28_d0;
output  [2:0] buf_V_27_address0;
output   buf_V_27_ce0;
output   buf_V_27_we0;
output  [3:0] buf_V_27_d0;
output  [2:0] buf_V_26_address0;
output   buf_V_26_ce0;
output   buf_V_26_we0;
output  [3:0] buf_V_26_d0;
output  [2:0] buf_V_25_address0;
output   buf_V_25_ce0;
output   buf_V_25_we0;
output  [3:0] buf_V_25_d0;
output  [2:0] buf_V_24_address0;
output   buf_V_24_ce0;
output   buf_V_24_we0;
output  [3:0] buf_V_24_d0;
output  [2:0] buf_V_23_address0;
output   buf_V_23_ce0;
output   buf_V_23_we0;
output  [3:0] buf_V_23_d0;
output  [2:0] buf_V_22_address0;
output   buf_V_22_ce0;
output   buf_V_22_we0;
output  [3:0] buf_V_22_d0;
output  [2:0] buf_V_21_address0;
output   buf_V_21_ce0;
output   buf_V_21_we0;
output  [3:0] buf_V_21_d0;
output  [2:0] buf_V_20_address0;
output   buf_V_20_ce0;
output   buf_V_20_we0;
output  [3:0] buf_V_20_d0;
output  [2:0] buf_V_19_address0;
output   buf_V_19_ce0;
output   buf_V_19_we0;
output  [3:0] buf_V_19_d0;
output  [2:0] buf_V_18_address0;
output   buf_V_18_ce0;
output   buf_V_18_we0;
output  [3:0] buf_V_18_d0;
output  [2:0] buf_V_17_address0;
output   buf_V_17_ce0;
output   buf_V_17_we0;
output  [3:0] buf_V_17_d0;
output  [2:0] buf_V_16_address0;
output   buf_V_16_ce0;
output   buf_V_16_we0;
output  [3:0] buf_V_16_d0;
output  [2:0] buf_V_15_address0;
output   buf_V_15_ce0;
output   buf_V_15_we0;
output  [3:0] buf_V_15_d0;
output  [2:0] buf_V_14_address0;
output   buf_V_14_ce0;
output   buf_V_14_we0;
output  [3:0] buf_V_14_d0;
output  [2:0] buf_V_13_address0;
output   buf_V_13_ce0;
output   buf_V_13_we0;
output  [3:0] buf_V_13_d0;
output  [2:0] buf_V_12_address0;
output   buf_V_12_ce0;
output   buf_V_12_we0;
output  [3:0] buf_V_12_d0;
output  [2:0] buf_V_11_address0;
output   buf_V_11_ce0;
output   buf_V_11_we0;
output  [3:0] buf_V_11_d0;
output  [2:0] buf_V_10_address0;
output   buf_V_10_ce0;
output   buf_V_10_we0;
output  [3:0] buf_V_10_d0;
output  [2:0] buf_V_9_address0;
output   buf_V_9_ce0;
output   buf_V_9_we0;
output  [3:0] buf_V_9_d0;
output  [2:0] buf_V_8_address0;
output   buf_V_8_ce0;
output   buf_V_8_we0;
output  [3:0] buf_V_8_d0;
output  [2:0] buf_V_7_address0;
output   buf_V_7_ce0;
output   buf_V_7_we0;
output  [3:0] buf_V_7_d0;
output  [2:0] buf_V_6_address0;
output   buf_V_6_ce0;
output   buf_V_6_we0;
output  [3:0] buf_V_6_d0;
output  [2:0] buf_V_5_address0;
output   buf_V_5_ce0;
output   buf_V_5_we0;
output  [3:0] buf_V_5_d0;
output  [2:0] buf_V_4_address0;
output   buf_V_4_ce0;
output   buf_V_4_we0;
output  [3:0] buf_V_4_d0;
output  [2:0] buf_V_3_address0;
output   buf_V_3_ce0;
output   buf_V_3_we0;
output  [3:0] buf_V_3_d0;
output  [2:0] buf_V_2_address0;
output   buf_V_2_ce0;
output   buf_V_2_we0;
output  [3:0] buf_V_2_d0;
output  [2:0] buf_V_1_address0;
output   buf_V_1_ce0;
output   buf_V_1_we0;
output  [3:0] buf_V_1_d0;
output  [2:0] buf_V_address0;
output   buf_V_ce0;
output   buf_V_we0;
output  [3:0] buf_V_d0;
input  [127:0] in0_V_TDATA;
output   in0_V_TREADY;

reg ap_idle;
reg buf_V_31_ce0;
reg buf_V_31_we0;
reg buf_V_30_ce0;
reg buf_V_30_we0;
reg buf_V_29_ce0;
reg buf_V_29_we0;
reg buf_V_28_ce0;
reg buf_V_28_we0;
reg buf_V_27_ce0;
reg buf_V_27_we0;
reg buf_V_26_ce0;
reg buf_V_26_we0;
reg buf_V_25_ce0;
reg buf_V_25_we0;
reg buf_V_24_ce0;
reg buf_V_24_we0;
reg buf_V_23_ce0;
reg buf_V_23_we0;
reg buf_V_22_ce0;
reg buf_V_22_we0;
reg buf_V_21_ce0;
reg buf_V_21_we0;
reg buf_V_20_ce0;
reg buf_V_20_we0;
reg buf_V_19_ce0;
reg buf_V_19_we0;
reg buf_V_18_ce0;
reg buf_V_18_we0;
reg buf_V_17_ce0;
reg buf_V_17_we0;
reg buf_V_16_ce0;
reg buf_V_16_we0;
reg buf_V_15_ce0;
reg buf_V_15_we0;
reg buf_V_14_ce0;
reg buf_V_14_we0;
reg buf_V_13_ce0;
reg buf_V_13_we0;
reg buf_V_12_ce0;
reg buf_V_12_we0;
reg buf_V_11_ce0;
reg buf_V_11_we0;
reg buf_V_10_ce0;
reg buf_V_10_we0;
reg buf_V_9_ce0;
reg buf_V_9_we0;
reg buf_V_8_ce0;
reg buf_V_8_we0;
reg buf_V_7_ce0;
reg buf_V_7_we0;
reg buf_V_6_ce0;
reg buf_V_6_we0;
reg buf_V_5_ce0;
reg buf_V_5_we0;
reg buf_V_4_ce0;
reg buf_V_4_we0;
reg buf_V_3_ce0;
reg buf_V_3_we0;
reg buf_V_2_ce0;
reg buf_V_2_we0;
reg buf_V_1_ce0;
reg buf_V_1_we0;
reg buf_V_ce0;
reg buf_V_we0;
reg in0_V_TREADY;

(* fsm_encoding = "none" *) reg   [0:0] ap_CS_fsm;
wire    ap_CS_fsm_state1;
wire   [0:0] icmp_ln158_fu_1254_p2;
reg    ap_block_state1_pp0_stage0_iter0;
reg    ap_condition_exit_pp0_iter0_stage0;
wire    ap_loop_exit_ready;
reg    ap_ready_int;
reg    in0_V_TDATA_blk_n;
wire   [63:0] zext_ln156_cast_fu_1050_p1;
reg   [1:0] kx_fu_298;
wire   [1:0] kx_2_fu_1260_p2;
wire    ap_loop_init;
reg   [1:0] ap_sig_allocacmp_kx_1;
reg   [3:0] oldMax_V_fu_302;
wire   [3:0] select_ln167_fu_1372_p3;
reg   [3:0] ap_sig_allocacmp_oldMax_V_load;
reg   [3:0] oldMax_V_1_fu_306;
wire   [3:0] select_ln167_1_fu_1397_p3;
reg   [3:0] ap_sig_allocacmp_oldMax_V_1_load;
reg   [3:0] oldMax_V_2_fu_310;
wire   [3:0] select_ln167_2_fu_1422_p3;
reg   [3:0] ap_sig_allocacmp_oldMax_V_2_load;
reg   [3:0] oldMax_V_3_fu_314;
wire   [3:0] select_ln167_3_fu_1447_p3;
reg   [3:0] ap_sig_allocacmp_oldMax_V_3_load;
reg   [3:0] oldMax_V_4_fu_318;
wire   [3:0] select_ln167_4_fu_1472_p3;
reg   [3:0] ap_sig_allocacmp_oldMax_V_4_load;
reg   [3:0] oldMax_V_5_fu_322;
wire   [3:0] select_ln167_5_fu_1497_p3;
reg   [3:0] ap_sig_allocacmp_oldMax_V_5_load;
reg   [3:0] oldMax_V_6_fu_326;
wire   [3:0] select_ln167_6_fu_1522_p3;
reg   [3:0] ap_sig_allocacmp_oldMax_V_6_load;
reg   [3:0] oldMax_V_7_fu_330;
wire   [3:0] select_ln167_7_fu_1547_p3;
reg   [3:0] ap_sig_allocacmp_oldMax_V_7_load;
reg   [3:0] oldMax_V_8_fu_334;
wire   [3:0] select_ln167_8_fu_1572_p3;
reg   [3:0] ap_sig_allocacmp_oldMax_V_8_load;
reg   [3:0] oldMax_V_9_fu_338;
wire   [3:0] select_ln167_9_fu_1597_p3;
reg   [3:0] ap_sig_allocacmp_oldMax_V_9_load;
reg   [3:0] oldMax_V_10_fu_342;
wire   [3:0] select_ln167_10_fu_1622_p3;
reg   [3:0] ap_sig_allocacmp_oldMax_V_10_load;
reg   [3:0] oldMax_V_11_fu_346;
wire   [3:0] select_ln167_11_fu_1647_p3;
reg   [3:0] ap_sig_allocacmp_oldMax_V_11_load;
reg   [3:0] oldMax_V_12_fu_350;
wire   [3:0] select_ln167_12_fu_1672_p3;
reg   [3:0] ap_sig_allocacmp_oldMax_V_12_load;
reg   [3:0] oldMax_V_13_fu_354;
wire   [3:0] select_ln167_13_fu_1697_p3;
reg   [3:0] ap_sig_allocacmp_oldMax_V_13_load;
reg   [3:0] oldMax_V_14_fu_358;
wire   [3:0] select_ln167_14_fu_1722_p3;
reg   [3:0] ap_sig_allocacmp_oldMax_V_14_load;
reg   [3:0] oldMax_V_15_fu_362;
wire   [3:0] select_ln167_15_fu_1747_p3;
reg   [3:0] ap_sig_allocacmp_oldMax_V_15_load;
reg   [3:0] oldMax_V_16_fu_366;
wire   [3:0] select_ln167_16_fu_1772_p3;
reg   [3:0] ap_sig_allocacmp_oldMax_V_16_load;
reg   [3:0] oldMax_V_17_fu_370;
wire   [3:0] select_ln167_17_fu_1797_p3;
reg   [3:0] ap_sig_allocacmp_oldMax_V_17_load;
reg   [3:0] oldMax_V_18_fu_374;
wire   [3:0] select_ln167_18_fu_1822_p3;
reg   [3:0] ap_sig_allocacmp_oldMax_V_18_load;
reg   [3:0] oldMax_V_19_fu_378;
wire   [3:0] select_ln167_19_fu_1847_p3;
reg   [3:0] ap_sig_allocacmp_oldMax_V_19_load;
reg   [3:0] oldMax_V_20_fu_382;
wire   [3:0] select_ln167_20_fu_1872_p3;
reg   [3:0] ap_sig_allocacmp_oldMax_V_20_load;
reg   [3:0] oldMax_V_21_fu_386;
wire   [3:0] select_ln167_21_fu_1897_p3;
reg   [3:0] ap_sig_allocacmp_oldMax_V_21_load;
reg   [3:0] oldMax_V_22_fu_390;
wire   [3:0] select_ln167_22_fu_1922_p3;
reg   [3:0] ap_sig_allocacmp_oldMax_V_22_load;
reg   [3:0] oldMax_V_23_fu_394;
wire   [3:0] select_ln167_23_fu_1947_p3;
reg   [3:0] ap_sig_allocacmp_oldMax_V_23_load;
reg   [3:0] oldMax_V_24_fu_398;
wire   [3:0] select_ln167_24_fu_1972_p3;
reg   [3:0] ap_sig_allocacmp_oldMax_V_24_load;
reg   [3:0] oldMax_V_25_fu_402;
wire   [3:0] select_ln167_25_fu_1997_p3;
reg   [3:0] ap_sig_allocacmp_oldMax_V_25_load;
reg   [3:0] oldMax_V_26_fu_406;
wire   [3:0] select_ln167_26_fu_2022_p3;
reg   [3:0] ap_sig_allocacmp_oldMax_V_26_load;
reg   [3:0] oldMax_V_27_fu_410;
wire   [3:0] select_ln167_27_fu_2047_p3;
reg   [3:0] ap_sig_allocacmp_oldMax_V_27_load;
reg   [3:0] oldMax_V_28_fu_414;
wire   [3:0] select_ln167_28_fu_2072_p3;
reg   [3:0] ap_sig_allocacmp_oldMax_V_28_load;
reg   [3:0] oldMax_V_29_fu_418;
wire   [3:0] select_ln167_29_fu_2097_p3;
reg   [3:0] ap_sig_allocacmp_oldMax_V_29_load;
reg   [3:0] oldMax_V_30_fu_422;
wire   [3:0] select_ln167_30_fu_2122_p3;
reg   [3:0] ap_sig_allocacmp_oldMax_V_30_load;
reg   [3:0] oldMax_V_31_fu_426;
wire   [3:0] select_ln167_31_fu_2147_p3;
reg   [3:0] ap_sig_allocacmp_oldMax_V_31_load;
wire   [0:0] icmp_ln158_1_fu_2156_p2;
wire   [3:0] channeldata_V_fu_1362_p1;
wire   [0:0] icmp_ln1035_fu_1366_p2;
wire   [3:0] channeldata_V_1_fu_1381_p4;
wire   [0:0] icmp_ln1035_1_fu_1391_p2;
wire   [3:0] channeldata_V_2_fu_1406_p4;
wire   [0:0] icmp_ln1035_2_fu_1416_p2;
wire   [3:0] channeldata_V_3_fu_1431_p4;
wire   [0:0] icmp_ln1035_3_fu_1441_p2;
wire   [3:0] channeldata_V_4_fu_1456_p4;
wire   [0:0] icmp_ln1035_4_fu_1466_p2;
wire   [3:0] channeldata_V_5_fu_1481_p4;
wire   [0:0] icmp_ln1035_5_fu_1491_p2;
wire   [3:0] channeldata_V_6_fu_1506_p4;
wire   [0:0] icmp_ln1035_6_fu_1516_p2;
wire   [3:0] channeldata_V_7_fu_1531_p4;
wire   [0:0] icmp_ln1035_7_fu_1541_p2;
wire   [3:0] channeldata_V_8_fu_1556_p4;
wire   [0:0] icmp_ln1035_8_fu_1566_p2;
wire   [3:0] channeldata_V_9_fu_1581_p4;
wire   [0:0] icmp_ln1035_9_fu_1591_p2;
wire   [3:0] channeldata_V_10_fu_1606_p4;
wire   [0:0] icmp_ln1035_10_fu_1616_p2;
wire   [3:0] channeldata_V_11_fu_1631_p4;
wire   [0:0] icmp_ln1035_11_fu_1641_p2;
wire   [3:0] channeldata_V_12_fu_1656_p4;
wire   [0:0] icmp_ln1035_12_fu_1666_p2;
wire   [3:0] channeldata_V_13_fu_1681_p4;
wire   [0:0] icmp_ln1035_13_fu_1691_p2;
wire   [3:0] channeldata_V_14_fu_1706_p4;
wire   [0:0] icmp_ln1035_14_fu_1716_p2;
wire   [3:0] channeldata_V_15_fu_1731_p4;
wire   [0:0] icmp_ln1035_15_fu_1741_p2;
wire   [3:0] channeldata_V_16_fu_1756_p4;
wire   [0:0] icmp_ln1035_16_fu_1766_p2;
wire   [3:0] channeldata_V_17_fu_1781_p4;
wire   [0:0] icmp_ln1035_17_fu_1791_p2;
wire   [3:0] channeldata_V_18_fu_1806_p4;
wire   [0:0] icmp_ln1035_18_fu_1816_p2;
wire   [3:0] channeldata_V_19_fu_1831_p4;
wire   [0:0] icmp_ln1035_19_fu_1841_p2;
wire   [3:0] channeldata_V_20_fu_1856_p4;
wire   [0:0] icmp_ln1035_20_fu_1866_p2;
wire   [3:0] channeldata_V_21_fu_1881_p4;
wire   [0:0] icmp_ln1035_21_fu_1891_p2;
wire   [3:0] channeldata_V_22_fu_1906_p4;
wire   [0:0] icmp_ln1035_22_fu_1916_p2;
wire   [3:0] channeldata_V_23_fu_1931_p4;
wire   [0:0] icmp_ln1035_23_fu_1941_p2;
wire   [3:0] channeldata_V_24_fu_1956_p4;
wire   [0:0] icmp_ln1035_24_fu_1966_p2;
wire   [3:0] channeldata_V_25_fu_1981_p4;
wire   [0:0] icmp_ln1035_25_fu_1991_p2;
wire   [3:0] channeldata_V_26_fu_2006_p4;
wire   [0:0] icmp_ln1035_26_fu_2016_p2;
wire   [3:0] channeldata_V_27_fu_2031_p4;
wire   [0:0] icmp_ln1035_27_fu_2041_p2;
wire   [3:0] channeldata_V_28_fu_2056_p4;
wire   [0:0] icmp_ln1035_28_fu_2066_p2;
wire   [3:0] channeldata_V_29_fu_2081_p4;
wire   [0:0] icmp_ln1035_29_fu_2091_p2;
wire   [3:0] channeldata_V_30_fu_2106_p4;
wire   [0:0] icmp_ln1035_30_fu_2116_p2;
wire   [3:0] channeldata_V_31_fu_2131_p4;
wire   [0:0] icmp_ln1035_31_fu_2141_p2;
reg    ap_done_reg;
wire    ap_continue_int;
reg    ap_done_int;
reg   [0:0] ap_NS_fsm;
reg    ap_ST_fsm_state1_blk;
wire    ap_start_int;
reg    ap_condition_1053;
wire    ap_ce_reg;

// power-on initialization
initial begin
#0 ap_CS_fsm = 1'd1;
#0 ap_done_reg = 1'b0;
end

StreamingMaxPool_hls_1_flow_control_loop_pipe_sequential_init flow_control_loop_pipe_sequential_init_U(
    .ap_clk(ap_clk),
    .ap_rst(ap_rst),
    .ap_start(ap_start),
    .ap_ready(ap_ready),
    .ap_done(ap_done),
    .ap_start_int(ap_start_int),
    .ap_loop_init(ap_loop_init),
    .ap_ready_int(ap_ready_int),
    .ap_loop_exit_ready(ap_condition_exit_pp0_iter0_stage0),
    .ap_loop_exit_done(ap_done_int),
    .ap_continue_int(ap_continue_int),
    .ap_done_int(ap_done_int)
);

always @ (posedge ap_clk) begin
    if (ap_rst == 1'b1) begin
        ap_CS_fsm <= ap_ST_fsm_state1;
    end else begin
        ap_CS_fsm <= ap_NS_fsm;
    end
end

always @ (posedge ap_clk) begin
    if (ap_rst == 1'b1) begin
        ap_done_reg <= 1'b0;
    end else begin
        if ((ap_continue_int == 1'b1)) begin
            ap_done_reg <= 1'b0;
        end else if ((~((ap_start_int == 1'b0) | ((icmp_ln158_fu_1254_p2 == 1'd0) & (in0_V_TVALID == 1'b0))) & (ap_loop_exit_ready == 1'b1) & (1'b1 == ap_CS_fsm_state1))) begin
            ap_done_reg <= 1'b1;
        end
    end
end

always @ (posedge ap_clk) begin
    if ((1'b1 == ap_condition_1053)) begin
        if ((icmp_ln158_fu_1254_p2 == 1'd0)) begin
            kx_fu_298 <= kx_2_fu_1260_p2;
        end else if ((ap_loop_init == 1'b1)) begin
            kx_fu_298 <= 2'd0;
        end
    end
end

always @ (posedge ap_clk) begin
    if ((1'b1 == ap_condition_1053)) begin
        if ((icmp_ln158_fu_1254_p2 == 1'd0)) begin
            oldMax_V_10_fu_342 <= select_ln167_10_fu_1622_p3;
        end else if ((ap_loop_init == 1'b1)) begin
            oldMax_V_10_fu_342 <= buf_V_10_load_1;
        end
    end
end

always @ (posedge ap_clk) begin
    if ((1'b1 == ap_condition_1053)) begin
        if ((icmp_ln158_fu_1254_p2 == 1'd0)) begin
            oldMax_V_11_fu_346 <= select_ln167_11_fu_1647_p3;
        end else if ((ap_loop_init == 1'b1)) begin
            oldMax_V_11_fu_346 <= buf_V_11_load_1;
        end
    end
end

always @ (posedge ap_clk) begin
    if ((1'b1 == ap_condition_1053)) begin
        if ((icmp_ln158_fu_1254_p2 == 1'd0)) begin
            oldMax_V_12_fu_350 <= select_ln167_12_fu_1672_p3;
        end else if ((ap_loop_init == 1'b1)) begin
            oldMax_V_12_fu_350 <= buf_V_12_load_1;
        end
    end
end

always @ (posedge ap_clk) begin
    if ((1'b1 == ap_condition_1053)) begin
        if ((icmp_ln158_fu_1254_p2 == 1'd0)) begin
            oldMax_V_13_fu_354 <= select_ln167_13_fu_1697_p3;
        end else if ((ap_loop_init == 1'b1)) begin
            oldMax_V_13_fu_354 <= buf_V_13_load_1;
        end
    end
end

always @ (posedge ap_clk) begin
    if ((1'b1 == ap_condition_1053)) begin
        if ((icmp_ln158_fu_1254_p2 == 1'd0)) begin
            oldMax_V_14_fu_358 <= select_ln167_14_fu_1722_p3;
        end else if ((ap_loop_init == 1'b1)) begin
            oldMax_V_14_fu_358 <= buf_V_14_load_1;
        end
    end
end

always @ (posedge ap_clk) begin
    if ((1'b1 == ap_condition_1053)) begin
        if ((icmp_ln158_fu_1254_p2 == 1'd0)) begin
            oldMax_V_15_fu_362 <= select_ln167_15_fu_1747_p3;
        end else if ((ap_loop_init == 1'b1)) begin
            oldMax_V_15_fu_362 <= buf_V_15_load_1;
        end
    end
end

always @ (posedge ap_clk) begin
    if ((1'b1 == ap_condition_1053)) begin
        if ((icmp_ln158_fu_1254_p2 == 1'd0)) begin
            oldMax_V_16_fu_366 <= select_ln167_16_fu_1772_p3;
        end else if ((ap_loop_init == 1'b1)) begin
            oldMax_V_16_fu_366 <= buf_V_16_load_1;
        end
    end
end

always @ (posedge ap_clk) begin
    if ((1'b1 == ap_condition_1053)) begin
        if ((icmp_ln158_fu_1254_p2 == 1'd0)) begin
            oldMax_V_17_fu_370 <= select_ln167_17_fu_1797_p3;
        end else if ((ap_loop_init == 1'b1)) begin
            oldMax_V_17_fu_370 <= buf_V_17_load_1;
        end
    end
end

always @ (posedge ap_clk) begin
    if ((1'b1 == ap_condition_1053)) begin
        if ((icmp_ln158_fu_1254_p2 == 1'd0)) begin
            oldMax_V_18_fu_374 <= select_ln167_18_fu_1822_p3;
        end else if ((ap_loop_init == 1'b1)) begin
            oldMax_V_18_fu_374 <= buf_V_18_load_1;
        end
    end
end

always @ (posedge ap_clk) begin
    if ((1'b1 == ap_condition_1053)) begin
        if ((icmp_ln158_fu_1254_p2 == 1'd0)) begin
            oldMax_V_19_fu_378 <= select_ln167_19_fu_1847_p3;
        end else if ((ap_loop_init == 1'b1)) begin
            oldMax_V_19_fu_378 <= buf_V_19_load_1;
        end
    end
end

always @ (posedge ap_clk) begin
    if ((1'b1 == ap_condition_1053)) begin
        if ((icmp_ln158_fu_1254_p2 == 1'd0)) begin
            oldMax_V_1_fu_306 <= select_ln167_1_fu_1397_p3;
        end else if ((ap_loop_init == 1'b1)) begin
            oldMax_V_1_fu_306 <= buf_V_1_load_1;
        end
    end
end

always @ (posedge ap_clk) begin
    if ((1'b1 == ap_condition_1053)) begin
        if ((icmp_ln158_fu_1254_p2 == 1'd0)) begin
            oldMax_V_20_fu_382 <= select_ln167_20_fu_1872_p3;
        end else if ((ap_loop_init == 1'b1)) begin
            oldMax_V_20_fu_382 <= buf_V_20_load_1;
        end
    end
end

always @ (posedge ap_clk) begin
    if ((1'b1 == ap_condition_1053)) begin
        if ((icmp_ln158_fu_1254_p2 == 1'd0)) begin
            oldMax_V_21_fu_386 <= select_ln167_21_fu_1897_p3;
        end else if ((ap_loop_init == 1'b1)) begin
            oldMax_V_21_fu_386 <= buf_V_21_load_1;
        end
    end
end

always @ (posedge ap_clk) begin
    if ((1'b1 == ap_condition_1053)) begin
        if ((icmp_ln158_fu_1254_p2 == 1'd0)) begin
            oldMax_V_22_fu_390 <= select_ln167_22_fu_1922_p3;
        end else if ((ap_loop_init == 1'b1)) begin
            oldMax_V_22_fu_390 <= buf_V_22_load_1;
        end
    end
end

always @ (posedge ap_clk) begin
    if ((1'b1 == ap_condition_1053)) begin
        if ((icmp_ln158_fu_1254_p2 == 1'd0)) begin
            oldMax_V_23_fu_394 <= select_ln167_23_fu_1947_p3;
        end else if ((ap_loop_init == 1'b1)) begin
            oldMax_V_23_fu_394 <= buf_V_23_load_1;
        end
    end
end

always @ (posedge ap_clk) begin
    if ((1'b1 == ap_condition_1053)) begin
        if ((icmp_ln158_fu_1254_p2 == 1'd0)) begin
            oldMax_V_24_fu_398 <= select_ln167_24_fu_1972_p3;
        end else if ((ap_loop_init == 1'b1)) begin
            oldMax_V_24_fu_398 <= buf_V_24_load_1;
        end
    end
end

always @ (posedge ap_clk) begin
    if ((1'b1 == ap_condition_1053)) begin
        if ((icmp_ln158_fu_1254_p2 == 1'd0)) begin
            oldMax_V_25_fu_402 <= select_ln167_25_fu_1997_p3;
        end else if ((ap_loop_init == 1'b1)) begin
            oldMax_V_25_fu_402 <= buf_V_25_load_1;
        end
    end
end

always @ (posedge ap_clk) begin
    if ((1'b1 == ap_condition_1053)) begin
        if ((icmp_ln158_fu_1254_p2 == 1'd0)) begin
            oldMax_V_26_fu_406 <= select_ln167_26_fu_2022_p3;
        end else if ((ap_loop_init == 1'b1)) begin
            oldMax_V_26_fu_406 <= buf_V_26_load_1;
        end
    end
end

always @ (posedge ap_clk) begin
    if ((1'b1 == ap_condition_1053)) begin
        if ((icmp_ln158_fu_1254_p2 == 1'd0)) begin
            oldMax_V_27_fu_410 <= select_ln167_27_fu_2047_p3;
        end else if ((ap_loop_init == 1'b1)) begin
            oldMax_V_27_fu_410 <= buf_V_27_load_1;
        end
    end
end

always @ (posedge ap_clk) begin
    if ((1'b1 == ap_condition_1053)) begin
        if ((icmp_ln158_fu_1254_p2 == 1'd0)) begin
            oldMax_V_28_fu_414 <= select_ln167_28_fu_2072_p3;
        end else if ((ap_loop_init == 1'b1)) begin
            oldMax_V_28_fu_414 <= buf_V_28_load_1;
        end
    end
end

always @ (posedge ap_clk) begin
    if ((1'b1 == ap_condition_1053)) begin
        if ((icmp_ln158_fu_1254_p2 == 1'd0)) begin
            oldMax_V_29_fu_418 <= select_ln167_29_fu_2097_p3;
        end else if ((ap_loop_init == 1'b1)) begin
            oldMax_V_29_fu_418 <= buf_V_29_load_1;
        end
    end
end

always @ (posedge ap_clk) begin
    if ((1'b1 == ap_condition_1053)) begin
        if ((icmp_ln158_fu_1254_p2 == 1'd0)) begin
            oldMax_V_2_fu_310 <= select_ln167_2_fu_1422_p3;
        end else if ((ap_loop_init == 1'b1)) begin
            oldMax_V_2_fu_310 <= buf_V_2_load_1;
        end
    end
end

always @ (posedge ap_clk) begin
    if ((1'b1 == ap_condition_1053)) begin
        if ((icmp_ln158_fu_1254_p2 == 1'd0)) begin
            oldMax_V_30_fu_422 <= select_ln167_30_fu_2122_p3;
        end else if ((ap_loop_init == 1'b1)) begin
            oldMax_V_30_fu_422 <= buf_V_30_load_1;
        end
    end
end

always @ (posedge ap_clk) begin
    if ((1'b1 == ap_condition_1053)) begin
        if ((icmp_ln158_fu_1254_p2 == 1'd0)) begin
            oldMax_V_31_fu_426 <= select_ln167_31_fu_2147_p3;
        end else if ((ap_loop_init == 1'b1)) begin
            oldMax_V_31_fu_426 <= buf_V_31_load_1;
        end
    end
end

always @ (posedge ap_clk) begin
    if ((1'b1 == ap_condition_1053)) begin
        if ((icmp_ln158_fu_1254_p2 == 1'd0)) begin
            oldMax_V_3_fu_314 <= select_ln167_3_fu_1447_p3;
        end else if ((ap_loop_init == 1'b1)) begin
            oldMax_V_3_fu_314 <= buf_V_3_load_1;
        end
    end
end

always @ (posedge ap_clk) begin
    if ((1'b1 == ap_condition_1053)) begin
        if ((icmp_ln158_fu_1254_p2 == 1'd0)) begin
            oldMax_V_4_fu_318 <= select_ln167_4_fu_1472_p3;
        end else if ((ap_loop_init == 1'b1)) begin
            oldMax_V_4_fu_318 <= buf_V_4_load_1;
        end
    end
end

always @ (posedge ap_clk) begin
    if ((1'b1 == ap_condition_1053)) begin
        if ((icmp_ln158_fu_1254_p2 == 1'd0)) begin
            oldMax_V_5_fu_322 <= select_ln167_5_fu_1497_p3;
        end else if ((ap_loop_init == 1'b1)) begin
            oldMax_V_5_fu_322 <= buf_V_5_load_1;
        end
    end
end

always @ (posedge ap_clk) begin
    if ((1'b1 == ap_condition_1053)) begin
        if ((icmp_ln158_fu_1254_p2 == 1'd0)) begin
            oldMax_V_6_fu_326 <= select_ln167_6_fu_1522_p3;
        end else if ((ap_loop_init == 1'b1)) begin
            oldMax_V_6_fu_326 <= buf_V_6_load_1;
        end
    end
end

always @ (posedge ap_clk) begin
    if ((1'b1 == ap_condition_1053)) begin
        if ((icmp_ln158_fu_1254_p2 == 1'd0)) begin
            oldMax_V_7_fu_330 <= select_ln167_7_fu_1547_p3;
        end else if ((ap_loop_init == 1'b1)) begin
            oldMax_V_7_fu_330 <= buf_V_7_load_1;
        end
    end
end

always @ (posedge ap_clk) begin
    if ((1'b1 == ap_condition_1053)) begin
        if ((icmp_ln158_fu_1254_p2 == 1'd0)) begin
            oldMax_V_8_fu_334 <= select_ln167_8_fu_1572_p3;
        end else if ((ap_loop_init == 1'b1)) begin
            oldMax_V_8_fu_334 <= buf_V_8_load_1;
        end
    end
end

always @ (posedge ap_clk) begin
    if ((1'b1 == ap_condition_1053)) begin
        if ((icmp_ln158_fu_1254_p2 == 1'd0)) begin
            oldMax_V_9_fu_338 <= select_ln167_9_fu_1597_p3;
        end else if ((ap_loop_init == 1'b1)) begin
            oldMax_V_9_fu_338 <= buf_V_9_load_1;
        end
    end
end

always @ (posedge ap_clk) begin
    if ((1'b1 == ap_condition_1053)) begin
        if ((icmp_ln158_fu_1254_p2 == 1'd0)) begin
            oldMax_V_fu_302 <= select_ln167_fu_1372_p3;
        end else if ((ap_loop_init == 1'b1)) begin
            oldMax_V_fu_302 <= buf_V_load_1;
        end
    end
end

always @ (*) begin
    if (((ap_start_int == 1'b0) | ((icmp_ln158_fu_1254_p2 == 1'd0) & (in0_V_TVALID == 1'b0)))) begin
        ap_ST_fsm_state1_blk = 1'b1;
    end else begin
        ap_ST_fsm_state1_blk = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((icmp_ln158_fu_1254_p2 == 1'd0) & (in0_V_TVALID == 1'b0))) & (icmp_ln158_fu_1254_p2 == 1'd1) & (1'b1 == ap_CS_fsm_state1))) begin
        ap_condition_exit_pp0_iter0_stage0 = 1'b1;
    end else begin
        ap_condition_exit_pp0_iter0_stage0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((icmp_ln158_fu_1254_p2 == 1'd0) & (in0_V_TVALID == 1'b0))) & (ap_loop_exit_ready == 1'b1) & (1'b1 == ap_CS_fsm_state1))) begin
        ap_done_int = 1'b1;
    end else begin
        ap_done_int = ap_done_reg;
    end
end

always @ (*) begin
    if (((1'b1 == ap_CS_fsm_state1) & (ap_start_int == 1'b0))) begin
        ap_idle = 1'b1;
    end else begin
        ap_idle = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((icmp_ln158_fu_1254_p2 == 1'd0) & (in0_V_TVALID == 1'b0))) & (1'b1 == ap_CS_fsm_state1))) begin
        ap_ready_int = 1'b1;
    end else begin
        ap_ready_int = 1'b0;
    end
end

always @ (*) begin
    if (((ap_loop_init == 1'b1) & (1'b1 == ap_CS_fsm_state1))) begin
        ap_sig_allocacmp_kx_1 = 2'd0;
    end else begin
        ap_sig_allocacmp_kx_1 = kx_fu_298;
    end
end

always @ (*) begin
    if (((ap_loop_init == 1'b1) & (1'b1 == ap_CS_fsm_state1))) begin
        ap_sig_allocacmp_oldMax_V_10_load = buf_V_10_load_1;
    end else begin
        ap_sig_allocacmp_oldMax_V_10_load = oldMax_V_10_fu_342;
    end
end

always @ (*) begin
    if (((ap_loop_init == 1'b1) & (1'b1 == ap_CS_fsm_state1))) begin
        ap_sig_allocacmp_oldMax_V_11_load = buf_V_11_load_1;
    end else begin
        ap_sig_allocacmp_oldMax_V_11_load = oldMax_V_11_fu_346;
    end
end

always @ (*) begin
    if (((ap_loop_init == 1'b1) & (1'b1 == ap_CS_fsm_state1))) begin
        ap_sig_allocacmp_oldMax_V_12_load = buf_V_12_load_1;
    end else begin
        ap_sig_allocacmp_oldMax_V_12_load = oldMax_V_12_fu_350;
    end
end

always @ (*) begin
    if (((ap_loop_init == 1'b1) & (1'b1 == ap_CS_fsm_state1))) begin
        ap_sig_allocacmp_oldMax_V_13_load = buf_V_13_load_1;
    end else begin
        ap_sig_allocacmp_oldMax_V_13_load = oldMax_V_13_fu_354;
    end
end

always @ (*) begin
    if (((ap_loop_init == 1'b1) & (1'b1 == ap_CS_fsm_state1))) begin
        ap_sig_allocacmp_oldMax_V_14_load = buf_V_14_load_1;
    end else begin
        ap_sig_allocacmp_oldMax_V_14_load = oldMax_V_14_fu_358;
    end
end

always @ (*) begin
    if (((ap_loop_init == 1'b1) & (1'b1 == ap_CS_fsm_state1))) begin
        ap_sig_allocacmp_oldMax_V_15_load = buf_V_15_load_1;
    end else begin
        ap_sig_allocacmp_oldMax_V_15_load = oldMax_V_15_fu_362;
    end
end

always @ (*) begin
    if (((ap_loop_init == 1'b1) & (1'b1 == ap_CS_fsm_state1))) begin
        ap_sig_allocacmp_oldMax_V_16_load = buf_V_16_load_1;
    end else begin
        ap_sig_allocacmp_oldMax_V_16_load = oldMax_V_16_fu_366;
    end
end

always @ (*) begin
    if (((ap_loop_init == 1'b1) & (1'b1 == ap_CS_fsm_state1))) begin
        ap_sig_allocacmp_oldMax_V_17_load = buf_V_17_load_1;
    end else begin
        ap_sig_allocacmp_oldMax_V_17_load = oldMax_V_17_fu_370;
    end
end

always @ (*) begin
    if (((ap_loop_init == 1'b1) & (1'b1 == ap_CS_fsm_state1))) begin
        ap_sig_allocacmp_oldMax_V_18_load = buf_V_18_load_1;
    end else begin
        ap_sig_allocacmp_oldMax_V_18_load = oldMax_V_18_fu_374;
    end
end

always @ (*) begin
    if (((ap_loop_init == 1'b1) & (1'b1 == ap_CS_fsm_state1))) begin
        ap_sig_allocacmp_oldMax_V_19_load = buf_V_19_load_1;
    end else begin
        ap_sig_allocacmp_oldMax_V_19_load = oldMax_V_19_fu_378;
    end
end

always @ (*) begin
    if (((ap_loop_init == 1'b1) & (1'b1 == ap_CS_fsm_state1))) begin
        ap_sig_allocacmp_oldMax_V_1_load = buf_V_1_load_1;
    end else begin
        ap_sig_allocacmp_oldMax_V_1_load = oldMax_V_1_fu_306;
    end
end

always @ (*) begin
    if (((ap_loop_init == 1'b1) & (1'b1 == ap_CS_fsm_state1))) begin
        ap_sig_allocacmp_oldMax_V_20_load = buf_V_20_load_1;
    end else begin
        ap_sig_allocacmp_oldMax_V_20_load = oldMax_V_20_fu_382;
    end
end

always @ (*) begin
    if (((ap_loop_init == 1'b1) & (1'b1 == ap_CS_fsm_state1))) begin
        ap_sig_allocacmp_oldMax_V_21_load = buf_V_21_load_1;
    end else begin
        ap_sig_allocacmp_oldMax_V_21_load = oldMax_V_21_fu_386;
    end
end

always @ (*) begin
    if (((ap_loop_init == 1'b1) & (1'b1 == ap_CS_fsm_state1))) begin
        ap_sig_allocacmp_oldMax_V_22_load = buf_V_22_load_1;
    end else begin
        ap_sig_allocacmp_oldMax_V_22_load = oldMax_V_22_fu_390;
    end
end

always @ (*) begin
    if (((ap_loop_init == 1'b1) & (1'b1 == ap_CS_fsm_state1))) begin
        ap_sig_allocacmp_oldMax_V_23_load = buf_V_23_load_1;
    end else begin
        ap_sig_allocacmp_oldMax_V_23_load = oldMax_V_23_fu_394;
    end
end

always @ (*) begin
    if (((ap_loop_init == 1'b1) & (1'b1 == ap_CS_fsm_state1))) begin
        ap_sig_allocacmp_oldMax_V_24_load = buf_V_24_load_1;
    end else begin
        ap_sig_allocacmp_oldMax_V_24_load = oldMax_V_24_fu_398;
    end
end

always @ (*) begin
    if (((ap_loop_init == 1'b1) & (1'b1 == ap_CS_fsm_state1))) begin
        ap_sig_allocacmp_oldMax_V_25_load = buf_V_25_load_1;
    end else begin
        ap_sig_allocacmp_oldMax_V_25_load = oldMax_V_25_fu_402;
    end
end

always @ (*) begin
    if (((ap_loop_init == 1'b1) & (1'b1 == ap_CS_fsm_state1))) begin
        ap_sig_allocacmp_oldMax_V_26_load = buf_V_26_load_1;
    end else begin
        ap_sig_allocacmp_oldMax_V_26_load = oldMax_V_26_fu_406;
    end
end

always @ (*) begin
    if (((ap_loop_init == 1'b1) & (1'b1 == ap_CS_fsm_state1))) begin
        ap_sig_allocacmp_oldMax_V_27_load = buf_V_27_load_1;
    end else begin
        ap_sig_allocacmp_oldMax_V_27_load = oldMax_V_27_fu_410;
    end
end

always @ (*) begin
    if (((ap_loop_init == 1'b1) & (1'b1 == ap_CS_fsm_state1))) begin
        ap_sig_allocacmp_oldMax_V_28_load = buf_V_28_load_1;
    end else begin
        ap_sig_allocacmp_oldMax_V_28_load = oldMax_V_28_fu_414;
    end
end

always @ (*) begin
    if (((ap_loop_init == 1'b1) & (1'b1 == ap_CS_fsm_state1))) begin
        ap_sig_allocacmp_oldMax_V_29_load = buf_V_29_load_1;
    end else begin
        ap_sig_allocacmp_oldMax_V_29_load = oldMax_V_29_fu_418;
    end
end

always @ (*) begin
    if (((ap_loop_init == 1'b1) & (1'b1 == ap_CS_fsm_state1))) begin
        ap_sig_allocacmp_oldMax_V_2_load = buf_V_2_load_1;
    end else begin
        ap_sig_allocacmp_oldMax_V_2_load = oldMax_V_2_fu_310;
    end
end

always @ (*) begin
    if (((ap_loop_init == 1'b1) & (1'b1 == ap_CS_fsm_state1))) begin
        ap_sig_allocacmp_oldMax_V_30_load = buf_V_30_load_1;
    end else begin
        ap_sig_allocacmp_oldMax_V_30_load = oldMax_V_30_fu_422;
    end
end

always @ (*) begin
    if (((ap_loop_init == 1'b1) & (1'b1 == ap_CS_fsm_state1))) begin
        ap_sig_allocacmp_oldMax_V_31_load = buf_V_31_load_1;
    end else begin
        ap_sig_allocacmp_oldMax_V_31_load = oldMax_V_31_fu_426;
    end
end

always @ (*) begin
    if (((ap_loop_init == 1'b1) & (1'b1 == ap_CS_fsm_state1))) begin
        ap_sig_allocacmp_oldMax_V_3_load = buf_V_3_load_1;
    end else begin
        ap_sig_allocacmp_oldMax_V_3_load = oldMax_V_3_fu_314;
    end
end

always @ (*) begin
    if (((ap_loop_init == 1'b1) & (1'b1 == ap_CS_fsm_state1))) begin
        ap_sig_allocacmp_oldMax_V_4_load = buf_V_4_load_1;
    end else begin
        ap_sig_allocacmp_oldMax_V_4_load = oldMax_V_4_fu_318;
    end
end

always @ (*) begin
    if (((ap_loop_init == 1'b1) & (1'b1 == ap_CS_fsm_state1))) begin
        ap_sig_allocacmp_oldMax_V_5_load = buf_V_5_load_1;
    end else begin
        ap_sig_allocacmp_oldMax_V_5_load = oldMax_V_5_fu_322;
    end
end

always @ (*) begin
    if (((ap_loop_init == 1'b1) & (1'b1 == ap_CS_fsm_state1))) begin
        ap_sig_allocacmp_oldMax_V_6_load = buf_V_6_load_1;
    end else begin
        ap_sig_allocacmp_oldMax_V_6_load = oldMax_V_6_fu_326;
    end
end

always @ (*) begin
    if (((ap_loop_init == 1'b1) & (1'b1 == ap_CS_fsm_state1))) begin
        ap_sig_allocacmp_oldMax_V_7_load = buf_V_7_load_1;
    end else begin
        ap_sig_allocacmp_oldMax_V_7_load = oldMax_V_7_fu_330;
    end
end

always @ (*) begin
    if (((ap_loop_init == 1'b1) & (1'b1 == ap_CS_fsm_state1))) begin
        ap_sig_allocacmp_oldMax_V_8_load = buf_V_8_load_1;
    end else begin
        ap_sig_allocacmp_oldMax_V_8_load = oldMax_V_8_fu_334;
    end
end

always @ (*) begin
    if (((ap_loop_init == 1'b1) & (1'b1 == ap_CS_fsm_state1))) begin
        ap_sig_allocacmp_oldMax_V_9_load = buf_V_9_load_1;
    end else begin
        ap_sig_allocacmp_oldMax_V_9_load = oldMax_V_9_fu_338;
    end
end

always @ (*) begin
    if (((ap_loop_init == 1'b1) & (1'b1 == ap_CS_fsm_state1))) begin
        ap_sig_allocacmp_oldMax_V_load = buf_V_load_1;
    end else begin
        ap_sig_allocacmp_oldMax_V_load = oldMax_V_fu_302;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((icmp_ln158_fu_1254_p2 == 1'd0) & (in0_V_TVALID == 1'b0))) & (1'b1 == ap_CS_fsm_state1))) begin
        buf_V_10_ce0 = 1'b1;
    end else begin
        buf_V_10_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((icmp_ln158_fu_1254_p2 == 1'd0) & (in0_V_TVALID == 1'b0))) & (icmp_ln158_1_fu_2156_p2 == 1'd1) & (icmp_ln158_fu_1254_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state1))) begin
        buf_V_10_we0 = 1'b1;
    end else begin
        buf_V_10_we0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((icmp_ln158_fu_1254_p2 == 1'd0) & (in0_V_TVALID == 1'b0))) & (1'b1 == ap_CS_fsm_state1))) begin
        buf_V_11_ce0 = 1'b1;
    end else begin
        buf_V_11_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((icmp_ln158_fu_1254_p2 == 1'd0) & (in0_V_TVALID == 1'b0))) & (icmp_ln158_1_fu_2156_p2 == 1'd1) & (icmp_ln158_fu_1254_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state1))) begin
        buf_V_11_we0 = 1'b1;
    end else begin
        buf_V_11_we0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((icmp_ln158_fu_1254_p2 == 1'd0) & (in0_V_TVALID == 1'b0))) & (1'b1 == ap_CS_fsm_state1))) begin
        buf_V_12_ce0 = 1'b1;
    end else begin
        buf_V_12_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((icmp_ln158_fu_1254_p2 == 1'd0) & (in0_V_TVALID == 1'b0))) & (icmp_ln158_1_fu_2156_p2 == 1'd1) & (icmp_ln158_fu_1254_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state1))) begin
        buf_V_12_we0 = 1'b1;
    end else begin
        buf_V_12_we0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((icmp_ln158_fu_1254_p2 == 1'd0) & (in0_V_TVALID == 1'b0))) & (1'b1 == ap_CS_fsm_state1))) begin
        buf_V_13_ce0 = 1'b1;
    end else begin
        buf_V_13_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((icmp_ln158_fu_1254_p2 == 1'd0) & (in0_V_TVALID == 1'b0))) & (icmp_ln158_1_fu_2156_p2 == 1'd1) & (icmp_ln158_fu_1254_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state1))) begin
        buf_V_13_we0 = 1'b1;
    end else begin
        buf_V_13_we0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((icmp_ln158_fu_1254_p2 == 1'd0) & (in0_V_TVALID == 1'b0))) & (1'b1 == ap_CS_fsm_state1))) begin
        buf_V_14_ce0 = 1'b1;
    end else begin
        buf_V_14_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((icmp_ln158_fu_1254_p2 == 1'd0) & (in0_V_TVALID == 1'b0))) & (icmp_ln158_1_fu_2156_p2 == 1'd1) & (icmp_ln158_fu_1254_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state1))) begin
        buf_V_14_we0 = 1'b1;
    end else begin
        buf_V_14_we0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((icmp_ln158_fu_1254_p2 == 1'd0) & (in0_V_TVALID == 1'b0))) & (1'b1 == ap_CS_fsm_state1))) begin
        buf_V_15_ce0 = 1'b1;
    end else begin
        buf_V_15_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((icmp_ln158_fu_1254_p2 == 1'd0) & (in0_V_TVALID == 1'b0))) & (icmp_ln158_1_fu_2156_p2 == 1'd1) & (icmp_ln158_fu_1254_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state1))) begin
        buf_V_15_we0 = 1'b1;
    end else begin
        buf_V_15_we0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((icmp_ln158_fu_1254_p2 == 1'd0) & (in0_V_TVALID == 1'b0))) & (1'b1 == ap_CS_fsm_state1))) begin
        buf_V_16_ce0 = 1'b1;
    end else begin
        buf_V_16_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((icmp_ln158_fu_1254_p2 == 1'd0) & (in0_V_TVALID == 1'b0))) & (icmp_ln158_1_fu_2156_p2 == 1'd1) & (icmp_ln158_fu_1254_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state1))) begin
        buf_V_16_we0 = 1'b1;
    end else begin
        buf_V_16_we0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((icmp_ln158_fu_1254_p2 == 1'd0) & (in0_V_TVALID == 1'b0))) & (1'b1 == ap_CS_fsm_state1))) begin
        buf_V_17_ce0 = 1'b1;
    end else begin
        buf_V_17_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((icmp_ln158_fu_1254_p2 == 1'd0) & (in0_V_TVALID == 1'b0))) & (icmp_ln158_1_fu_2156_p2 == 1'd1) & (icmp_ln158_fu_1254_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state1))) begin
        buf_V_17_we0 = 1'b1;
    end else begin
        buf_V_17_we0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((icmp_ln158_fu_1254_p2 == 1'd0) & (in0_V_TVALID == 1'b0))) & (1'b1 == ap_CS_fsm_state1))) begin
        buf_V_18_ce0 = 1'b1;
    end else begin
        buf_V_18_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((icmp_ln158_fu_1254_p2 == 1'd0) & (in0_V_TVALID == 1'b0))) & (icmp_ln158_1_fu_2156_p2 == 1'd1) & (icmp_ln158_fu_1254_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state1))) begin
        buf_V_18_we0 = 1'b1;
    end else begin
        buf_V_18_we0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((icmp_ln158_fu_1254_p2 == 1'd0) & (in0_V_TVALID == 1'b0))) & (1'b1 == ap_CS_fsm_state1))) begin
        buf_V_19_ce0 = 1'b1;
    end else begin
        buf_V_19_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((icmp_ln158_fu_1254_p2 == 1'd0) & (in0_V_TVALID == 1'b0))) & (icmp_ln158_1_fu_2156_p2 == 1'd1) & (icmp_ln158_fu_1254_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state1))) begin
        buf_V_19_we0 = 1'b1;
    end else begin
        buf_V_19_we0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((icmp_ln158_fu_1254_p2 == 1'd0) & (in0_V_TVALID == 1'b0))) & (1'b1 == ap_CS_fsm_state1))) begin
        buf_V_1_ce0 = 1'b1;
    end else begin
        buf_V_1_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((icmp_ln158_fu_1254_p2 == 1'd0) & (in0_V_TVALID == 1'b0))) & (icmp_ln158_1_fu_2156_p2 == 1'd1) & (icmp_ln158_fu_1254_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state1))) begin
        buf_V_1_we0 = 1'b1;
    end else begin
        buf_V_1_we0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((icmp_ln158_fu_1254_p2 == 1'd0) & (in0_V_TVALID == 1'b0))) & (1'b1 == ap_CS_fsm_state1))) begin
        buf_V_20_ce0 = 1'b1;
    end else begin
        buf_V_20_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((icmp_ln158_fu_1254_p2 == 1'd0) & (in0_V_TVALID == 1'b0))) & (icmp_ln158_1_fu_2156_p2 == 1'd1) & (icmp_ln158_fu_1254_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state1))) begin
        buf_V_20_we0 = 1'b1;
    end else begin
        buf_V_20_we0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((icmp_ln158_fu_1254_p2 == 1'd0) & (in0_V_TVALID == 1'b0))) & (1'b1 == ap_CS_fsm_state1))) begin
        buf_V_21_ce0 = 1'b1;
    end else begin
        buf_V_21_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((icmp_ln158_fu_1254_p2 == 1'd0) & (in0_V_TVALID == 1'b0))) & (icmp_ln158_1_fu_2156_p2 == 1'd1) & (icmp_ln158_fu_1254_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state1))) begin
        buf_V_21_we0 = 1'b1;
    end else begin
        buf_V_21_we0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((icmp_ln158_fu_1254_p2 == 1'd0) & (in0_V_TVALID == 1'b0))) & (1'b1 == ap_CS_fsm_state1))) begin
        buf_V_22_ce0 = 1'b1;
    end else begin
        buf_V_22_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((icmp_ln158_fu_1254_p2 == 1'd0) & (in0_V_TVALID == 1'b0))) & (icmp_ln158_1_fu_2156_p2 == 1'd1) & (icmp_ln158_fu_1254_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state1))) begin
        buf_V_22_we0 = 1'b1;
    end else begin
        buf_V_22_we0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((icmp_ln158_fu_1254_p2 == 1'd0) & (in0_V_TVALID == 1'b0))) & (1'b1 == ap_CS_fsm_state1))) begin
        buf_V_23_ce0 = 1'b1;
    end else begin
        buf_V_23_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((icmp_ln158_fu_1254_p2 == 1'd0) & (in0_V_TVALID == 1'b0))) & (icmp_ln158_1_fu_2156_p2 == 1'd1) & (icmp_ln158_fu_1254_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state1))) begin
        buf_V_23_we0 = 1'b1;
    end else begin
        buf_V_23_we0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((icmp_ln158_fu_1254_p2 == 1'd0) & (in0_V_TVALID == 1'b0))) & (1'b1 == ap_CS_fsm_state1))) begin
        buf_V_24_ce0 = 1'b1;
    end else begin
        buf_V_24_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((icmp_ln158_fu_1254_p2 == 1'd0) & (in0_V_TVALID == 1'b0))) & (icmp_ln158_1_fu_2156_p2 == 1'd1) & (icmp_ln158_fu_1254_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state1))) begin
        buf_V_24_we0 = 1'b1;
    end else begin
        buf_V_24_we0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((icmp_ln158_fu_1254_p2 == 1'd0) & (in0_V_TVALID == 1'b0))) & (1'b1 == ap_CS_fsm_state1))) begin
        buf_V_25_ce0 = 1'b1;
    end else begin
        buf_V_25_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((icmp_ln158_fu_1254_p2 == 1'd0) & (in0_V_TVALID == 1'b0))) & (icmp_ln158_1_fu_2156_p2 == 1'd1) & (icmp_ln158_fu_1254_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state1))) begin
        buf_V_25_we0 = 1'b1;
    end else begin
        buf_V_25_we0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((icmp_ln158_fu_1254_p2 == 1'd0) & (in0_V_TVALID == 1'b0))) & (1'b1 == ap_CS_fsm_state1))) begin
        buf_V_26_ce0 = 1'b1;
    end else begin
        buf_V_26_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((icmp_ln158_fu_1254_p2 == 1'd0) & (in0_V_TVALID == 1'b0))) & (icmp_ln158_1_fu_2156_p2 == 1'd1) & (icmp_ln158_fu_1254_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state1))) begin
        buf_V_26_we0 = 1'b1;
    end else begin
        buf_V_26_we0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((icmp_ln158_fu_1254_p2 == 1'd0) & (in0_V_TVALID == 1'b0))) & (1'b1 == ap_CS_fsm_state1))) begin
        buf_V_27_ce0 = 1'b1;
    end else begin
        buf_V_27_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((icmp_ln158_fu_1254_p2 == 1'd0) & (in0_V_TVALID == 1'b0))) & (icmp_ln158_1_fu_2156_p2 == 1'd1) & (icmp_ln158_fu_1254_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state1))) begin
        buf_V_27_we0 = 1'b1;
    end else begin
        buf_V_27_we0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((icmp_ln158_fu_1254_p2 == 1'd0) & (in0_V_TVALID == 1'b0))) & (1'b1 == ap_CS_fsm_state1))) begin
        buf_V_28_ce0 = 1'b1;
    end else begin
        buf_V_28_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((icmp_ln158_fu_1254_p2 == 1'd0) & (in0_V_TVALID == 1'b0))) & (icmp_ln158_1_fu_2156_p2 == 1'd1) & (icmp_ln158_fu_1254_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state1))) begin
        buf_V_28_we0 = 1'b1;
    end else begin
        buf_V_28_we0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((icmp_ln158_fu_1254_p2 == 1'd0) & (in0_V_TVALID == 1'b0))) & (1'b1 == ap_CS_fsm_state1))) begin
        buf_V_29_ce0 = 1'b1;
    end else begin
        buf_V_29_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((icmp_ln158_fu_1254_p2 == 1'd0) & (in0_V_TVALID == 1'b0))) & (icmp_ln158_1_fu_2156_p2 == 1'd1) & (icmp_ln158_fu_1254_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state1))) begin
        buf_V_29_we0 = 1'b1;
    end else begin
        buf_V_29_we0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((icmp_ln158_fu_1254_p2 == 1'd0) & (in0_V_TVALID == 1'b0))) & (1'b1 == ap_CS_fsm_state1))) begin
        buf_V_2_ce0 = 1'b1;
    end else begin
        buf_V_2_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((icmp_ln158_fu_1254_p2 == 1'd0) & (in0_V_TVALID == 1'b0))) & (icmp_ln158_1_fu_2156_p2 == 1'd1) & (icmp_ln158_fu_1254_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state1))) begin
        buf_V_2_we0 = 1'b1;
    end else begin
        buf_V_2_we0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((icmp_ln158_fu_1254_p2 == 1'd0) & (in0_V_TVALID == 1'b0))) & (1'b1 == ap_CS_fsm_state1))) begin
        buf_V_30_ce0 = 1'b1;
    end else begin
        buf_V_30_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((icmp_ln158_fu_1254_p2 == 1'd0) & (in0_V_TVALID == 1'b0))) & (icmp_ln158_1_fu_2156_p2 == 1'd1) & (icmp_ln158_fu_1254_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state1))) begin
        buf_V_30_we0 = 1'b1;
    end else begin
        buf_V_30_we0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((icmp_ln158_fu_1254_p2 == 1'd0) & (in0_V_TVALID == 1'b0))) & (1'b1 == ap_CS_fsm_state1))) begin
        buf_V_31_ce0 = 1'b1;
    end else begin
        buf_V_31_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((icmp_ln158_fu_1254_p2 == 1'd0) & (in0_V_TVALID == 1'b0))) & (icmp_ln158_1_fu_2156_p2 == 1'd1) & (icmp_ln158_fu_1254_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state1))) begin
        buf_V_31_we0 = 1'b1;
    end else begin
        buf_V_31_we0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((icmp_ln158_fu_1254_p2 == 1'd0) & (in0_V_TVALID == 1'b0))) & (1'b1 == ap_CS_fsm_state1))) begin
        buf_V_3_ce0 = 1'b1;
    end else begin
        buf_V_3_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((icmp_ln158_fu_1254_p2 == 1'd0) & (in0_V_TVALID == 1'b0))) & (icmp_ln158_1_fu_2156_p2 == 1'd1) & (icmp_ln158_fu_1254_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state1))) begin
        buf_V_3_we0 = 1'b1;
    end else begin
        buf_V_3_we0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((icmp_ln158_fu_1254_p2 == 1'd0) & (in0_V_TVALID == 1'b0))) & (1'b1 == ap_CS_fsm_state1))) begin
        buf_V_4_ce0 = 1'b1;
    end else begin
        buf_V_4_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((icmp_ln158_fu_1254_p2 == 1'd0) & (in0_V_TVALID == 1'b0))) & (icmp_ln158_1_fu_2156_p2 == 1'd1) & (icmp_ln158_fu_1254_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state1))) begin
        buf_V_4_we0 = 1'b1;
    end else begin
        buf_V_4_we0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((icmp_ln158_fu_1254_p2 == 1'd0) & (in0_V_TVALID == 1'b0))) & (1'b1 == ap_CS_fsm_state1))) begin
        buf_V_5_ce0 = 1'b1;
    end else begin
        buf_V_5_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((icmp_ln158_fu_1254_p2 == 1'd0) & (in0_V_TVALID == 1'b0))) & (icmp_ln158_1_fu_2156_p2 == 1'd1) & (icmp_ln158_fu_1254_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state1))) begin
        buf_V_5_we0 = 1'b1;
    end else begin
        buf_V_5_we0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((icmp_ln158_fu_1254_p2 == 1'd0) & (in0_V_TVALID == 1'b0))) & (1'b1 == ap_CS_fsm_state1))) begin
        buf_V_6_ce0 = 1'b1;
    end else begin
        buf_V_6_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((icmp_ln158_fu_1254_p2 == 1'd0) & (in0_V_TVALID == 1'b0))) & (icmp_ln158_1_fu_2156_p2 == 1'd1) & (icmp_ln158_fu_1254_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state1))) begin
        buf_V_6_we0 = 1'b1;
    end else begin
        buf_V_6_we0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((icmp_ln158_fu_1254_p2 == 1'd0) & (in0_V_TVALID == 1'b0))) & (1'b1 == ap_CS_fsm_state1))) begin
        buf_V_7_ce0 = 1'b1;
    end else begin
        buf_V_7_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((icmp_ln158_fu_1254_p2 == 1'd0) & (in0_V_TVALID == 1'b0))) & (icmp_ln158_1_fu_2156_p2 == 1'd1) & (icmp_ln158_fu_1254_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state1))) begin
        buf_V_7_we0 = 1'b1;
    end else begin
        buf_V_7_we0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((icmp_ln158_fu_1254_p2 == 1'd0) & (in0_V_TVALID == 1'b0))) & (1'b1 == ap_CS_fsm_state1))) begin
        buf_V_8_ce0 = 1'b1;
    end else begin
        buf_V_8_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((icmp_ln158_fu_1254_p2 == 1'd0) & (in0_V_TVALID == 1'b0))) & (icmp_ln158_1_fu_2156_p2 == 1'd1) & (icmp_ln158_fu_1254_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state1))) begin
        buf_V_8_we0 = 1'b1;
    end else begin
        buf_V_8_we0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((icmp_ln158_fu_1254_p2 == 1'd0) & (in0_V_TVALID == 1'b0))) & (1'b1 == ap_CS_fsm_state1))) begin
        buf_V_9_ce0 = 1'b1;
    end else begin
        buf_V_9_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((icmp_ln158_fu_1254_p2 == 1'd0) & (in0_V_TVALID == 1'b0))) & (icmp_ln158_1_fu_2156_p2 == 1'd1) & (icmp_ln158_fu_1254_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state1))) begin
        buf_V_9_we0 = 1'b1;
    end else begin
        buf_V_9_we0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((icmp_ln158_fu_1254_p2 == 1'd0) & (in0_V_TVALID == 1'b0))) & (1'b1 == ap_CS_fsm_state1))) begin
        buf_V_ce0 = 1'b1;
    end else begin
        buf_V_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((icmp_ln158_fu_1254_p2 == 1'd0) & (in0_V_TVALID == 1'b0))) & (icmp_ln158_1_fu_2156_p2 == 1'd1) & (icmp_ln158_fu_1254_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state1))) begin
        buf_V_we0 = 1'b1;
    end else begin
        buf_V_we0 = 1'b0;
    end
end

always @ (*) begin
    if (((icmp_ln158_fu_1254_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state1) & (ap_start_int == 1'b1))) begin
        in0_V_TDATA_blk_n = in0_V_TVALID;
    end else begin
        in0_V_TDATA_blk_n = 1'b1;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((icmp_ln158_fu_1254_p2 == 1'd0) & (in0_V_TVALID == 1'b0))) & (icmp_ln158_fu_1254_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state1))) begin
        in0_V_TREADY = 1'b1;
    end else begin
        in0_V_TREADY = 1'b0;
    end
end

always @ (*) begin
    case (ap_CS_fsm)
        ap_ST_fsm_state1 : begin
            ap_NS_fsm = ap_ST_fsm_state1;
        end
        default : begin
            ap_NS_fsm = 'bx;
        end
    endcase
end

assign ap_CS_fsm_state1 = ap_CS_fsm[32'd0];

always @ (*) begin
    ap_block_state1_pp0_stage0_iter0 = ((ap_start_int == 1'b0) | ((icmp_ln158_fu_1254_p2 == 1'd0) & (in0_V_TVALID == 1'b0)));
end

always @ (*) begin
    ap_condition_1053 = (~((ap_start_int == 1'b0) | ((icmp_ln158_fu_1254_p2 == 1'd0) & (in0_V_TVALID == 1'b0))) & (1'b1 == ap_CS_fsm_state1));
end

assign ap_loop_exit_ready = ap_condition_exit_pp0_iter0_stage0;

assign buf_V_10_address0 = zext_ln156_cast_fu_1050_p1;

assign buf_V_10_d0 = ((icmp_ln1035_10_fu_1616_p2[0:0] == 1'b1) ? channeldata_V_10_fu_1606_p4 : ap_sig_allocacmp_oldMax_V_10_load);

assign buf_V_11_address0 = zext_ln156_cast_fu_1050_p1;

assign buf_V_11_d0 = ((icmp_ln1035_11_fu_1641_p2[0:0] == 1'b1) ? channeldata_V_11_fu_1631_p4 : ap_sig_allocacmp_oldMax_V_11_load);

assign buf_V_12_address0 = zext_ln156_cast_fu_1050_p1;

assign buf_V_12_d0 = ((icmp_ln1035_12_fu_1666_p2[0:0] == 1'b1) ? channeldata_V_12_fu_1656_p4 : ap_sig_allocacmp_oldMax_V_12_load);

assign buf_V_13_address0 = zext_ln156_cast_fu_1050_p1;

assign buf_V_13_d0 = ((icmp_ln1035_13_fu_1691_p2[0:0] == 1'b1) ? channeldata_V_13_fu_1681_p4 : ap_sig_allocacmp_oldMax_V_13_load);

assign buf_V_14_address0 = zext_ln156_cast_fu_1050_p1;

assign buf_V_14_d0 = ((icmp_ln1035_14_fu_1716_p2[0:0] == 1'b1) ? channeldata_V_14_fu_1706_p4 : ap_sig_allocacmp_oldMax_V_14_load);

assign buf_V_15_address0 = zext_ln156_cast_fu_1050_p1;

assign buf_V_15_d0 = ((icmp_ln1035_15_fu_1741_p2[0:0] == 1'b1) ? channeldata_V_15_fu_1731_p4 : ap_sig_allocacmp_oldMax_V_15_load);

assign buf_V_16_address0 = zext_ln156_cast_fu_1050_p1;

assign buf_V_16_d0 = ((icmp_ln1035_16_fu_1766_p2[0:0] == 1'b1) ? channeldata_V_16_fu_1756_p4 : ap_sig_allocacmp_oldMax_V_16_load);

assign buf_V_17_address0 = zext_ln156_cast_fu_1050_p1;

assign buf_V_17_d0 = ((icmp_ln1035_17_fu_1791_p2[0:0] == 1'b1) ? channeldata_V_17_fu_1781_p4 : ap_sig_allocacmp_oldMax_V_17_load);

assign buf_V_18_address0 = zext_ln156_cast_fu_1050_p1;

assign buf_V_18_d0 = ((icmp_ln1035_18_fu_1816_p2[0:0] == 1'b1) ? channeldata_V_18_fu_1806_p4 : ap_sig_allocacmp_oldMax_V_18_load);

assign buf_V_19_address0 = zext_ln156_cast_fu_1050_p1;

assign buf_V_19_d0 = ((icmp_ln1035_19_fu_1841_p2[0:0] == 1'b1) ? channeldata_V_19_fu_1831_p4 : ap_sig_allocacmp_oldMax_V_19_load);

assign buf_V_1_address0 = zext_ln156_cast_fu_1050_p1;

assign buf_V_1_d0 = ((icmp_ln1035_1_fu_1391_p2[0:0] == 1'b1) ? channeldata_V_1_fu_1381_p4 : ap_sig_allocacmp_oldMax_V_1_load);

assign buf_V_20_address0 = zext_ln156_cast_fu_1050_p1;

assign buf_V_20_d0 = ((icmp_ln1035_20_fu_1866_p2[0:0] == 1'b1) ? channeldata_V_20_fu_1856_p4 : ap_sig_allocacmp_oldMax_V_20_load);

assign buf_V_21_address0 = zext_ln156_cast_fu_1050_p1;

assign buf_V_21_d0 = ((icmp_ln1035_21_fu_1891_p2[0:0] == 1'b1) ? channeldata_V_21_fu_1881_p4 : ap_sig_allocacmp_oldMax_V_21_load);

assign buf_V_22_address0 = zext_ln156_cast_fu_1050_p1;

assign buf_V_22_d0 = ((icmp_ln1035_22_fu_1916_p2[0:0] == 1'b1) ? channeldata_V_22_fu_1906_p4 : ap_sig_allocacmp_oldMax_V_22_load);

assign buf_V_23_address0 = zext_ln156_cast_fu_1050_p1;

assign buf_V_23_d0 = ((icmp_ln1035_23_fu_1941_p2[0:0] == 1'b1) ? channeldata_V_23_fu_1931_p4 : ap_sig_allocacmp_oldMax_V_23_load);

assign buf_V_24_address0 = zext_ln156_cast_fu_1050_p1;

assign buf_V_24_d0 = ((icmp_ln1035_24_fu_1966_p2[0:0] == 1'b1) ? channeldata_V_24_fu_1956_p4 : ap_sig_allocacmp_oldMax_V_24_load);

assign buf_V_25_address0 = zext_ln156_cast_fu_1050_p1;

assign buf_V_25_d0 = ((icmp_ln1035_25_fu_1991_p2[0:0] == 1'b1) ? channeldata_V_25_fu_1981_p4 : ap_sig_allocacmp_oldMax_V_25_load);

assign buf_V_26_address0 = zext_ln156_cast_fu_1050_p1;

assign buf_V_26_d0 = ((icmp_ln1035_26_fu_2016_p2[0:0] == 1'b1) ? channeldata_V_26_fu_2006_p4 : ap_sig_allocacmp_oldMax_V_26_load);

assign buf_V_27_address0 = zext_ln156_cast_fu_1050_p1;

assign buf_V_27_d0 = ((icmp_ln1035_27_fu_2041_p2[0:0] == 1'b1) ? channeldata_V_27_fu_2031_p4 : ap_sig_allocacmp_oldMax_V_27_load);

assign buf_V_28_address0 = zext_ln156_cast_fu_1050_p1;

assign buf_V_28_d0 = ((icmp_ln1035_28_fu_2066_p2[0:0] == 1'b1) ? channeldata_V_28_fu_2056_p4 : ap_sig_allocacmp_oldMax_V_28_load);

assign buf_V_29_address0 = zext_ln156_cast_fu_1050_p1;

assign buf_V_29_d0 = ((icmp_ln1035_29_fu_2091_p2[0:0] == 1'b1) ? channeldata_V_29_fu_2081_p4 : ap_sig_allocacmp_oldMax_V_29_load);

assign buf_V_2_address0 = zext_ln156_cast_fu_1050_p1;

assign buf_V_2_d0 = ((icmp_ln1035_2_fu_1416_p2[0:0] == 1'b1) ? channeldata_V_2_fu_1406_p4 : ap_sig_allocacmp_oldMax_V_2_load);

assign buf_V_30_address0 = zext_ln156_cast_fu_1050_p1;

assign buf_V_30_d0 = ((icmp_ln1035_30_fu_2116_p2[0:0] == 1'b1) ? channeldata_V_30_fu_2106_p4 : ap_sig_allocacmp_oldMax_V_30_load);

assign buf_V_31_address0 = zext_ln156_cast_fu_1050_p1;

assign buf_V_31_d0 = ((icmp_ln1035_31_fu_2141_p2[0:0] == 1'b1) ? channeldata_V_31_fu_2131_p4 : ap_sig_allocacmp_oldMax_V_31_load);

assign buf_V_3_address0 = zext_ln156_cast_fu_1050_p1;

assign buf_V_3_d0 = ((icmp_ln1035_3_fu_1441_p2[0:0] == 1'b1) ? channeldata_V_3_fu_1431_p4 : ap_sig_allocacmp_oldMax_V_3_load);

assign buf_V_4_address0 = zext_ln156_cast_fu_1050_p1;

assign buf_V_4_d0 = ((icmp_ln1035_4_fu_1466_p2[0:0] == 1'b1) ? channeldata_V_4_fu_1456_p4 : ap_sig_allocacmp_oldMax_V_4_load);

assign buf_V_5_address0 = zext_ln156_cast_fu_1050_p1;

assign buf_V_5_d0 = ((icmp_ln1035_5_fu_1491_p2[0:0] == 1'b1) ? channeldata_V_5_fu_1481_p4 : ap_sig_allocacmp_oldMax_V_5_load);

assign buf_V_6_address0 = zext_ln156_cast_fu_1050_p1;

assign buf_V_6_d0 = ((icmp_ln1035_6_fu_1516_p2[0:0] == 1'b1) ? channeldata_V_6_fu_1506_p4 : ap_sig_allocacmp_oldMax_V_6_load);

assign buf_V_7_address0 = zext_ln156_cast_fu_1050_p1;

assign buf_V_7_d0 = ((icmp_ln1035_7_fu_1541_p2[0:0] == 1'b1) ? channeldata_V_7_fu_1531_p4 : ap_sig_allocacmp_oldMax_V_7_load);

assign buf_V_8_address0 = zext_ln156_cast_fu_1050_p1;

assign buf_V_8_d0 = ((icmp_ln1035_8_fu_1566_p2[0:0] == 1'b1) ? channeldata_V_8_fu_1556_p4 : ap_sig_allocacmp_oldMax_V_8_load);

assign buf_V_9_address0 = zext_ln156_cast_fu_1050_p1;

assign buf_V_9_d0 = ((icmp_ln1035_9_fu_1591_p2[0:0] == 1'b1) ? channeldata_V_9_fu_1581_p4 : ap_sig_allocacmp_oldMax_V_9_load);

assign buf_V_address0 = zext_ln156_cast_fu_1050_p1;

assign buf_V_d0 = ((icmp_ln1035_fu_1366_p2[0:0] == 1'b1) ? channeldata_V_fu_1362_p1 : ap_sig_allocacmp_oldMax_V_load);

assign channeldata_V_10_fu_1606_p4 = {{in0_V_TDATA[43:40]}};

assign channeldata_V_11_fu_1631_p4 = {{in0_V_TDATA[47:44]}};

assign channeldata_V_12_fu_1656_p4 = {{in0_V_TDATA[51:48]}};

assign channeldata_V_13_fu_1681_p4 = {{in0_V_TDATA[55:52]}};

assign channeldata_V_14_fu_1706_p4 = {{in0_V_TDATA[59:56]}};

assign channeldata_V_15_fu_1731_p4 = {{in0_V_TDATA[63:60]}};

assign channeldata_V_16_fu_1756_p4 = {{in0_V_TDATA[67:64]}};

assign channeldata_V_17_fu_1781_p4 = {{in0_V_TDATA[71:68]}};

assign channeldata_V_18_fu_1806_p4 = {{in0_V_TDATA[75:72]}};

assign channeldata_V_19_fu_1831_p4 = {{in0_V_TDATA[79:76]}};

assign channeldata_V_1_fu_1381_p4 = {{in0_V_TDATA[7:4]}};

assign channeldata_V_20_fu_1856_p4 = {{in0_V_TDATA[83:80]}};

assign channeldata_V_21_fu_1881_p4 = {{in0_V_TDATA[87:84]}};

assign channeldata_V_22_fu_1906_p4 = {{in0_V_TDATA[91:88]}};

assign channeldata_V_23_fu_1931_p4 = {{in0_V_TDATA[95:92]}};

assign channeldata_V_24_fu_1956_p4 = {{in0_V_TDATA[99:96]}};

assign channeldata_V_25_fu_1981_p4 = {{in0_V_TDATA[103:100]}};

assign channeldata_V_26_fu_2006_p4 = {{in0_V_TDATA[107:104]}};

assign channeldata_V_27_fu_2031_p4 = {{in0_V_TDATA[111:108]}};

assign channeldata_V_28_fu_2056_p4 = {{in0_V_TDATA[115:112]}};

assign channeldata_V_29_fu_2081_p4 = {{in0_V_TDATA[119:116]}};

assign channeldata_V_2_fu_1406_p4 = {{in0_V_TDATA[11:8]}};

assign channeldata_V_30_fu_2106_p4 = {{in0_V_TDATA[123:120]}};

assign channeldata_V_31_fu_2131_p4 = {{in0_V_TDATA[127:124]}};

assign channeldata_V_3_fu_1431_p4 = {{in0_V_TDATA[15:12]}};

assign channeldata_V_4_fu_1456_p4 = {{in0_V_TDATA[19:16]}};

assign channeldata_V_5_fu_1481_p4 = {{in0_V_TDATA[23:20]}};

assign channeldata_V_6_fu_1506_p4 = {{in0_V_TDATA[27:24]}};

assign channeldata_V_7_fu_1531_p4 = {{in0_V_TDATA[31:28]}};

assign channeldata_V_8_fu_1556_p4 = {{in0_V_TDATA[35:32]}};

assign channeldata_V_9_fu_1581_p4 = {{in0_V_TDATA[39:36]}};

assign channeldata_V_fu_1362_p1 = in0_V_TDATA[3:0];

assign icmp_ln1035_10_fu_1616_p2 = ((channeldata_V_10_fu_1606_p4 > ap_sig_allocacmp_oldMax_V_10_load) ? 1'b1 : 1'b0);

assign icmp_ln1035_11_fu_1641_p2 = ((channeldata_V_11_fu_1631_p4 > ap_sig_allocacmp_oldMax_V_11_load) ? 1'b1 : 1'b0);

assign icmp_ln1035_12_fu_1666_p2 = ((channeldata_V_12_fu_1656_p4 > ap_sig_allocacmp_oldMax_V_12_load) ? 1'b1 : 1'b0);

assign icmp_ln1035_13_fu_1691_p2 = ((channeldata_V_13_fu_1681_p4 > ap_sig_allocacmp_oldMax_V_13_load) ? 1'b1 : 1'b0);

assign icmp_ln1035_14_fu_1716_p2 = ((channeldata_V_14_fu_1706_p4 > ap_sig_allocacmp_oldMax_V_14_load) ? 1'b1 : 1'b0);

assign icmp_ln1035_15_fu_1741_p2 = ((channeldata_V_15_fu_1731_p4 > ap_sig_allocacmp_oldMax_V_15_load) ? 1'b1 : 1'b0);

assign icmp_ln1035_16_fu_1766_p2 = ((channeldata_V_16_fu_1756_p4 > ap_sig_allocacmp_oldMax_V_16_load) ? 1'b1 : 1'b0);

assign icmp_ln1035_17_fu_1791_p2 = ((channeldata_V_17_fu_1781_p4 > ap_sig_allocacmp_oldMax_V_17_load) ? 1'b1 : 1'b0);

assign icmp_ln1035_18_fu_1816_p2 = ((channeldata_V_18_fu_1806_p4 > ap_sig_allocacmp_oldMax_V_18_load) ? 1'b1 : 1'b0);

assign icmp_ln1035_19_fu_1841_p2 = ((channeldata_V_19_fu_1831_p4 > ap_sig_allocacmp_oldMax_V_19_load) ? 1'b1 : 1'b0);

assign icmp_ln1035_1_fu_1391_p2 = ((channeldata_V_1_fu_1381_p4 > ap_sig_allocacmp_oldMax_V_1_load) ? 1'b1 : 1'b0);

assign icmp_ln1035_20_fu_1866_p2 = ((channeldata_V_20_fu_1856_p4 > ap_sig_allocacmp_oldMax_V_20_load) ? 1'b1 : 1'b0);

assign icmp_ln1035_21_fu_1891_p2 = ((channeldata_V_21_fu_1881_p4 > ap_sig_allocacmp_oldMax_V_21_load) ? 1'b1 : 1'b0);

assign icmp_ln1035_22_fu_1916_p2 = ((channeldata_V_22_fu_1906_p4 > ap_sig_allocacmp_oldMax_V_22_load) ? 1'b1 : 1'b0);

assign icmp_ln1035_23_fu_1941_p2 = ((channeldata_V_23_fu_1931_p4 > ap_sig_allocacmp_oldMax_V_23_load) ? 1'b1 : 1'b0);

assign icmp_ln1035_24_fu_1966_p2 = ((channeldata_V_24_fu_1956_p4 > ap_sig_allocacmp_oldMax_V_24_load) ? 1'b1 : 1'b0);

assign icmp_ln1035_25_fu_1991_p2 = ((channeldata_V_25_fu_1981_p4 > ap_sig_allocacmp_oldMax_V_25_load) ? 1'b1 : 1'b0);

assign icmp_ln1035_26_fu_2016_p2 = ((channeldata_V_26_fu_2006_p4 > ap_sig_allocacmp_oldMax_V_26_load) ? 1'b1 : 1'b0);

assign icmp_ln1035_27_fu_2041_p2 = ((channeldata_V_27_fu_2031_p4 > ap_sig_allocacmp_oldMax_V_27_load) ? 1'b1 : 1'b0);

assign icmp_ln1035_28_fu_2066_p2 = ((channeldata_V_28_fu_2056_p4 > ap_sig_allocacmp_oldMax_V_28_load) ? 1'b1 : 1'b0);

assign icmp_ln1035_29_fu_2091_p2 = ((channeldata_V_29_fu_2081_p4 > ap_sig_allocacmp_oldMax_V_29_load) ? 1'b1 : 1'b0);

assign icmp_ln1035_2_fu_1416_p2 = ((channeldata_V_2_fu_1406_p4 > ap_sig_allocacmp_oldMax_V_2_load) ? 1'b1 : 1'b0);

assign icmp_ln1035_30_fu_2116_p2 = ((channeldata_V_30_fu_2106_p4 > ap_sig_allocacmp_oldMax_V_30_load) ? 1'b1 : 1'b0);

assign icmp_ln1035_31_fu_2141_p2 = ((channeldata_V_31_fu_2131_p4 > ap_sig_allocacmp_oldMax_V_31_load) ? 1'b1 : 1'b0);

assign icmp_ln1035_3_fu_1441_p2 = ((channeldata_V_3_fu_1431_p4 > ap_sig_allocacmp_oldMax_V_3_load) ? 1'b1 : 1'b0);

assign icmp_ln1035_4_fu_1466_p2 = ((channeldata_V_4_fu_1456_p4 > ap_sig_allocacmp_oldMax_V_4_load) ? 1'b1 : 1'b0);

assign icmp_ln1035_5_fu_1491_p2 = ((channeldata_V_5_fu_1481_p4 > ap_sig_allocacmp_oldMax_V_5_load) ? 1'b1 : 1'b0);

assign icmp_ln1035_6_fu_1516_p2 = ((channeldata_V_6_fu_1506_p4 > ap_sig_allocacmp_oldMax_V_6_load) ? 1'b1 : 1'b0);

assign icmp_ln1035_7_fu_1541_p2 = ((channeldata_V_7_fu_1531_p4 > ap_sig_allocacmp_oldMax_V_7_load) ? 1'b1 : 1'b0);

assign icmp_ln1035_8_fu_1566_p2 = ((channeldata_V_8_fu_1556_p4 > ap_sig_allocacmp_oldMax_V_8_load) ? 1'b1 : 1'b0);

assign icmp_ln1035_9_fu_1591_p2 = ((channeldata_V_9_fu_1581_p4 > ap_sig_allocacmp_oldMax_V_9_load) ? 1'b1 : 1'b0);

assign icmp_ln1035_fu_1366_p2 = ((channeldata_V_fu_1362_p1 > ap_sig_allocacmp_oldMax_V_load) ? 1'b1 : 1'b0);

assign icmp_ln158_1_fu_2156_p2 = ((kx_2_fu_1260_p2 == 2'd2) ? 1'b1 : 1'b0);

assign icmp_ln158_fu_1254_p2 = ((ap_sig_allocacmp_kx_1 == 2'd2) ? 1'b1 : 1'b0);

assign kx_2_fu_1260_p2 = (ap_sig_allocacmp_kx_1 + 2'd1);

assign select_ln167_10_fu_1622_p3 = ((icmp_ln1035_10_fu_1616_p2[0:0] == 1'b1) ? channeldata_V_10_fu_1606_p4 : ap_sig_allocacmp_oldMax_V_10_load);

assign select_ln167_11_fu_1647_p3 = ((icmp_ln1035_11_fu_1641_p2[0:0] == 1'b1) ? channeldata_V_11_fu_1631_p4 : ap_sig_allocacmp_oldMax_V_11_load);

assign select_ln167_12_fu_1672_p3 = ((icmp_ln1035_12_fu_1666_p2[0:0] == 1'b1) ? channeldata_V_12_fu_1656_p4 : ap_sig_allocacmp_oldMax_V_12_load);

assign select_ln167_13_fu_1697_p3 = ((icmp_ln1035_13_fu_1691_p2[0:0] == 1'b1) ? channeldata_V_13_fu_1681_p4 : ap_sig_allocacmp_oldMax_V_13_load);

assign select_ln167_14_fu_1722_p3 = ((icmp_ln1035_14_fu_1716_p2[0:0] == 1'b1) ? channeldata_V_14_fu_1706_p4 : ap_sig_allocacmp_oldMax_V_14_load);

assign select_ln167_15_fu_1747_p3 = ((icmp_ln1035_15_fu_1741_p2[0:0] == 1'b1) ? channeldata_V_15_fu_1731_p4 : ap_sig_allocacmp_oldMax_V_15_load);

assign select_ln167_16_fu_1772_p3 = ((icmp_ln1035_16_fu_1766_p2[0:0] == 1'b1) ? channeldata_V_16_fu_1756_p4 : ap_sig_allocacmp_oldMax_V_16_load);

assign select_ln167_17_fu_1797_p3 = ((icmp_ln1035_17_fu_1791_p2[0:0] == 1'b1) ? channeldata_V_17_fu_1781_p4 : ap_sig_allocacmp_oldMax_V_17_load);

assign select_ln167_18_fu_1822_p3 = ((icmp_ln1035_18_fu_1816_p2[0:0] == 1'b1) ? channeldata_V_18_fu_1806_p4 : ap_sig_allocacmp_oldMax_V_18_load);

assign select_ln167_19_fu_1847_p3 = ((icmp_ln1035_19_fu_1841_p2[0:0] == 1'b1) ? channeldata_V_19_fu_1831_p4 : ap_sig_allocacmp_oldMax_V_19_load);

assign select_ln167_1_fu_1397_p3 = ((icmp_ln1035_1_fu_1391_p2[0:0] == 1'b1) ? channeldata_V_1_fu_1381_p4 : ap_sig_allocacmp_oldMax_V_1_load);

assign select_ln167_20_fu_1872_p3 = ((icmp_ln1035_20_fu_1866_p2[0:0] == 1'b1) ? channeldata_V_20_fu_1856_p4 : ap_sig_allocacmp_oldMax_V_20_load);

assign select_ln167_21_fu_1897_p3 = ((icmp_ln1035_21_fu_1891_p2[0:0] == 1'b1) ? channeldata_V_21_fu_1881_p4 : ap_sig_allocacmp_oldMax_V_21_load);

assign select_ln167_22_fu_1922_p3 = ((icmp_ln1035_22_fu_1916_p2[0:0] == 1'b1) ? channeldata_V_22_fu_1906_p4 : ap_sig_allocacmp_oldMax_V_22_load);

assign select_ln167_23_fu_1947_p3 = ((icmp_ln1035_23_fu_1941_p2[0:0] == 1'b1) ? channeldata_V_23_fu_1931_p4 : ap_sig_allocacmp_oldMax_V_23_load);

assign select_ln167_24_fu_1972_p3 = ((icmp_ln1035_24_fu_1966_p2[0:0] == 1'b1) ? channeldata_V_24_fu_1956_p4 : ap_sig_allocacmp_oldMax_V_24_load);

assign select_ln167_25_fu_1997_p3 = ((icmp_ln1035_25_fu_1991_p2[0:0] == 1'b1) ? channeldata_V_25_fu_1981_p4 : ap_sig_allocacmp_oldMax_V_25_load);

assign select_ln167_26_fu_2022_p3 = ((icmp_ln1035_26_fu_2016_p2[0:0] == 1'b1) ? channeldata_V_26_fu_2006_p4 : ap_sig_allocacmp_oldMax_V_26_load);

assign select_ln167_27_fu_2047_p3 = ((icmp_ln1035_27_fu_2041_p2[0:0] == 1'b1) ? channeldata_V_27_fu_2031_p4 : ap_sig_allocacmp_oldMax_V_27_load);

assign select_ln167_28_fu_2072_p3 = ((icmp_ln1035_28_fu_2066_p2[0:0] == 1'b1) ? channeldata_V_28_fu_2056_p4 : ap_sig_allocacmp_oldMax_V_28_load);

assign select_ln167_29_fu_2097_p3 = ((icmp_ln1035_29_fu_2091_p2[0:0] == 1'b1) ? channeldata_V_29_fu_2081_p4 : ap_sig_allocacmp_oldMax_V_29_load);

assign select_ln167_2_fu_1422_p3 = ((icmp_ln1035_2_fu_1416_p2[0:0] == 1'b1) ? channeldata_V_2_fu_1406_p4 : ap_sig_allocacmp_oldMax_V_2_load);

assign select_ln167_30_fu_2122_p3 = ((icmp_ln1035_30_fu_2116_p2[0:0] == 1'b1) ? channeldata_V_30_fu_2106_p4 : ap_sig_allocacmp_oldMax_V_30_load);

assign select_ln167_31_fu_2147_p3 = ((icmp_ln1035_31_fu_2141_p2[0:0] == 1'b1) ? channeldata_V_31_fu_2131_p4 : ap_sig_allocacmp_oldMax_V_31_load);

assign select_ln167_3_fu_1447_p3 = ((icmp_ln1035_3_fu_1441_p2[0:0] == 1'b1) ? channeldata_V_3_fu_1431_p4 : ap_sig_allocacmp_oldMax_V_3_load);

assign select_ln167_4_fu_1472_p3 = ((icmp_ln1035_4_fu_1466_p2[0:0] == 1'b1) ? channeldata_V_4_fu_1456_p4 : ap_sig_allocacmp_oldMax_V_4_load);

assign select_ln167_5_fu_1497_p3 = ((icmp_ln1035_5_fu_1491_p2[0:0] == 1'b1) ? channeldata_V_5_fu_1481_p4 : ap_sig_allocacmp_oldMax_V_5_load);

assign select_ln167_6_fu_1522_p3 = ((icmp_ln1035_6_fu_1516_p2[0:0] == 1'b1) ? channeldata_V_6_fu_1506_p4 : ap_sig_allocacmp_oldMax_V_6_load);

assign select_ln167_7_fu_1547_p3 = ((icmp_ln1035_7_fu_1541_p2[0:0] == 1'b1) ? channeldata_V_7_fu_1531_p4 : ap_sig_allocacmp_oldMax_V_7_load);

assign select_ln167_8_fu_1572_p3 = ((icmp_ln1035_8_fu_1566_p2[0:0] == 1'b1) ? channeldata_V_8_fu_1556_p4 : ap_sig_allocacmp_oldMax_V_8_load);

assign select_ln167_9_fu_1597_p3 = ((icmp_ln1035_9_fu_1591_p2[0:0] == 1'b1) ? channeldata_V_9_fu_1581_p4 : ap_sig_allocacmp_oldMax_V_9_load);

assign select_ln167_fu_1372_p3 = ((icmp_ln1035_fu_1366_p2[0:0] == 1'b1) ? channeldata_V_fu_1362_p1 : ap_sig_allocacmp_oldMax_V_load);

assign zext_ln156_cast_fu_1050_p1 = zext_ln156;

endmodule //StreamingMaxPool_hls_1_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6
//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/code_gen_ipgen_ConvolutionInputGenerator_rtl_0_sgzv3feu/ConvolutionInputGenerator_rtl_0_impl.sv


/******************************************************************************
 * Copyright (C) 2022, Advanced Micro Devices, Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *  1. Redistributions of source code must retain the above copyright notice,
 *     this list of conditions and the following disclaimer.
 *
 *  2. Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *
 *  3. Neither the name of the copyright holder nor the names of its
 *     contributors may be used to endorse or promote products derived from
 *     this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION). HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *****************************************************************************/
module ConvolutionInputGenerator_rtl_0_impl #(
    int  BIT_WIDTH,
    int  SIMD,
    int  MMV_IN,
    int  MMV_OUT,
    int  LAST_READ_ELEM = 2699,
    int  LAST_WRITE_ELEM = 2699,
    int  BUF_ELEM_TOTAL = 189,
    int  ELEM_PER_WINDOW = 27,
    int  INCR_BITWIDTH = 9
)(
    input   logic  ap_clk,
    input   logic  ap_rst_n,

    input   logic  in0_V_V_TVALID,
    output  logic  in0_V_V_TREADY,
    input   logic [BIT_WIDTH * SIMD * MMV_IN-1:0]  in0_V_V_TDATA,

    output  logic  out_V_V_TVALID,
    input   logic  out_V_V_TREADY,
    output  logic [BIT_WIDTH * SIMD * MMV_OUT-1:0]  out_V_V_TDATA
);
    // derived constants
    localparam int unsigned  BUF_IN_WIDTH = BIT_WIDTH * SIMD * MMV_IN;
    localparam int unsigned  BUF_OUT_ELEM_WIDTH = BIT_WIDTH * SIMD;
    localparam int unsigned  BUF_OUT_WIDTH = BIT_WIDTH * SIMD * MMV_OUT;

   // main buffer instantiation
    uwire [BUF_IN_WIDTH -1:0]  window_buffer_in;
    uwire [BUF_OUT_WIDTH-1:0]  window_buffer_out;
    uwire  window_buffer_write_enable;
    uwire  window_buffer_read_enable;
    uwire [$clog2(BUF_ELEM_TOTAL)-1:0]  window_buffer_write_addr;
    uwire [$clog2(BUF_ELEM_TOTAL)-1:0]  window_buffer_read_addr;
    swg_cyclic_buffer_addressable #(
        .WIDTH(BUF_IN_WIDTH),
        .DEPTH(BUF_ELEM_TOTAL),
        .RAM_STYLE("distributed")
    ) window_buffer_inst (
        .clk(ap_clk),

        .write_enable(window_buffer_write_enable),
        .write_addr(window_buffer_write_addr),
        .data_in(window_buffer_in),

        .read_enable(window_buffer_read_enable),
        .read_addr(window_buffer_read_addr),
        .data_out(window_buffer_out)
    );

    //controller instantiation
    uwire  advance_controller;
    uwire signed [INCR_BITWIDTH-1:0]  addr_incr;
    uwire        [INCR_BITWIDTH-1:0]  tail_incr;
    swg_controller #(
        .LOOP_H_ITERATIONS(26),
        .LOOP_W_ITERATIONS(26),
        .LOOP_KH_ITERATIONS(1),
        .LOOP_KW_ITERATIONS(1),
        .LOOP_SIMD_ITERATIONS(0),
        .HEAD_INCR_SIMD(1),
        .HEAD_INCR_KW(1),
        .HEAD_INCR_KH(82),
        .HEAD_INCR_W(-185),
        .HEAD_INCR_H(-179),
        .TAIL_INCR_W(3),
        .TAIL_INCR_H(9),
        .TAIL_INCR_LAST(188),
        .INCR_BITWIDTH(9),
        .IS_DEPTHWISE(0),
        .INNERMOST_STATE(swg::STATE_LOOP_SIMD)
    )
    controller_inst (
        .clk(ap_clk),
        .rst_n(ap_rst_n),
        .advance(advance_controller),
        .addr_incr(addr_incr),
        .tail_incr(tail_incr)
    );

    // Counters/address registers
    // Add a sign bit even to (most) unsigned counters and Window_buffer_read_addr_reg,
    // so we can use automatic sign extension and simplify calculations w/ signed increment.
    // Alternatively, we could manually sign-extend and shave off a bit here or there.
    logic signed [$clog2(LAST_READ_ELEM+1)+1-1:0]  Newest_buffered_elem = -1;
    logic        [$clog2(LAST_READ_ELEM+1)+1-1:0]  Current_elem = 0;
    logic        [$clog2(LAST_READ_ELEM+1)+1-1:0]  First_elem_next_window = 0;
    logic        [$clog2(ELEM_PER_WINDOW)   -1:0]  Position_in_window = 0;
    logic        [$clog2(BUF_ELEM_TOTAL)+1  -1:0]  Window_buffer_read_addr_reg = 0;
    logic        [$clog2(BUF_ELEM_TOTAL)-1:0]      Window_buffer_write_addr_reg = 0;

    // Control signals/registers
    logic  Write_cmd    = 0;
    logic  Writing_done = 0;
    uwire  write_ok      = Write_cmd &&  out_V_V_TREADY;
    uwire  write_blocked = Write_cmd && !out_V_V_TREADY;

    logic  Fetching_done = 0;
    uwire  fetch_cmd = !($signed(Current_elem) > Newest_buffered_elem) && !write_blocked && !Fetching_done;

    uwire  reading_done = Newest_buffered_elem == LAST_READ_ELEM;
    uwire  read_cmd =
        !reading_done && ( // if there is still an input element left to read
            Fetching_done || ( // if fetching is done (e.g. for skipped rows at FM end due to stride)
                $signed(((Newest_buffered_elem - (BUF_ELEM_TOTAL - 1)))) < $signed(First_elem_next_window) &&
                $signed(((Newest_buffered_elem - (BUF_ELEM_TOTAL - 1)))) < $signed(Current_elem)
            ) // (over-)write to buffer if oldest buffered element will no longer be needed
        );
    uwire  read_ok      = read_cmd && in0_V_V_TVALID;

    //assign buffer control
    assign  window_buffer_write_addr = Window_buffer_write_addr_reg;
    assign  window_buffer_read_addr = Window_buffer_read_addr_reg;
    assign  window_buffer_write_enable = read_ok;
    assign  window_buffer_read_enable = fetch_cmd;
    assign  advance_controller = fetch_cmd;

    //assign I/O ports
    assign  window_buffer_in = in0_V_V_TDATA;
    assign  out_V_V_TDATA = window_buffer_out;
    assign  in0_V_V_TREADY = ap_rst_n && read_ok; //only asserted if data is available and we can store it (allowed)
    assign  out_V_V_TVALID = ap_rst_n && Write_cmd; //only asserted if we have data available and it has not been read yet (don't wait for READY from sink)

    //main process for advancing counters
    always_ff @(posedge ap_clk) begin
        if(!ap_rst_n) begin
            Newest_buffered_elem <= -1;
            Current_elem <= 0;
            First_elem_next_window <= 0;
            Position_in_window <= 0;
            Window_buffer_read_addr_reg <= 0;
            Window_buffer_write_addr_reg <= 0;
            Fetching_done <= 0;
            Write_cmd <= 0;
            Writing_done <= 0;
        end
        else begin
            if (read_ok) begin
                Window_buffer_write_addr_reg <= (Window_buffer_write_addr_reg == BUF_ELEM_TOTAL-1)? 0 : Window_buffer_write_addr_reg + 1;
                Newest_buffered_elem <= Newest_buffered_elem+1;

                if (Newest_buffered_elem == LAST_READ_ELEM-1) begin
                    Window_buffer_write_addr_reg <= 0;
                end
                //check if this is the last read cycle (reading_done will be true afterwards)
                if ((Newest_buffered_elem == LAST_READ_ELEM-1) && Writing_done) begin
                    //start processing of next FM if writing is done already (possible due to unused input elements at the tail end)
                    //todo: allow for read overlapping between feature maps (i.e., reading first elements from next FM while still writing last window of current FM)
                    Newest_buffered_elem <= -1;
                    Current_elem <= 0;
                    Window_buffer_read_addr_reg <= 0;
                    First_elem_next_window <= 0;
                    Writing_done <= 0;
                    Fetching_done <= 0;
                end
            end

            if (fetch_cmd) begin
                //count up to track which element index is about to be read from the buffer, and where it is located within the buffer
                //use increment value calculated by controller

                // absolute buffer address wrap-around
                automatic logic signed [$clog2(BUF_ELEM_TOTAL)+1:0]  ra = $signed(Window_buffer_read_addr_reg) + $signed(addr_incr);
                automatic logic signed [$clog2(BUF_ELEM_TOTAL+1):0]  ra_correct =
                    (ra >= BUF_ELEM_TOTAL)? -BUF_ELEM_TOTAL :
                    (ra <               0)?  BUF_ELEM_TOTAL : 0;
                Window_buffer_read_addr_reg <= ra + ra_correct;

                //keep track where we are within a window
                Position_in_window <= (Position_in_window != ELEM_PER_WINDOW - 1)? Position_in_window+1 : 0;

                //update first element of next window to allow buffer overwrite up until that point
                if (Position_in_window == 0)
                    First_elem_next_window <= First_elem_next_window + tail_incr;

                //check if this is the last write cycle (Writing_done will be true afterwards)
                if (Current_elem == LAST_WRITE_ELEM)
                    Fetching_done <= 1;
                else
                    Current_elem <= $signed(Current_elem) + addr_incr;

                // determine if prefetched data will be outstanding in the next cycle
                // if we fetch in this cycle -> yes
                // if we do not fetch nor write -> do not change
                // if we do not fetch but write successfully-> clear outstanding data
                Write_cmd <= fetch_cmd;
            end

            if (write_ok)
                Write_cmd <= fetch_cmd;

            if (write_ok && Fetching_done) begin
                //check if this is the last write cycle (Writing_done will be true afterwards)
                if (reading_done || (read_ok && (Newest_buffered_elem == LAST_READ_ELEM - 1))) begin
                    //start processing of next FM if reading is done already, or completes in the same cycle
                    Newest_buffered_elem <= -1;
                    Current_elem <= 0;
                    Window_buffer_read_addr_reg <= 0;
                    First_elem_next_window <= 0;
                    Fetching_done <= 0;
                end else
                    Writing_done <= 1;
            end
        end
    end

endmodule : ConvolutionInputGenerator_rtl_0_impl
//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/code_gen_ipgen_FMPadding_rtl_0_e702v3yh/axi2we.sv


/******************************************************************************
 * Copyright (C) 2022, Advanced Micro Devices, Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *  1. Redistributions of source code must retain the above copyright notice,
 *     this list of conditions and the following disclaimer.
 *
 *  2. Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *
 *  3. Neither the name of the copyright holder nor the names of its
 *     contributors may be used to endorse or promote products derived from
 *     this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION). HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * @brief	AXI-Light adapter for trivial write enable interface.
 * @author	Thomas B. Preuer <tpreusse@amd.com>
 *****************************************************************************/

module axi2we #(
	int unsigned  ADDR_BITS
)(
	//- Global Control ------------------
	input	logic  ap_clk,
	input	logic  ap_rst_n,

	//- AXI Lite ------------------------
	// Writing
	input	                 s_axilite_AWVALID,
	output	                 s_axilite_AWREADY,
	input	[ADDR_BITS-1:0]  s_axilite_AWADDR,

	input	        s_axilite_WVALID,
	output	        s_axilite_WREADY,
	input	[31:0]  s_axilite_WDATA,
	input	[ 3:0]  s_axilite_WSTRB,

	output	       s_axilite_BVALID,
	input	       s_axilite_BREADY,
	output	[1:0]  s_axilite_BRESP,

	// Reading tied to all-ones
	input	       s_axilite_ARVALID,
	output	       s_axilite_ARREADY,
	input	[ADDR_BITS-1:0]  s_axilite_ARADDR,

	output	        s_axilite_RVALID,
	input	        s_axilite_RREADY,
	output	[31:0]  s_axilite_RDATA,
	output	[ 1:0]  s_axilite_RRESP,

	// Write Enable Interface
	output	logic                  we,
	output	logic [ADDR_BITS-1:0]  wa,
	output	logic [         31:0]  wd
);

	uwire  clk = ap_clk;
	uwire  rst = !ap_rst_n;


	logic  WABusy = 0;
	logic  WDBusy = 0;
	logic [ADDR_BITS-1:0]  Addr = 'x;
	logic [         31:0]  Data = 'x;

	assign	we = WABusy && WDBusy && s_axilite_BREADY;
	assign	wa = Addr;
	assign	wd = Data;

	uwire  clr_wr = rst || we;
	always_ff @(posedge clk) begin
		if(clr_wr) begin
			WABusy <= 0;
			Addr <= 'x;
			WDBusy <= 0;
			Data <= 'x;
		end
		else begin
			if(!WABusy) begin
				WABusy <= s_axilite_AWVALID;
				Addr   <= s_axilite_AWADDR;
			end
			if(!WDBusy) begin
				WDBusy <= s_axilite_WVALID;
				Data   <= s_axilite_WDATA;
			end
		end
	end
	assign	s_axilite_AWREADY = !WABusy;
	assign	s_axilite_WREADY  = !WDBusy;
	assign	s_axilite_BVALID  = WABusy && WDBusy;
	assign	s_axilite_BRESP   = '0; // OK

	// Answer all reads with '1
	logic  RValid =  0;
	uwire  clr_rd = rst || (RValid && s_axilite_RREADY);
	always_ff @(posedge clk) begin
		if(clr_rd)        RValid <=  0;
		else if(!RValid)  RValid <= s_axilite_ARVALID;
	end
	assign	s_axilite_ARREADY = !RValid;
	assign	s_axilite_RVALID  = RValid;
	assign	s_axilite_RDATA   = '1;
	assign	s_axilite_RRESP   = '0; // OK

endmodule : axi2we
//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/vivado_stitch_proj_w5fn6zuu/finn_vivado_stitch_proj.gen/sources_1/bd/finn_design/ipshared/18e4/hdl/verilog/MVAU_hls_0_Matrix_Vector_Activate_Stream_Batch_p_ZL7threshs_12_ROM_AUTO_1R.v


// ==============================================================
// Vitis HLS - High-Level Synthesis from C, C++ and OpenCL v2022.2 (64-bit)
// Version: 2022.2
// Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.
// ==============================================================
`timescale 1 ns / 1 ps
module MVAU_hls_0_Matrix_Vector_Activate_Stream_Batch_p_ZL7threshs_12_ROM_AUTO_1R (
    address0, ce0, q0, 
    reset, clk);

parameter DataWidth = 12;
parameter AddressWidth = 4;
parameter AddressRange = 16;
 
input[AddressWidth-1:0] address0;
input ce0;
output reg[DataWidth-1:0] q0;

input reset;
input clk;

 
reg [DataWidth-1:0] rom0[0:AddressRange-1];


initial begin
     
    $readmemh("/home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/code_gen_ipgen_MVAU_hls_0_z2r2fzak/project_MVAU_hls_0/sol1/impl/ip/hdl/verilog/MVAU_hls_0_Matrix_Vector_Activate_Stream_Batch_p_ZL7threshs_12_ROM_AUTO_1R.dat", rom0);
end

  
always @(posedge clk) 
begin 
    if (ce0) 
    begin
        q0 <= rom0[address0];
    end
end


endmodule

//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/vivado_stitch_proj_w5fn6zuu/finn_vivado_stitch_proj.gen/sources_1/bd/finn_design/ip/finn_design_StreamingFIFO_rtl_8_0/synth/finn_design_StreamingFIFO_rtl_8_0.v


// (c) Copyright 1995-2026 Xilinx, Inc. All rights reserved.
// 
// This file contains confidential and proprietary information
// of Xilinx, Inc. and is protected under U.S. and
// international copyright and other intellectual property
// laws.
// 
// DISCLAIMER
// This disclaimer is not a license and does not grant any
// rights to the materials distributed herewith. Except as
// otherwise provided in a valid license issued to you by
// Xilinx, and to the maximum extent permitted by applicable
// law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
// WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
// AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
// BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
// INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
// (2) Xilinx shall not be liable (whether in contract or tort,
// including negligence, or under any other theory of
// liability) for any loss or damage of any kind or nature
// related to, arising under or in connection with these
// materials, including for any direct, or any indirect,
// special, incidental, or consequential loss or damage
// (including loss of data, profits, goodwill, or any type of
// loss or damage suffered as a result of any action brought
// by a third party) even if such damage or loss was
// reasonably foreseeable or Xilinx had been advised of the
// possibility of the same.
// 
// CRITICAL APPLICATIONS
// Xilinx products are not designed or intended to be fail-
// safe, or for use in any application requiring fail-safe
// performance, such as life-support or safety devices or
// systems, Class III medical devices, nuclear facilities,
// applications related to the deployment of airbags, or any
// other applications that could lead to death, personal
// injury, or severe property or environmental damage
// (individually and collectively, "Critical
// Applications"). Customer assumes the sole risk and
// liability of any use of Xilinx products in Critical
// Applications, subject only to applicable laws and
// regulations governing limitations on product liability.
// 
// THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
// PART OF THIS FILE AT ALL TIMES.
// 
// DO NOT MODIFY THIS FILE.


// IP VLNV: xilinx.com:module_ref:StreamingFIFO_rtl_8:1.0
// IP Revision: 1

(* X_CORE_INFO = "StreamingFIFO_rtl_8,Vivado 2022.2" *)
(* CHECK_LICENSE_TYPE = "finn_design_StreamingFIFO_rtl_8_0,StreamingFIFO_rtl_8,{}" *)
(* CORE_GENERATION_INFO = "finn_design_StreamingFIFO_rtl_8_0,StreamingFIFO_rtl_8,{x_ipProduct=Vivado 2022.2,x_ipVendor=xilinx.com,x_ipLibrary=module_ref,x_ipName=StreamingFIFO_rtl_8,x_ipVersion=1.0,x_ipCoreRevision=1,x_ipLanguage=VERILOG,x_ipSimLanguage=MIXED}" *)
(* IP_DEFINITION_SOURCE = "module_ref" *)
(* DowngradeIPIdentifiedWarnings = "yes" *)
module finn_design_StreamingFIFO_rtl_8_0 (
  ap_clk,
  ap_rst_n,
  count,
  maxcount,
  in0_V_TREADY,
  in0_V_TVALID,
  in0_V_TDATA,
  out_V_TREADY,
  out_V_TVALID,
  out_V_TDATA
);

(* X_INTERFACE_PARAMETER = "XIL_INTERFACENAME ap_clk, ASSOCIATED_RESET ap_rst_n, ASSOCIATED_BUSIF in0_V:out_V, FREQ_HZ 100000000, FREQ_TOLERANCE_HZ 0, PHASE 0.0, CLK_DOMAIN finn_design_ap_clk_0, INSERT_VIP 0" *)
(* X_INTERFACE_INFO = "xilinx.com:signal:clock:1.0 ap_clk CLK" *)
input wire ap_clk;
(* X_INTERFACE_PARAMETER = "XIL_INTERFACENAME ap_rst_n, POLARITY ACTIVE_LOW, INSERT_VIP 0" *)
(* X_INTERFACE_INFO = "xilinx.com:signal:reset:1.0 ap_rst_n RST" *)
input wire ap_rst_n;
output wire [12 : 0] count;
output wire [12 : 0] maxcount;
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 in0_V TREADY" *)
output wire in0_V_TREADY;
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 in0_V TVALID" *)
input wire in0_V_TVALID;
(* X_INTERFACE_PARAMETER = "XIL_INTERFACENAME in0_V, TDATA_NUM_BYTES 1, TDEST_WIDTH 0, TID_WIDTH 0, TUSER_WIDTH 0, HAS_TREADY 1, HAS_TSTRB 0, HAS_TKEEP 0, HAS_TLAST 0, FREQ_HZ 100000000, PHASE 0.0, CLK_DOMAIN finn_design_ap_clk_0, LAYERED_METADATA undef, INSERT_VIP 0" *)
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 in0_V TDATA" *)
input wire [7 : 0] in0_V_TDATA;
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 out_V TREADY" *)
input wire out_V_TREADY;
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 out_V TVALID" *)
output wire out_V_TVALID;
(* X_INTERFACE_PARAMETER = "XIL_INTERFACENAME out_V, TDATA_NUM_BYTES 1, TDEST_WIDTH 0, TID_WIDTH 0, TUSER_WIDTH 0, HAS_TREADY 1, HAS_TSTRB 0, HAS_TKEEP 0, HAS_TLAST 0, FREQ_HZ 100000000, PHASE 0.0, CLK_DOMAIN finn_design_ap_clk_0, LAYERED_METADATA undef, INSERT_VIP 0" *)
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 out_V TDATA" *)
output wire [7 : 0] out_V_TDATA;

  StreamingFIFO_rtl_8 inst (
    .ap_clk(ap_clk),
    .ap_rst_n(ap_rst_n),
    .count(count),
    .maxcount(maxcount),
    .in0_V_TREADY(in0_V_TREADY),
    .in0_V_TVALID(in0_V_TVALID),
    .in0_V_TDATA(in0_V_TDATA),
    .out_V_TREADY(out_V_TREADY),
    .out_V_TVALID(out_V_TVALID),
    .out_V_TDATA(out_V_TDATA)
  );
endmodule
//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/code_gen_ipgen_StreamingFIFO_rtl_6_gcub_frn/StreamingFIFO_rtl_6.v


/******************************************************************************
 * Copyright (C) 2024, Advanced Micro Devices, Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *  1. Redistributions of source code must retain the above copyright notice,
 *     this list of conditions and the following disclaimer.
 *
 *  2. Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *
 *  3. Neither the name of the copyright holder nor the names of its
 *     contributors may be used to endorse or promote products derived from
 *     this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION). HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *****************************************************************************/

module StreamingFIFO_rtl_6(
//- Global Control ------------------
(* X_INTERFACE_PARAMETER = "ASSOCIATED_BUSIF in0_V:out_V, ASSOCIATED_RESET = ap_rst_n" *)
(* X_INTERFACE_INFO = "xilinx.com:signal:clock:1.0 ap_clk CLK" *)
input   ap_clk,
(* X_INTERFACE_PARAMETER = "POLARITY ACTIVE_LOW" *)
input   ap_rst_n,

output [7:0] count,
output [7:0] maxcount,

//- AXI Stream - Input --------------
output   in0_V_TREADY,
input   in0_V_TVALID,
input  [63:0] in0_V_TDATA,

//- AXI Stream - Output --------------
input   out_V_TREADY,
output   out_V_TVALID,
output  [63:0] out_V_TDATA
);

Q_srl #(
.depth(196),
.width(64)
)
impl
(
 .clock(ap_clk),
 .reset(!ap_rst_n),
 .count(count),
 .maxcount(maxcount),
 .i_d(in0_V_TDATA),
 .i_v(in0_V_TVALID),
 .i_r(in0_V_TREADY),
 .o_d(out_V_TDATA),
 .o_v(out_V_TVALID),
 .o_r(out_V_TREADY)
);

endmodule
//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/vivado_stitch_proj_w5fn6zuu/finn_vivado_stitch_proj.gen/sources_1/bd/finn_design/ipshared/4d6a/hdl/verilog/StreamingMaxPool_hls_1_StreamingMaxPool_Precision_14u_2u_32u_ap_uint_4_0_128_s_buf_V_RAM_AUTO_1R1W.v


// ==============================================================
// Vitis HLS - High-Level Synthesis from C, C++ and OpenCL v2022.2 (64-bit)
// Version: 2022.2
// Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.
// ==============================================================
`timescale 1 ns / 1 ps
module StreamingMaxPool_hls_1_StreamingMaxPool_Precision_14u_2u_32u_ap_uint_4_0_128_s_buf_V_RAM_AUTO_1R1W (
     
    address0, ce0,
    d0, we0, 
    q0, 
     
    reset, clk);

parameter DataWidth = 4;
parameter AddressWidth = 3;
parameter AddressRange = 7;
 
input[AddressWidth-1:0] address0;
input ce0;
input[DataWidth-1:0] d0;
input we0; 
output reg[DataWidth-1:0] q0; 

input reset;
input clk;

(* ram_style = "auto"  *)reg [DataWidth-1:0] ram[0:AddressRange-1];


 





//read first
always @(posedge clk)  
begin 
    if (ce0) begin
        if (we0) 
            ram[address0] <= d0; 
        q0 <= ram[address0];

    end
end 
 
 

endmodule

//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/vivado_stitch_proj_w5fn6zuu/finn_vivado_stitch_proj.gen/sources_1/bd/finn_design/ipshared/18e4/hdl/verilog/MVAU_hls_0_Matrix_Vector_Activate_Stream_Batch_p_ZL7threshs_4_ROM_AUTO_1R.v


// ==============================================================
// Vitis HLS - High-Level Synthesis from C, C++ and OpenCL v2022.2 (64-bit)
// Version: 2022.2
// Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.
// ==============================================================
`timescale 1 ns / 1 ps
module MVAU_hls_0_Matrix_Vector_Activate_Stream_Batch_p_ZL7threshs_4_ROM_AUTO_1R (
    address0, ce0, q0, 
    reset, clk);

parameter DataWidth = 13;
parameter AddressWidth = 4;
parameter AddressRange = 16;
 
input[AddressWidth-1:0] address0;
input ce0;
output reg[DataWidth-1:0] q0;

input reset;
input clk;

 
reg [DataWidth-1:0] rom0[0:AddressRange-1];


initial begin
     
    $readmemh("/home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/code_gen_ipgen_MVAU_hls_0_z2r2fzak/project_MVAU_hls_0/sol1/impl/ip/hdl/verilog/MVAU_hls_0_Matrix_Vector_Activate_Stream_Batch_p_ZL7threshs_4_ROM_AUTO_1R.dat", rom0);
end

  
always @(posedge clk) 
begin 
    if (ce0) 
    begin
        q0 <= rom0[address0];
    end
end


endmodule

//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/code_gen_ipgen_StreamingDataWidthConverter_rtl_2_8cmmvtlt/dwc_axi.sv


/******************************************************************************
 * Copyright (C) 2023, Advanced Micro Devices, Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *  1. Redistributions of source code must retain the above copyright notice,
 *     this list of conditions and the following disclaimer.
 *
 *  2. Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *
 *  3. Neither the name of the copyright holder nor the names of its
 *     contributors may be used to endorse or promote products derived from
 *     this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION). HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * @brief	AXI Stream Adapter for Data Width Converter.
 * @author	Thomas B. Preuer <tpreusse@amd.com>
 *****************************************************************************/
module dwc_axi #(
	int unsigned  IBITS,
	int unsigned  OBITS,

	localparam int unsigned  AXI_IBITS = (IBITS+7)/8 * 8,
	localparam int unsigned  AXI_OBITS = (OBITS+7)/8 * 8
)(
	//- Global Control ------------------
	input	logic  ap_clk,
	input	logic  ap_rst_n,

	//- AXI Stream - Input --------------
	output	logic  s_axis_tready,
	input	logic  s_axis_tvalid,
	input	logic [AXI_IBITS-1:0]  s_axis_tdata,

	//- AXI Stream - Output -------------
	input	logic  m_axis_tready,
	output	logic  m_axis_tvalid,
	output	logic [AXI_OBITS-1:0]  m_axis_tdata
);

	dwc #(.IBITS(IBITS), .OBITS(OBITS)) core (
		.clk(ap_clk), .rst(!ap_rst_n),
		.irdy(s_axis_tready), .ivld(s_axis_tvalid), .idat(s_axis_tdata[IBITS-1:0]),
		.ordy(m_axis_tready), .ovld(m_axis_tvalid), .odat(m_axis_tdata[OBITS-1:0])
	);
	if(OBITS < AXI_OBITS) begin
		assign	m_axis_tdata[AXI_OBITS-1:OBITS] = '0;
	end

endmodule : dwc_axi
//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/vivado_stitch_proj_w5fn6zuu/finn_vivado_stitch_proj.gen/sources_1/bd/finn_design/ipshared/fb57/hdl/verilog/MVAU_hls_1_Matrix_Vector_Activate_Stream_Batch_p_ZL7threshs_1_ROM_AUTO_1R.v


// ==============================================================
// Vitis HLS - High-Level Synthesis from C, C++ and OpenCL v2022.2 (64-bit)
// Version: 2022.2
// Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.
// ==============================================================
`timescale 1 ns / 1 ps
module MVAU_hls_1_Matrix_Vector_Activate_Stream_Batch_p_ZL7threshs_1_ROM_AUTO_1R (
    address0, ce0, q0, 
    reset, clk);

parameter DataWidth = 10;
parameter AddressWidth = 5;
parameter AddressRange = 32;
 
input[AddressWidth-1:0] address0;
input ce0;
output reg[DataWidth-1:0] q0;

input reset;
input clk;

 
reg [DataWidth-1:0] rom0[0:AddressRange-1];


initial begin
     
    $readmemh("/home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/code_gen_ipgen_MVAU_hls_1__774deg0/project_MVAU_hls_1/sol1/impl/ip/hdl/verilog/MVAU_hls_1_Matrix_Vector_Activate_Stream_Batch_p_ZL7threshs_1_ROM_AUTO_1R.dat", rom0);
end

  
always @(posedge clk) 
begin 
    if (ce0) 
    begin
        q0 <= rom0[address0];
    end
end


endmodule

//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/code_gen_ipgen_StreamingDataWidthConverter_rtl_0_dwunb9n0/StreamingDataWidthConverter_rtl_0.v


/******************************************************************************
 * Copyright (C) 2023, Advanced Micro Devices, Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *  1. Redistributions of source code must retain the above copyright notice,
 *     this list of conditions and the following disclaimer.
 *
 *  2. Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *
 *  3. Neither the name of the copyright holder nor the names of its
 *     contributors may be used to endorse or promote products derived from
 *     this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION). HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *****************************************************************************/

module StreamingDataWidthConverter_rtl_0 #(
	parameter  IBITS = 24,
	parameter  OBITS = 8,

	parameter  AXI_IBITS = (IBITS+7)/8 * 8,
	parameter  AXI_OBITS = (OBITS+7)/8 * 8
)(
	//- Global Control ------------------
	(* X_INTERFACE_INFO = "xilinx.com:signal:clock:1.0 ap_clk CLK" *)
	(* X_INTERFACE_PARAMETER = "ASSOCIATED_BUSIF in0_V:out_V, ASSOCIATED_RESET ap_rst_n" *)
	input	ap_clk,
	(* X_INTERFACE_PARAMETER = "POLARITY ACTIVE_LOW" *)
	input	ap_rst_n,

	//- AXI Stream - Input --------------
	output	in0_V_TREADY,
	input	in0_V_TVALID,
	input	[AXI_IBITS-1:0]  in0_V_TDATA,

	//- AXI Stream - Output -------------
	input	out_V_TREADY,
	output	out_V_TVALID,
	output	[AXI_OBITS-1:0]  out_V_TDATA
);

	dwc_axi #(
		.IBITS(IBITS),
		.OBITS(OBITS)
	) impl (
		.ap_clk(ap_clk),
		.ap_rst_n(ap_rst_n),
		.s_axis_tready(in0_V_TREADY),
		.s_axis_tvalid(in0_V_TVALID),
		.s_axis_tdata(in0_V_TDATA),
		.m_axis_tready(out_V_TREADY),
		.m_axis_tvalid(out_V_TVALID),
		.m_axis_tdata(out_V_TDATA)
	);

endmodule
//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/vivado_stitch_proj_w5fn6zuu/finn_vivado_stitch_proj.gen/sources_1/bd/finn_design/ipshared/fb57/hdl/verilog/MVAU_hls_1_Matrix_Vector_Activate_Stream_Batch_p_ZL7threshs_2_ROM_AUTO_1R.v


// ==============================================================
// Vitis HLS - High-Level Synthesis from C, C++ and OpenCL v2022.2 (64-bit)
// Version: 2022.2
// Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.
// ==============================================================
`timescale 1 ns / 1 ps
module MVAU_hls_1_Matrix_Vector_Activate_Stream_Batch_p_ZL7threshs_2_ROM_AUTO_1R (
    address0, ce0, q0, 
    reset, clk);

parameter DataWidth = 10;
parameter AddressWidth = 5;
parameter AddressRange = 32;
 
input[AddressWidth-1:0] address0;
input ce0;
output reg[DataWidth-1:0] q0;

input reset;
input clk;

 
reg [DataWidth-1:0] rom0[0:AddressRange-1];


initial begin
     
    $readmemh("/home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/code_gen_ipgen_MVAU_hls_1__774deg0/project_MVAU_hls_1/sol1/impl/ip/hdl/verilog/MVAU_hls_1_Matrix_Vector_Activate_Stream_Batch_p_ZL7threshs_2_ROM_AUTO_1R.dat", rom0);
end

  
always @(posedge clk) 
begin 
    if (ce0) 
    begin
        q0 <= rom0[address0];
    end
end


endmodule

//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/code_gen_ipgen_StreamingFIFO_rtl_14_df3tdjyd/StreamingFIFO_rtl_14.v


/******************************************************************************
 * Copyright (C) 2024, Advanced Micro Devices, Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *  1. Redistributions of source code must retain the above copyright notice,
 *     this list of conditions and the following disclaimer.
 *
 *  2. Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *
 *  3. Neither the name of the copyright holder nor the names of its
 *     contributors may be used to endorse or promote products derived from
 *     this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION). HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *****************************************************************************/

module StreamingFIFO_rtl_14(
//- Global Control ------------------
(* X_INTERFACE_PARAMETER = "ASSOCIATED_BUSIF in0_V:out_V, ASSOCIATED_RESET = ap_rst_n" *)
(* X_INTERFACE_INFO = "xilinx.com:signal:clock:1.0 ap_clk CLK" *)
input   ap_clk,
(* X_INTERFACE_PARAMETER = "POLARITY ACTIVE_LOW" *)
input   ap_rst_n,

output [3:0] count,
output [3:0] maxcount,

//- AXI Stream - Input --------------
output   in0_V_TREADY,
input   in0_V_TVALID,
input  [23:0] in0_V_TDATA,

//- AXI Stream - Output --------------
input   out_V_TREADY,
output   out_V_TVALID,
output  [23:0] out_V_TDATA
);

Q_srl #(
.depth(10),
.width(24)
)
impl
(
 .clock(ap_clk),
 .reset(!ap_rst_n),
 .count(count),
 .maxcount(maxcount),
 .i_d(in0_V_TDATA),
 .i_v(in0_V_TVALID),
 .i_r(in0_V_TREADY),
 .o_d(out_V_TDATA),
 .o_v(out_V_TVALID),
 .o_r(out_V_TREADY)
);

endmodule
//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/vivado_stitch_proj_w5fn6zuu/finn_vivado_stitch_proj.gen/sources_1/bd/finn_design/ipshared/4d6a/hdl/verilog/StreamingMaxPool_hls_1_StreamingMaxPool_Precision_14u_2u_32u_ap_uint_4_0_128_s.v


// ==============================================================
// RTL generated by Vitis HLS - High-Level Synthesis from C, C++ and OpenCL v2022.2 (64-bit)
// Version: 2022.2
// Copyright (C) Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.
// 
// ===========================================================

`timescale 1 ns / 1 ps 

module StreamingMaxPool_hls_1_StreamingMaxPool_Precision_14u_2u_32u_ap_uint_4_0_128_s (
        ap_clk,
        ap_rst,
        ap_start,
        ap_done,
        ap_idle,
        ap_ready,
        in0_V_TDATA,
        in0_V_TVALID,
        in0_V_TREADY,
        out_V_TDATA,
        out_V_TVALID,
        out_V_TREADY
);

parameter    ap_ST_fsm_state1 = 8'd1;
parameter    ap_ST_fsm_state2 = 8'd2;
parameter    ap_ST_fsm_state3 = 8'd4;
parameter    ap_ST_fsm_state4 = 8'd8;
parameter    ap_ST_fsm_state5 = 8'd16;
parameter    ap_ST_fsm_state6 = 8'd32;
parameter    ap_ST_fsm_state7 = 8'd64;
parameter    ap_ST_fsm_state8 = 8'd128;

input   ap_clk;
input   ap_rst;
input   ap_start;
output   ap_done;
output   ap_idle;
output   ap_ready;
input  [127:0] in0_V_TDATA;
input   in0_V_TVALID;
output   in0_V_TREADY;
output  [127:0] out_V_TDATA;
output   out_V_TVALID;
input   out_V_TREADY;

reg ap_done;
reg ap_idle;
reg ap_ready;
reg in0_V_TREADY;

(* fsm_encoding = "none" *) reg   [7:0] ap_CS_fsm;
wire    ap_CS_fsm_state1;
wire   [2:0] yp_2_fu_785_p2;
reg   [2:0] yp_2_reg_873;
wire    ap_CS_fsm_state3;
wire   [3:0] add_ln155_fu_797_p2;
reg   [3:0] add_ln155_reg_881;
wire    ap_CS_fsm_state4;
wire   [2:0] select_ln155_fu_809_p3;
reg   [2:0] select_ln155_reg_886;
wire   [0:0] icmp_ln155_fu_791_p2;
wire   [2:0] add_ln156_fu_853_p2;
reg   [2:0] add_ln156_reg_1051;
wire   [3:0] buf_V_q0;
reg   [3:0] buf_V_load_reg_1056;
wire    ap_CS_fsm_state5;
wire   [3:0] buf_V_1_q0;
reg   [3:0] buf_V_1_load_reg_1061;
wire   [3:0] buf_V_2_q0;
reg   [3:0] buf_V_2_load_reg_1066;
wire   [3:0] buf_V_3_q0;
reg   [3:0] buf_V_3_load_reg_1071;
wire   [3:0] buf_V_4_q0;
reg   [3:0] buf_V_4_load_reg_1076;
wire   [3:0] buf_V_5_q0;
reg   [3:0] buf_V_5_load_reg_1081;
wire   [3:0] buf_V_6_q0;
reg   [3:0] buf_V_6_load_reg_1086;
wire   [3:0] buf_V_7_q0;
reg   [3:0] buf_V_7_load_reg_1091;
wire   [3:0] buf_V_8_q0;
reg   [3:0] buf_V_8_load_reg_1096;
wire   [3:0] buf_V_9_q0;
reg   [3:0] buf_V_9_load_reg_1101;
wire   [3:0] buf_V_10_q0;
reg   [3:0] buf_V_10_load_reg_1106;
wire   [3:0] buf_V_11_q0;
reg   [3:0] buf_V_11_load_reg_1111;
wire   [3:0] buf_V_12_q0;
reg   [3:0] buf_V_12_load_reg_1116;
wire   [3:0] buf_V_13_q0;
reg   [3:0] buf_V_13_load_reg_1121;
wire   [3:0] buf_V_14_q0;
reg   [3:0] buf_V_14_load_reg_1126;
wire   [3:0] buf_V_15_q0;
reg   [3:0] buf_V_15_load_reg_1131;
wire   [3:0] buf_V_16_q0;
reg   [3:0] buf_V_16_load_reg_1136;
wire   [3:0] buf_V_17_q0;
reg   [3:0] buf_V_17_load_reg_1141;
wire   [3:0] buf_V_18_q0;
reg   [3:0] buf_V_18_load_reg_1146;
wire   [3:0] buf_V_19_q0;
reg   [3:0] buf_V_19_load_reg_1151;
wire   [3:0] buf_V_20_q0;
reg   [3:0] buf_V_20_load_reg_1156;
wire   [3:0] buf_V_21_q0;
reg   [3:0] buf_V_21_load_reg_1161;
wire   [3:0] buf_V_22_q0;
reg   [3:0] buf_V_22_load_reg_1166;
wire   [3:0] buf_V_23_q0;
reg   [3:0] buf_V_23_load_reg_1171;
wire   [3:0] buf_V_24_q0;
reg   [3:0] buf_V_24_load_reg_1176;
wire   [3:0] buf_V_25_q0;
reg   [3:0] buf_V_25_load_reg_1181;
wire   [3:0] buf_V_26_q0;
reg   [3:0] buf_V_26_load_reg_1186;
wire   [3:0] buf_V_27_q0;
reg   [3:0] buf_V_27_load_reg_1191;
wire   [3:0] buf_V_28_q0;
reg   [3:0] buf_V_28_load_reg_1196;
wire   [3:0] buf_V_29_q0;
reg   [3:0] buf_V_29_load_reg_1201;
wire   [3:0] buf_V_30_q0;
reg   [3:0] buf_V_30_load_reg_1206;
wire   [3:0] buf_V_31_q0;
reg   [3:0] buf_V_31_load_reg_1211;
reg   [2:0] buf_V_address0;
reg    buf_V_ce0;
reg    buf_V_we0;
reg   [3:0] buf_V_d0;
reg   [2:0] buf_V_1_address0;
reg    buf_V_1_ce0;
reg    buf_V_1_we0;
reg   [3:0] buf_V_1_d0;
reg   [2:0] buf_V_2_address0;
reg    buf_V_2_ce0;
reg    buf_V_2_we0;
reg   [3:0] buf_V_2_d0;
reg   [2:0] buf_V_3_address0;
reg    buf_V_3_ce0;
reg    buf_V_3_we0;
reg   [3:0] buf_V_3_d0;
reg   [2:0] buf_V_4_address0;
reg    buf_V_4_ce0;
reg    buf_V_4_we0;
reg   [3:0] buf_V_4_d0;
reg   [2:0] buf_V_5_address0;
reg    buf_V_5_ce0;
reg    buf_V_5_we0;
reg   [3:0] buf_V_5_d0;
reg   [2:0] buf_V_6_address0;
reg    buf_V_6_ce0;
reg    buf_V_6_we0;
reg   [3:0] buf_V_6_d0;
reg   [2:0] buf_V_7_address0;
reg    buf_V_7_ce0;
reg    buf_V_7_we0;
reg   [3:0] buf_V_7_d0;
reg   [2:0] buf_V_8_address0;
reg    buf_V_8_ce0;
reg    buf_V_8_we0;
reg   [3:0] buf_V_8_d0;
reg   [2:0] buf_V_9_address0;
reg    buf_V_9_ce0;
reg    buf_V_9_we0;
reg   [3:0] buf_V_9_d0;
reg   [2:0] buf_V_10_address0;
reg    buf_V_10_ce0;
reg    buf_V_10_we0;
reg   [3:0] buf_V_10_d0;
reg   [2:0] buf_V_11_address0;
reg    buf_V_11_ce0;
reg    buf_V_11_we0;
reg   [3:0] buf_V_11_d0;
reg   [2:0] buf_V_12_address0;
reg    buf_V_12_ce0;
reg    buf_V_12_we0;
reg   [3:0] buf_V_12_d0;
reg   [2:0] buf_V_13_address0;
reg    buf_V_13_ce0;
reg    buf_V_13_we0;
reg   [3:0] buf_V_13_d0;
reg   [2:0] buf_V_14_address0;
reg    buf_V_14_ce0;
reg    buf_V_14_we0;
reg   [3:0] buf_V_14_d0;
reg   [2:0] buf_V_15_address0;
reg    buf_V_15_ce0;
reg    buf_V_15_we0;
reg   [3:0] buf_V_15_d0;
reg   [2:0] buf_V_16_address0;
reg    buf_V_16_ce0;
reg    buf_V_16_we0;
reg   [3:0] buf_V_16_d0;
reg   [2:0] buf_V_17_address0;
reg    buf_V_17_ce0;
reg    buf_V_17_we0;
reg   [3:0] buf_V_17_d0;
reg   [2:0] buf_V_18_address0;
reg    buf_V_18_ce0;
reg    buf_V_18_we0;
reg   [3:0] buf_V_18_d0;
reg   [2:0] buf_V_19_address0;
reg    buf_V_19_ce0;
reg    buf_V_19_we0;
reg   [3:0] buf_V_19_d0;
reg   [2:0] buf_V_20_address0;
reg    buf_V_20_ce0;
reg    buf_V_20_we0;
reg   [3:0] buf_V_20_d0;
reg   [2:0] buf_V_21_address0;
reg    buf_V_21_ce0;
reg    buf_V_21_we0;
reg   [3:0] buf_V_21_d0;
reg   [2:0] buf_V_22_address0;
reg    buf_V_22_ce0;
reg    buf_V_22_we0;
reg   [3:0] buf_V_22_d0;
reg   [2:0] buf_V_23_address0;
reg    buf_V_23_ce0;
reg    buf_V_23_we0;
reg   [3:0] buf_V_23_d0;
reg   [2:0] buf_V_24_address0;
reg    buf_V_24_ce0;
reg    buf_V_24_we0;
reg   [3:0] buf_V_24_d0;
reg   [2:0] buf_V_25_address0;
reg    buf_V_25_ce0;
reg    buf_V_25_we0;
reg   [3:0] buf_V_25_d0;
reg   [2:0] buf_V_26_address0;
reg    buf_V_26_ce0;
reg    buf_V_26_we0;
reg   [3:0] buf_V_26_d0;
reg   [2:0] buf_V_27_address0;
reg    buf_V_27_ce0;
reg    buf_V_27_we0;
reg   [3:0] buf_V_27_d0;
reg   [2:0] buf_V_28_address0;
reg    buf_V_28_ce0;
reg    buf_V_28_we0;
reg   [3:0] buf_V_28_d0;
reg   [2:0] buf_V_29_address0;
reg    buf_V_29_ce0;
reg    buf_V_29_we0;
reg   [3:0] buf_V_29_d0;
reg   [2:0] buf_V_30_address0;
reg    buf_V_30_ce0;
reg    buf_V_30_we0;
reg   [3:0] buf_V_30_d0;
reg   [2:0] buf_V_31_address0;
reg    buf_V_31_ce0;
reg    buf_V_31_we0;
reg   [3:0] buf_V_31_d0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_ap_start;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_ap_done;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_ap_idle;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_ap_ready;
wire   [2:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_address0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_ce0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_we0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_d0;
wire   [2:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_1_address0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_1_ce0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_1_we0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_1_d0;
wire   [2:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_2_address0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_2_ce0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_2_we0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_2_d0;
wire   [2:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_3_address0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_3_ce0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_3_we0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_3_d0;
wire   [2:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_4_address0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_4_ce0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_4_we0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_4_d0;
wire   [2:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_5_address0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_5_ce0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_5_we0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_5_d0;
wire   [2:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_6_address0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_6_ce0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_6_we0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_6_d0;
wire   [2:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_7_address0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_7_ce0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_7_we0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_7_d0;
wire   [2:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_8_address0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_8_ce0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_8_we0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_8_d0;
wire   [2:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_9_address0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_9_ce0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_9_we0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_9_d0;
wire   [2:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_10_address0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_10_ce0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_10_we0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_10_d0;
wire   [2:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_11_address0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_11_ce0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_11_we0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_11_d0;
wire   [2:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_12_address0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_12_ce0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_12_we0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_12_d0;
wire   [2:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_13_address0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_13_ce0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_13_we0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_13_d0;
wire   [2:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_14_address0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_14_ce0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_14_we0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_14_d0;
wire   [2:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_15_address0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_15_ce0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_15_we0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_15_d0;
wire   [2:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_16_address0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_16_ce0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_16_we0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_16_d0;
wire   [2:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_17_address0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_17_ce0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_17_we0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_17_d0;
wire   [2:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_18_address0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_18_ce0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_18_we0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_18_d0;
wire   [2:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_19_address0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_19_ce0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_19_we0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_19_d0;
wire   [2:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_20_address0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_20_ce0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_20_we0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_20_d0;
wire   [2:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_21_address0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_21_ce0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_21_we0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_21_d0;
wire   [2:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_22_address0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_22_ce0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_22_we0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_22_d0;
wire   [2:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_23_address0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_23_ce0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_23_we0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_23_d0;
wire   [2:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_24_address0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_24_ce0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_24_we0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_24_d0;
wire   [2:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_25_address0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_25_ce0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_25_we0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_25_d0;
wire   [2:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_26_address0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_26_ce0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_26_we0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_26_d0;
wire   [2:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_27_address0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_27_ce0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_27_we0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_27_d0;
wire   [2:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_28_address0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_28_ce0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_28_we0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_28_d0;
wire   [2:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_29_address0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_29_ce0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_29_we0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_29_d0;
wire   [2:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_30_address0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_30_ce0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_30_we0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_30_d0;
wire   [2:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_31_address0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_31_ce0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_31_we0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_31_d0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_ap_start;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_ap_done;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_ap_idle;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_ap_ready;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_out_V_TREADY;
wire   [2:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_address0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_ce0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_we0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_d0;
wire   [2:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_1_address0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_1_ce0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_1_we0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_1_d0;
wire   [2:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_2_address0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_2_ce0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_2_we0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_2_d0;
wire   [2:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_3_address0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_3_ce0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_3_we0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_3_d0;
wire   [2:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_4_address0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_4_ce0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_4_we0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_4_d0;
wire   [2:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_5_address0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_5_ce0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_5_we0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_5_d0;
wire   [2:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_6_address0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_6_ce0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_6_we0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_6_d0;
wire   [2:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_7_address0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_7_ce0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_7_we0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_7_d0;
wire   [2:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_8_address0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_8_ce0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_8_we0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_8_d0;
wire   [2:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_9_address0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_9_ce0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_9_we0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_9_d0;
wire   [2:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_10_address0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_10_ce0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_10_we0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_10_d0;
wire   [2:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_11_address0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_11_ce0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_11_we0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_11_d0;
wire   [2:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_12_address0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_12_ce0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_12_we0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_12_d0;
wire   [2:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_13_address0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_13_ce0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_13_we0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_13_d0;
wire   [2:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_14_address0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_14_ce0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_14_we0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_14_d0;
wire   [2:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_15_address0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_15_ce0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_15_we0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_15_d0;
wire   [2:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_16_address0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_16_ce0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_16_we0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_16_d0;
wire   [2:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_17_address0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_17_ce0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_17_we0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_17_d0;
wire   [2:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_18_address0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_18_ce0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_18_we0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_18_d0;
wire   [2:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_19_address0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_19_ce0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_19_we0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_19_d0;
wire   [2:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_20_address0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_20_ce0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_20_we0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_20_d0;
wire   [2:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_21_address0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_21_ce0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_21_we0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_21_d0;
wire   [2:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_22_address0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_22_ce0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_22_we0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_22_d0;
wire   [2:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_23_address0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_23_ce0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_23_we0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_23_d0;
wire   [2:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_24_address0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_24_ce0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_24_we0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_24_d0;
wire   [2:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_25_address0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_25_ce0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_25_we0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_25_d0;
wire   [2:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_26_address0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_26_ce0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_26_we0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_26_d0;
wire   [2:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_27_address0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_27_ce0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_27_we0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_27_d0;
wire   [2:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_28_address0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_28_ce0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_28_we0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_28_d0;
wire   [2:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_29_address0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_29_ce0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_29_we0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_29_d0;
wire   [2:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_30_address0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_30_ce0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_30_we0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_30_d0;
wire   [2:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_31_address0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_31_ce0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_31_we0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_31_d0;
wire   [127:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_out_V_TDATA;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_out_V_TVALID;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_ap_start;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_ap_done;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_ap_idle;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_ap_ready;
wire   [2:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_31_address0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_31_ce0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_31_we0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_31_d0;
wire   [2:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_30_address0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_30_ce0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_30_we0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_30_d0;
wire   [2:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_29_address0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_29_ce0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_29_we0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_29_d0;
wire   [2:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_28_address0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_28_ce0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_28_we0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_28_d0;
wire   [2:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_27_address0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_27_ce0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_27_we0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_27_d0;
wire   [2:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_26_address0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_26_ce0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_26_we0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_26_d0;
wire   [2:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_25_address0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_25_ce0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_25_we0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_25_d0;
wire   [2:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_24_address0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_24_ce0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_24_we0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_24_d0;
wire   [2:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_23_address0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_23_ce0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_23_we0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_23_d0;
wire   [2:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_22_address0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_22_ce0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_22_we0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_22_d0;
wire   [2:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_21_address0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_21_ce0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_21_we0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_21_d0;
wire   [2:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_20_address0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_20_ce0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_20_we0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_20_d0;
wire   [2:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_19_address0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_19_ce0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_19_we0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_19_d0;
wire   [2:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_18_address0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_18_ce0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_18_we0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_18_d0;
wire   [2:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_17_address0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_17_ce0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_17_we0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_17_d0;
wire   [2:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_16_address0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_16_ce0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_16_we0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_16_d0;
wire   [2:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_15_address0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_15_ce0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_15_we0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_15_d0;
wire   [2:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_14_address0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_14_ce0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_14_we0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_14_d0;
wire   [2:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_13_address0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_13_ce0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_13_we0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_13_d0;
wire   [2:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_12_address0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_12_ce0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_12_we0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_12_d0;
wire   [2:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_11_address0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_11_ce0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_11_we0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_11_d0;
wire   [2:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_10_address0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_10_ce0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_10_we0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_10_d0;
wire   [2:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_9_address0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_9_ce0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_9_we0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_9_d0;
wire   [2:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_8_address0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_8_ce0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_8_we0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_8_d0;
wire   [2:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_7_address0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_7_ce0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_7_we0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_7_d0;
wire   [2:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_6_address0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_6_ce0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_6_we0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_6_d0;
wire   [2:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_5_address0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_5_ce0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_5_we0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_5_d0;
wire   [2:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_4_address0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_4_ce0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_4_we0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_4_d0;
wire   [2:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_3_address0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_3_ce0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_3_we0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_3_d0;
wire   [2:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_2_address0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_2_ce0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_2_we0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_2_d0;
wire   [2:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_1_address0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_1_ce0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_1_we0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_1_d0;
wire   [2:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_address0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_ce0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_we0;
wire   [3:0] grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_d0;
wire    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_in0_V_TREADY;
reg   [3:0] indvar_flatten_reg_572;
wire   [0:0] icmp_ln154_fu_779_p2;
wire    ap_CS_fsm_state7;
reg   [2:0] xp_reg_583;
reg    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_ap_start_reg;
wire    ap_CS_fsm_state2;
reg    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_ap_start_reg;
wire    ap_CS_fsm_state8;
reg    grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_ap_start_reg;
wire    ap_CS_fsm_state6;
wire   [63:0] zext_ln156_fu_817_p1;
reg   [2:0] yp_fu_56;
wire   [0:0] icmp_ln156_fu_803_p2;
reg   [7:0] ap_NS_fsm;
reg    ap_ST_fsm_state1_blk;
reg    ap_ST_fsm_state2_blk;
wire    ap_ST_fsm_state3_blk;
wire    ap_ST_fsm_state4_blk;
wire    ap_ST_fsm_state5_blk;
wire    ap_ST_fsm_state6_blk;
reg    ap_ST_fsm_state7_blk;
reg    ap_ST_fsm_state8_blk;
wire    ap_ce_reg;

// power-on initialization
initial begin
#0 ap_CS_fsm = 8'd1;
#0 grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_ap_start_reg = 1'b0;
#0 grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_ap_start_reg = 1'b0;
#0 grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_ap_start_reg = 1'b0;
end

StreamingMaxPool_hls_1_StreamingMaxPool_Precision_14u_2u_32u_ap_uint_4_0_128_s_buf_V_RAM_AUTO_1R1W #(
    .DataWidth( 4 ),
    .AddressRange( 7 ),
    .AddressWidth( 3 ))
buf_V_U(
    .clk(ap_clk),
    .reset(ap_rst),
    .address0(buf_V_address0),
    .ce0(buf_V_ce0),
    .we0(buf_V_we0),
    .d0(buf_V_d0),
    .q0(buf_V_q0)
);

StreamingMaxPool_hls_1_StreamingMaxPool_Precision_14u_2u_32u_ap_uint_4_0_128_s_buf_V_RAM_AUTO_1R1W #(
    .DataWidth( 4 ),
    .AddressRange( 7 ),
    .AddressWidth( 3 ))
buf_V_1_U(
    .clk(ap_clk),
    .reset(ap_rst),
    .address0(buf_V_1_address0),
    .ce0(buf_V_1_ce0),
    .we0(buf_V_1_we0),
    .d0(buf_V_1_d0),
    .q0(buf_V_1_q0)
);

StreamingMaxPool_hls_1_StreamingMaxPool_Precision_14u_2u_32u_ap_uint_4_0_128_s_buf_V_RAM_AUTO_1R1W #(
    .DataWidth( 4 ),
    .AddressRange( 7 ),
    .AddressWidth( 3 ))
buf_V_2_U(
    .clk(ap_clk),
    .reset(ap_rst),
    .address0(buf_V_2_address0),
    .ce0(buf_V_2_ce0),
    .we0(buf_V_2_we0),
    .d0(buf_V_2_d0),
    .q0(buf_V_2_q0)
);

StreamingMaxPool_hls_1_StreamingMaxPool_Precision_14u_2u_32u_ap_uint_4_0_128_s_buf_V_RAM_AUTO_1R1W #(
    .DataWidth( 4 ),
    .AddressRange( 7 ),
    .AddressWidth( 3 ))
buf_V_3_U(
    .clk(ap_clk),
    .reset(ap_rst),
    .address0(buf_V_3_address0),
    .ce0(buf_V_3_ce0),
    .we0(buf_V_3_we0),
    .d0(buf_V_3_d0),
    .q0(buf_V_3_q0)
);

StreamingMaxPool_hls_1_StreamingMaxPool_Precision_14u_2u_32u_ap_uint_4_0_128_s_buf_V_RAM_AUTO_1R1W #(
    .DataWidth( 4 ),
    .AddressRange( 7 ),
    .AddressWidth( 3 ))
buf_V_4_U(
    .clk(ap_clk),
    .reset(ap_rst),
    .address0(buf_V_4_address0),
    .ce0(buf_V_4_ce0),
    .we0(buf_V_4_we0),
    .d0(buf_V_4_d0),
    .q0(buf_V_4_q0)
);

StreamingMaxPool_hls_1_StreamingMaxPool_Precision_14u_2u_32u_ap_uint_4_0_128_s_buf_V_RAM_AUTO_1R1W #(
    .DataWidth( 4 ),
    .AddressRange( 7 ),
    .AddressWidth( 3 ))
buf_V_5_U(
    .clk(ap_clk),
    .reset(ap_rst),
    .address0(buf_V_5_address0),
    .ce0(buf_V_5_ce0),
    .we0(buf_V_5_we0),
    .d0(buf_V_5_d0),
    .q0(buf_V_5_q0)
);

StreamingMaxPool_hls_1_StreamingMaxPool_Precision_14u_2u_32u_ap_uint_4_0_128_s_buf_V_RAM_AUTO_1R1W #(
    .DataWidth( 4 ),
    .AddressRange( 7 ),
    .AddressWidth( 3 ))
buf_V_6_U(
    .clk(ap_clk),
    .reset(ap_rst),
    .address0(buf_V_6_address0),
    .ce0(buf_V_6_ce0),
    .we0(buf_V_6_we0),
    .d0(buf_V_6_d0),
    .q0(buf_V_6_q0)
);

StreamingMaxPool_hls_1_StreamingMaxPool_Precision_14u_2u_32u_ap_uint_4_0_128_s_buf_V_RAM_AUTO_1R1W #(
    .DataWidth( 4 ),
    .AddressRange( 7 ),
    .AddressWidth( 3 ))
buf_V_7_U(
    .clk(ap_clk),
    .reset(ap_rst),
    .address0(buf_V_7_address0),
    .ce0(buf_V_7_ce0),
    .we0(buf_V_7_we0),
    .d0(buf_V_7_d0),
    .q0(buf_V_7_q0)
);

StreamingMaxPool_hls_1_StreamingMaxPool_Precision_14u_2u_32u_ap_uint_4_0_128_s_buf_V_RAM_AUTO_1R1W #(
    .DataWidth( 4 ),
    .AddressRange( 7 ),
    .AddressWidth( 3 ))
buf_V_8_U(
    .clk(ap_clk),
    .reset(ap_rst),
    .address0(buf_V_8_address0),
    .ce0(buf_V_8_ce0),
    .we0(buf_V_8_we0),
    .d0(buf_V_8_d0),
    .q0(buf_V_8_q0)
);

StreamingMaxPool_hls_1_StreamingMaxPool_Precision_14u_2u_32u_ap_uint_4_0_128_s_buf_V_RAM_AUTO_1R1W #(
    .DataWidth( 4 ),
    .AddressRange( 7 ),
    .AddressWidth( 3 ))
buf_V_9_U(
    .clk(ap_clk),
    .reset(ap_rst),
    .address0(buf_V_9_address0),
    .ce0(buf_V_9_ce0),
    .we0(buf_V_9_we0),
    .d0(buf_V_9_d0),
    .q0(buf_V_9_q0)
);

StreamingMaxPool_hls_1_StreamingMaxPool_Precision_14u_2u_32u_ap_uint_4_0_128_s_buf_V_RAM_AUTO_1R1W #(
    .DataWidth( 4 ),
    .AddressRange( 7 ),
    .AddressWidth( 3 ))
buf_V_10_U(
    .clk(ap_clk),
    .reset(ap_rst),
    .address0(buf_V_10_address0),
    .ce0(buf_V_10_ce0),
    .we0(buf_V_10_we0),
    .d0(buf_V_10_d0),
    .q0(buf_V_10_q0)
);

StreamingMaxPool_hls_1_StreamingMaxPool_Precision_14u_2u_32u_ap_uint_4_0_128_s_buf_V_RAM_AUTO_1R1W #(
    .DataWidth( 4 ),
    .AddressRange( 7 ),
    .AddressWidth( 3 ))
buf_V_11_U(
    .clk(ap_clk),
    .reset(ap_rst),
    .address0(buf_V_11_address0),
    .ce0(buf_V_11_ce0),
    .we0(buf_V_11_we0),
    .d0(buf_V_11_d0),
    .q0(buf_V_11_q0)
);

StreamingMaxPool_hls_1_StreamingMaxPool_Precision_14u_2u_32u_ap_uint_4_0_128_s_buf_V_RAM_AUTO_1R1W #(
    .DataWidth( 4 ),
    .AddressRange( 7 ),
    .AddressWidth( 3 ))
buf_V_12_U(
    .clk(ap_clk),
    .reset(ap_rst),
    .address0(buf_V_12_address0),
    .ce0(buf_V_12_ce0),
    .we0(buf_V_12_we0),
    .d0(buf_V_12_d0),
    .q0(buf_V_12_q0)
);

StreamingMaxPool_hls_1_StreamingMaxPool_Precision_14u_2u_32u_ap_uint_4_0_128_s_buf_V_RAM_AUTO_1R1W #(
    .DataWidth( 4 ),
    .AddressRange( 7 ),
    .AddressWidth( 3 ))
buf_V_13_U(
    .clk(ap_clk),
    .reset(ap_rst),
    .address0(buf_V_13_address0),
    .ce0(buf_V_13_ce0),
    .we0(buf_V_13_we0),
    .d0(buf_V_13_d0),
    .q0(buf_V_13_q0)
);

StreamingMaxPool_hls_1_StreamingMaxPool_Precision_14u_2u_32u_ap_uint_4_0_128_s_buf_V_RAM_AUTO_1R1W #(
    .DataWidth( 4 ),
    .AddressRange( 7 ),
    .AddressWidth( 3 ))
buf_V_14_U(
    .clk(ap_clk),
    .reset(ap_rst),
    .address0(buf_V_14_address0),
    .ce0(buf_V_14_ce0),
    .we0(buf_V_14_we0),
    .d0(buf_V_14_d0),
    .q0(buf_V_14_q0)
);

StreamingMaxPool_hls_1_StreamingMaxPool_Precision_14u_2u_32u_ap_uint_4_0_128_s_buf_V_RAM_AUTO_1R1W #(
    .DataWidth( 4 ),
    .AddressRange( 7 ),
    .AddressWidth( 3 ))
buf_V_15_U(
    .clk(ap_clk),
    .reset(ap_rst),
    .address0(buf_V_15_address0),
    .ce0(buf_V_15_ce0),
    .we0(buf_V_15_we0),
    .d0(buf_V_15_d0),
    .q0(buf_V_15_q0)
);

StreamingMaxPool_hls_1_StreamingMaxPool_Precision_14u_2u_32u_ap_uint_4_0_128_s_buf_V_RAM_AUTO_1R1W #(
    .DataWidth( 4 ),
    .AddressRange( 7 ),
    .AddressWidth( 3 ))
buf_V_16_U(
    .clk(ap_clk),
    .reset(ap_rst),
    .address0(buf_V_16_address0),
    .ce0(buf_V_16_ce0),
    .we0(buf_V_16_we0),
    .d0(buf_V_16_d0),
    .q0(buf_V_16_q0)
);

StreamingMaxPool_hls_1_StreamingMaxPool_Precision_14u_2u_32u_ap_uint_4_0_128_s_buf_V_RAM_AUTO_1R1W #(
    .DataWidth( 4 ),
    .AddressRange( 7 ),
    .AddressWidth( 3 ))
buf_V_17_U(
    .clk(ap_clk),
    .reset(ap_rst),
    .address0(buf_V_17_address0),
    .ce0(buf_V_17_ce0),
    .we0(buf_V_17_we0),
    .d0(buf_V_17_d0),
    .q0(buf_V_17_q0)
);

StreamingMaxPool_hls_1_StreamingMaxPool_Precision_14u_2u_32u_ap_uint_4_0_128_s_buf_V_RAM_AUTO_1R1W #(
    .DataWidth( 4 ),
    .AddressRange( 7 ),
    .AddressWidth( 3 ))
buf_V_18_U(
    .clk(ap_clk),
    .reset(ap_rst),
    .address0(buf_V_18_address0),
    .ce0(buf_V_18_ce0),
    .we0(buf_V_18_we0),
    .d0(buf_V_18_d0),
    .q0(buf_V_18_q0)
);

StreamingMaxPool_hls_1_StreamingMaxPool_Precision_14u_2u_32u_ap_uint_4_0_128_s_buf_V_RAM_AUTO_1R1W #(
    .DataWidth( 4 ),
    .AddressRange( 7 ),
    .AddressWidth( 3 ))
buf_V_19_U(
    .clk(ap_clk),
    .reset(ap_rst),
    .address0(buf_V_19_address0),
    .ce0(buf_V_19_ce0),
    .we0(buf_V_19_we0),
    .d0(buf_V_19_d0),
    .q0(buf_V_19_q0)
);

StreamingMaxPool_hls_1_StreamingMaxPool_Precision_14u_2u_32u_ap_uint_4_0_128_s_buf_V_RAM_AUTO_1R1W #(
    .DataWidth( 4 ),
    .AddressRange( 7 ),
    .AddressWidth( 3 ))
buf_V_20_U(
    .clk(ap_clk),
    .reset(ap_rst),
    .address0(buf_V_20_address0),
    .ce0(buf_V_20_ce0),
    .we0(buf_V_20_we0),
    .d0(buf_V_20_d0),
    .q0(buf_V_20_q0)
);

StreamingMaxPool_hls_1_StreamingMaxPool_Precision_14u_2u_32u_ap_uint_4_0_128_s_buf_V_RAM_AUTO_1R1W #(
    .DataWidth( 4 ),
    .AddressRange( 7 ),
    .AddressWidth( 3 ))
buf_V_21_U(
    .clk(ap_clk),
    .reset(ap_rst),
    .address0(buf_V_21_address0),
    .ce0(buf_V_21_ce0),
    .we0(buf_V_21_we0),
    .d0(buf_V_21_d0),
    .q0(buf_V_21_q0)
);

StreamingMaxPool_hls_1_StreamingMaxPool_Precision_14u_2u_32u_ap_uint_4_0_128_s_buf_V_RAM_AUTO_1R1W #(
    .DataWidth( 4 ),
    .AddressRange( 7 ),
    .AddressWidth( 3 ))
buf_V_22_U(
    .clk(ap_clk),
    .reset(ap_rst),
    .address0(buf_V_22_address0),
    .ce0(buf_V_22_ce0),
    .we0(buf_V_22_we0),
    .d0(buf_V_22_d0),
    .q0(buf_V_22_q0)
);

StreamingMaxPool_hls_1_StreamingMaxPool_Precision_14u_2u_32u_ap_uint_4_0_128_s_buf_V_RAM_AUTO_1R1W #(
    .DataWidth( 4 ),
    .AddressRange( 7 ),
    .AddressWidth( 3 ))
buf_V_23_U(
    .clk(ap_clk),
    .reset(ap_rst),
    .address0(buf_V_23_address0),
    .ce0(buf_V_23_ce0),
    .we0(buf_V_23_we0),
    .d0(buf_V_23_d0),
    .q0(buf_V_23_q0)
);

StreamingMaxPool_hls_1_StreamingMaxPool_Precision_14u_2u_32u_ap_uint_4_0_128_s_buf_V_RAM_AUTO_1R1W #(
    .DataWidth( 4 ),
    .AddressRange( 7 ),
    .AddressWidth( 3 ))
buf_V_24_U(
    .clk(ap_clk),
    .reset(ap_rst),
    .address0(buf_V_24_address0),
    .ce0(buf_V_24_ce0),
    .we0(buf_V_24_we0),
    .d0(buf_V_24_d0),
    .q0(buf_V_24_q0)
);

StreamingMaxPool_hls_1_StreamingMaxPool_Precision_14u_2u_32u_ap_uint_4_0_128_s_buf_V_RAM_AUTO_1R1W #(
    .DataWidth( 4 ),
    .AddressRange( 7 ),
    .AddressWidth( 3 ))
buf_V_25_U(
    .clk(ap_clk),
    .reset(ap_rst),
    .address0(buf_V_25_address0),
    .ce0(buf_V_25_ce0),
    .we0(buf_V_25_we0),
    .d0(buf_V_25_d0),
    .q0(buf_V_25_q0)
);

StreamingMaxPool_hls_1_StreamingMaxPool_Precision_14u_2u_32u_ap_uint_4_0_128_s_buf_V_RAM_AUTO_1R1W #(
    .DataWidth( 4 ),
    .AddressRange( 7 ),
    .AddressWidth( 3 ))
buf_V_26_U(
    .clk(ap_clk),
    .reset(ap_rst),
    .address0(buf_V_26_address0),
    .ce0(buf_V_26_ce0),
    .we0(buf_V_26_we0),
    .d0(buf_V_26_d0),
    .q0(buf_V_26_q0)
);

StreamingMaxPool_hls_1_StreamingMaxPool_Precision_14u_2u_32u_ap_uint_4_0_128_s_buf_V_RAM_AUTO_1R1W #(
    .DataWidth( 4 ),
    .AddressRange( 7 ),
    .AddressWidth( 3 ))
buf_V_27_U(
    .clk(ap_clk),
    .reset(ap_rst),
    .address0(buf_V_27_address0),
    .ce0(buf_V_27_ce0),
    .we0(buf_V_27_we0),
    .d0(buf_V_27_d0),
    .q0(buf_V_27_q0)
);

StreamingMaxPool_hls_1_StreamingMaxPool_Precision_14u_2u_32u_ap_uint_4_0_128_s_buf_V_RAM_AUTO_1R1W #(
    .DataWidth( 4 ),
    .AddressRange( 7 ),
    .AddressWidth( 3 ))
buf_V_28_U(
    .clk(ap_clk),
    .reset(ap_rst),
    .address0(buf_V_28_address0),
    .ce0(buf_V_28_ce0),
    .we0(buf_V_28_we0),
    .d0(buf_V_28_d0),
    .q0(buf_V_28_q0)
);

StreamingMaxPool_hls_1_StreamingMaxPool_Precision_14u_2u_32u_ap_uint_4_0_128_s_buf_V_RAM_AUTO_1R1W #(
    .DataWidth( 4 ),
    .AddressRange( 7 ),
    .AddressWidth( 3 ))
buf_V_29_U(
    .clk(ap_clk),
    .reset(ap_rst),
    .address0(buf_V_29_address0),
    .ce0(buf_V_29_ce0),
    .we0(buf_V_29_we0),
    .d0(buf_V_29_d0),
    .q0(buf_V_29_q0)
);

StreamingMaxPool_hls_1_StreamingMaxPool_Precision_14u_2u_32u_ap_uint_4_0_128_s_buf_V_RAM_AUTO_1R1W #(
    .DataWidth( 4 ),
    .AddressRange( 7 ),
    .AddressWidth( 3 ))
buf_V_30_U(
    .clk(ap_clk),
    .reset(ap_rst),
    .address0(buf_V_30_address0),
    .ce0(buf_V_30_ce0),
    .we0(buf_V_30_we0),
    .d0(buf_V_30_d0),
    .q0(buf_V_30_q0)
);

StreamingMaxPool_hls_1_StreamingMaxPool_Precision_14u_2u_32u_ap_uint_4_0_128_s_buf_V_RAM_AUTO_1R1W #(
    .DataWidth( 4 ),
    .AddressRange( 7 ),
    .AddressWidth( 3 ))
buf_V_31_U(
    .clk(ap_clk),
    .reset(ap_rst),
    .address0(buf_V_31_address0),
    .ce0(buf_V_31_ce0),
    .we0(buf_V_31_we0),
    .d0(buf_V_31_d0),
    .q0(buf_V_31_q0)
);

StreamingMaxPool_hls_1_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1 grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594(
    .ap_clk(ap_clk),
    .ap_rst(ap_rst),
    .ap_start(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_ap_start),
    .ap_done(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_ap_done),
    .ap_idle(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_ap_idle),
    .ap_ready(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_ap_ready),
    .buf_V_address0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_address0),
    .buf_V_ce0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_ce0),
    .buf_V_we0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_we0),
    .buf_V_d0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_d0),
    .buf_V_1_address0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_1_address0),
    .buf_V_1_ce0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_1_ce0),
    .buf_V_1_we0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_1_we0),
    .buf_V_1_d0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_1_d0),
    .buf_V_2_address0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_2_address0),
    .buf_V_2_ce0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_2_ce0),
    .buf_V_2_we0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_2_we0),
    .buf_V_2_d0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_2_d0),
    .buf_V_3_address0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_3_address0),
    .buf_V_3_ce0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_3_ce0),
    .buf_V_3_we0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_3_we0),
    .buf_V_3_d0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_3_d0),
    .buf_V_4_address0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_4_address0),
    .buf_V_4_ce0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_4_ce0),
    .buf_V_4_we0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_4_we0),
    .buf_V_4_d0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_4_d0),
    .buf_V_5_address0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_5_address0),
    .buf_V_5_ce0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_5_ce0),
    .buf_V_5_we0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_5_we0),
    .buf_V_5_d0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_5_d0),
    .buf_V_6_address0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_6_address0),
    .buf_V_6_ce0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_6_ce0),
    .buf_V_6_we0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_6_we0),
    .buf_V_6_d0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_6_d0),
    .buf_V_7_address0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_7_address0),
    .buf_V_7_ce0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_7_ce0),
    .buf_V_7_we0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_7_we0),
    .buf_V_7_d0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_7_d0),
    .buf_V_8_address0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_8_address0),
    .buf_V_8_ce0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_8_ce0),
    .buf_V_8_we0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_8_we0),
    .buf_V_8_d0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_8_d0),
    .buf_V_9_address0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_9_address0),
    .buf_V_9_ce0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_9_ce0),
    .buf_V_9_we0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_9_we0),
    .buf_V_9_d0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_9_d0),
    .buf_V_10_address0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_10_address0),
    .buf_V_10_ce0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_10_ce0),
    .buf_V_10_we0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_10_we0),
    .buf_V_10_d0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_10_d0),
    .buf_V_11_address0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_11_address0),
    .buf_V_11_ce0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_11_ce0),
    .buf_V_11_we0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_11_we0),
    .buf_V_11_d0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_11_d0),
    .buf_V_12_address0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_12_address0),
    .buf_V_12_ce0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_12_ce0),
    .buf_V_12_we0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_12_we0),
    .buf_V_12_d0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_12_d0),
    .buf_V_13_address0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_13_address0),
    .buf_V_13_ce0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_13_ce0),
    .buf_V_13_we0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_13_we0),
    .buf_V_13_d0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_13_d0),
    .buf_V_14_address0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_14_address0),
    .buf_V_14_ce0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_14_ce0),
    .buf_V_14_we0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_14_we0),
    .buf_V_14_d0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_14_d0),
    .buf_V_15_address0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_15_address0),
    .buf_V_15_ce0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_15_ce0),
    .buf_V_15_we0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_15_we0),
    .buf_V_15_d0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_15_d0),
    .buf_V_16_address0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_16_address0),
    .buf_V_16_ce0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_16_ce0),
    .buf_V_16_we0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_16_we0),
    .buf_V_16_d0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_16_d0),
    .buf_V_17_address0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_17_address0),
    .buf_V_17_ce0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_17_ce0),
    .buf_V_17_we0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_17_we0),
    .buf_V_17_d0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_17_d0),
    .buf_V_18_address0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_18_address0),
    .buf_V_18_ce0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_18_ce0),
    .buf_V_18_we0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_18_we0),
    .buf_V_18_d0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_18_d0),
    .buf_V_19_address0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_19_address0),
    .buf_V_19_ce0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_19_ce0),
    .buf_V_19_we0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_19_we0),
    .buf_V_19_d0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_19_d0),
    .buf_V_20_address0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_20_address0),
    .buf_V_20_ce0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_20_ce0),
    .buf_V_20_we0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_20_we0),
    .buf_V_20_d0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_20_d0),
    .buf_V_21_address0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_21_address0),
    .buf_V_21_ce0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_21_ce0),
    .buf_V_21_we0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_21_we0),
    .buf_V_21_d0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_21_d0),
    .buf_V_22_address0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_22_address0),
    .buf_V_22_ce0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_22_ce0),
    .buf_V_22_we0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_22_we0),
    .buf_V_22_d0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_22_d0),
    .buf_V_23_address0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_23_address0),
    .buf_V_23_ce0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_23_ce0),
    .buf_V_23_we0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_23_we0),
    .buf_V_23_d0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_23_d0),
    .buf_V_24_address0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_24_address0),
    .buf_V_24_ce0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_24_ce0),
    .buf_V_24_we0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_24_we0),
    .buf_V_24_d0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_24_d0),
    .buf_V_25_address0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_25_address0),
    .buf_V_25_ce0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_25_ce0),
    .buf_V_25_we0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_25_we0),
    .buf_V_25_d0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_25_d0),
    .buf_V_26_address0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_26_address0),
    .buf_V_26_ce0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_26_ce0),
    .buf_V_26_we0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_26_we0),
    .buf_V_26_d0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_26_d0),
    .buf_V_27_address0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_27_address0),
    .buf_V_27_ce0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_27_ce0),
    .buf_V_27_we0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_27_we0),
    .buf_V_27_d0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_27_d0),
    .buf_V_28_address0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_28_address0),
    .buf_V_28_ce0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_28_ce0),
    .buf_V_28_we0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_28_we0),
    .buf_V_28_d0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_28_d0),
    .buf_V_29_address0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_29_address0),
    .buf_V_29_ce0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_29_ce0),
    .buf_V_29_we0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_29_we0),
    .buf_V_29_d0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_29_d0),
    .buf_V_30_address0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_30_address0),
    .buf_V_30_ce0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_30_ce0),
    .buf_V_30_we0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_30_we0),
    .buf_V_30_d0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_30_d0),
    .buf_V_31_address0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_31_address0),
    .buf_V_31_ce0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_31_ce0),
    .buf_V_31_we0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_31_we0),
    .buf_V_31_d0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_31_d0)
);

StreamingMaxPool_hls_1_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8 grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662(
    .ap_clk(ap_clk),
    .ap_rst(ap_rst),
    .ap_start(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_ap_start),
    .ap_done(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_ap_done),
    .ap_idle(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_ap_idle),
    .ap_ready(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_ap_ready),
    .out_V_TREADY(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_out_V_TREADY),
    .buf_V_address0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_address0),
    .buf_V_ce0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_ce0),
    .buf_V_we0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_we0),
    .buf_V_d0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_d0),
    .buf_V_q0(buf_V_q0),
    .buf_V_1_address0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_1_address0),
    .buf_V_1_ce0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_1_ce0),
    .buf_V_1_we0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_1_we0),
    .buf_V_1_d0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_1_d0),
    .buf_V_1_q0(buf_V_1_q0),
    .buf_V_2_address0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_2_address0),
    .buf_V_2_ce0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_2_ce0),
    .buf_V_2_we0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_2_we0),
    .buf_V_2_d0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_2_d0),
    .buf_V_2_q0(buf_V_2_q0),
    .buf_V_3_address0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_3_address0),
    .buf_V_3_ce0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_3_ce0),
    .buf_V_3_we0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_3_we0),
    .buf_V_3_d0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_3_d0),
    .buf_V_3_q0(buf_V_3_q0),
    .buf_V_4_address0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_4_address0),
    .buf_V_4_ce0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_4_ce0),
    .buf_V_4_we0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_4_we0),
    .buf_V_4_d0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_4_d0),
    .buf_V_4_q0(buf_V_4_q0),
    .buf_V_5_address0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_5_address0),
    .buf_V_5_ce0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_5_ce0),
    .buf_V_5_we0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_5_we0),
    .buf_V_5_d0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_5_d0),
    .buf_V_5_q0(buf_V_5_q0),
    .buf_V_6_address0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_6_address0),
    .buf_V_6_ce0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_6_ce0),
    .buf_V_6_we0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_6_we0),
    .buf_V_6_d0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_6_d0),
    .buf_V_6_q0(buf_V_6_q0),
    .buf_V_7_address0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_7_address0),
    .buf_V_7_ce0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_7_ce0),
    .buf_V_7_we0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_7_we0),
    .buf_V_7_d0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_7_d0),
    .buf_V_7_q0(buf_V_7_q0),
    .buf_V_8_address0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_8_address0),
    .buf_V_8_ce0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_8_ce0),
    .buf_V_8_we0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_8_we0),
    .buf_V_8_d0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_8_d0),
    .buf_V_8_q0(buf_V_8_q0),
    .buf_V_9_address0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_9_address0),
    .buf_V_9_ce0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_9_ce0),
    .buf_V_9_we0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_9_we0),
    .buf_V_9_d0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_9_d0),
    .buf_V_9_q0(buf_V_9_q0),
    .buf_V_10_address0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_10_address0),
    .buf_V_10_ce0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_10_ce0),
    .buf_V_10_we0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_10_we0),
    .buf_V_10_d0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_10_d0),
    .buf_V_10_q0(buf_V_10_q0),
    .buf_V_11_address0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_11_address0),
    .buf_V_11_ce0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_11_ce0),
    .buf_V_11_we0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_11_we0),
    .buf_V_11_d0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_11_d0),
    .buf_V_11_q0(buf_V_11_q0),
    .buf_V_12_address0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_12_address0),
    .buf_V_12_ce0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_12_ce0),
    .buf_V_12_we0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_12_we0),
    .buf_V_12_d0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_12_d0),
    .buf_V_12_q0(buf_V_12_q0),
    .buf_V_13_address0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_13_address0),
    .buf_V_13_ce0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_13_ce0),
    .buf_V_13_we0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_13_we0),
    .buf_V_13_d0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_13_d0),
    .buf_V_13_q0(buf_V_13_q0),
    .buf_V_14_address0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_14_address0),
    .buf_V_14_ce0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_14_ce0),
    .buf_V_14_we0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_14_we0),
    .buf_V_14_d0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_14_d0),
    .buf_V_14_q0(buf_V_14_q0),
    .buf_V_15_address0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_15_address0),
    .buf_V_15_ce0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_15_ce0),
    .buf_V_15_we0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_15_we0),
    .buf_V_15_d0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_15_d0),
    .buf_V_15_q0(buf_V_15_q0),
    .buf_V_16_address0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_16_address0),
    .buf_V_16_ce0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_16_ce0),
    .buf_V_16_we0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_16_we0),
    .buf_V_16_d0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_16_d0),
    .buf_V_16_q0(buf_V_16_q0),
    .buf_V_17_address0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_17_address0),
    .buf_V_17_ce0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_17_ce0),
    .buf_V_17_we0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_17_we0),
    .buf_V_17_d0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_17_d0),
    .buf_V_17_q0(buf_V_17_q0),
    .buf_V_18_address0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_18_address0),
    .buf_V_18_ce0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_18_ce0),
    .buf_V_18_we0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_18_we0),
    .buf_V_18_d0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_18_d0),
    .buf_V_18_q0(buf_V_18_q0),
    .buf_V_19_address0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_19_address0),
    .buf_V_19_ce0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_19_ce0),
    .buf_V_19_we0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_19_we0),
    .buf_V_19_d0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_19_d0),
    .buf_V_19_q0(buf_V_19_q0),
    .buf_V_20_address0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_20_address0),
    .buf_V_20_ce0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_20_ce0),
    .buf_V_20_we0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_20_we0),
    .buf_V_20_d0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_20_d0),
    .buf_V_20_q0(buf_V_20_q0),
    .buf_V_21_address0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_21_address0),
    .buf_V_21_ce0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_21_ce0),
    .buf_V_21_we0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_21_we0),
    .buf_V_21_d0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_21_d0),
    .buf_V_21_q0(buf_V_21_q0),
    .buf_V_22_address0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_22_address0),
    .buf_V_22_ce0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_22_ce0),
    .buf_V_22_we0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_22_we0),
    .buf_V_22_d0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_22_d0),
    .buf_V_22_q0(buf_V_22_q0),
    .buf_V_23_address0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_23_address0),
    .buf_V_23_ce0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_23_ce0),
    .buf_V_23_we0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_23_we0),
    .buf_V_23_d0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_23_d0),
    .buf_V_23_q0(buf_V_23_q0),
    .buf_V_24_address0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_24_address0),
    .buf_V_24_ce0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_24_ce0),
    .buf_V_24_we0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_24_we0),
    .buf_V_24_d0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_24_d0),
    .buf_V_24_q0(buf_V_24_q0),
    .buf_V_25_address0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_25_address0),
    .buf_V_25_ce0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_25_ce0),
    .buf_V_25_we0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_25_we0),
    .buf_V_25_d0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_25_d0),
    .buf_V_25_q0(buf_V_25_q0),
    .buf_V_26_address0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_26_address0),
    .buf_V_26_ce0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_26_ce0),
    .buf_V_26_we0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_26_we0),
    .buf_V_26_d0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_26_d0),
    .buf_V_26_q0(buf_V_26_q0),
    .buf_V_27_address0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_27_address0),
    .buf_V_27_ce0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_27_ce0),
    .buf_V_27_we0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_27_we0),
    .buf_V_27_d0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_27_d0),
    .buf_V_27_q0(buf_V_27_q0),
    .buf_V_28_address0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_28_address0),
    .buf_V_28_ce0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_28_ce0),
    .buf_V_28_we0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_28_we0),
    .buf_V_28_d0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_28_d0),
    .buf_V_28_q0(buf_V_28_q0),
    .buf_V_29_address0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_29_address0),
    .buf_V_29_ce0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_29_ce0),
    .buf_V_29_we0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_29_we0),
    .buf_V_29_d0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_29_d0),
    .buf_V_29_q0(buf_V_29_q0),
    .buf_V_30_address0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_30_address0),
    .buf_V_30_ce0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_30_ce0),
    .buf_V_30_we0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_30_we0),
    .buf_V_30_d0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_30_d0),
    .buf_V_30_q0(buf_V_30_q0),
    .buf_V_31_address0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_31_address0),
    .buf_V_31_ce0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_31_ce0),
    .buf_V_31_we0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_31_we0),
    .buf_V_31_d0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_31_d0),
    .buf_V_31_q0(buf_V_31_q0),
    .out_V_TDATA(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_out_V_TDATA),
    .out_V_TVALID(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_out_V_TVALID)
);

StreamingMaxPool_hls_1_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6 grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700(
    .ap_clk(ap_clk),
    .ap_rst(ap_rst),
    .ap_start(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_ap_start),
    .ap_done(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_ap_done),
    .ap_idle(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_ap_idle),
    .ap_ready(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_ap_ready),
    .in0_V_TVALID(in0_V_TVALID),
    .buf_V_31_load_1(buf_V_31_load_reg_1211),
    .buf_V_30_load_1(buf_V_30_load_reg_1206),
    .buf_V_29_load_1(buf_V_29_load_reg_1201),
    .buf_V_28_load_1(buf_V_28_load_reg_1196),
    .buf_V_27_load_1(buf_V_27_load_reg_1191),
    .buf_V_26_load_1(buf_V_26_load_reg_1186),
    .buf_V_25_load_1(buf_V_25_load_reg_1181),
    .buf_V_24_load_1(buf_V_24_load_reg_1176),
    .buf_V_23_load_1(buf_V_23_load_reg_1171),
    .buf_V_22_load_1(buf_V_22_load_reg_1166),
    .buf_V_21_load_1(buf_V_21_load_reg_1161),
    .buf_V_20_load_1(buf_V_20_load_reg_1156),
    .buf_V_19_load_1(buf_V_19_load_reg_1151),
    .buf_V_18_load_1(buf_V_18_load_reg_1146),
    .buf_V_17_load_1(buf_V_17_load_reg_1141),
    .buf_V_16_load_1(buf_V_16_load_reg_1136),
    .buf_V_15_load_1(buf_V_15_load_reg_1131),
    .buf_V_14_load_1(buf_V_14_load_reg_1126),
    .buf_V_13_load_1(buf_V_13_load_reg_1121),
    .buf_V_12_load_1(buf_V_12_load_reg_1116),
    .buf_V_11_load_1(buf_V_11_load_reg_1111),
    .buf_V_10_load_1(buf_V_10_load_reg_1106),
    .buf_V_9_load_1(buf_V_9_load_reg_1101),
    .buf_V_8_load_1(buf_V_8_load_reg_1096),
    .buf_V_7_load_1(buf_V_7_load_reg_1091),
    .buf_V_6_load_1(buf_V_6_load_reg_1086),
    .buf_V_5_load_1(buf_V_5_load_reg_1081),
    .buf_V_4_load_1(buf_V_4_load_reg_1076),
    .buf_V_3_load_1(buf_V_3_load_reg_1071),
    .buf_V_2_load_1(buf_V_2_load_reg_1066),
    .buf_V_1_load_1(buf_V_1_load_reg_1061),
    .buf_V_load_1(buf_V_load_reg_1056),
    .buf_V_31_address0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_31_address0),
    .buf_V_31_ce0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_31_ce0),
    .buf_V_31_we0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_31_we0),
    .buf_V_31_d0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_31_d0),
    .zext_ln156(select_ln155_reg_886),
    .buf_V_30_address0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_30_address0),
    .buf_V_30_ce0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_30_ce0),
    .buf_V_30_we0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_30_we0),
    .buf_V_30_d0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_30_d0),
    .buf_V_29_address0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_29_address0),
    .buf_V_29_ce0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_29_ce0),
    .buf_V_29_we0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_29_we0),
    .buf_V_29_d0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_29_d0),
    .buf_V_28_address0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_28_address0),
    .buf_V_28_ce0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_28_ce0),
    .buf_V_28_we0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_28_we0),
    .buf_V_28_d0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_28_d0),
    .buf_V_27_address0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_27_address0),
    .buf_V_27_ce0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_27_ce0),
    .buf_V_27_we0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_27_we0),
    .buf_V_27_d0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_27_d0),
    .buf_V_26_address0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_26_address0),
    .buf_V_26_ce0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_26_ce0),
    .buf_V_26_we0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_26_we0),
    .buf_V_26_d0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_26_d0),
    .buf_V_25_address0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_25_address0),
    .buf_V_25_ce0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_25_ce0),
    .buf_V_25_we0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_25_we0),
    .buf_V_25_d0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_25_d0),
    .buf_V_24_address0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_24_address0),
    .buf_V_24_ce0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_24_ce0),
    .buf_V_24_we0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_24_we0),
    .buf_V_24_d0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_24_d0),
    .buf_V_23_address0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_23_address0),
    .buf_V_23_ce0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_23_ce0),
    .buf_V_23_we0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_23_we0),
    .buf_V_23_d0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_23_d0),
    .buf_V_22_address0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_22_address0),
    .buf_V_22_ce0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_22_ce0),
    .buf_V_22_we0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_22_we0),
    .buf_V_22_d0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_22_d0),
    .buf_V_21_address0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_21_address0),
    .buf_V_21_ce0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_21_ce0),
    .buf_V_21_we0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_21_we0),
    .buf_V_21_d0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_21_d0),
    .buf_V_20_address0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_20_address0),
    .buf_V_20_ce0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_20_ce0),
    .buf_V_20_we0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_20_we0),
    .buf_V_20_d0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_20_d0),
    .buf_V_19_address0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_19_address0),
    .buf_V_19_ce0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_19_ce0),
    .buf_V_19_we0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_19_we0),
    .buf_V_19_d0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_19_d0),
    .buf_V_18_address0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_18_address0),
    .buf_V_18_ce0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_18_ce0),
    .buf_V_18_we0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_18_we0),
    .buf_V_18_d0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_18_d0),
    .buf_V_17_address0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_17_address0),
    .buf_V_17_ce0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_17_ce0),
    .buf_V_17_we0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_17_we0),
    .buf_V_17_d0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_17_d0),
    .buf_V_16_address0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_16_address0),
    .buf_V_16_ce0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_16_ce0),
    .buf_V_16_we0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_16_we0),
    .buf_V_16_d0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_16_d0),
    .buf_V_15_address0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_15_address0),
    .buf_V_15_ce0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_15_ce0),
    .buf_V_15_we0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_15_we0),
    .buf_V_15_d0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_15_d0),
    .buf_V_14_address0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_14_address0),
    .buf_V_14_ce0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_14_ce0),
    .buf_V_14_we0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_14_we0),
    .buf_V_14_d0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_14_d0),
    .buf_V_13_address0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_13_address0),
    .buf_V_13_ce0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_13_ce0),
    .buf_V_13_we0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_13_we0),
    .buf_V_13_d0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_13_d0),
    .buf_V_12_address0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_12_address0),
    .buf_V_12_ce0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_12_ce0),
    .buf_V_12_we0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_12_we0),
    .buf_V_12_d0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_12_d0),
    .buf_V_11_address0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_11_address0),
    .buf_V_11_ce0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_11_ce0),
    .buf_V_11_we0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_11_we0),
    .buf_V_11_d0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_11_d0),
    .buf_V_10_address0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_10_address0),
    .buf_V_10_ce0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_10_ce0),
    .buf_V_10_we0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_10_we0),
    .buf_V_10_d0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_10_d0),
    .buf_V_9_address0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_9_address0),
    .buf_V_9_ce0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_9_ce0),
    .buf_V_9_we0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_9_we0),
    .buf_V_9_d0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_9_d0),
    .buf_V_8_address0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_8_address0),
    .buf_V_8_ce0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_8_ce0),
    .buf_V_8_we0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_8_we0),
    .buf_V_8_d0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_8_d0),
    .buf_V_7_address0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_7_address0),
    .buf_V_7_ce0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_7_ce0),
    .buf_V_7_we0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_7_we0),
    .buf_V_7_d0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_7_d0),
    .buf_V_6_address0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_6_address0),
    .buf_V_6_ce0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_6_ce0),
    .buf_V_6_we0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_6_we0),
    .buf_V_6_d0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_6_d0),
    .buf_V_5_address0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_5_address0),
    .buf_V_5_ce0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_5_ce0),
    .buf_V_5_we0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_5_we0),
    .buf_V_5_d0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_5_d0),
    .buf_V_4_address0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_4_address0),
    .buf_V_4_ce0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_4_ce0),
    .buf_V_4_we0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_4_we0),
    .buf_V_4_d0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_4_d0),
    .buf_V_3_address0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_3_address0),
    .buf_V_3_ce0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_3_ce0),
    .buf_V_3_we0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_3_we0),
    .buf_V_3_d0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_3_d0),
    .buf_V_2_address0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_2_address0),
    .buf_V_2_ce0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_2_ce0),
    .buf_V_2_we0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_2_we0),
    .buf_V_2_d0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_2_d0),
    .buf_V_1_address0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_1_address0),
    .buf_V_1_ce0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_1_ce0),
    .buf_V_1_we0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_1_we0),
    .buf_V_1_d0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_1_d0),
    .buf_V_address0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_address0),
    .buf_V_ce0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_ce0),
    .buf_V_we0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_we0),
    .buf_V_d0(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_d0),
    .in0_V_TDATA(in0_V_TDATA),
    .in0_V_TREADY(grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_in0_V_TREADY)
);

always @ (posedge ap_clk) begin
    if (ap_rst == 1'b1) begin
        ap_CS_fsm <= ap_ST_fsm_state1;
    end else begin
        ap_CS_fsm <= ap_NS_fsm;
    end
end

always @ (posedge ap_clk) begin
    if (ap_rst == 1'b1) begin
        grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_ap_start_reg <= 1'b0;
    end else begin
        if (((1'b1 == ap_CS_fsm_state1) & (ap_start == 1'b1))) begin
            grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_ap_start_reg <= 1'b1;
        end else if ((grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_ap_ready == 1'b1)) begin
            grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_ap_start_reg <= 1'b0;
        end
    end
end

always @ (posedge ap_clk) begin
    if (ap_rst == 1'b1) begin
        grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_ap_start_reg <= 1'b0;
    end else begin
        if ((1'b1 == ap_CS_fsm_state6)) begin
            grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_ap_start_reg <= 1'b1;
        end else if ((grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_ap_ready == 1'b1)) begin
            grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_ap_start_reg <= 1'b0;
        end
    end
end

always @ (posedge ap_clk) begin
    if (ap_rst == 1'b1) begin
        grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_ap_start_reg <= 1'b0;
    end else begin
        if (((icmp_ln155_fu_791_p2 == 1'd1) & (1'b1 == ap_CS_fsm_state4))) begin
            grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_ap_start_reg <= 1'b1;
        end else if ((grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_ap_ready == 1'b1)) begin
            grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_ap_start_reg <= 1'b0;
        end
    end
end

always @ (posedge ap_clk) begin
    if (((grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_ap_done == 1'b1) & (1'b1 == ap_CS_fsm_state7))) begin
        indvar_flatten_reg_572 <= add_ln155_reg_881;
    end else if (((icmp_ln154_fu_779_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state3))) begin
        indvar_flatten_reg_572 <= 4'd0;
    end
end

always @ (posedge ap_clk) begin
    if (((grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_ap_done == 1'b1) & (1'b1 == ap_CS_fsm_state7))) begin
        xp_reg_583 <= add_ln156_reg_1051;
    end else if (((icmp_ln154_fu_779_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state3))) begin
        xp_reg_583 <= 3'd0;
    end
end

always @ (posedge ap_clk) begin
    if (((1'b1 == ap_CS_fsm_state1) & (ap_start == 1'b1))) begin
        yp_fu_56 <= 3'd0;
    end else if (((icmp_ln155_fu_791_p2 == 1'd1) & (1'b1 == ap_CS_fsm_state4))) begin
        yp_fu_56 <= yp_2_reg_873;
    end
end

always @ (posedge ap_clk) begin
    if ((1'b1 == ap_CS_fsm_state4)) begin
        add_ln155_reg_881 <= add_ln155_fu_797_p2;
    end
end

always @ (posedge ap_clk) begin
    if (((icmp_ln155_fu_791_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state4))) begin
        add_ln156_reg_1051 <= add_ln156_fu_853_p2;
        select_ln155_reg_886 <= select_ln155_fu_809_p3;
    end
end

always @ (posedge ap_clk) begin
    if ((1'b1 == ap_CS_fsm_state5)) begin
        buf_V_10_load_reg_1106 <= buf_V_10_q0;
        buf_V_11_load_reg_1111 <= buf_V_11_q0;
        buf_V_12_load_reg_1116 <= buf_V_12_q0;
        buf_V_13_load_reg_1121 <= buf_V_13_q0;
        buf_V_14_load_reg_1126 <= buf_V_14_q0;
        buf_V_15_load_reg_1131 <= buf_V_15_q0;
        buf_V_16_load_reg_1136 <= buf_V_16_q0;
        buf_V_17_load_reg_1141 <= buf_V_17_q0;
        buf_V_18_load_reg_1146 <= buf_V_18_q0;
        buf_V_19_load_reg_1151 <= buf_V_19_q0;
        buf_V_1_load_reg_1061 <= buf_V_1_q0;
        buf_V_20_load_reg_1156 <= buf_V_20_q0;
        buf_V_21_load_reg_1161 <= buf_V_21_q0;
        buf_V_22_load_reg_1166 <= buf_V_22_q0;
        buf_V_23_load_reg_1171 <= buf_V_23_q0;
        buf_V_24_load_reg_1176 <= buf_V_24_q0;
        buf_V_25_load_reg_1181 <= buf_V_25_q0;
        buf_V_26_load_reg_1186 <= buf_V_26_q0;
        buf_V_27_load_reg_1191 <= buf_V_27_q0;
        buf_V_28_load_reg_1196 <= buf_V_28_q0;
        buf_V_29_load_reg_1201 <= buf_V_29_q0;
        buf_V_2_load_reg_1066 <= buf_V_2_q0;
        buf_V_30_load_reg_1206 <= buf_V_30_q0;
        buf_V_31_load_reg_1211 <= buf_V_31_q0;
        buf_V_3_load_reg_1071 <= buf_V_3_q0;
        buf_V_4_load_reg_1076 <= buf_V_4_q0;
        buf_V_5_load_reg_1081 <= buf_V_5_q0;
        buf_V_6_load_reg_1086 <= buf_V_6_q0;
        buf_V_7_load_reg_1091 <= buf_V_7_q0;
        buf_V_8_load_reg_1096 <= buf_V_8_q0;
        buf_V_9_load_reg_1101 <= buf_V_9_q0;
        buf_V_load_reg_1056 <= buf_V_q0;
    end
end

always @ (posedge ap_clk) begin
    if ((1'b1 == ap_CS_fsm_state3)) begin
        yp_2_reg_873 <= yp_2_fu_785_p2;
    end
end

always @ (*) begin
    if ((ap_start == 1'b0)) begin
        ap_ST_fsm_state1_blk = 1'b1;
    end else begin
        ap_ST_fsm_state1_blk = 1'b0;
    end
end

always @ (*) begin
    if ((grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_ap_done == 1'b0)) begin
        ap_ST_fsm_state2_blk = 1'b1;
    end else begin
        ap_ST_fsm_state2_blk = 1'b0;
    end
end

assign ap_ST_fsm_state3_blk = 1'b0;

assign ap_ST_fsm_state4_blk = 1'b0;

assign ap_ST_fsm_state5_blk = 1'b0;

assign ap_ST_fsm_state6_blk = 1'b0;

always @ (*) begin
    if ((grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_ap_done == 1'b0)) begin
        ap_ST_fsm_state7_blk = 1'b1;
    end else begin
        ap_ST_fsm_state7_blk = 1'b0;
    end
end

always @ (*) begin
    if ((grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_ap_done == 1'b0)) begin
        ap_ST_fsm_state8_blk = 1'b1;
    end else begin
        ap_ST_fsm_state8_blk = 1'b0;
    end
end

always @ (*) begin
    if ((((icmp_ln154_fu_779_p2 == 1'd1) & (1'b1 == ap_CS_fsm_state3)) | ((1'b1 == ap_CS_fsm_state1) & (ap_start == 1'b0)))) begin
        ap_done = 1'b1;
    end else begin
        ap_done = 1'b0;
    end
end

always @ (*) begin
    if (((1'b1 == ap_CS_fsm_state1) & (ap_start == 1'b0))) begin
        ap_idle = 1'b1;
    end else begin
        ap_idle = 1'b0;
    end
end

always @ (*) begin
    if (((icmp_ln154_fu_779_p2 == 1'd1) & (1'b1 == ap_CS_fsm_state3))) begin
        ap_ready = 1'b1;
    end else begin
        ap_ready = 1'b0;
    end
end

always @ (*) begin
    if (((icmp_ln155_fu_791_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state4))) begin
        buf_V_10_address0 = zext_ln156_fu_817_p1;
    end else if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_10_address0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_10_address0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_10_address0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_10_address0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_10_address0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_10_address0;
    end else begin
        buf_V_10_address0 = 'bx;
    end
end

always @ (*) begin
    if (((icmp_ln155_fu_791_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state4))) begin
        buf_V_10_ce0 = 1'b1;
    end else if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_10_ce0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_10_ce0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_10_ce0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_10_ce0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_10_ce0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_10_ce0;
    end else begin
        buf_V_10_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_10_d0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_10_d0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_10_d0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_10_d0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_10_d0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_10_d0;
    end else begin
        buf_V_10_d0 = 'bx;
    end
end

always @ (*) begin
    if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_10_we0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_10_we0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_10_we0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_10_we0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_10_we0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_10_we0;
    end else begin
        buf_V_10_we0 = 1'b0;
    end
end

always @ (*) begin
    if (((icmp_ln155_fu_791_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state4))) begin
        buf_V_11_address0 = zext_ln156_fu_817_p1;
    end else if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_11_address0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_11_address0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_11_address0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_11_address0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_11_address0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_11_address0;
    end else begin
        buf_V_11_address0 = 'bx;
    end
end

always @ (*) begin
    if (((icmp_ln155_fu_791_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state4))) begin
        buf_V_11_ce0 = 1'b1;
    end else if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_11_ce0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_11_ce0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_11_ce0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_11_ce0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_11_ce0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_11_ce0;
    end else begin
        buf_V_11_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_11_d0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_11_d0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_11_d0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_11_d0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_11_d0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_11_d0;
    end else begin
        buf_V_11_d0 = 'bx;
    end
end

always @ (*) begin
    if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_11_we0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_11_we0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_11_we0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_11_we0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_11_we0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_11_we0;
    end else begin
        buf_V_11_we0 = 1'b0;
    end
end

always @ (*) begin
    if (((icmp_ln155_fu_791_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state4))) begin
        buf_V_12_address0 = zext_ln156_fu_817_p1;
    end else if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_12_address0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_12_address0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_12_address0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_12_address0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_12_address0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_12_address0;
    end else begin
        buf_V_12_address0 = 'bx;
    end
end

always @ (*) begin
    if (((icmp_ln155_fu_791_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state4))) begin
        buf_V_12_ce0 = 1'b1;
    end else if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_12_ce0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_12_ce0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_12_ce0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_12_ce0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_12_ce0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_12_ce0;
    end else begin
        buf_V_12_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_12_d0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_12_d0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_12_d0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_12_d0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_12_d0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_12_d0;
    end else begin
        buf_V_12_d0 = 'bx;
    end
end

always @ (*) begin
    if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_12_we0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_12_we0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_12_we0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_12_we0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_12_we0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_12_we0;
    end else begin
        buf_V_12_we0 = 1'b0;
    end
end

always @ (*) begin
    if (((icmp_ln155_fu_791_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state4))) begin
        buf_V_13_address0 = zext_ln156_fu_817_p1;
    end else if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_13_address0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_13_address0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_13_address0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_13_address0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_13_address0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_13_address0;
    end else begin
        buf_V_13_address0 = 'bx;
    end
end

always @ (*) begin
    if (((icmp_ln155_fu_791_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state4))) begin
        buf_V_13_ce0 = 1'b1;
    end else if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_13_ce0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_13_ce0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_13_ce0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_13_ce0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_13_ce0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_13_ce0;
    end else begin
        buf_V_13_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_13_d0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_13_d0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_13_d0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_13_d0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_13_d0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_13_d0;
    end else begin
        buf_V_13_d0 = 'bx;
    end
end

always @ (*) begin
    if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_13_we0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_13_we0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_13_we0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_13_we0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_13_we0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_13_we0;
    end else begin
        buf_V_13_we0 = 1'b0;
    end
end

always @ (*) begin
    if (((icmp_ln155_fu_791_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state4))) begin
        buf_V_14_address0 = zext_ln156_fu_817_p1;
    end else if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_14_address0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_14_address0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_14_address0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_14_address0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_14_address0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_14_address0;
    end else begin
        buf_V_14_address0 = 'bx;
    end
end

always @ (*) begin
    if (((icmp_ln155_fu_791_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state4))) begin
        buf_V_14_ce0 = 1'b1;
    end else if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_14_ce0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_14_ce0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_14_ce0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_14_ce0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_14_ce0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_14_ce0;
    end else begin
        buf_V_14_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_14_d0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_14_d0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_14_d0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_14_d0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_14_d0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_14_d0;
    end else begin
        buf_V_14_d0 = 'bx;
    end
end

always @ (*) begin
    if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_14_we0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_14_we0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_14_we0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_14_we0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_14_we0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_14_we0;
    end else begin
        buf_V_14_we0 = 1'b0;
    end
end

always @ (*) begin
    if (((icmp_ln155_fu_791_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state4))) begin
        buf_V_15_address0 = zext_ln156_fu_817_p1;
    end else if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_15_address0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_15_address0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_15_address0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_15_address0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_15_address0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_15_address0;
    end else begin
        buf_V_15_address0 = 'bx;
    end
end

always @ (*) begin
    if (((icmp_ln155_fu_791_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state4))) begin
        buf_V_15_ce0 = 1'b1;
    end else if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_15_ce0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_15_ce0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_15_ce0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_15_ce0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_15_ce0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_15_ce0;
    end else begin
        buf_V_15_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_15_d0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_15_d0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_15_d0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_15_d0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_15_d0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_15_d0;
    end else begin
        buf_V_15_d0 = 'bx;
    end
end

always @ (*) begin
    if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_15_we0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_15_we0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_15_we0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_15_we0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_15_we0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_15_we0;
    end else begin
        buf_V_15_we0 = 1'b0;
    end
end

always @ (*) begin
    if (((icmp_ln155_fu_791_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state4))) begin
        buf_V_16_address0 = zext_ln156_fu_817_p1;
    end else if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_16_address0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_16_address0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_16_address0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_16_address0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_16_address0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_16_address0;
    end else begin
        buf_V_16_address0 = 'bx;
    end
end

always @ (*) begin
    if (((icmp_ln155_fu_791_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state4))) begin
        buf_V_16_ce0 = 1'b1;
    end else if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_16_ce0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_16_ce0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_16_ce0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_16_ce0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_16_ce0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_16_ce0;
    end else begin
        buf_V_16_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_16_d0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_16_d0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_16_d0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_16_d0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_16_d0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_16_d0;
    end else begin
        buf_V_16_d0 = 'bx;
    end
end

always @ (*) begin
    if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_16_we0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_16_we0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_16_we0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_16_we0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_16_we0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_16_we0;
    end else begin
        buf_V_16_we0 = 1'b0;
    end
end

always @ (*) begin
    if (((icmp_ln155_fu_791_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state4))) begin
        buf_V_17_address0 = zext_ln156_fu_817_p1;
    end else if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_17_address0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_17_address0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_17_address0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_17_address0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_17_address0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_17_address0;
    end else begin
        buf_V_17_address0 = 'bx;
    end
end

always @ (*) begin
    if (((icmp_ln155_fu_791_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state4))) begin
        buf_V_17_ce0 = 1'b1;
    end else if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_17_ce0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_17_ce0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_17_ce0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_17_ce0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_17_ce0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_17_ce0;
    end else begin
        buf_V_17_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_17_d0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_17_d0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_17_d0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_17_d0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_17_d0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_17_d0;
    end else begin
        buf_V_17_d0 = 'bx;
    end
end

always @ (*) begin
    if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_17_we0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_17_we0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_17_we0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_17_we0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_17_we0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_17_we0;
    end else begin
        buf_V_17_we0 = 1'b0;
    end
end

always @ (*) begin
    if (((icmp_ln155_fu_791_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state4))) begin
        buf_V_18_address0 = zext_ln156_fu_817_p1;
    end else if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_18_address0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_18_address0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_18_address0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_18_address0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_18_address0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_18_address0;
    end else begin
        buf_V_18_address0 = 'bx;
    end
end

always @ (*) begin
    if (((icmp_ln155_fu_791_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state4))) begin
        buf_V_18_ce0 = 1'b1;
    end else if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_18_ce0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_18_ce0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_18_ce0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_18_ce0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_18_ce0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_18_ce0;
    end else begin
        buf_V_18_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_18_d0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_18_d0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_18_d0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_18_d0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_18_d0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_18_d0;
    end else begin
        buf_V_18_d0 = 'bx;
    end
end

always @ (*) begin
    if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_18_we0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_18_we0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_18_we0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_18_we0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_18_we0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_18_we0;
    end else begin
        buf_V_18_we0 = 1'b0;
    end
end

always @ (*) begin
    if (((icmp_ln155_fu_791_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state4))) begin
        buf_V_19_address0 = zext_ln156_fu_817_p1;
    end else if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_19_address0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_19_address0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_19_address0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_19_address0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_19_address0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_19_address0;
    end else begin
        buf_V_19_address0 = 'bx;
    end
end

always @ (*) begin
    if (((icmp_ln155_fu_791_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state4))) begin
        buf_V_19_ce0 = 1'b1;
    end else if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_19_ce0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_19_ce0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_19_ce0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_19_ce0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_19_ce0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_19_ce0;
    end else begin
        buf_V_19_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_19_d0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_19_d0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_19_d0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_19_d0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_19_d0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_19_d0;
    end else begin
        buf_V_19_d0 = 'bx;
    end
end

always @ (*) begin
    if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_19_we0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_19_we0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_19_we0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_19_we0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_19_we0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_19_we0;
    end else begin
        buf_V_19_we0 = 1'b0;
    end
end

always @ (*) begin
    if (((icmp_ln155_fu_791_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state4))) begin
        buf_V_1_address0 = zext_ln156_fu_817_p1;
    end else if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_1_address0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_1_address0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_1_address0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_1_address0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_1_address0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_1_address0;
    end else begin
        buf_V_1_address0 = 'bx;
    end
end

always @ (*) begin
    if (((icmp_ln155_fu_791_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state4))) begin
        buf_V_1_ce0 = 1'b1;
    end else if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_1_ce0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_1_ce0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_1_ce0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_1_ce0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_1_ce0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_1_ce0;
    end else begin
        buf_V_1_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_1_d0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_1_d0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_1_d0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_1_d0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_1_d0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_1_d0;
    end else begin
        buf_V_1_d0 = 'bx;
    end
end

always @ (*) begin
    if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_1_we0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_1_we0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_1_we0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_1_we0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_1_we0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_1_we0;
    end else begin
        buf_V_1_we0 = 1'b0;
    end
end

always @ (*) begin
    if (((icmp_ln155_fu_791_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state4))) begin
        buf_V_20_address0 = zext_ln156_fu_817_p1;
    end else if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_20_address0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_20_address0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_20_address0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_20_address0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_20_address0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_20_address0;
    end else begin
        buf_V_20_address0 = 'bx;
    end
end

always @ (*) begin
    if (((icmp_ln155_fu_791_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state4))) begin
        buf_V_20_ce0 = 1'b1;
    end else if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_20_ce0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_20_ce0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_20_ce0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_20_ce0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_20_ce0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_20_ce0;
    end else begin
        buf_V_20_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_20_d0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_20_d0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_20_d0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_20_d0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_20_d0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_20_d0;
    end else begin
        buf_V_20_d0 = 'bx;
    end
end

always @ (*) begin
    if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_20_we0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_20_we0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_20_we0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_20_we0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_20_we0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_20_we0;
    end else begin
        buf_V_20_we0 = 1'b0;
    end
end

always @ (*) begin
    if (((icmp_ln155_fu_791_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state4))) begin
        buf_V_21_address0 = zext_ln156_fu_817_p1;
    end else if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_21_address0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_21_address0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_21_address0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_21_address0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_21_address0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_21_address0;
    end else begin
        buf_V_21_address0 = 'bx;
    end
end

always @ (*) begin
    if (((icmp_ln155_fu_791_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state4))) begin
        buf_V_21_ce0 = 1'b1;
    end else if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_21_ce0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_21_ce0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_21_ce0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_21_ce0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_21_ce0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_21_ce0;
    end else begin
        buf_V_21_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_21_d0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_21_d0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_21_d0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_21_d0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_21_d0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_21_d0;
    end else begin
        buf_V_21_d0 = 'bx;
    end
end

always @ (*) begin
    if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_21_we0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_21_we0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_21_we0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_21_we0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_21_we0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_21_we0;
    end else begin
        buf_V_21_we0 = 1'b0;
    end
end

always @ (*) begin
    if (((icmp_ln155_fu_791_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state4))) begin
        buf_V_22_address0 = zext_ln156_fu_817_p1;
    end else if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_22_address0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_22_address0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_22_address0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_22_address0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_22_address0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_22_address0;
    end else begin
        buf_V_22_address0 = 'bx;
    end
end

always @ (*) begin
    if (((icmp_ln155_fu_791_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state4))) begin
        buf_V_22_ce0 = 1'b1;
    end else if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_22_ce0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_22_ce0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_22_ce0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_22_ce0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_22_ce0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_22_ce0;
    end else begin
        buf_V_22_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_22_d0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_22_d0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_22_d0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_22_d0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_22_d0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_22_d0;
    end else begin
        buf_V_22_d0 = 'bx;
    end
end

always @ (*) begin
    if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_22_we0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_22_we0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_22_we0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_22_we0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_22_we0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_22_we0;
    end else begin
        buf_V_22_we0 = 1'b0;
    end
end

always @ (*) begin
    if (((icmp_ln155_fu_791_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state4))) begin
        buf_V_23_address0 = zext_ln156_fu_817_p1;
    end else if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_23_address0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_23_address0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_23_address0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_23_address0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_23_address0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_23_address0;
    end else begin
        buf_V_23_address0 = 'bx;
    end
end

always @ (*) begin
    if (((icmp_ln155_fu_791_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state4))) begin
        buf_V_23_ce0 = 1'b1;
    end else if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_23_ce0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_23_ce0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_23_ce0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_23_ce0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_23_ce0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_23_ce0;
    end else begin
        buf_V_23_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_23_d0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_23_d0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_23_d0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_23_d0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_23_d0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_23_d0;
    end else begin
        buf_V_23_d0 = 'bx;
    end
end

always @ (*) begin
    if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_23_we0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_23_we0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_23_we0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_23_we0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_23_we0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_23_we0;
    end else begin
        buf_V_23_we0 = 1'b0;
    end
end

always @ (*) begin
    if (((icmp_ln155_fu_791_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state4))) begin
        buf_V_24_address0 = zext_ln156_fu_817_p1;
    end else if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_24_address0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_24_address0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_24_address0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_24_address0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_24_address0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_24_address0;
    end else begin
        buf_V_24_address0 = 'bx;
    end
end

always @ (*) begin
    if (((icmp_ln155_fu_791_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state4))) begin
        buf_V_24_ce0 = 1'b1;
    end else if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_24_ce0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_24_ce0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_24_ce0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_24_ce0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_24_ce0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_24_ce0;
    end else begin
        buf_V_24_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_24_d0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_24_d0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_24_d0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_24_d0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_24_d0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_24_d0;
    end else begin
        buf_V_24_d0 = 'bx;
    end
end

always @ (*) begin
    if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_24_we0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_24_we0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_24_we0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_24_we0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_24_we0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_24_we0;
    end else begin
        buf_V_24_we0 = 1'b0;
    end
end

always @ (*) begin
    if (((icmp_ln155_fu_791_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state4))) begin
        buf_V_25_address0 = zext_ln156_fu_817_p1;
    end else if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_25_address0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_25_address0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_25_address0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_25_address0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_25_address0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_25_address0;
    end else begin
        buf_V_25_address0 = 'bx;
    end
end

always @ (*) begin
    if (((icmp_ln155_fu_791_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state4))) begin
        buf_V_25_ce0 = 1'b1;
    end else if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_25_ce0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_25_ce0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_25_ce0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_25_ce0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_25_ce0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_25_ce0;
    end else begin
        buf_V_25_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_25_d0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_25_d0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_25_d0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_25_d0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_25_d0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_25_d0;
    end else begin
        buf_V_25_d0 = 'bx;
    end
end

always @ (*) begin
    if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_25_we0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_25_we0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_25_we0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_25_we0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_25_we0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_25_we0;
    end else begin
        buf_V_25_we0 = 1'b0;
    end
end

always @ (*) begin
    if (((icmp_ln155_fu_791_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state4))) begin
        buf_V_26_address0 = zext_ln156_fu_817_p1;
    end else if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_26_address0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_26_address0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_26_address0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_26_address0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_26_address0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_26_address0;
    end else begin
        buf_V_26_address0 = 'bx;
    end
end

always @ (*) begin
    if (((icmp_ln155_fu_791_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state4))) begin
        buf_V_26_ce0 = 1'b1;
    end else if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_26_ce0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_26_ce0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_26_ce0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_26_ce0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_26_ce0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_26_ce0;
    end else begin
        buf_V_26_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_26_d0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_26_d0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_26_d0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_26_d0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_26_d0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_26_d0;
    end else begin
        buf_V_26_d0 = 'bx;
    end
end

always @ (*) begin
    if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_26_we0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_26_we0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_26_we0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_26_we0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_26_we0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_26_we0;
    end else begin
        buf_V_26_we0 = 1'b0;
    end
end

always @ (*) begin
    if (((icmp_ln155_fu_791_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state4))) begin
        buf_V_27_address0 = zext_ln156_fu_817_p1;
    end else if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_27_address0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_27_address0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_27_address0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_27_address0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_27_address0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_27_address0;
    end else begin
        buf_V_27_address0 = 'bx;
    end
end

always @ (*) begin
    if (((icmp_ln155_fu_791_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state4))) begin
        buf_V_27_ce0 = 1'b1;
    end else if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_27_ce0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_27_ce0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_27_ce0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_27_ce0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_27_ce0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_27_ce0;
    end else begin
        buf_V_27_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_27_d0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_27_d0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_27_d0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_27_d0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_27_d0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_27_d0;
    end else begin
        buf_V_27_d0 = 'bx;
    end
end

always @ (*) begin
    if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_27_we0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_27_we0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_27_we0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_27_we0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_27_we0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_27_we0;
    end else begin
        buf_V_27_we0 = 1'b0;
    end
end

always @ (*) begin
    if (((icmp_ln155_fu_791_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state4))) begin
        buf_V_28_address0 = zext_ln156_fu_817_p1;
    end else if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_28_address0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_28_address0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_28_address0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_28_address0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_28_address0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_28_address0;
    end else begin
        buf_V_28_address0 = 'bx;
    end
end

always @ (*) begin
    if (((icmp_ln155_fu_791_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state4))) begin
        buf_V_28_ce0 = 1'b1;
    end else if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_28_ce0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_28_ce0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_28_ce0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_28_ce0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_28_ce0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_28_ce0;
    end else begin
        buf_V_28_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_28_d0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_28_d0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_28_d0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_28_d0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_28_d0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_28_d0;
    end else begin
        buf_V_28_d0 = 'bx;
    end
end

always @ (*) begin
    if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_28_we0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_28_we0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_28_we0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_28_we0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_28_we0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_28_we0;
    end else begin
        buf_V_28_we0 = 1'b0;
    end
end

always @ (*) begin
    if (((icmp_ln155_fu_791_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state4))) begin
        buf_V_29_address0 = zext_ln156_fu_817_p1;
    end else if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_29_address0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_29_address0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_29_address0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_29_address0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_29_address0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_29_address0;
    end else begin
        buf_V_29_address0 = 'bx;
    end
end

always @ (*) begin
    if (((icmp_ln155_fu_791_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state4))) begin
        buf_V_29_ce0 = 1'b1;
    end else if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_29_ce0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_29_ce0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_29_ce0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_29_ce0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_29_ce0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_29_ce0;
    end else begin
        buf_V_29_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_29_d0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_29_d0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_29_d0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_29_d0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_29_d0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_29_d0;
    end else begin
        buf_V_29_d0 = 'bx;
    end
end

always @ (*) begin
    if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_29_we0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_29_we0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_29_we0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_29_we0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_29_we0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_29_we0;
    end else begin
        buf_V_29_we0 = 1'b0;
    end
end

always @ (*) begin
    if (((icmp_ln155_fu_791_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state4))) begin
        buf_V_2_address0 = zext_ln156_fu_817_p1;
    end else if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_2_address0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_2_address0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_2_address0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_2_address0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_2_address0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_2_address0;
    end else begin
        buf_V_2_address0 = 'bx;
    end
end

always @ (*) begin
    if (((icmp_ln155_fu_791_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state4))) begin
        buf_V_2_ce0 = 1'b1;
    end else if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_2_ce0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_2_ce0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_2_ce0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_2_ce0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_2_ce0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_2_ce0;
    end else begin
        buf_V_2_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_2_d0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_2_d0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_2_d0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_2_d0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_2_d0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_2_d0;
    end else begin
        buf_V_2_d0 = 'bx;
    end
end

always @ (*) begin
    if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_2_we0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_2_we0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_2_we0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_2_we0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_2_we0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_2_we0;
    end else begin
        buf_V_2_we0 = 1'b0;
    end
end

always @ (*) begin
    if (((icmp_ln155_fu_791_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state4))) begin
        buf_V_30_address0 = zext_ln156_fu_817_p1;
    end else if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_30_address0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_30_address0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_30_address0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_30_address0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_30_address0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_30_address0;
    end else begin
        buf_V_30_address0 = 'bx;
    end
end

always @ (*) begin
    if (((icmp_ln155_fu_791_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state4))) begin
        buf_V_30_ce0 = 1'b1;
    end else if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_30_ce0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_30_ce0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_30_ce0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_30_ce0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_30_ce0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_30_ce0;
    end else begin
        buf_V_30_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_30_d0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_30_d0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_30_d0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_30_d0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_30_d0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_30_d0;
    end else begin
        buf_V_30_d0 = 'bx;
    end
end

always @ (*) begin
    if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_30_we0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_30_we0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_30_we0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_30_we0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_30_we0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_30_we0;
    end else begin
        buf_V_30_we0 = 1'b0;
    end
end

always @ (*) begin
    if (((icmp_ln155_fu_791_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state4))) begin
        buf_V_31_address0 = zext_ln156_fu_817_p1;
    end else if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_31_address0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_31_address0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_31_address0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_31_address0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_31_address0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_31_address0;
    end else begin
        buf_V_31_address0 = 'bx;
    end
end

always @ (*) begin
    if (((icmp_ln155_fu_791_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state4))) begin
        buf_V_31_ce0 = 1'b1;
    end else if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_31_ce0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_31_ce0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_31_ce0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_31_ce0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_31_ce0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_31_ce0;
    end else begin
        buf_V_31_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_31_d0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_31_d0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_31_d0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_31_d0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_31_d0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_31_d0;
    end else begin
        buf_V_31_d0 = 'bx;
    end
end

always @ (*) begin
    if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_31_we0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_31_we0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_31_we0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_31_we0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_31_we0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_31_we0;
    end else begin
        buf_V_31_we0 = 1'b0;
    end
end

always @ (*) begin
    if (((icmp_ln155_fu_791_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state4))) begin
        buf_V_3_address0 = zext_ln156_fu_817_p1;
    end else if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_3_address0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_3_address0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_3_address0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_3_address0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_3_address0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_3_address0;
    end else begin
        buf_V_3_address0 = 'bx;
    end
end

always @ (*) begin
    if (((icmp_ln155_fu_791_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state4))) begin
        buf_V_3_ce0 = 1'b1;
    end else if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_3_ce0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_3_ce0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_3_ce0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_3_ce0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_3_ce0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_3_ce0;
    end else begin
        buf_V_3_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_3_d0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_3_d0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_3_d0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_3_d0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_3_d0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_3_d0;
    end else begin
        buf_V_3_d0 = 'bx;
    end
end

always @ (*) begin
    if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_3_we0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_3_we0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_3_we0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_3_we0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_3_we0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_3_we0;
    end else begin
        buf_V_3_we0 = 1'b0;
    end
end

always @ (*) begin
    if (((icmp_ln155_fu_791_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state4))) begin
        buf_V_4_address0 = zext_ln156_fu_817_p1;
    end else if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_4_address0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_4_address0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_4_address0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_4_address0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_4_address0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_4_address0;
    end else begin
        buf_V_4_address0 = 'bx;
    end
end

always @ (*) begin
    if (((icmp_ln155_fu_791_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state4))) begin
        buf_V_4_ce0 = 1'b1;
    end else if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_4_ce0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_4_ce0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_4_ce0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_4_ce0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_4_ce0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_4_ce0;
    end else begin
        buf_V_4_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_4_d0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_4_d0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_4_d0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_4_d0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_4_d0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_4_d0;
    end else begin
        buf_V_4_d0 = 'bx;
    end
end

always @ (*) begin
    if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_4_we0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_4_we0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_4_we0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_4_we0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_4_we0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_4_we0;
    end else begin
        buf_V_4_we0 = 1'b0;
    end
end

always @ (*) begin
    if (((icmp_ln155_fu_791_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state4))) begin
        buf_V_5_address0 = zext_ln156_fu_817_p1;
    end else if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_5_address0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_5_address0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_5_address0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_5_address0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_5_address0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_5_address0;
    end else begin
        buf_V_5_address0 = 'bx;
    end
end

always @ (*) begin
    if (((icmp_ln155_fu_791_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state4))) begin
        buf_V_5_ce0 = 1'b1;
    end else if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_5_ce0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_5_ce0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_5_ce0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_5_ce0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_5_ce0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_5_ce0;
    end else begin
        buf_V_5_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_5_d0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_5_d0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_5_d0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_5_d0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_5_d0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_5_d0;
    end else begin
        buf_V_5_d0 = 'bx;
    end
end

always @ (*) begin
    if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_5_we0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_5_we0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_5_we0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_5_we0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_5_we0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_5_we0;
    end else begin
        buf_V_5_we0 = 1'b0;
    end
end

always @ (*) begin
    if (((icmp_ln155_fu_791_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state4))) begin
        buf_V_6_address0 = zext_ln156_fu_817_p1;
    end else if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_6_address0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_6_address0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_6_address0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_6_address0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_6_address0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_6_address0;
    end else begin
        buf_V_6_address0 = 'bx;
    end
end

always @ (*) begin
    if (((icmp_ln155_fu_791_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state4))) begin
        buf_V_6_ce0 = 1'b1;
    end else if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_6_ce0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_6_ce0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_6_ce0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_6_ce0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_6_ce0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_6_ce0;
    end else begin
        buf_V_6_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_6_d0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_6_d0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_6_d0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_6_d0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_6_d0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_6_d0;
    end else begin
        buf_V_6_d0 = 'bx;
    end
end

always @ (*) begin
    if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_6_we0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_6_we0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_6_we0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_6_we0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_6_we0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_6_we0;
    end else begin
        buf_V_6_we0 = 1'b0;
    end
end

always @ (*) begin
    if (((icmp_ln155_fu_791_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state4))) begin
        buf_V_7_address0 = zext_ln156_fu_817_p1;
    end else if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_7_address0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_7_address0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_7_address0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_7_address0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_7_address0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_7_address0;
    end else begin
        buf_V_7_address0 = 'bx;
    end
end

always @ (*) begin
    if (((icmp_ln155_fu_791_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state4))) begin
        buf_V_7_ce0 = 1'b1;
    end else if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_7_ce0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_7_ce0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_7_ce0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_7_ce0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_7_ce0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_7_ce0;
    end else begin
        buf_V_7_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_7_d0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_7_d0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_7_d0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_7_d0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_7_d0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_7_d0;
    end else begin
        buf_V_7_d0 = 'bx;
    end
end

always @ (*) begin
    if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_7_we0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_7_we0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_7_we0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_7_we0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_7_we0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_7_we0;
    end else begin
        buf_V_7_we0 = 1'b0;
    end
end

always @ (*) begin
    if (((icmp_ln155_fu_791_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state4))) begin
        buf_V_8_address0 = zext_ln156_fu_817_p1;
    end else if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_8_address0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_8_address0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_8_address0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_8_address0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_8_address0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_8_address0;
    end else begin
        buf_V_8_address0 = 'bx;
    end
end

always @ (*) begin
    if (((icmp_ln155_fu_791_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state4))) begin
        buf_V_8_ce0 = 1'b1;
    end else if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_8_ce0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_8_ce0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_8_ce0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_8_ce0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_8_ce0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_8_ce0;
    end else begin
        buf_V_8_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_8_d0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_8_d0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_8_d0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_8_d0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_8_d0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_8_d0;
    end else begin
        buf_V_8_d0 = 'bx;
    end
end

always @ (*) begin
    if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_8_we0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_8_we0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_8_we0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_8_we0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_8_we0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_8_we0;
    end else begin
        buf_V_8_we0 = 1'b0;
    end
end

always @ (*) begin
    if (((icmp_ln155_fu_791_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state4))) begin
        buf_V_9_address0 = zext_ln156_fu_817_p1;
    end else if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_9_address0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_9_address0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_9_address0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_9_address0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_9_address0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_9_address0;
    end else begin
        buf_V_9_address0 = 'bx;
    end
end

always @ (*) begin
    if (((icmp_ln155_fu_791_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state4))) begin
        buf_V_9_ce0 = 1'b1;
    end else if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_9_ce0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_9_ce0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_9_ce0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_9_ce0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_9_ce0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_9_ce0;
    end else begin
        buf_V_9_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_9_d0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_9_d0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_9_d0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_9_d0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_9_d0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_9_d0;
    end else begin
        buf_V_9_d0 = 'bx;
    end
end

always @ (*) begin
    if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_9_we0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_9_we0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_9_we0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_9_we0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_9_we0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_9_we0;
    end else begin
        buf_V_9_we0 = 1'b0;
    end
end

always @ (*) begin
    if (((icmp_ln155_fu_791_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state4))) begin
        buf_V_address0 = zext_ln156_fu_817_p1;
    end else if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_address0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_address0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_address0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_address0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_address0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_address0;
    end else begin
        buf_V_address0 = 'bx;
    end
end

always @ (*) begin
    if (((icmp_ln155_fu_791_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state4))) begin
        buf_V_ce0 = 1'b1;
    end else if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_ce0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_ce0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_ce0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_ce0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_ce0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_ce0;
    end else begin
        buf_V_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_d0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_d0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_d0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_d0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_d0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_d0;
    end else begin
        buf_V_d0 = 'bx;
    end
end

always @ (*) begin
    if ((1'b1 == ap_CS_fsm_state7)) begin
        buf_V_we0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_buf_V_we0;
    end else if ((1'b1 == ap_CS_fsm_state8)) begin
        buf_V_we0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_buf_V_we0;
    end else if ((1'b1 == ap_CS_fsm_state2)) begin
        buf_V_we0 = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_buf_V_we0;
    end else begin
        buf_V_we0 = 1'b0;
    end
end

always @ (*) begin
    if ((1'b1 == ap_CS_fsm_state7)) begin
        in0_V_TREADY = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_in0_V_TREADY;
    end else begin
        in0_V_TREADY = 1'b0;
    end
end

always @ (*) begin
    case (ap_CS_fsm)
        ap_ST_fsm_state1 : begin
            if (((1'b1 == ap_CS_fsm_state1) & (ap_start == 1'b1))) begin
                ap_NS_fsm = ap_ST_fsm_state2;
            end else begin
                ap_NS_fsm = ap_ST_fsm_state1;
            end
        end
        ap_ST_fsm_state2 : begin
            if (((grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_ap_done == 1'b1) & (1'b1 == ap_CS_fsm_state2))) begin
                ap_NS_fsm = ap_ST_fsm_state3;
            end else begin
                ap_NS_fsm = ap_ST_fsm_state2;
            end
        end
        ap_ST_fsm_state3 : begin
            if (((icmp_ln154_fu_779_p2 == 1'd1) & (1'b1 == ap_CS_fsm_state3))) begin
                ap_NS_fsm = ap_ST_fsm_state1;
            end else begin
                ap_NS_fsm = ap_ST_fsm_state4;
            end
        end
        ap_ST_fsm_state4 : begin
            if (((icmp_ln155_fu_791_p2 == 1'd1) & (1'b1 == ap_CS_fsm_state4))) begin
                ap_NS_fsm = ap_ST_fsm_state8;
            end else begin
                ap_NS_fsm = ap_ST_fsm_state5;
            end
        end
        ap_ST_fsm_state5 : begin
            ap_NS_fsm = ap_ST_fsm_state6;
        end
        ap_ST_fsm_state6 : begin
            ap_NS_fsm = ap_ST_fsm_state7;
        end
        ap_ST_fsm_state7 : begin
            if (((grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_ap_done == 1'b1) & (1'b1 == ap_CS_fsm_state7))) begin
                ap_NS_fsm = ap_ST_fsm_state4;
            end else begin
                ap_NS_fsm = ap_ST_fsm_state7;
            end
        end
        ap_ST_fsm_state8 : begin
            if (((grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_ap_done == 1'b1) & (1'b1 == ap_CS_fsm_state8))) begin
                ap_NS_fsm = ap_ST_fsm_state3;
            end else begin
                ap_NS_fsm = ap_ST_fsm_state8;
            end
        end
        default : begin
            ap_NS_fsm = 'bx;
        end
    endcase
end

assign add_ln155_fu_797_p2 = (indvar_flatten_reg_572 + 4'd1);

assign add_ln156_fu_853_p2 = (select_ln155_fu_809_p3 + 3'd1);

assign ap_CS_fsm_state1 = ap_CS_fsm[32'd0];

assign ap_CS_fsm_state2 = ap_CS_fsm[32'd1];

assign ap_CS_fsm_state3 = ap_CS_fsm[32'd2];

assign ap_CS_fsm_state4 = ap_CS_fsm[32'd3];

assign ap_CS_fsm_state5 = ap_CS_fsm[32'd4];

assign ap_CS_fsm_state6 = ap_CS_fsm[32'd5];

assign ap_CS_fsm_state7 = ap_CS_fsm[32'd6];

assign ap_CS_fsm_state8 = ap_CS_fsm[32'd7];

assign grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_ap_start = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_147_1_fu_594_ap_start_reg;

assign grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_ap_start = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6_fu_700_ap_start_reg;

assign grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_ap_start = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_ap_start_reg;

assign grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_out_V_TREADY = (out_V_TREADY & ap_CS_fsm_state8);

assign icmp_ln154_fu_779_p2 = ((yp_fu_56 == 3'd7) ? 1'b1 : 1'b0);

assign icmp_ln155_fu_791_p2 = ((indvar_flatten_reg_572 == 4'd14) ? 1'b1 : 1'b0);

assign icmp_ln156_fu_803_p2 = ((xp_reg_583 == 3'd7) ? 1'b1 : 1'b0);

assign out_V_TDATA = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_out_V_TDATA;

assign out_V_TVALID = grp_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_174_8_fu_662_out_V_TVALID;

assign select_ln155_fu_809_p3 = ((icmp_ln156_fu_803_p2[0:0] == 1'b1) ? 3'd0 : xp_reg_583);

assign yp_2_fu_785_p2 = (yp_fu_56 + 3'd1);

assign zext_ln156_fu_817_p1 = select_ln155_fu_809_p3;

endmodule //StreamingMaxPool_hls_1_StreamingMaxPool_Precision_14u_2u_32u_ap_uint_4_0_128_s
//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/vivado_stitch_proj_w5fn6zuu/finn_vivado_stitch_proj.gen/sources_1/bd/finn_design/ipshared/18e4/hdl/verilog/MVAU_hls_0_Matrix_Vector_Activate_Stream_Batch_p_ZL7threshs_0_ROM_AUTO_1R.v


// ==============================================================
// Vitis HLS - High-Level Synthesis from C, C++ and OpenCL v2022.2 (64-bit)
// Version: 2022.2
// Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.
// ==============================================================
`timescale 1 ns / 1 ps
module MVAU_hls_0_Matrix_Vector_Activate_Stream_Batch_p_ZL7threshs_0_ROM_AUTO_1R (
    address0, ce0, q0, 
    reset, clk);

parameter DataWidth = 12;
parameter AddressWidth = 4;
parameter AddressRange = 16;
 
input[AddressWidth-1:0] address0;
input ce0;
output reg[DataWidth-1:0] q0;

input reset;
input clk;

 
reg [DataWidth-1:0] rom0[0:AddressRange-1];


initial begin
     
    $readmemh("/home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/code_gen_ipgen_MVAU_hls_0_z2r2fzak/project_MVAU_hls_0/sol1/impl/ip/hdl/verilog/MVAU_hls_0_Matrix_Vector_Activate_Stream_Batch_p_ZL7threshs_0_ROM_AUTO_1R.dat", rom0);
end

  
always @(posedge clk) 
begin 
    if (ce0) 
    begin
        q0 <= rom0[address0];
    end
end


endmodule

//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/vivado_stitch_proj_w5fn6zuu/finn_vivado_stitch_proj.gen/sources_1/bd/finn_design/ip/finn_design_MVAU_hls_0_0/synth/finn_design_MVAU_hls_0_0.v


// (c) Copyright 1995-2026 Xilinx, Inc. All rights reserved.
// 
// This file contains confidential and proprietary information
// of Xilinx, Inc. and is protected under U.S. and
// international copyright and other intellectual property
// laws.
// 
// DISCLAIMER
// This disclaimer is not a license and does not grant any
// rights to the materials distributed herewith. Except as
// otherwise provided in a valid license issued to you by
// Xilinx, and to the maximum extent permitted by applicable
// law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
// WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
// AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
// BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
// INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
// (2) Xilinx shall not be liable (whether in contract or tort,
// including negligence, or under any other theory of
// liability) for any loss or damage of any kind or nature
// related to, arising under or in connection with these
// materials, including for any direct, or any indirect,
// special, incidental, or consequential loss or damage
// (including loss of data, profits, goodwill, or any type of
// loss or damage suffered as a result of any action brought
// by a third party) even if such damage or loss was
// reasonably foreseeable or Xilinx had been advised of the
// possibility of the same.
// 
// CRITICAL APPLICATIONS
// Xilinx products are not designed or intended to be fail-
// safe, or for use in any application requiring fail-safe
// performance, such as life-support or safety devices or
// systems, Class III medical devices, nuclear facilities,
// applications related to the deployment of airbags, or any
// other applications that could lead to death, personal
// injury, or severe property or environmental damage
// (individually and collectively, "Critical
// Applications"). Customer assumes the sole risk and
// liability of any use of Xilinx products in Critical
// Applications, subject only to applicable laws and
// regulations governing limitations on product liability.
// 
// THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
// PART OF THIS FILE AT ALL TIMES.
// 
// DO NOT MODIFY THIS FILE.


// IP VLNV: xilinx.com:hls:MVAU_hls_0:1.0
// IP Revision: 2114489083

(* X_CORE_INFO = "MVAU_hls_0,Vivado 2022.2" *)
(* CHECK_LICENSE_TYPE = "finn_design_MVAU_hls_0_0,MVAU_hls_0,{}" *)
(* CORE_GENERATION_INFO = "finn_design_MVAU_hls_0_0,MVAU_hls_0,{x_ipProduct=Vivado 2022.2,x_ipVendor=xilinx.com,x_ipLibrary=hls,x_ipName=MVAU_hls_0,x_ipVersion=1.0,x_ipCoreRevision=2114489083,x_ipLanguage=VERILOG,x_ipSimLanguage=MIXED}" *)
(* IP_DEFINITION_SOURCE = "HLS" *)
(* DowngradeIPIdentifiedWarnings = "yes" *)
module finn_design_MVAU_hls_0_0 (
  ap_clk,
  ap_rst_n,
  in0_V_TVALID,
  in0_V_TREADY,
  in0_V_TDATA,
  weights_V_TVALID,
  weights_V_TREADY,
  weights_V_TDATA,
  out_V_TVALID,
  out_V_TREADY,
  out_V_TDATA
);

(* X_INTERFACE_PARAMETER = "XIL_INTERFACENAME ap_clk, ASSOCIATED_BUSIF in0_V:weights_V:out_V, ASSOCIATED_RESET ap_rst_n, FREQ_HZ 100000000, FREQ_TOLERANCE_HZ 0, PHASE 0.0, CLK_DOMAIN finn_design_ap_clk_0, INSERT_VIP 0" *)
(* X_INTERFACE_INFO = "xilinx.com:signal:clock:1.0 ap_clk CLK" *)
input wire ap_clk;
(* X_INTERFACE_PARAMETER = "XIL_INTERFACENAME ap_rst_n, POLARITY ACTIVE_LOW, INSERT_VIP 0" *)
(* X_INTERFACE_INFO = "xilinx.com:signal:reset:1.0 ap_rst_n RST" *)
input wire ap_rst_n;
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 in0_V TVALID" *)
input wire in0_V_TVALID;
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 in0_V TREADY" *)
output wire in0_V_TREADY;
(* X_INTERFACE_PARAMETER = "XIL_INTERFACENAME in0_V, TDATA_NUM_BYTES 1, TUSER_WIDTH 0, TDEST_WIDTH 0, TID_WIDTH 0, HAS_TREADY 1, HAS_TSTRB 0, HAS_TKEEP 0, HAS_TLAST 0, FREQ_HZ 100000000, PHASE 0.0, CLK_DOMAIN finn_design_ap_clk_0, INSERT_VIP 0" *)
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 in0_V TDATA" *)
input wire [7 : 0] in0_V_TDATA;
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 weights_V TVALID" *)
input wire weights_V_TVALID;
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 weights_V TREADY" *)
output wire weights_V_TREADY;
(* X_INTERFACE_PARAMETER = "XIL_INTERFACENAME weights_V, TDATA_NUM_BYTES 1, TUSER_WIDTH 0, TDEST_WIDTH 0, TID_WIDTH 0, HAS_TREADY 1, HAS_TSTRB 0, HAS_TKEEP 0, HAS_TLAST 0, FREQ_HZ 100000000, PHASE 0.0, CLK_DOMAIN finn_design_ap_clk_0, INSERT_VIP 0" *)
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 weights_V TDATA" *)
input wire [7 : 0] weights_V_TDATA;
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 out_V TVALID" *)
output wire out_V_TVALID;
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 out_V TREADY" *)
input wire out_V_TREADY;
(* X_INTERFACE_PARAMETER = "XIL_INTERFACENAME out_V, TDATA_NUM_BYTES 1, TUSER_WIDTH 0, TDEST_WIDTH 0, TID_WIDTH 0, HAS_TREADY 1, HAS_TSTRB 0, HAS_TKEEP 0, HAS_TLAST 0, FREQ_HZ 100000000, PHASE 0.0, CLK_DOMAIN finn_design_ap_clk_0, INSERT_VIP 0" *)
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 out_V TDATA" *)
output wire [7 : 0] out_V_TDATA;

(* SDX_KERNEL = "true" *)
(* SDX_KERNEL_TYPE = "hls" *)
(* SDX_KERNEL_SYNTH_INST = "inst" *)
  MVAU_hls_0 inst (
    .ap_clk(ap_clk),
    .ap_rst_n(ap_rst_n),
    .in0_V_TVALID(in0_V_TVALID),
    .in0_V_TREADY(in0_V_TREADY),
    .in0_V_TDATA(in0_V_TDATA),
    .weights_V_TVALID(weights_V_TVALID),
    .weights_V_TREADY(weights_V_TREADY),
    .weights_V_TDATA(weights_V_TDATA),
    .out_V_TVALID(out_V_TVALID),
    .out_V_TREADY(out_V_TREADY),
    .out_V_TDATA(out_V_TDATA)
  );
endmodule
//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/vivado_stitch_proj_w5fn6zuu/finn_vivado_stitch_proj.gen/sources_1/bd/finn_design/ipshared/18e4/hdl/verilog/MVAU_hls_0_regslice_both.v


// ==============================================================
// Vitis HLS - High-Level Synthesis from C, C++ and OpenCL v2022.2 (64-bit)
// Tool Version Limit: 2019.12
// Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.
// ==============================================================

`timescale 1ns/1ps

module MVAU_hls_0_regslice_both
#(parameter 
    DataWidth=32
)(
    input ap_clk ,
    input ap_rst,

    input [DataWidth-1:0] data_in , 
    input vld_in , 
    output ack_in ,
    output [DataWidth-1:0] data_out, 
    output vld_out,
    input ack_out,
    output apdone_blk
);
 

reg   [1:0] B_V_data_1_state;
wire   [DataWidth-1:0] B_V_data_1_data_in;
reg   [DataWidth-1:0] B_V_data_1_data_out;
wire    B_V_data_1_vld_reg;
wire    B_V_data_1_vld_in;
wire    B_V_data_1_vld_out;
reg   [DataWidth-1:0] B_V_data_1_payload_A;
reg   [DataWidth-1:0] B_V_data_1_payload_B;
reg    B_V_data_1_sel_rd;
reg    B_V_data_1_sel_wr;
wire    B_V_data_1_sel;
wire    B_V_data_1_load_A;
wire    B_V_data_1_load_B;
wire    B_V_data_1_state_cmp_full;
wire    B_V_data_1_ack_in;
wire    B_V_data_1_ack_out;

always @ (posedge ap_clk) begin
    if (ap_rst == 1'b1) begin
        B_V_data_1_sel_rd <= 1'b0;
    end else begin
        if (((1'b1 == B_V_data_1_vld_out) & (1'b1 == B_V_data_1_ack_out))) begin
            B_V_data_1_sel_rd <= ~B_V_data_1_sel_rd;
        end else begin
            B_V_data_1_sel_rd <= B_V_data_1_sel_rd;
        end
    end
end

always @ (posedge ap_clk) begin
    if (ap_rst == 1'b1) begin
        B_V_data_1_sel_wr <= 1'b0;
    end else begin
        if (((1'b1 == B_V_data_1_vld_in) & (1'b1 == B_V_data_1_ack_in))) begin
            B_V_data_1_sel_wr <= ~B_V_data_1_sel_wr;
        end else begin
            B_V_data_1_sel_wr <= B_V_data_1_sel_wr;
        end
    end
end

always @ (posedge ap_clk) begin
    if (ap_rst == 1'b1) begin
        B_V_data_1_state <= 2'd0;
    end else begin
        if ((((2'd3 == B_V_data_1_state) & (1'b0 == B_V_data_1_vld_in) & (1'b1 == B_V_data_1_ack_out)) | ((2'd2 == B_V_data_1_state) & (1'b0 == B_V_data_1_vld_in)))) begin
            B_V_data_1_state <= 2'd2;
        end else if ((((2'd1 == B_V_data_1_state) & (1'b0 == B_V_data_1_ack_out)) | ((2'd3 == B_V_data_1_state) & (1'b0 == B_V_data_1_ack_out) & (1'b1 == B_V_data_1_vld_in)))) begin
            B_V_data_1_state <= 2'd1;
        end else if ((((2'd1 == B_V_data_1_state) & (1'b1 == B_V_data_1_ack_out)) | (~((1'b0 == B_V_data_1_ack_out) & (1'b1 == B_V_data_1_vld_in)) & ~((1'b0 == B_V_data_1_vld_in) & (1'b1 == B_V_data_1_ack_out)) & (2'd3 == B_V_data_1_state)) | ((2'd2 == B_V_data_1_state) & (1'b1 == B_V_data_1_vld_in)))) begin
            B_V_data_1_state <= 2'd3;
        end else begin
            B_V_data_1_state <= 2'd2;
        end
    end
end

always @ (posedge ap_clk) begin
    if ((1'b1 == B_V_data_1_load_A)) begin
        B_V_data_1_payload_A <= B_V_data_1_data_in;
    end
end

always @ (posedge ap_clk) begin
    if ((1'b1 == B_V_data_1_load_B)) begin
        B_V_data_1_payload_B <= B_V_data_1_data_in;
    end
end

always @ (*) begin
    if ((1'b1 == B_V_data_1_sel)) begin
        B_V_data_1_data_out = B_V_data_1_payload_B;
    end else begin
        B_V_data_1_data_out = B_V_data_1_payload_A;
    end
end

assign B_V_data_1_ack_in = B_V_data_1_state[1'd1];
assign B_V_data_1_load_A = (~B_V_data_1_sel_wr & B_V_data_1_state_cmp_full);
assign B_V_data_1_load_B = (B_V_data_1_state_cmp_full & B_V_data_1_sel_wr);
assign B_V_data_1_sel = B_V_data_1_sel_rd;
assign B_V_data_1_state_cmp_full = ((B_V_data_1_state != 2'd1) ? 1'b1 : 1'b0);
assign B_V_data_1_vld_out = B_V_data_1_state[1'd0];

assign ack_in = B_V_data_1_ack_in;
assign B_V_data_1_data_in = data_in;
assign B_V_data_1_vld_in = vld_in;

assign vld_out = B_V_data_1_vld_out;
assign data_out = B_V_data_1_data_out;
assign B_V_data_1_ack_out = ack_out;

assign apdone_blk = ((B_V_data_1_state == 2'd3 && ack_out == 1'b0) | (B_V_data_1_state == 2'd1));

endmodule // both

module MVAU_hls_0_regslice_both_w1
#(parameter 
    DataWidth=1
)(
    input ap_clk ,
    input ap_rst,

    input data_in , 
    input vld_in , 
    output ack_in ,
    output data_out, 
    output vld_out,
    input ack_out,
    output apdone_blk
);

reg     [1:0] B_V_data_1_state;
wire    B_V_data_1_data_in;
reg     B_V_data_1_data_out;
wire    B_V_data_1_vld_reg;
wire    B_V_data_1_vld_in;
wire    B_V_data_1_vld_out;
reg     B_V_data_1_payload_A;
reg     B_V_data_1_payload_B;
reg     B_V_data_1_sel_rd;
reg     B_V_data_1_sel_wr;
wire    B_V_data_1_sel;
wire    B_V_data_1_load_A;
wire    B_V_data_1_load_B;
wire    B_V_data_1_state_cmp_full;
wire    B_V_data_1_ack_in;
wire    B_V_data_1_ack_out;

always @ (posedge ap_clk) begin
    if (ap_rst == 1'b1) begin
        B_V_data_1_sel_rd <= 1'b0;
    end else begin
        if (((1'b1 == B_V_data_1_vld_out) & (1'b1 == B_V_data_1_ack_out))) begin
            B_V_data_1_sel_rd <= ~B_V_data_1_sel_rd;
        end else begin
            B_V_data_1_sel_rd <= B_V_data_1_sel_rd;
        end
    end
end

always @ (posedge ap_clk) begin
    if (ap_rst == 1'b1) begin
        B_V_data_1_sel_wr <= 1'b0;
    end else begin
        if (((1'b1 == B_V_data_1_vld_in) & (1'b1 == B_V_data_1_ack_in))) begin
            B_V_data_1_sel_wr <= ~B_V_data_1_sel_wr;
        end else begin
            B_V_data_1_sel_wr <= B_V_data_1_sel_wr;
        end
    end
end

always @ (posedge ap_clk) begin
    if (ap_rst == 1'b1) begin
        B_V_data_1_state <= 2'd0;
    end else begin
        if ((((2'd3 == B_V_data_1_state) & (1'b0 == B_V_data_1_vld_in) & (1'b1 == B_V_data_1_ack_out)) | ((2'd2 == B_V_data_1_state) & (1'b0 == B_V_data_1_vld_in)))) begin
            B_V_data_1_state <= 2'd2;
        end else if ((((2'd1 == B_V_data_1_state) & (1'b0 == B_V_data_1_ack_out)) | ((2'd3 == B_V_data_1_state) & (1'b0 == B_V_data_1_ack_out) & (1'b1 == B_V_data_1_vld_in)))) begin
            B_V_data_1_state <= 2'd1;
        end else if ((((2'd1 == B_V_data_1_state) & (1'b1 == B_V_data_1_ack_out)) | (~((1'b0 == B_V_data_1_ack_out) & (1'b1 == B_V_data_1_vld_in)) & ~((1'b0 == B_V_data_1_vld_in) & (1'b1 == B_V_data_1_ack_out)) & (2'd3 == B_V_data_1_state)) | ((2'd2 == B_V_data_1_state) & (1'b1 == B_V_data_1_vld_in)))) begin
            B_V_data_1_state <= 2'd3;
        end else begin
            B_V_data_1_state <= 2'd2;
        end
    end
end

always @ (posedge ap_clk) begin
    if ((1'b1 == B_V_data_1_load_A)) begin
        B_V_data_1_payload_A <= B_V_data_1_data_in;
    end
end

always @ (posedge ap_clk) begin
    if ((1'b1 == B_V_data_1_load_B)) begin
        B_V_data_1_payload_B <= B_V_data_1_data_in;
    end
end

always @ (*) begin
    if ((1'b1 == B_V_data_1_sel)) begin
        B_V_data_1_data_out = B_V_data_1_payload_B;
    end else begin
        B_V_data_1_data_out = B_V_data_1_payload_A;
    end
end

assign B_V_data_1_ack_in = B_V_data_1_state[1'd1];
assign B_V_data_1_load_A = (~B_V_data_1_sel_wr & B_V_data_1_state_cmp_full);
assign B_V_data_1_load_B = (B_V_data_1_state_cmp_full & B_V_data_1_sel_wr);
assign B_V_data_1_sel = B_V_data_1_sel_rd;
assign B_V_data_1_state_cmp_full = ((B_V_data_1_state != 2'd1) ? 1'b1 : 1'b0);
assign B_V_data_1_vld_out = B_V_data_1_state[1'd0];

assign ack_in = B_V_data_1_ack_in;
assign B_V_data_1_data_in = data_in;
assign B_V_data_1_vld_in = vld_in;

assign vld_out = B_V_data_1_vld_out;
assign data_out = B_V_data_1_data_out;
assign B_V_data_1_ack_out = ack_out;

assign apdone_blk = ((B_V_data_1_state == 2'd3 && ack_out == 1'b0) | (B_V_data_1_state == 2'd1));

endmodule // both


//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/code_gen_ipgen_FMPadding_rtl_0_e702v3yh/fmpadding.sv


/******************************************************************************
 * Copyright (C) 2022, Advanced Micro Devices, Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *  1. Redistributions of source code must retain the above copyright notice,
 *     this list of conditions and the following disclaimer.
 *
 *  2. Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *
 *  3. Neither the name of the copyright holder nor the names of its
 *     contributors may be used to endorse or promote products derived from
 *     this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION). HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * @brief	Feature map padding.
 * @author	Thomas B. Preuer <tpreusse@amd.com>
 *****************************************************************************/

module fmpadding #(
	int unsigned  XCOUNTER_BITS,
	int unsigned  YCOUNTER_BITS,
	int unsigned  NUM_CHANNELS,
	int unsigned  SIMD,
	int unsigned  ELEM_BITS,
	int unsigned  INIT_XON,
	int unsigned  INIT_XOFF,
	int unsigned  INIT_XEND,
	int unsigned  INIT_YON,
	int unsigned  INIT_YOFF,
	int unsigned  INIT_YEND,

	localparam int unsigned  STREAM_BITS = 8*(1 + (SIMD*ELEM_BITS-1)/8)
)(
	//- Global Control ------------------
	input	logic  ap_clk,
	input	logic  ap_rst_n,

	// Parameter Configuration ----------
	input	logic         we,
	input	logic [ 4:0]  wa,
	input	logic [31:0]  wd,

	//- AXI Stream - Input --------------
	output	logic  s_axis_tready,
	input	logic  s_axis_tvalid,
	input	logic [STREAM_BITS-1:0]  s_axis_tdata,

	//- AXI Stream - Output -------------
	input	logic  m_axis_tready,
	output	logic  m_axis_tvalid,
	output	logic [STREAM_BITS-1:0]  m_axis_tdata
);

	uwire  clk = ap_clk;
	uwire  rst = !ap_rst_n;

	//-----------------------------------------------------------------------
	// Parameter Sanity Checking
	initial begin
		automatic bit  fail = 0;

		if(XCOUNTER_BITS < $clog2(1+INIT_XEND)) begin
			$error("XCounter size too small to accommodate end count.");
			fail = 1;
		end
		if(XCOUNTER_BITS < $clog2(1+INIT_XON)) begin
			$error("XCounter size too small to accommodate ON count.");
			fail = 1;
		end
		if(XCOUNTER_BITS < $clog2(1+INIT_XOFF)) begin
			$error("XCounter size too small to accommodate OFF count.");
			fail = 1;
		end
		if(YCOUNTER_BITS < $clog2(1+INIT_YEND)) begin
			$error("YCounter size too small to accommodate end count.");
			fail = 1;
		end
		if(YCOUNTER_BITS < $clog2(1+INIT_YON)) begin
			$error("YCounter size too small to accommodate ON count.");
			fail = 1;
		end
		if(YCOUNTER_BITS < $clog2(1+INIT_YOFF)) begin
			$error("YCounter size too small to accommodate OFF count.");
			fail = 1;
		end

		if((INIT_XEND < INIT_XON) || (INIT_XOFF <= INIT_XON)) begin
			$warning("Initial empty X output range.");
		end
		if((INIT_YEND < INIT_YON) || (INIT_YOFF <= INIT_YON)) begin
			$warning("Initial empty Y output range.");
		end

		if(fail)  $finish();
	end

	//-----------------------------------------------------------------------
	// Dynamically configurable state
	typedef logic [XCOUNTER_BITS-1:0]  xcount_t;
	xcount_t  XEnd = INIT_XEND;
	xcount_t  XOn  = INIT_XON;
	xcount_t  XOff = INIT_XOFF;

	typedef logic [YCOUNTER_BITS-1:0]  ycount_t;
	ycount_t  YEnd = INIT_YEND;
	ycount_t  YOn  = INIT_YON;
	ycount_t  YOff = INIT_YOFF;

	always_ff @(posedge clk) begin
		if(we) begin
			unique case(wa)
			0*4:  XOn  <= wd;
			1*4:  XOff <= wd;
			2*4:  XEnd <= wd;
			3*4:  YOn  <= wd;
			4*4:  YOff <= wd;
			5*4:  YEnd <= wd;

			default:  assert(0) else begin
				$error("Illegal write address.");
				$stop;
			end
			endcase
		end
	end

	//-----------------------------------------------------------------------
	// Cascaded enables for the nested counters: SCount, XCount, YCount
	uwire  sen;
	uwire  xen;
	uwire  yen;

	//- S-Counter: SIMD fold ------------
	initial begin
		if((NUM_CHANNELS < 1) || (NUM_CHANNELS % SIMD != 0)) begin
			$error("Channel count must be SIMD multiple.");
			$finish;
		end
	end
	// Count SF-2, SF-3, ..., 1, 0, -1
	localparam int unsigned  SF = NUM_CHANNELS/SIMD;
	typedef logic [$clog2(SF-1):0]  scount_t;
	scount_t  SCount = SF-2;

	assign	xen = sen && SCount[$left(SCount)];
	uwire  sclr = rst || xen;
	always_ff @(posedge clk) begin
		if(sclr)      SCount <= SF-2;
		else if(sen)  SCount <= SCount - 1;
	end

	//- X-Counter: image width ----------
	xcount_t  XCount = 0;

	assign	yen = xen && (XCount == XEnd);
	uwire  xclr = rst || yen;
	always_ff @(posedge clk) begin
		if(xclr)      XCount <= 0;
		else if(xen)  XCount <= XCount + 1;
	end
	uwire  xfwd = (XOn <= XCount) && (XCount < XOff);

	//- Y-Counter: image height ---------
	ycount_t  YCount = 0;

	uwire  yclr = rst || (yen && (YCount == YEnd));
	always_ff @(posedge clk) begin
		if(yclr)      YCount <= 0;
		else if(yen)  YCount <= YCount + 1;
	end
	uwire  yfwd = (YOn <= YCount) && (YCount < YOff);

	//-----------------------------------------------------------------------
	// Input forwarding and edge padding
	typedef struct {
		logic  vld;
		logic [STREAM_BITS-1:0]  dat;
	} buf_t;
	buf_t  A = '{ vld: 0, dat: 'x };
	buf_t  B = '{ vld: 0, dat: 'x };

	uwire  fwd = xfwd && yfwd;
	assign	sen = (m_axis_tready || !B.vld) && (s_axis_tvalid || A.vld || !fwd);
	assign	s_axis_tready = !A.vld;
	assign	m_axis_tvalid =  B.vld;
	assign	m_axis_tdata  =  B.dat;

	always_ff @(posedge clk) begin
		if(rst) begin
			B <= '{ vld: 0, dat: 'x };
		end
		else if(m_axis_tready || !B.vld) begin
			B.vld <= s_axis_tvalid || A.vld || !fwd;
			B.dat <= !fwd? '0 : A.vld? A.dat : s_axis_tdata;
		end
	end

	always_ff @(posedge clk) begin
		if(rst) begin
			A <= '{ vld: 0, dat: 'x };
		end
		else begin
			A.vld <= (A.vld || s_axis_tvalid) && ((B.vld && !m_axis_tready) || !fwd);
			if(!A.vld)  A.dat <= s_axis_tdata;
		end
	end

endmodule : fmpadding
//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/code_gen_ipgen_ConvolutionInputGenerator_rtl_1_6arfz_kp/ConvolutionInputGenerator_rtl_1_impl.sv


/******************************************************************************
 * Copyright (C) 2022, Advanced Micro Devices, Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *  1. Redistributions of source code must retain the above copyright notice,
 *     this list of conditions and the following disclaimer.
 *
 *  2. Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *
 *  3. Neither the name of the copyright holder nor the names of its
 *     contributors may be used to endorse or promote products derived from
 *     this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION). HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *****************************************************************************/
module ConvolutionInputGenerator_rtl_1_impl #(
    int  BIT_WIDTH,
    int  SIMD,
    int  MMV_IN,
    int  MMV_OUT,
    int  LAST_READ_ELEM = 4095,
    int  LAST_WRITE_ELEM = 4095,
    int  BUF_ELEM_TOTAL = 560,
    int  ELEM_PER_WINDOW = 144,
    int  INCR_BITWIDTH = 11
)(
    input   logic  ap_clk,
    input   logic  ap_rst_n,

    input   logic  in0_V_V_TVALID,
    output  logic  in0_V_V_TREADY,
    input   logic [BIT_WIDTH * SIMD * MMV_IN-1:0]  in0_V_V_TDATA,

    output  logic  out_V_V_TVALID,
    input   logic  out_V_V_TREADY,
    output  logic [BIT_WIDTH * SIMD * MMV_OUT-1:0]  out_V_V_TDATA
);
    // derived constants
    localparam int unsigned  BUF_IN_WIDTH = BIT_WIDTH * SIMD * MMV_IN;
    localparam int unsigned  BUF_OUT_ELEM_WIDTH = BIT_WIDTH * SIMD;
    localparam int unsigned  BUF_OUT_WIDTH = BIT_WIDTH * SIMD * MMV_OUT;

   // main buffer instantiation
    uwire [BUF_IN_WIDTH -1:0]  window_buffer_in;
    uwire [BUF_OUT_WIDTH-1:0]  window_buffer_out;
    uwire  window_buffer_write_enable;
    uwire  window_buffer_read_enable;
    uwire [$clog2(BUF_ELEM_TOTAL)-1:0]  window_buffer_write_addr;
    uwire [$clog2(BUF_ELEM_TOTAL)-1:0]  window_buffer_read_addr;
    swg_cyclic_buffer_addressable #(
        .WIDTH(BUF_IN_WIDTH),
        .DEPTH(BUF_ELEM_TOTAL),
        .RAM_STYLE("distributed")
    ) window_buffer_inst (
        .clk(ap_clk),

        .write_enable(window_buffer_write_enable),
        .write_addr(window_buffer_write_addr),
        .data_in(window_buffer_in),

        .read_enable(window_buffer_read_enable),
        .read_addr(window_buffer_read_addr),
        .data_out(window_buffer_out)
    );

    //controller instantiation
    uwire  advance_controller;
    uwire signed [INCR_BITWIDTH-1:0]  addr_incr;
    uwire        [INCR_BITWIDTH-1:0]  tail_incr;
    swg_controller #(
        .LOOP_H_ITERATIONS(12),
        .LOOP_W_ITERATIONS(12),
        .LOOP_KH_ITERATIONS(1),
        .LOOP_KW_ITERATIONS(1),
        .LOOP_SIMD_ITERATIONS(13),
        .HEAD_INCR_SIMD(1),
        .HEAD_INCR_KW(1),
        .HEAD_INCR_KH(209),
        .HEAD_INCR_W(-543),
        .HEAD_INCR_H(-511),
        .TAIL_INCR_W(16),
        .TAIL_INCR_H(48),
        .TAIL_INCR_LAST(559),
        .INCR_BITWIDTH(11),
        .IS_DEPTHWISE(0),
        .INNERMOST_STATE(swg::STATE_LOOP_SIMD)
    )
    controller_inst (
        .clk(ap_clk),
        .rst_n(ap_rst_n),
        .advance(advance_controller),
        .addr_incr(addr_incr),
        .tail_incr(tail_incr)
    );

    // Counters/address registers
    // Add a sign bit even to (most) unsigned counters and Window_buffer_read_addr_reg,
    // so we can use automatic sign extension and simplify calculations w/ signed increment.
    // Alternatively, we could manually sign-extend and shave off a bit here or there.
    logic signed [$clog2(LAST_READ_ELEM+1)+1-1:0]  Newest_buffered_elem = -1;
    logic        [$clog2(LAST_READ_ELEM+1)+1-1:0]  Current_elem = 0;
    logic        [$clog2(LAST_READ_ELEM+1)+1-1:0]  First_elem_next_window = 0;
    logic        [$clog2(ELEM_PER_WINDOW)   -1:0]  Position_in_window = 0;
    logic        [$clog2(BUF_ELEM_TOTAL)+1  -1:0]  Window_buffer_read_addr_reg = 0;
    logic        [$clog2(BUF_ELEM_TOTAL)-1:0]      Window_buffer_write_addr_reg = 0;

    // Control signals/registers
    logic  Write_cmd    = 0;
    logic  Writing_done = 0;
    uwire  write_ok      = Write_cmd &&  out_V_V_TREADY;
    uwire  write_blocked = Write_cmd && !out_V_V_TREADY;

    logic  Fetching_done = 0;
    uwire  fetch_cmd = !($signed(Current_elem) > Newest_buffered_elem) && !write_blocked && !Fetching_done;

    uwire  reading_done = Newest_buffered_elem == LAST_READ_ELEM;
    uwire  read_cmd =
        !reading_done && ( // if there is still an input element left to read
            Fetching_done || ( // if fetching is done (e.g. for skipped rows at FM end due to stride)
                $signed(((Newest_buffered_elem - (BUF_ELEM_TOTAL - 1)))) < $signed(First_elem_next_window) &&
                $signed(((Newest_buffered_elem - (BUF_ELEM_TOTAL - 1)))) < $signed(Current_elem)
            ) // (over-)write to buffer if oldest buffered element will no longer be needed
        );
    uwire  read_ok      = read_cmd && in0_V_V_TVALID;

    //assign buffer control
    assign  window_buffer_write_addr = Window_buffer_write_addr_reg;
    assign  window_buffer_read_addr = Window_buffer_read_addr_reg;
    assign  window_buffer_write_enable = read_ok;
    assign  window_buffer_read_enable = fetch_cmd;
    assign  advance_controller = fetch_cmd;

    //assign I/O ports
    assign  window_buffer_in = in0_V_V_TDATA;
    assign  out_V_V_TDATA = window_buffer_out;
    assign  in0_V_V_TREADY = ap_rst_n && read_ok; //only asserted if data is available and we can store it (allowed)
    assign  out_V_V_TVALID = ap_rst_n && Write_cmd; //only asserted if we have data available and it has not been read yet (don't wait for READY from sink)

    //main process for advancing counters
    always_ff @(posedge ap_clk) begin
        if(!ap_rst_n) begin
            Newest_buffered_elem <= -1;
            Current_elem <= 0;
            First_elem_next_window <= 0;
            Position_in_window <= 0;
            Window_buffer_read_addr_reg <= 0;
            Window_buffer_write_addr_reg <= 0;
            Fetching_done <= 0;
            Write_cmd <= 0;
            Writing_done <= 0;
        end
        else begin
            if (read_ok) begin
                Window_buffer_write_addr_reg <= (Window_buffer_write_addr_reg == BUF_ELEM_TOTAL-1)? 0 : Window_buffer_write_addr_reg + 1;
                Newest_buffered_elem <= Newest_buffered_elem+1;

                if (Newest_buffered_elem == LAST_READ_ELEM-1) begin
                    Window_buffer_write_addr_reg <= 0;
                end
                //check if this is the last read cycle (reading_done will be true afterwards)
                if ((Newest_buffered_elem == LAST_READ_ELEM-1) && Writing_done) begin
                    //start processing of next FM if writing is done already (possible due to unused input elements at the tail end)
                    //todo: allow for read overlapping between feature maps (i.e., reading first elements from next FM while still writing last window of current FM)
                    Newest_buffered_elem <= -1;
                    Current_elem <= 0;
                    Window_buffer_read_addr_reg <= 0;
                    First_elem_next_window <= 0;
                    Writing_done <= 0;
                    Fetching_done <= 0;
                end
            end

            if (fetch_cmd) begin
                //count up to track which element index is about to be read from the buffer, and where it is located within the buffer
                //use increment value calculated by controller

                // absolute buffer address wrap-around
                automatic logic signed [$clog2(BUF_ELEM_TOTAL)+1:0]  ra = $signed(Window_buffer_read_addr_reg) + $signed(addr_incr);
                automatic logic signed [$clog2(BUF_ELEM_TOTAL+1):0]  ra_correct =
                    (ra >= BUF_ELEM_TOTAL)? -BUF_ELEM_TOTAL :
                    (ra <               0)?  BUF_ELEM_TOTAL : 0;
                Window_buffer_read_addr_reg <= ra + ra_correct;

                //keep track where we are within a window
                Position_in_window <= (Position_in_window != ELEM_PER_WINDOW - 1)? Position_in_window+1 : 0;

                //update first element of next window to allow buffer overwrite up until that point
                if (Position_in_window == 0)
                    First_elem_next_window <= First_elem_next_window + tail_incr;

                //check if this is the last write cycle (Writing_done will be true afterwards)
                if (Current_elem == LAST_WRITE_ELEM)
                    Fetching_done <= 1;
                else
                    Current_elem <= $signed(Current_elem) + addr_incr;

                // determine if prefetched data will be outstanding in the next cycle
                // if we fetch in this cycle -> yes
                // if we do not fetch nor write -> do not change
                // if we do not fetch but write successfully-> clear outstanding data
                Write_cmd <= fetch_cmd;
            end

            if (write_ok)
                Write_cmd <= fetch_cmd;

            if (write_ok && Fetching_done) begin
                //check if this is the last write cycle (Writing_done will be true afterwards)
                if (reading_done || (read_ok && (Newest_buffered_elem == LAST_READ_ELEM - 1))) begin
                    //start processing of next FM if reading is done already, or completes in the same cycle
                    Newest_buffered_elem <= -1;
                    Current_elem <= 0;
                    Window_buffer_read_addr_reg <= 0;
                    First_elem_next_window <= 0;
                    Fetching_done <= 0;
                end else
                    Writing_done <= 1;
            end
        end
    end

endmodule : ConvolutionInputGenerator_rtl_1_impl
//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/vivado_stitch_proj_w5fn6zuu/finn_vivado_stitch_proj.gen/sources_1/bd/finn_design/ipshared/4d6a/hdl/verilog/StreamingMaxPool_hls_1.v


// ==============================================================
// RTL generated by Vitis HLS - High-Level Synthesis from C, C++ and OpenCL v2022.2 (64-bit)
// Version: 2022.2
// Copyright (C) Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.
// 
// ===========================================================

`timescale 1 ns / 1 ps 

(* CORE_GENERATION_INFO="StreamingMaxPool_hls_1_StreamingMaxPool_hls_1,hls_ip_2022_2,{HLS_INPUT_TYPE=cxx,HLS_INPUT_FLOAT=0,HLS_INPUT_FIXED=0,HLS_INPUT_PART=xc7z010-clg400-1,HLS_INPUT_CLOCK=10.000000,HLS_INPUT_ARCH=others,HLS_SYN_CLOCK=6.236000,HLS_SYN_LAT=882,HLS_SYN_TPT=none,HLS_SYN_MEM=0,HLS_SYN_DSP=0,HLS_SYN_FF=441,HLS_SYN_LUT=4283,HLS_VERSION=2022_2}" *)

module StreamingMaxPool_hls_1 (
        ap_clk,
        ap_rst_n,
        in0_V_TDATA,
        in0_V_TVALID,
        in0_V_TREADY,
        out_V_TDATA,
        out_V_TVALID,
        out_V_TREADY
);

parameter    ap_ST_fsm_state1 = 4'd1;
parameter    ap_ST_fsm_state2 = 4'd2;
parameter    ap_ST_fsm_state3 = 4'd4;
parameter    ap_ST_fsm_state4 = 4'd8;

input   ap_clk;
input   ap_rst_n;
input  [127:0] in0_V_TDATA;
input   in0_V_TVALID;
output   in0_V_TREADY;
output  [127:0] out_V_TDATA;
output   out_V_TVALID;
input   out_V_TREADY;

 reg    ap_rst_n_inv;
wire    grp_StreamingMaxPool_Precision_14u_2u_32u_ap_uint_4_0_128_s_fu_28_ap_start;
wire    grp_StreamingMaxPool_Precision_14u_2u_32u_ap_uint_4_0_128_s_fu_28_ap_done;
wire    grp_StreamingMaxPool_Precision_14u_2u_32u_ap_uint_4_0_128_s_fu_28_ap_idle;
wire    grp_StreamingMaxPool_Precision_14u_2u_32u_ap_uint_4_0_128_s_fu_28_ap_ready;
wire    grp_StreamingMaxPool_Precision_14u_2u_32u_ap_uint_4_0_128_s_fu_28_in0_V_TREADY;
wire   [127:0] grp_StreamingMaxPool_Precision_14u_2u_32u_ap_uint_4_0_128_s_fu_28_out_V_TDATA;
wire    grp_StreamingMaxPool_Precision_14u_2u_32u_ap_uint_4_0_128_s_fu_28_out_V_TVALID;
wire    grp_StreamingMaxPool_Precision_14u_2u_32u_ap_uint_4_0_128_s_fu_28_out_V_TREADY;
reg    grp_StreamingMaxPool_Precision_14u_2u_32u_ap_uint_4_0_128_s_fu_28_ap_start_reg;
(* fsm_encoding = "none" *) reg   [3:0] ap_CS_fsm;
wire    ap_CS_fsm_state2;
wire    ap_CS_fsm_state3;
reg   [3:0] ap_NS_fsm;
wire    ap_ST_fsm_state1_blk;
wire    ap_ST_fsm_state2_blk;
reg    ap_ST_fsm_state3_blk;
reg    ap_ST_fsm_state4_blk;
wire    regslice_both_out_V_U_apdone_blk;
wire    ap_CS_fsm_state4;
wire    regslice_both_in0_V_U_apdone_blk;
wire   [127:0] in0_V_TDATA_int_regslice;
wire    in0_V_TVALID_int_regslice;
reg    in0_V_TREADY_int_regslice;
wire    regslice_both_in0_V_U_ack_in;
wire    out_V_TREADY_int_regslice;
wire    regslice_both_out_V_U_vld_out;
wire    ap_ce_reg;

// power-on initialization
initial begin
#0 grp_StreamingMaxPool_Precision_14u_2u_32u_ap_uint_4_0_128_s_fu_28_ap_start_reg = 1'b0;
#0 ap_CS_fsm = 4'd1;
end

StreamingMaxPool_hls_1_StreamingMaxPool_Precision_14u_2u_32u_ap_uint_4_0_128_s grp_StreamingMaxPool_Precision_14u_2u_32u_ap_uint_4_0_128_s_fu_28(
    .ap_clk(ap_clk),
    .ap_rst(ap_rst_n_inv),
    .ap_start(grp_StreamingMaxPool_Precision_14u_2u_32u_ap_uint_4_0_128_s_fu_28_ap_start),
    .ap_done(grp_StreamingMaxPool_Precision_14u_2u_32u_ap_uint_4_0_128_s_fu_28_ap_done),
    .ap_idle(grp_StreamingMaxPool_Precision_14u_2u_32u_ap_uint_4_0_128_s_fu_28_ap_idle),
    .ap_ready(grp_StreamingMaxPool_Precision_14u_2u_32u_ap_uint_4_0_128_s_fu_28_ap_ready),
    .in0_V_TDATA(in0_V_TDATA_int_regslice),
    .in0_V_TVALID(in0_V_TVALID_int_regslice),
    .in0_V_TREADY(grp_StreamingMaxPool_Precision_14u_2u_32u_ap_uint_4_0_128_s_fu_28_in0_V_TREADY),
    .out_V_TDATA(grp_StreamingMaxPool_Precision_14u_2u_32u_ap_uint_4_0_128_s_fu_28_out_V_TDATA),
    .out_V_TVALID(grp_StreamingMaxPool_Precision_14u_2u_32u_ap_uint_4_0_128_s_fu_28_out_V_TVALID),
    .out_V_TREADY(grp_StreamingMaxPool_Precision_14u_2u_32u_ap_uint_4_0_128_s_fu_28_out_V_TREADY)
);

StreamingMaxPool_hls_1_regslice_both #(
    .DataWidth( 128 ))
regslice_both_in0_V_U(
    .ap_clk(ap_clk),
    .ap_rst(ap_rst_n_inv),
    .data_in(in0_V_TDATA),
    .vld_in(in0_V_TVALID),
    .ack_in(regslice_both_in0_V_U_ack_in),
    .data_out(in0_V_TDATA_int_regslice),
    .vld_out(in0_V_TVALID_int_regslice),
    .ack_out(in0_V_TREADY_int_regslice),
    .apdone_blk(regslice_both_in0_V_U_apdone_blk)
);

StreamingMaxPool_hls_1_regslice_both #(
    .DataWidth( 128 ))
regslice_both_out_V_U(
    .ap_clk(ap_clk),
    .ap_rst(ap_rst_n_inv),
    .data_in(grp_StreamingMaxPool_Precision_14u_2u_32u_ap_uint_4_0_128_s_fu_28_out_V_TDATA),
    .vld_in(grp_StreamingMaxPool_Precision_14u_2u_32u_ap_uint_4_0_128_s_fu_28_out_V_TVALID),
    .ack_in(out_V_TREADY_int_regslice),
    .data_out(out_V_TDATA),
    .vld_out(regslice_both_out_V_U_vld_out),
    .ack_out(out_V_TREADY),
    .apdone_blk(regslice_both_out_V_U_apdone_blk)
);

always @ (posedge ap_clk) begin
    if (ap_rst_n_inv == 1'b1) begin
        ap_CS_fsm <= ap_ST_fsm_state1;
    end else begin
        ap_CS_fsm <= ap_NS_fsm;
    end
end

always @ (posedge ap_clk) begin
    if (ap_rst_n_inv == 1'b1) begin
        grp_StreamingMaxPool_Precision_14u_2u_32u_ap_uint_4_0_128_s_fu_28_ap_start_reg <= 1'b0;
    end else begin
        if ((1'b1 == ap_CS_fsm_state2)) begin
            grp_StreamingMaxPool_Precision_14u_2u_32u_ap_uint_4_0_128_s_fu_28_ap_start_reg <= 1'b1;
        end else if ((grp_StreamingMaxPool_Precision_14u_2u_32u_ap_uint_4_0_128_s_fu_28_ap_ready == 1'b1)) begin
            grp_StreamingMaxPool_Precision_14u_2u_32u_ap_uint_4_0_128_s_fu_28_ap_start_reg <= 1'b0;
        end
    end
end

assign ap_ST_fsm_state1_blk = 1'b0;

assign ap_ST_fsm_state2_blk = 1'b0;

always @ (*) begin
    if ((grp_StreamingMaxPool_Precision_14u_2u_32u_ap_uint_4_0_128_s_fu_28_ap_done == 1'b0)) begin
        ap_ST_fsm_state3_blk = 1'b1;
    end else begin
        ap_ST_fsm_state3_blk = 1'b0;
    end
end

always @ (*) begin
    if ((regslice_both_out_V_U_apdone_blk == 1'b1)) begin
        ap_ST_fsm_state4_blk = 1'b1;
    end else begin
        ap_ST_fsm_state4_blk = 1'b0;
    end
end

always @ (*) begin
    if ((1'b1 == ap_CS_fsm_state3)) begin
        in0_V_TREADY_int_regslice = grp_StreamingMaxPool_Precision_14u_2u_32u_ap_uint_4_0_128_s_fu_28_in0_V_TREADY;
    end else begin
        in0_V_TREADY_int_regslice = 1'b0;
    end
end

always @ (*) begin
    case (ap_CS_fsm)
        ap_ST_fsm_state1 : begin
            ap_NS_fsm = ap_ST_fsm_state2;
        end
        ap_ST_fsm_state2 : begin
            ap_NS_fsm = ap_ST_fsm_state3;
        end
        ap_ST_fsm_state3 : begin
            if (((grp_StreamingMaxPool_Precision_14u_2u_32u_ap_uint_4_0_128_s_fu_28_ap_done == 1'b1) & (1'b1 == ap_CS_fsm_state3))) begin
                ap_NS_fsm = ap_ST_fsm_state4;
            end else begin
                ap_NS_fsm = ap_ST_fsm_state3;
            end
        end
        ap_ST_fsm_state4 : begin
            if (((regslice_both_out_V_U_apdone_blk == 1'b0) & (1'b1 == ap_CS_fsm_state4))) begin
                ap_NS_fsm = ap_ST_fsm_state1;
            end else begin
                ap_NS_fsm = ap_ST_fsm_state4;
            end
        end
        default : begin
            ap_NS_fsm = 'bx;
        end
    endcase
end

assign ap_CS_fsm_state2 = ap_CS_fsm[32'd1];

assign ap_CS_fsm_state3 = ap_CS_fsm[32'd2];

assign ap_CS_fsm_state4 = ap_CS_fsm[32'd3];

always @ (*) begin
    ap_rst_n_inv = ~ap_rst_n;
end

assign grp_StreamingMaxPool_Precision_14u_2u_32u_ap_uint_4_0_128_s_fu_28_ap_start = grp_StreamingMaxPool_Precision_14u_2u_32u_ap_uint_4_0_128_s_fu_28_ap_start_reg;

assign grp_StreamingMaxPool_Precision_14u_2u_32u_ap_uint_4_0_128_s_fu_28_out_V_TREADY = (out_V_TREADY_int_regslice & ap_CS_fsm_state3);

assign in0_V_TREADY = regslice_both_in0_V_U_ack_in;

assign out_V_TVALID = regslice_both_out_V_U_vld_out;

endmodule //StreamingMaxPool_hls_1
//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/vivado_stitch_proj_w5fn6zuu/finn_vivado_stitch_proj.gen/sources_1/bd/finn_design/ipshared/18e4/hdl/verilog/MVAU_hls_0_flow_control_loop_pipe_sequential_init.v


// ==============================================================
// Vitis HLS - High-Level Synthesis from C, C++ and OpenCL v2022.2 (64-bit)
// Tool Version Limit: 2019.12
// Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.
// ==============================================================

`timescale 1 ns / 1 ps

module MVAU_hls_0_flow_control_loop_pipe_sequential_init(
        ap_clk,
        ap_rst,
        ap_start,
        ap_ready,
        ap_done,
        ap_start_int,
        ap_ready_int,
        ap_done_int,
        ap_continue_int,
        ap_loop_init,
        ap_loop_exit_ready,
        ap_loop_exit_done
);

input   ap_clk;
input   ap_rst;

//Block level handshake with outside loop
input   ap_start;
output  ap_ready;
output  ap_done;

//Block level handshake with loop body
output  ap_start_int;
input   ap_ready_int;
input   ap_done_int;
output  ap_continue_int;

//Init live in variables
output   ap_loop_init;
wire     ap_loop_init;
reg ap_loop_init_int;
reg ap_done;
reg ap_done_cache;

//Exit signal from loop body
input   ap_loop_exit_ready;
input   ap_loop_exit_done;

// power-on initialization
initial begin
#0 ap_loop_init_int = 1'b1;
#0 ap_done_cache = 1'b0;
end

assign ap_start_int = ap_start;

assign ap_continue_int = 1'b1;

assign ap_ready = ap_loop_exit_ready;

//ap_loop_init is valid for the first II
//of the first loop run so as to enable
//the init block ops which are pushed into
//the first state of the pipeline region
always @ (posedge ap_clk)
begin
    if (ap_rst == 1'b1) begin
        ap_loop_init_int <= 1'b1;
    end else if(ap_loop_exit_done == 1'b1) begin
        ap_loop_init_int <= 1'b1;
    end else if(ap_ready_int == 1'b1) begin
        ap_loop_init_int <= 1'b0;
    end
end

assign ap_loop_init = ap_loop_init_int & ap_start;

// if no ap_continue port and current module is not top module, 
// ap_done handshakes with ap_start. Internally, flow control sends out 
// ap_conintue_int = 1'b1 so the ap_done_int is asserted high for 1 clock cycle.
// ap_done_cache is used to record ap_done_int, and de-assert if ap_start_int
// is asserted, so DUT can start the next run
always @(posedge ap_clk)
begin
    if (ap_rst == 1'b1) begin
        ap_done_cache <= 1'b0;
    end else if (ap_done_int == 1'b1) begin
        ap_done_cache <= 1'b1;
    end else if (ap_start_int == 1'b1) begin
        ap_done_cache <= 1'b0;
    end
end

// if no ap_continue port and current module is not top module, ap_done handshakes with ap_start
always @(*)
begin
    if ((ap_done_int == 1'b1) || ((ap_done_cache == 1'b1) && (ap_start_int == 1'b0))) begin
        ap_done = 1'b1;
    end else begin
        ap_done = 1'b0;
    end
end

endmodule
        
//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/vivado_stitch_proj_w5fn6zuu/finn_vivado_stitch_proj.gen/sources_1/bd/finn_design/ip/finn_design_StreamingMaxPool_hls_1_0/synth/finn_design_StreamingMaxPool_hls_1_0.v


// (c) Copyright 1995-2026 Xilinx, Inc. All rights reserved.
// 
// This file contains confidential and proprietary information
// of Xilinx, Inc. and is protected under U.S. and
// international copyright and other intellectual property
// laws.
// 
// DISCLAIMER
// This disclaimer is not a license and does not grant any
// rights to the materials distributed herewith. Except as
// otherwise provided in a valid license issued to you by
// Xilinx, and to the maximum extent permitted by applicable
// law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
// WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
// AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
// BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
// INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
// (2) Xilinx shall not be liable (whether in contract or tort,
// including negligence, or under any other theory of
// liability) for any loss or damage of any kind or nature
// related to, arising under or in connection with these
// materials, including for any direct, or any indirect,
// special, incidental, or consequential loss or damage
// (including loss of data, profits, goodwill, or any type of
// loss or damage suffered as a result of any action brought
// by a third party) even if such damage or loss was
// reasonably foreseeable or Xilinx had been advised of the
// possibility of the same.
// 
// CRITICAL APPLICATIONS
// Xilinx products are not designed or intended to be fail-
// safe, or for use in any application requiring fail-safe
// performance, such as life-support or safety devices or
// systems, Class III medical devices, nuclear facilities,
// applications related to the deployment of airbags, or any
// other applications that could lead to death, personal
// injury, or severe property or environmental damage
// (individually and collectively, "Critical
// Applications"). Customer assumes the sole risk and
// liability of any use of Xilinx products in Critical
// Applications, subject only to applicable laws and
// regulations governing limitations on product liability.
// 
// THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
// PART OF THIS FILE AT ALL TIMES.
// 
// DO NOT MODIFY THIS FILE.


// IP VLNV: xilinx.com:hls:StreamingMaxPool_hls_1:1.0
// IP Revision: 2114489081

(* X_CORE_INFO = "StreamingMaxPool_hls_1,Vivado 2022.2" *)
(* CHECK_LICENSE_TYPE = "finn_design_StreamingMaxPool_hls_1_0,StreamingMaxPool_hls_1,{}" *)
(* CORE_GENERATION_INFO = "finn_design_StreamingMaxPool_hls_1_0,StreamingMaxPool_hls_1,{x_ipProduct=Vivado 2022.2,x_ipVendor=xilinx.com,x_ipLibrary=hls,x_ipName=StreamingMaxPool_hls_1,x_ipVersion=1.0,x_ipCoreRevision=2114489081,x_ipLanguage=VERILOG,x_ipSimLanguage=MIXED}" *)
(* IP_DEFINITION_SOURCE = "HLS" *)
(* DowngradeIPIdentifiedWarnings = "yes" *)
module finn_design_StreamingMaxPool_hls_1_0 (
  ap_clk,
  ap_rst_n,
  in0_V_TVALID,
  in0_V_TREADY,
  in0_V_TDATA,
  out_V_TVALID,
  out_V_TREADY,
  out_V_TDATA
);

(* X_INTERFACE_PARAMETER = "XIL_INTERFACENAME ap_clk, ASSOCIATED_BUSIF in0_V:out_V, ASSOCIATED_RESET ap_rst_n, FREQ_HZ 100000000, FREQ_TOLERANCE_HZ 0, PHASE 0.0, CLK_DOMAIN finn_design_ap_clk_0, INSERT_VIP 0" *)
(* X_INTERFACE_INFO = "xilinx.com:signal:clock:1.0 ap_clk CLK" *)
input wire ap_clk;
(* X_INTERFACE_PARAMETER = "XIL_INTERFACENAME ap_rst_n, POLARITY ACTIVE_LOW, INSERT_VIP 0" *)
(* X_INTERFACE_INFO = "xilinx.com:signal:reset:1.0 ap_rst_n RST" *)
input wire ap_rst_n;
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 in0_V TVALID" *)
input wire in0_V_TVALID;
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 in0_V TREADY" *)
output wire in0_V_TREADY;
(* X_INTERFACE_PARAMETER = "XIL_INTERFACENAME in0_V, TDATA_NUM_BYTES 16, TUSER_WIDTH 0, TDEST_WIDTH 0, TID_WIDTH 0, HAS_TREADY 1, HAS_TSTRB 0, HAS_TKEEP 0, HAS_TLAST 0, FREQ_HZ 100000000, PHASE 0.0, CLK_DOMAIN finn_design_ap_clk_0, INSERT_VIP 0" *)
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 in0_V TDATA" *)
input wire [127 : 0] in0_V_TDATA;
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 out_V TVALID" *)
output wire out_V_TVALID;
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 out_V TREADY" *)
input wire out_V_TREADY;
(* X_INTERFACE_PARAMETER = "XIL_INTERFACENAME out_V, TDATA_NUM_BYTES 16, TUSER_WIDTH 0, TDEST_WIDTH 0, TID_WIDTH 0, HAS_TREADY 1, HAS_TSTRB 0, HAS_TKEEP 0, HAS_TLAST 0, FREQ_HZ 100000000, PHASE 0.0, CLK_DOMAIN finn_design_ap_clk_0, INSERT_VIP 0" *)
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 out_V TDATA" *)
output wire [127 : 0] out_V_TDATA;

(* SDX_KERNEL = "true" *)
(* SDX_KERNEL_TYPE = "hls" *)
(* SDX_KERNEL_SYNTH_INST = "inst" *)
  StreamingMaxPool_hls_1 inst (
    .ap_clk(ap_clk),
    .ap_rst_n(ap_rst_n),
    .in0_V_TVALID(in0_V_TVALID),
    .in0_V_TREADY(in0_V_TREADY),
    .in0_V_TDATA(in0_V_TDATA),
    .out_V_TVALID(out_V_TVALID),
    .out_V_TREADY(out_V_TREADY),
    .out_V_TDATA(out_V_TDATA)
  );
endmodule
//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/code_gen_ipgen_FMPadding_rtl_0_e702v3yh/FMPadding_rtl_0.v


/******************************************************************************
 * Copyright (C) 2022, Advanced Micro Devices, Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *  1. Redistributions of source code must retain the above copyright notice,
 *     this list of conditions and the following disclaimer.
 *
 *  2. Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *
 *  3. Neither the name of the copyright holder nor the names of its
 *     contributors may be used to endorse or promote products derived from
 *     this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION). HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *****************************************************************************/

module FMPadding_rtl_0(
//- Global Control ------------------
(* X_INTERFACE_PARAMETER = "ASSOCIATED_BUSIF in0_V:out_V:s_axilite, ASSOCIATED_RESET = ap_rst_n" *)
(* X_INTERFACE_INFO = "xilinx.com:signal:clock:1.0 ap_clk CLK" *)
input   ap_clk,
(* X_INTERFACE_PARAMETER = "POLARITY ACTIVE_LOW" *)
input   ap_rst_n,

//- AXI Lite ------------------------
// Writing
input	       s_axilite_AWVALID,
output	       s_axilite_AWREADY,
input	[4:0]  s_axilite_AWADDR,

input	        s_axilite_WVALID,
output	        s_axilite_WREADY,
input	[31:0]  s_axilite_WDATA,
input	[ 3:0]  s_axilite_WSTRB,

output	       s_axilite_BVALID,
input	       s_axilite_BREADY,
output	[1:0]  s_axilite_BRESP,

// Reading
input	       s_axilite_ARVALID,
output	       s_axilite_ARREADY,
input	[4:0]  s_axilite_ARADDR,

output	        s_axilite_RVALID,
input	        s_axilite_RREADY,
output	[31:0]  s_axilite_RDATA,
output	[ 1:0]  s_axilite_RRESP,

//- AXI Stream - Input --------------
output	in0_V_TREADY,
input	in0_V_TVALID,
input	[24-1:0]  in0_V_TDATA,

//- AXI Stream - Output -------------
input	out_V_TREADY,
output	out_V_TVALID,
output	[24-1:0]  out_V_TDATA
);


fmpadding_axi #(
.XCOUNTER_BITS(5),
.YCOUNTER_BITS(5),
.NUM_CHANNELS(3),
.SIMD(3),
.ELEM_BITS(8),
.INIT_XON(1),
.INIT_XOFF(29),
.INIT_XEND(29),
.INIT_YON(1),
.INIT_YOFF(29),
.INIT_YEND(29)
)
impl
(
 .ap_clk(ap_clk),
 .ap_rst_n(ap_rst_n),
 .s_axilite_AWVALID(s_axilite_AWVALID),
 .s_axilite_AWREADY(s_axilite_AWREADY),
 .s_axilite_AWADDR(s_axilite_AWADDR),
 .s_axilite_WVALID(s_axilite_WVALID),
 .s_axilite_WREADY(s_axilite_WREADY),
 .s_axilite_WDATA(s_axilite_WDATA),
 .s_axilite_WSTRB(s_axilite_WSTRB),
 .s_axilite_BVALID(s_axilite_BVALID),
 .s_axilite_BREADY(s_axilite_BREADY),
 .s_axilite_BRESP(s_axilite_BRESP),
 .s_axilite_ARVALID(s_axilite_ARVALID),
 .s_axilite_ARREADY(s_axilite_ARREADY),
 .s_axilite_ARADDR(s_axilite_ARADDR),
 .s_axilite_RVALID(s_axilite_RVALID),
 .s_axilite_RREADY(s_axilite_RREADY),
 .s_axilite_RDATA(s_axilite_RDATA),
 .s_axilite_RRESP(s_axilite_RRESP),
 .s_axis_tready(in0_V_TREADY),
 .s_axis_tvalid(in0_V_TVALID),
 .s_axis_tdata(in0_V_TDATA),
 .m_axis_tready(out_V_TREADY),
 .m_axis_tvalid(out_V_TVALID),
 .m_axis_tdata(out_V_TDATA)
);

endmodule
//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/vivado_stitch_proj_w5fn6zuu/finn_vivado_stitch_proj.gen/sources_1/bd/finn_design/ipshared/18e4/hdl/verilog/MVAU_hls_0_mac_muladd_8s_4s_15s_15_4_1.v


// ==============================================================
// Vitis HLS - High-Level Synthesis from C, C++ and OpenCL v2022.2 (64-bit)
// Tool Version Limit: 2019.12
// Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.
// ==============================================================
`timescale 1 ns / 1 ps

(* use_dsp = "yes" *) module MVAU_hls_0_mac_muladd_8s_4s_15s_15_4_1_DSP48_0(
    input clk,
    input rst,
    input ce,
    input  [8 - 1:0] in0,
    input  [4 - 1:0] in1,
    input  [15 - 1:0] in2,
    output [15 - 1:0]  dout);

wire signed [25 - 1:0]     a;
wire signed [18 - 1:0]     b;
wire signed [48 - 1:0]     c;
wire signed [43 - 1:0]     m;
wire signed [48 - 1:0]     p;
reg  signed [43 - 1:0]     m_reg;
reg  signed [25 - 1:0]     a_reg;
reg  signed [18 - 1:0]     b_reg;
reg  signed [48 - 1:0]     p_reg;

assign a  = $signed(in0);
assign b  = $signed(in1);
assign c  = $signed(in2);

assign m  = a_reg * b_reg;
assign p  = m_reg + c;

always @(posedge clk) begin
    if (ce) begin
        m_reg  <= m;
        a_reg  <= a;
        b_reg  <= b;
        p_reg  <= p;
    end
end

assign dout = p_reg;

endmodule
`timescale 1 ns / 1 ps
module MVAU_hls_0_mac_muladd_8s_4s_15s_15_4_1(
    clk,
    reset,
    ce,
    din0,
    din1,
    din2,
    dout);

parameter ID = 32'd1;
parameter NUM_STAGE = 32'd1;
parameter din0_WIDTH = 32'd1;
parameter din1_WIDTH = 32'd1;
parameter din2_WIDTH = 32'd1;
parameter dout_WIDTH = 32'd1;
input clk;
input reset;
input ce;
input[din0_WIDTH - 1:0] din0;
input[din1_WIDTH - 1:0] din1;
input[din2_WIDTH - 1:0] din2;
output[dout_WIDTH - 1:0] dout;



MVAU_hls_0_mac_muladd_8s_4s_15s_15_4_1_DSP48_0 MVAU_hls_0_mac_muladd_8s_4s_15s_15_4_1_DSP48_0_U(
    .clk( clk ),
    .rst( reset ),
    .ce( ce ),
    .in0( din0 ),
    .in1( din1 ),
    .in2( din2 ),
    .dout( dout ));

endmodule

//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/vivado_stitch_proj_w5fn6zuu/finn_vivado_stitch_proj.gen/sources_1/bd/finn_design/ipshared/fb57/hdl/verilog/MVAU_hls_1_Matrix_Vector_Activate_Stream_Batch_p_ZL7threshs_13_ROM_AUTO_1R.v


// ==============================================================
// Vitis HLS - High-Level Synthesis from C, C++ and OpenCL v2022.2 (64-bit)
// Version: 2022.2
// Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.
// ==============================================================
`timescale 1 ns / 1 ps
module MVAU_hls_1_Matrix_Vector_Activate_Stream_Batch_p_ZL7threshs_13_ROM_AUTO_1R (
    address0, ce0, q0, 
    reset, clk);

parameter DataWidth = 10;
parameter AddressWidth = 5;
parameter AddressRange = 32;
 
input[AddressWidth-1:0] address0;
input ce0;
output reg[DataWidth-1:0] q0;

input reset;
input clk;

 
reg [DataWidth-1:0] rom0[0:AddressRange-1];


initial begin
     
    $readmemh("/home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/code_gen_ipgen_MVAU_hls_1__774deg0/project_MVAU_hls_1/sol1/impl/ip/hdl/verilog/MVAU_hls_1_Matrix_Vector_Activate_Stream_Batch_p_ZL7threshs_13_ROM_AUTO_1R.dat", rom0);
end

  
always @(posedge clk) 
begin 
    if (ce0) 
    begin
        q0 <= rom0[address0];
    end
end


endmodule

//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/vivado_stitch_proj_w5fn6zuu/finn_vivado_stitch_proj.gen/sources_1/bd/finn_design/ipshared/6bf6/hdl/verilog/StreamingMaxPool_hls_0_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6.v


// ==============================================================
// RTL generated by Vitis HLS - High-Level Synthesis from C, C++ and OpenCL v2022.2 (64-bit)
// Version: 2022.2
// Copyright (C) Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.
// 
// ===========================================================

`timescale 1 ns / 1 ps 

module StreamingMaxPool_hls_0_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6 (
        ap_clk,
        ap_rst,
        ap_start,
        ap_done,
        ap_idle,
        ap_ready,
        in0_V_TVALID,
        buf_V_15_load_1,
        buf_V_14_load_1,
        buf_V_13_load_1,
        buf_V_12_load_1,
        buf_V_11_load_1,
        buf_V_10_load_1,
        buf_V_9_load_1,
        buf_V_8_load_1,
        buf_V_7_load_1,
        buf_V_6_load_1,
        buf_V_5_load_1,
        buf_V_4_load_1,
        buf_V_3_load_1,
        buf_V_2_load_1,
        buf_V_1_load_1,
        buf_V_load_1,
        buf_V_15_address0,
        buf_V_15_ce0,
        buf_V_15_we0,
        buf_V_15_d0,
        zext_ln156,
        buf_V_14_address0,
        buf_V_14_ce0,
        buf_V_14_we0,
        buf_V_14_d0,
        buf_V_13_address0,
        buf_V_13_ce0,
        buf_V_13_we0,
        buf_V_13_d0,
        buf_V_12_address0,
        buf_V_12_ce0,
        buf_V_12_we0,
        buf_V_12_d0,
        buf_V_11_address0,
        buf_V_11_ce0,
        buf_V_11_we0,
        buf_V_11_d0,
        buf_V_10_address0,
        buf_V_10_ce0,
        buf_V_10_we0,
        buf_V_10_d0,
        buf_V_9_address0,
        buf_V_9_ce0,
        buf_V_9_we0,
        buf_V_9_d0,
        buf_V_8_address0,
        buf_V_8_ce0,
        buf_V_8_we0,
        buf_V_8_d0,
        buf_V_7_address0,
        buf_V_7_ce0,
        buf_V_7_we0,
        buf_V_7_d0,
        buf_V_6_address0,
        buf_V_6_ce0,
        buf_V_6_we0,
        buf_V_6_d0,
        buf_V_5_address0,
        buf_V_5_ce0,
        buf_V_5_we0,
        buf_V_5_d0,
        buf_V_4_address0,
        buf_V_4_ce0,
        buf_V_4_we0,
        buf_V_4_d0,
        buf_V_3_address0,
        buf_V_3_ce0,
        buf_V_3_we0,
        buf_V_3_d0,
        buf_V_2_address0,
        buf_V_2_ce0,
        buf_V_2_we0,
        buf_V_2_d0,
        buf_V_1_address0,
        buf_V_1_ce0,
        buf_V_1_we0,
        buf_V_1_d0,
        buf_V_address0,
        buf_V_ce0,
        buf_V_we0,
        buf_V_d0,
        in0_V_TDATA,
        in0_V_TREADY
);

parameter    ap_ST_fsm_state1 = 1'd1;

input   ap_clk;
input   ap_rst;
input   ap_start;
output   ap_done;
output   ap_idle;
output   ap_ready;
input   in0_V_TVALID;
input  [3:0] buf_V_15_load_1;
input  [3:0] buf_V_14_load_1;
input  [3:0] buf_V_13_load_1;
input  [3:0] buf_V_12_load_1;
input  [3:0] buf_V_11_load_1;
input  [3:0] buf_V_10_load_1;
input  [3:0] buf_V_9_load_1;
input  [3:0] buf_V_8_load_1;
input  [3:0] buf_V_7_load_1;
input  [3:0] buf_V_6_load_1;
input  [3:0] buf_V_5_load_1;
input  [3:0] buf_V_4_load_1;
input  [3:0] buf_V_3_load_1;
input  [3:0] buf_V_2_load_1;
input  [3:0] buf_V_1_load_1;
input  [3:0] buf_V_load_1;
output  [3:0] buf_V_15_address0;
output   buf_V_15_ce0;
output   buf_V_15_we0;
output  [3:0] buf_V_15_d0;
input  [3:0] zext_ln156;
output  [3:0] buf_V_14_address0;
output   buf_V_14_ce0;
output   buf_V_14_we0;
output  [3:0] buf_V_14_d0;
output  [3:0] buf_V_13_address0;
output   buf_V_13_ce0;
output   buf_V_13_we0;
output  [3:0] buf_V_13_d0;
output  [3:0] buf_V_12_address0;
output   buf_V_12_ce0;
output   buf_V_12_we0;
output  [3:0] buf_V_12_d0;
output  [3:0] buf_V_11_address0;
output   buf_V_11_ce0;
output   buf_V_11_we0;
output  [3:0] buf_V_11_d0;
output  [3:0] buf_V_10_address0;
output   buf_V_10_ce0;
output   buf_V_10_we0;
output  [3:0] buf_V_10_d0;
output  [3:0] buf_V_9_address0;
output   buf_V_9_ce0;
output   buf_V_9_we0;
output  [3:0] buf_V_9_d0;
output  [3:0] buf_V_8_address0;
output   buf_V_8_ce0;
output   buf_V_8_we0;
output  [3:0] buf_V_8_d0;
output  [3:0] buf_V_7_address0;
output   buf_V_7_ce0;
output   buf_V_7_we0;
output  [3:0] buf_V_7_d0;
output  [3:0] buf_V_6_address0;
output   buf_V_6_ce0;
output   buf_V_6_we0;
output  [3:0] buf_V_6_d0;
output  [3:0] buf_V_5_address0;
output   buf_V_5_ce0;
output   buf_V_5_we0;
output  [3:0] buf_V_5_d0;
output  [3:0] buf_V_4_address0;
output   buf_V_4_ce0;
output   buf_V_4_we0;
output  [3:0] buf_V_4_d0;
output  [3:0] buf_V_3_address0;
output   buf_V_3_ce0;
output   buf_V_3_we0;
output  [3:0] buf_V_3_d0;
output  [3:0] buf_V_2_address0;
output   buf_V_2_ce0;
output   buf_V_2_we0;
output  [3:0] buf_V_2_d0;
output  [3:0] buf_V_1_address0;
output   buf_V_1_ce0;
output   buf_V_1_we0;
output  [3:0] buf_V_1_d0;
output  [3:0] buf_V_address0;
output   buf_V_ce0;
output   buf_V_we0;
output  [3:0] buf_V_d0;
input  [63:0] in0_V_TDATA;
output   in0_V_TREADY;

reg ap_idle;
reg buf_V_15_ce0;
reg buf_V_15_we0;
reg buf_V_14_ce0;
reg buf_V_14_we0;
reg buf_V_13_ce0;
reg buf_V_13_we0;
reg buf_V_12_ce0;
reg buf_V_12_we0;
reg buf_V_11_ce0;
reg buf_V_11_we0;
reg buf_V_10_ce0;
reg buf_V_10_we0;
reg buf_V_9_ce0;
reg buf_V_9_we0;
reg buf_V_8_ce0;
reg buf_V_8_we0;
reg buf_V_7_ce0;
reg buf_V_7_we0;
reg buf_V_6_ce0;
reg buf_V_6_we0;
reg buf_V_5_ce0;
reg buf_V_5_we0;
reg buf_V_4_ce0;
reg buf_V_4_we0;
reg buf_V_3_ce0;
reg buf_V_3_we0;
reg buf_V_2_ce0;
reg buf_V_2_we0;
reg buf_V_1_ce0;
reg buf_V_1_we0;
reg buf_V_ce0;
reg buf_V_we0;
reg in0_V_TREADY;

(* fsm_encoding = "none" *) reg   [0:0] ap_CS_fsm;
wire    ap_CS_fsm_state1;
wire   [0:0] icmp_ln158_fu_660_p2;
reg    ap_block_state1_pp0_stage0_iter0;
reg    ap_condition_exit_pp0_iter0_stage0;
wire    ap_loop_exit_ready;
reg    ap_ready_int;
reg    in0_V_TDATA_blk_n;
wire   [63:0] zext_ln156_cast_fu_552_p1;
reg   [1:0] kx_fu_168;
wire   [1:0] kx_2_fu_666_p2;
wire    ap_loop_init;
reg   [1:0] ap_sig_allocacmp_kx_1;
reg   [3:0] oldMax_V_fu_172;
wire   [3:0] select_ln167_fu_730_p3;
reg   [3:0] ap_sig_allocacmp_oldMax_V_load;
reg   [3:0] oldMax_V_1_fu_176;
wire   [3:0] select_ln167_1_fu_755_p3;
reg   [3:0] ap_sig_allocacmp_oldMax_V_1_load;
reg   [3:0] oldMax_V_2_fu_180;
wire   [3:0] select_ln167_2_fu_780_p3;
reg   [3:0] ap_sig_allocacmp_oldMax_V_2_load;
reg   [3:0] oldMax_V_3_fu_184;
wire   [3:0] select_ln167_3_fu_805_p3;
reg   [3:0] ap_sig_allocacmp_oldMax_V_3_load;
reg   [3:0] oldMax_V_4_fu_188;
wire   [3:0] select_ln167_4_fu_830_p3;
reg   [3:0] ap_sig_allocacmp_oldMax_V_4_load;
reg   [3:0] oldMax_V_5_fu_192;
wire   [3:0] select_ln167_5_fu_855_p3;
reg   [3:0] ap_sig_allocacmp_oldMax_V_5_load;
reg   [3:0] oldMax_V_6_fu_196;
wire   [3:0] select_ln167_6_fu_880_p3;
reg   [3:0] ap_sig_allocacmp_oldMax_V_6_load;
reg   [3:0] oldMax_V_7_fu_200;
wire   [3:0] select_ln167_7_fu_905_p3;
reg   [3:0] ap_sig_allocacmp_oldMax_V_7_load;
reg   [3:0] oldMax_V_8_fu_204;
wire   [3:0] select_ln167_8_fu_930_p3;
reg   [3:0] ap_sig_allocacmp_oldMax_V_8_load;
reg   [3:0] oldMax_V_9_fu_208;
wire   [3:0] select_ln167_9_fu_955_p3;
reg   [3:0] ap_sig_allocacmp_oldMax_V_9_load;
reg   [3:0] oldMax_V_10_fu_212;
wire   [3:0] select_ln167_10_fu_980_p3;
reg   [3:0] ap_sig_allocacmp_oldMax_V_10_load;
reg   [3:0] oldMax_V_11_fu_216;
wire   [3:0] select_ln167_11_fu_1005_p3;
reg   [3:0] ap_sig_allocacmp_oldMax_V_11_load;
reg   [3:0] oldMax_V_12_fu_220;
wire   [3:0] select_ln167_12_fu_1030_p3;
reg   [3:0] ap_sig_allocacmp_oldMax_V_12_load;
reg   [3:0] oldMax_V_13_fu_224;
wire   [3:0] select_ln167_13_fu_1055_p3;
reg   [3:0] ap_sig_allocacmp_oldMax_V_13_load;
reg   [3:0] oldMax_V_14_fu_228;
wire   [3:0] select_ln167_14_fu_1080_p3;
reg   [3:0] ap_sig_allocacmp_oldMax_V_14_load;
reg   [3:0] oldMax_V_15_fu_232;
wire   [3:0] select_ln167_15_fu_1105_p3;
reg   [3:0] ap_sig_allocacmp_oldMax_V_15_load;
wire   [0:0] icmp_ln158_1_fu_1114_p2;
wire   [3:0] channeldata_V_fu_720_p1;
wire   [0:0] icmp_ln1035_fu_724_p2;
wire   [3:0] channeldata_V_1_fu_739_p4;
wire   [0:0] icmp_ln1035_1_fu_749_p2;
wire   [3:0] channeldata_V_2_fu_764_p4;
wire   [0:0] icmp_ln1035_2_fu_774_p2;
wire   [3:0] channeldata_V_3_fu_789_p4;
wire   [0:0] icmp_ln1035_3_fu_799_p2;
wire   [3:0] channeldata_V_4_fu_814_p4;
wire   [0:0] icmp_ln1035_4_fu_824_p2;
wire   [3:0] channeldata_V_5_fu_839_p4;
wire   [0:0] icmp_ln1035_5_fu_849_p2;
wire   [3:0] channeldata_V_6_fu_864_p4;
wire   [0:0] icmp_ln1035_6_fu_874_p2;
wire   [3:0] channeldata_V_7_fu_889_p4;
wire   [0:0] icmp_ln1035_7_fu_899_p2;
wire   [3:0] channeldata_V_8_fu_914_p4;
wire   [0:0] icmp_ln1035_8_fu_924_p2;
wire   [3:0] channeldata_V_9_fu_939_p4;
wire   [0:0] icmp_ln1035_9_fu_949_p2;
wire   [3:0] channeldata_V_10_fu_964_p4;
wire   [0:0] icmp_ln1035_10_fu_974_p2;
wire   [3:0] channeldata_V_11_fu_989_p4;
wire   [0:0] icmp_ln1035_11_fu_999_p2;
wire   [3:0] channeldata_V_12_fu_1014_p4;
wire   [0:0] icmp_ln1035_12_fu_1024_p2;
wire   [3:0] channeldata_V_13_fu_1039_p4;
wire   [0:0] icmp_ln1035_13_fu_1049_p2;
wire   [3:0] channeldata_V_14_fu_1064_p4;
wire   [0:0] icmp_ln1035_14_fu_1074_p2;
wire   [3:0] channeldata_V_15_fu_1089_p4;
wire   [0:0] icmp_ln1035_15_fu_1099_p2;
reg    ap_done_reg;
wire    ap_continue_int;
reg    ap_done_int;
reg   [0:0] ap_NS_fsm;
reg    ap_ST_fsm_state1_blk;
wire    ap_start_int;
reg    ap_condition_573;
wire    ap_ce_reg;

// power-on initialization
initial begin
#0 ap_CS_fsm = 1'd1;
#0 ap_done_reg = 1'b0;
end

StreamingMaxPool_hls_0_flow_control_loop_pipe_sequential_init flow_control_loop_pipe_sequential_init_U(
    .ap_clk(ap_clk),
    .ap_rst(ap_rst),
    .ap_start(ap_start),
    .ap_ready(ap_ready),
    .ap_done(ap_done),
    .ap_start_int(ap_start_int),
    .ap_loop_init(ap_loop_init),
    .ap_ready_int(ap_ready_int),
    .ap_loop_exit_ready(ap_condition_exit_pp0_iter0_stage0),
    .ap_loop_exit_done(ap_done_int),
    .ap_continue_int(ap_continue_int),
    .ap_done_int(ap_done_int)
);

always @ (posedge ap_clk) begin
    if (ap_rst == 1'b1) begin
        ap_CS_fsm <= ap_ST_fsm_state1;
    end else begin
        ap_CS_fsm <= ap_NS_fsm;
    end
end

always @ (posedge ap_clk) begin
    if (ap_rst == 1'b1) begin
        ap_done_reg <= 1'b0;
    end else begin
        if ((ap_continue_int == 1'b1)) begin
            ap_done_reg <= 1'b0;
        end else if ((~((ap_start_int == 1'b0) | ((icmp_ln158_fu_660_p2 == 1'd0) & (in0_V_TVALID == 1'b0))) & (ap_loop_exit_ready == 1'b1) & (1'b1 == ap_CS_fsm_state1))) begin
            ap_done_reg <= 1'b1;
        end
    end
end

always @ (posedge ap_clk) begin
    if ((1'b1 == ap_condition_573)) begin
        if ((icmp_ln158_fu_660_p2 == 1'd0)) begin
            kx_fu_168 <= kx_2_fu_666_p2;
        end else if ((ap_loop_init == 1'b1)) begin
            kx_fu_168 <= 2'd0;
        end
    end
end

always @ (posedge ap_clk) begin
    if ((1'b1 == ap_condition_573)) begin
        if ((icmp_ln158_fu_660_p2 == 1'd0)) begin
            oldMax_V_10_fu_212 <= select_ln167_10_fu_980_p3;
        end else if ((ap_loop_init == 1'b1)) begin
            oldMax_V_10_fu_212 <= buf_V_10_load_1;
        end
    end
end

always @ (posedge ap_clk) begin
    if ((1'b1 == ap_condition_573)) begin
        if ((icmp_ln158_fu_660_p2 == 1'd0)) begin
            oldMax_V_11_fu_216 <= select_ln167_11_fu_1005_p3;
        end else if ((ap_loop_init == 1'b1)) begin
            oldMax_V_11_fu_216 <= buf_V_11_load_1;
        end
    end
end

always @ (posedge ap_clk) begin
    if ((1'b1 == ap_condition_573)) begin
        if ((icmp_ln158_fu_660_p2 == 1'd0)) begin
            oldMax_V_12_fu_220 <= select_ln167_12_fu_1030_p3;
        end else if ((ap_loop_init == 1'b1)) begin
            oldMax_V_12_fu_220 <= buf_V_12_load_1;
        end
    end
end

always @ (posedge ap_clk) begin
    if ((1'b1 == ap_condition_573)) begin
        if ((icmp_ln158_fu_660_p2 == 1'd0)) begin
            oldMax_V_13_fu_224 <= select_ln167_13_fu_1055_p3;
        end else if ((ap_loop_init == 1'b1)) begin
            oldMax_V_13_fu_224 <= buf_V_13_load_1;
        end
    end
end

always @ (posedge ap_clk) begin
    if ((1'b1 == ap_condition_573)) begin
        if ((icmp_ln158_fu_660_p2 == 1'd0)) begin
            oldMax_V_14_fu_228 <= select_ln167_14_fu_1080_p3;
        end else if ((ap_loop_init == 1'b1)) begin
            oldMax_V_14_fu_228 <= buf_V_14_load_1;
        end
    end
end

always @ (posedge ap_clk) begin
    if ((1'b1 == ap_condition_573)) begin
        if ((icmp_ln158_fu_660_p2 == 1'd0)) begin
            oldMax_V_15_fu_232 <= select_ln167_15_fu_1105_p3;
        end else if ((ap_loop_init == 1'b1)) begin
            oldMax_V_15_fu_232 <= buf_V_15_load_1;
        end
    end
end

always @ (posedge ap_clk) begin
    if ((1'b1 == ap_condition_573)) begin
        if ((icmp_ln158_fu_660_p2 == 1'd0)) begin
            oldMax_V_1_fu_176 <= select_ln167_1_fu_755_p3;
        end else if ((ap_loop_init == 1'b1)) begin
            oldMax_V_1_fu_176 <= buf_V_1_load_1;
        end
    end
end

always @ (posedge ap_clk) begin
    if ((1'b1 == ap_condition_573)) begin
        if ((icmp_ln158_fu_660_p2 == 1'd0)) begin
            oldMax_V_2_fu_180 <= select_ln167_2_fu_780_p3;
        end else if ((ap_loop_init == 1'b1)) begin
            oldMax_V_2_fu_180 <= buf_V_2_load_1;
        end
    end
end

always @ (posedge ap_clk) begin
    if ((1'b1 == ap_condition_573)) begin
        if ((icmp_ln158_fu_660_p2 == 1'd0)) begin
            oldMax_V_3_fu_184 <= select_ln167_3_fu_805_p3;
        end else if ((ap_loop_init == 1'b1)) begin
            oldMax_V_3_fu_184 <= buf_V_3_load_1;
        end
    end
end

always @ (posedge ap_clk) begin
    if ((1'b1 == ap_condition_573)) begin
        if ((icmp_ln158_fu_660_p2 == 1'd0)) begin
            oldMax_V_4_fu_188 <= select_ln167_4_fu_830_p3;
        end else if ((ap_loop_init == 1'b1)) begin
            oldMax_V_4_fu_188 <= buf_V_4_load_1;
        end
    end
end

always @ (posedge ap_clk) begin
    if ((1'b1 == ap_condition_573)) begin
        if ((icmp_ln158_fu_660_p2 == 1'd0)) begin
            oldMax_V_5_fu_192 <= select_ln167_5_fu_855_p3;
        end else if ((ap_loop_init == 1'b1)) begin
            oldMax_V_5_fu_192 <= buf_V_5_load_1;
        end
    end
end

always @ (posedge ap_clk) begin
    if ((1'b1 == ap_condition_573)) begin
        if ((icmp_ln158_fu_660_p2 == 1'd0)) begin
            oldMax_V_6_fu_196 <= select_ln167_6_fu_880_p3;
        end else if ((ap_loop_init == 1'b1)) begin
            oldMax_V_6_fu_196 <= buf_V_6_load_1;
        end
    end
end

always @ (posedge ap_clk) begin
    if ((1'b1 == ap_condition_573)) begin
        if ((icmp_ln158_fu_660_p2 == 1'd0)) begin
            oldMax_V_7_fu_200 <= select_ln167_7_fu_905_p3;
        end else if ((ap_loop_init == 1'b1)) begin
            oldMax_V_7_fu_200 <= buf_V_7_load_1;
        end
    end
end

always @ (posedge ap_clk) begin
    if ((1'b1 == ap_condition_573)) begin
        if ((icmp_ln158_fu_660_p2 == 1'd0)) begin
            oldMax_V_8_fu_204 <= select_ln167_8_fu_930_p3;
        end else if ((ap_loop_init == 1'b1)) begin
            oldMax_V_8_fu_204 <= buf_V_8_load_1;
        end
    end
end

always @ (posedge ap_clk) begin
    if ((1'b1 == ap_condition_573)) begin
        if ((icmp_ln158_fu_660_p2 == 1'd0)) begin
            oldMax_V_9_fu_208 <= select_ln167_9_fu_955_p3;
        end else if ((ap_loop_init == 1'b1)) begin
            oldMax_V_9_fu_208 <= buf_V_9_load_1;
        end
    end
end

always @ (posedge ap_clk) begin
    if ((1'b1 == ap_condition_573)) begin
        if ((icmp_ln158_fu_660_p2 == 1'd0)) begin
            oldMax_V_fu_172 <= select_ln167_fu_730_p3;
        end else if ((ap_loop_init == 1'b1)) begin
            oldMax_V_fu_172 <= buf_V_load_1;
        end
    end
end

always @ (*) begin
    if (((ap_start_int == 1'b0) | ((icmp_ln158_fu_660_p2 == 1'd0) & (in0_V_TVALID == 1'b0)))) begin
        ap_ST_fsm_state1_blk = 1'b1;
    end else begin
        ap_ST_fsm_state1_blk = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((icmp_ln158_fu_660_p2 == 1'd0) & (in0_V_TVALID == 1'b0))) & (icmp_ln158_fu_660_p2 == 1'd1) & (1'b1 == ap_CS_fsm_state1))) begin
        ap_condition_exit_pp0_iter0_stage0 = 1'b1;
    end else begin
        ap_condition_exit_pp0_iter0_stage0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((icmp_ln158_fu_660_p2 == 1'd0) & (in0_V_TVALID == 1'b0))) & (ap_loop_exit_ready == 1'b1) & (1'b1 == ap_CS_fsm_state1))) begin
        ap_done_int = 1'b1;
    end else begin
        ap_done_int = ap_done_reg;
    end
end

always @ (*) begin
    if (((ap_start_int == 1'b0) & (1'b1 == ap_CS_fsm_state1))) begin
        ap_idle = 1'b1;
    end else begin
        ap_idle = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((icmp_ln158_fu_660_p2 == 1'd0) & (in0_V_TVALID == 1'b0))) & (1'b1 == ap_CS_fsm_state1))) begin
        ap_ready_int = 1'b1;
    end else begin
        ap_ready_int = 1'b0;
    end
end

always @ (*) begin
    if (((1'b1 == ap_CS_fsm_state1) & (ap_loop_init == 1'b1))) begin
        ap_sig_allocacmp_kx_1 = 2'd0;
    end else begin
        ap_sig_allocacmp_kx_1 = kx_fu_168;
    end
end

always @ (*) begin
    if (((1'b1 == ap_CS_fsm_state1) & (ap_loop_init == 1'b1))) begin
        ap_sig_allocacmp_oldMax_V_10_load = buf_V_10_load_1;
    end else begin
        ap_sig_allocacmp_oldMax_V_10_load = oldMax_V_10_fu_212;
    end
end

always @ (*) begin
    if (((1'b1 == ap_CS_fsm_state1) & (ap_loop_init == 1'b1))) begin
        ap_sig_allocacmp_oldMax_V_11_load = buf_V_11_load_1;
    end else begin
        ap_sig_allocacmp_oldMax_V_11_load = oldMax_V_11_fu_216;
    end
end

always @ (*) begin
    if (((1'b1 == ap_CS_fsm_state1) & (ap_loop_init == 1'b1))) begin
        ap_sig_allocacmp_oldMax_V_12_load = buf_V_12_load_1;
    end else begin
        ap_sig_allocacmp_oldMax_V_12_load = oldMax_V_12_fu_220;
    end
end

always @ (*) begin
    if (((1'b1 == ap_CS_fsm_state1) & (ap_loop_init == 1'b1))) begin
        ap_sig_allocacmp_oldMax_V_13_load = buf_V_13_load_1;
    end else begin
        ap_sig_allocacmp_oldMax_V_13_load = oldMax_V_13_fu_224;
    end
end

always @ (*) begin
    if (((1'b1 == ap_CS_fsm_state1) & (ap_loop_init == 1'b1))) begin
        ap_sig_allocacmp_oldMax_V_14_load = buf_V_14_load_1;
    end else begin
        ap_sig_allocacmp_oldMax_V_14_load = oldMax_V_14_fu_228;
    end
end

always @ (*) begin
    if (((1'b1 == ap_CS_fsm_state1) & (ap_loop_init == 1'b1))) begin
        ap_sig_allocacmp_oldMax_V_15_load = buf_V_15_load_1;
    end else begin
        ap_sig_allocacmp_oldMax_V_15_load = oldMax_V_15_fu_232;
    end
end

always @ (*) begin
    if (((1'b1 == ap_CS_fsm_state1) & (ap_loop_init == 1'b1))) begin
        ap_sig_allocacmp_oldMax_V_1_load = buf_V_1_load_1;
    end else begin
        ap_sig_allocacmp_oldMax_V_1_load = oldMax_V_1_fu_176;
    end
end

always @ (*) begin
    if (((1'b1 == ap_CS_fsm_state1) & (ap_loop_init == 1'b1))) begin
        ap_sig_allocacmp_oldMax_V_2_load = buf_V_2_load_1;
    end else begin
        ap_sig_allocacmp_oldMax_V_2_load = oldMax_V_2_fu_180;
    end
end

always @ (*) begin
    if (((1'b1 == ap_CS_fsm_state1) & (ap_loop_init == 1'b1))) begin
        ap_sig_allocacmp_oldMax_V_3_load = buf_V_3_load_1;
    end else begin
        ap_sig_allocacmp_oldMax_V_3_load = oldMax_V_3_fu_184;
    end
end

always @ (*) begin
    if (((1'b1 == ap_CS_fsm_state1) & (ap_loop_init == 1'b1))) begin
        ap_sig_allocacmp_oldMax_V_4_load = buf_V_4_load_1;
    end else begin
        ap_sig_allocacmp_oldMax_V_4_load = oldMax_V_4_fu_188;
    end
end

always @ (*) begin
    if (((1'b1 == ap_CS_fsm_state1) & (ap_loop_init == 1'b1))) begin
        ap_sig_allocacmp_oldMax_V_5_load = buf_V_5_load_1;
    end else begin
        ap_sig_allocacmp_oldMax_V_5_load = oldMax_V_5_fu_192;
    end
end

always @ (*) begin
    if (((1'b1 == ap_CS_fsm_state1) & (ap_loop_init == 1'b1))) begin
        ap_sig_allocacmp_oldMax_V_6_load = buf_V_6_load_1;
    end else begin
        ap_sig_allocacmp_oldMax_V_6_load = oldMax_V_6_fu_196;
    end
end

always @ (*) begin
    if (((1'b1 == ap_CS_fsm_state1) & (ap_loop_init == 1'b1))) begin
        ap_sig_allocacmp_oldMax_V_7_load = buf_V_7_load_1;
    end else begin
        ap_sig_allocacmp_oldMax_V_7_load = oldMax_V_7_fu_200;
    end
end

always @ (*) begin
    if (((1'b1 == ap_CS_fsm_state1) & (ap_loop_init == 1'b1))) begin
        ap_sig_allocacmp_oldMax_V_8_load = buf_V_8_load_1;
    end else begin
        ap_sig_allocacmp_oldMax_V_8_load = oldMax_V_8_fu_204;
    end
end

always @ (*) begin
    if (((1'b1 == ap_CS_fsm_state1) & (ap_loop_init == 1'b1))) begin
        ap_sig_allocacmp_oldMax_V_9_load = buf_V_9_load_1;
    end else begin
        ap_sig_allocacmp_oldMax_V_9_load = oldMax_V_9_fu_208;
    end
end

always @ (*) begin
    if (((1'b1 == ap_CS_fsm_state1) & (ap_loop_init == 1'b1))) begin
        ap_sig_allocacmp_oldMax_V_load = buf_V_load_1;
    end else begin
        ap_sig_allocacmp_oldMax_V_load = oldMax_V_fu_172;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((icmp_ln158_fu_660_p2 == 1'd0) & (in0_V_TVALID == 1'b0))) & (1'b1 == ap_CS_fsm_state1))) begin
        buf_V_10_ce0 = 1'b1;
    end else begin
        buf_V_10_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((icmp_ln158_fu_660_p2 == 1'd0) & (in0_V_TVALID == 1'b0))) & (icmp_ln158_1_fu_1114_p2 == 1'd1) & (icmp_ln158_fu_660_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state1))) begin
        buf_V_10_we0 = 1'b1;
    end else begin
        buf_V_10_we0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((icmp_ln158_fu_660_p2 == 1'd0) & (in0_V_TVALID == 1'b0))) & (1'b1 == ap_CS_fsm_state1))) begin
        buf_V_11_ce0 = 1'b1;
    end else begin
        buf_V_11_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((icmp_ln158_fu_660_p2 == 1'd0) & (in0_V_TVALID == 1'b0))) & (icmp_ln158_1_fu_1114_p2 == 1'd1) & (icmp_ln158_fu_660_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state1))) begin
        buf_V_11_we0 = 1'b1;
    end else begin
        buf_V_11_we0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((icmp_ln158_fu_660_p2 == 1'd0) & (in0_V_TVALID == 1'b0))) & (1'b1 == ap_CS_fsm_state1))) begin
        buf_V_12_ce0 = 1'b1;
    end else begin
        buf_V_12_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((icmp_ln158_fu_660_p2 == 1'd0) & (in0_V_TVALID == 1'b0))) & (icmp_ln158_1_fu_1114_p2 == 1'd1) & (icmp_ln158_fu_660_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state1))) begin
        buf_V_12_we0 = 1'b1;
    end else begin
        buf_V_12_we0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((icmp_ln158_fu_660_p2 == 1'd0) & (in0_V_TVALID == 1'b0))) & (1'b1 == ap_CS_fsm_state1))) begin
        buf_V_13_ce0 = 1'b1;
    end else begin
        buf_V_13_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((icmp_ln158_fu_660_p2 == 1'd0) & (in0_V_TVALID == 1'b0))) & (icmp_ln158_1_fu_1114_p2 == 1'd1) & (icmp_ln158_fu_660_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state1))) begin
        buf_V_13_we0 = 1'b1;
    end else begin
        buf_V_13_we0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((icmp_ln158_fu_660_p2 == 1'd0) & (in0_V_TVALID == 1'b0))) & (1'b1 == ap_CS_fsm_state1))) begin
        buf_V_14_ce0 = 1'b1;
    end else begin
        buf_V_14_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((icmp_ln158_fu_660_p2 == 1'd0) & (in0_V_TVALID == 1'b0))) & (icmp_ln158_1_fu_1114_p2 == 1'd1) & (icmp_ln158_fu_660_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state1))) begin
        buf_V_14_we0 = 1'b1;
    end else begin
        buf_V_14_we0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((icmp_ln158_fu_660_p2 == 1'd0) & (in0_V_TVALID == 1'b0))) & (1'b1 == ap_CS_fsm_state1))) begin
        buf_V_15_ce0 = 1'b1;
    end else begin
        buf_V_15_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((icmp_ln158_fu_660_p2 == 1'd0) & (in0_V_TVALID == 1'b0))) & (icmp_ln158_1_fu_1114_p2 == 1'd1) & (icmp_ln158_fu_660_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state1))) begin
        buf_V_15_we0 = 1'b1;
    end else begin
        buf_V_15_we0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((icmp_ln158_fu_660_p2 == 1'd0) & (in0_V_TVALID == 1'b0))) & (1'b1 == ap_CS_fsm_state1))) begin
        buf_V_1_ce0 = 1'b1;
    end else begin
        buf_V_1_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((icmp_ln158_fu_660_p2 == 1'd0) & (in0_V_TVALID == 1'b0))) & (icmp_ln158_1_fu_1114_p2 == 1'd1) & (icmp_ln158_fu_660_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state1))) begin
        buf_V_1_we0 = 1'b1;
    end else begin
        buf_V_1_we0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((icmp_ln158_fu_660_p2 == 1'd0) & (in0_V_TVALID == 1'b0))) & (1'b1 == ap_CS_fsm_state1))) begin
        buf_V_2_ce0 = 1'b1;
    end else begin
        buf_V_2_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((icmp_ln158_fu_660_p2 == 1'd0) & (in0_V_TVALID == 1'b0))) & (icmp_ln158_1_fu_1114_p2 == 1'd1) & (icmp_ln158_fu_660_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state1))) begin
        buf_V_2_we0 = 1'b1;
    end else begin
        buf_V_2_we0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((icmp_ln158_fu_660_p2 == 1'd0) & (in0_V_TVALID == 1'b0))) & (1'b1 == ap_CS_fsm_state1))) begin
        buf_V_3_ce0 = 1'b1;
    end else begin
        buf_V_3_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((icmp_ln158_fu_660_p2 == 1'd0) & (in0_V_TVALID == 1'b0))) & (icmp_ln158_1_fu_1114_p2 == 1'd1) & (icmp_ln158_fu_660_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state1))) begin
        buf_V_3_we0 = 1'b1;
    end else begin
        buf_V_3_we0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((icmp_ln158_fu_660_p2 == 1'd0) & (in0_V_TVALID == 1'b0))) & (1'b1 == ap_CS_fsm_state1))) begin
        buf_V_4_ce0 = 1'b1;
    end else begin
        buf_V_4_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((icmp_ln158_fu_660_p2 == 1'd0) & (in0_V_TVALID == 1'b0))) & (icmp_ln158_1_fu_1114_p2 == 1'd1) & (icmp_ln158_fu_660_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state1))) begin
        buf_V_4_we0 = 1'b1;
    end else begin
        buf_V_4_we0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((icmp_ln158_fu_660_p2 == 1'd0) & (in0_V_TVALID == 1'b0))) & (1'b1 == ap_CS_fsm_state1))) begin
        buf_V_5_ce0 = 1'b1;
    end else begin
        buf_V_5_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((icmp_ln158_fu_660_p2 == 1'd0) & (in0_V_TVALID == 1'b0))) & (icmp_ln158_1_fu_1114_p2 == 1'd1) & (icmp_ln158_fu_660_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state1))) begin
        buf_V_5_we0 = 1'b1;
    end else begin
        buf_V_5_we0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((icmp_ln158_fu_660_p2 == 1'd0) & (in0_V_TVALID == 1'b0))) & (1'b1 == ap_CS_fsm_state1))) begin
        buf_V_6_ce0 = 1'b1;
    end else begin
        buf_V_6_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((icmp_ln158_fu_660_p2 == 1'd0) & (in0_V_TVALID == 1'b0))) & (icmp_ln158_1_fu_1114_p2 == 1'd1) & (icmp_ln158_fu_660_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state1))) begin
        buf_V_6_we0 = 1'b1;
    end else begin
        buf_V_6_we0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((icmp_ln158_fu_660_p2 == 1'd0) & (in0_V_TVALID == 1'b0))) & (1'b1 == ap_CS_fsm_state1))) begin
        buf_V_7_ce0 = 1'b1;
    end else begin
        buf_V_7_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((icmp_ln158_fu_660_p2 == 1'd0) & (in0_V_TVALID == 1'b0))) & (icmp_ln158_1_fu_1114_p2 == 1'd1) & (icmp_ln158_fu_660_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state1))) begin
        buf_V_7_we0 = 1'b1;
    end else begin
        buf_V_7_we0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((icmp_ln158_fu_660_p2 == 1'd0) & (in0_V_TVALID == 1'b0))) & (1'b1 == ap_CS_fsm_state1))) begin
        buf_V_8_ce0 = 1'b1;
    end else begin
        buf_V_8_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((icmp_ln158_fu_660_p2 == 1'd0) & (in0_V_TVALID == 1'b0))) & (icmp_ln158_1_fu_1114_p2 == 1'd1) & (icmp_ln158_fu_660_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state1))) begin
        buf_V_8_we0 = 1'b1;
    end else begin
        buf_V_8_we0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((icmp_ln158_fu_660_p2 == 1'd0) & (in0_V_TVALID == 1'b0))) & (1'b1 == ap_CS_fsm_state1))) begin
        buf_V_9_ce0 = 1'b1;
    end else begin
        buf_V_9_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((icmp_ln158_fu_660_p2 == 1'd0) & (in0_V_TVALID == 1'b0))) & (icmp_ln158_1_fu_1114_p2 == 1'd1) & (icmp_ln158_fu_660_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state1))) begin
        buf_V_9_we0 = 1'b1;
    end else begin
        buf_V_9_we0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((icmp_ln158_fu_660_p2 == 1'd0) & (in0_V_TVALID == 1'b0))) & (1'b1 == ap_CS_fsm_state1))) begin
        buf_V_ce0 = 1'b1;
    end else begin
        buf_V_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((icmp_ln158_fu_660_p2 == 1'd0) & (in0_V_TVALID == 1'b0))) & (icmp_ln158_1_fu_1114_p2 == 1'd1) & (icmp_ln158_fu_660_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state1))) begin
        buf_V_we0 = 1'b1;
    end else begin
        buf_V_we0 = 1'b0;
    end
end

always @ (*) begin
    if (((ap_start_int == 1'b1) & (icmp_ln158_fu_660_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state1))) begin
        in0_V_TDATA_blk_n = in0_V_TVALID;
    end else begin
        in0_V_TDATA_blk_n = 1'b1;
    end
end

always @ (*) begin
    if ((~((ap_start_int == 1'b0) | ((icmp_ln158_fu_660_p2 == 1'd0) & (in0_V_TVALID == 1'b0))) & (icmp_ln158_fu_660_p2 == 1'd0) & (1'b1 == ap_CS_fsm_state1))) begin
        in0_V_TREADY = 1'b1;
    end else begin
        in0_V_TREADY = 1'b0;
    end
end

always @ (*) begin
    case (ap_CS_fsm)
        ap_ST_fsm_state1 : begin
            ap_NS_fsm = ap_ST_fsm_state1;
        end
        default : begin
            ap_NS_fsm = 'bx;
        end
    endcase
end

assign ap_CS_fsm_state1 = ap_CS_fsm[32'd0];

always @ (*) begin
    ap_block_state1_pp0_stage0_iter0 = ((ap_start_int == 1'b0) | ((icmp_ln158_fu_660_p2 == 1'd0) & (in0_V_TVALID == 1'b0)));
end

always @ (*) begin
    ap_condition_573 = (~((ap_start_int == 1'b0) | ((icmp_ln158_fu_660_p2 == 1'd0) & (in0_V_TVALID == 1'b0))) & (1'b1 == ap_CS_fsm_state1));
end

assign ap_loop_exit_ready = ap_condition_exit_pp0_iter0_stage0;

assign buf_V_10_address0 = zext_ln156_cast_fu_552_p1;

assign buf_V_10_d0 = ((icmp_ln1035_10_fu_974_p2[0:0] == 1'b1) ? channeldata_V_10_fu_964_p4 : ap_sig_allocacmp_oldMax_V_10_load);

assign buf_V_11_address0 = zext_ln156_cast_fu_552_p1;

assign buf_V_11_d0 = ((icmp_ln1035_11_fu_999_p2[0:0] == 1'b1) ? channeldata_V_11_fu_989_p4 : ap_sig_allocacmp_oldMax_V_11_load);

assign buf_V_12_address0 = zext_ln156_cast_fu_552_p1;

assign buf_V_12_d0 = ((icmp_ln1035_12_fu_1024_p2[0:0] == 1'b1) ? channeldata_V_12_fu_1014_p4 : ap_sig_allocacmp_oldMax_V_12_load);

assign buf_V_13_address0 = zext_ln156_cast_fu_552_p1;

assign buf_V_13_d0 = ((icmp_ln1035_13_fu_1049_p2[0:0] == 1'b1) ? channeldata_V_13_fu_1039_p4 : ap_sig_allocacmp_oldMax_V_13_load);

assign buf_V_14_address0 = zext_ln156_cast_fu_552_p1;

assign buf_V_14_d0 = ((icmp_ln1035_14_fu_1074_p2[0:0] == 1'b1) ? channeldata_V_14_fu_1064_p4 : ap_sig_allocacmp_oldMax_V_14_load);

assign buf_V_15_address0 = zext_ln156_cast_fu_552_p1;

assign buf_V_15_d0 = ((icmp_ln1035_15_fu_1099_p2[0:0] == 1'b1) ? channeldata_V_15_fu_1089_p4 : ap_sig_allocacmp_oldMax_V_15_load);

assign buf_V_1_address0 = zext_ln156_cast_fu_552_p1;

assign buf_V_1_d0 = ((icmp_ln1035_1_fu_749_p2[0:0] == 1'b1) ? channeldata_V_1_fu_739_p4 : ap_sig_allocacmp_oldMax_V_1_load);

assign buf_V_2_address0 = zext_ln156_cast_fu_552_p1;

assign buf_V_2_d0 = ((icmp_ln1035_2_fu_774_p2[0:0] == 1'b1) ? channeldata_V_2_fu_764_p4 : ap_sig_allocacmp_oldMax_V_2_load);

assign buf_V_3_address0 = zext_ln156_cast_fu_552_p1;

assign buf_V_3_d0 = ((icmp_ln1035_3_fu_799_p2[0:0] == 1'b1) ? channeldata_V_3_fu_789_p4 : ap_sig_allocacmp_oldMax_V_3_load);

assign buf_V_4_address0 = zext_ln156_cast_fu_552_p1;

assign buf_V_4_d0 = ((icmp_ln1035_4_fu_824_p2[0:0] == 1'b1) ? channeldata_V_4_fu_814_p4 : ap_sig_allocacmp_oldMax_V_4_load);

assign buf_V_5_address0 = zext_ln156_cast_fu_552_p1;

assign buf_V_5_d0 = ((icmp_ln1035_5_fu_849_p2[0:0] == 1'b1) ? channeldata_V_5_fu_839_p4 : ap_sig_allocacmp_oldMax_V_5_load);

assign buf_V_6_address0 = zext_ln156_cast_fu_552_p1;

assign buf_V_6_d0 = ((icmp_ln1035_6_fu_874_p2[0:0] == 1'b1) ? channeldata_V_6_fu_864_p4 : ap_sig_allocacmp_oldMax_V_6_load);

assign buf_V_7_address0 = zext_ln156_cast_fu_552_p1;

assign buf_V_7_d0 = ((icmp_ln1035_7_fu_899_p2[0:0] == 1'b1) ? channeldata_V_7_fu_889_p4 : ap_sig_allocacmp_oldMax_V_7_load);

assign buf_V_8_address0 = zext_ln156_cast_fu_552_p1;

assign buf_V_8_d0 = ((icmp_ln1035_8_fu_924_p2[0:0] == 1'b1) ? channeldata_V_8_fu_914_p4 : ap_sig_allocacmp_oldMax_V_8_load);

assign buf_V_9_address0 = zext_ln156_cast_fu_552_p1;

assign buf_V_9_d0 = ((icmp_ln1035_9_fu_949_p2[0:0] == 1'b1) ? channeldata_V_9_fu_939_p4 : ap_sig_allocacmp_oldMax_V_9_load);

assign buf_V_address0 = zext_ln156_cast_fu_552_p1;

assign buf_V_d0 = ((icmp_ln1035_fu_724_p2[0:0] == 1'b1) ? channeldata_V_fu_720_p1 : ap_sig_allocacmp_oldMax_V_load);

assign channeldata_V_10_fu_964_p4 = {{in0_V_TDATA[43:40]}};

assign channeldata_V_11_fu_989_p4 = {{in0_V_TDATA[47:44]}};

assign channeldata_V_12_fu_1014_p4 = {{in0_V_TDATA[51:48]}};

assign channeldata_V_13_fu_1039_p4 = {{in0_V_TDATA[55:52]}};

assign channeldata_V_14_fu_1064_p4 = {{in0_V_TDATA[59:56]}};

assign channeldata_V_15_fu_1089_p4 = {{in0_V_TDATA[63:60]}};

assign channeldata_V_1_fu_739_p4 = {{in0_V_TDATA[7:4]}};

assign channeldata_V_2_fu_764_p4 = {{in0_V_TDATA[11:8]}};

assign channeldata_V_3_fu_789_p4 = {{in0_V_TDATA[15:12]}};

assign channeldata_V_4_fu_814_p4 = {{in0_V_TDATA[19:16]}};

assign channeldata_V_5_fu_839_p4 = {{in0_V_TDATA[23:20]}};

assign channeldata_V_6_fu_864_p4 = {{in0_V_TDATA[27:24]}};

assign channeldata_V_7_fu_889_p4 = {{in0_V_TDATA[31:28]}};

assign channeldata_V_8_fu_914_p4 = {{in0_V_TDATA[35:32]}};

assign channeldata_V_9_fu_939_p4 = {{in0_V_TDATA[39:36]}};

assign channeldata_V_fu_720_p1 = in0_V_TDATA[3:0];

assign icmp_ln1035_10_fu_974_p2 = ((channeldata_V_10_fu_964_p4 > ap_sig_allocacmp_oldMax_V_10_load) ? 1'b1 : 1'b0);

assign icmp_ln1035_11_fu_999_p2 = ((channeldata_V_11_fu_989_p4 > ap_sig_allocacmp_oldMax_V_11_load) ? 1'b1 : 1'b0);

assign icmp_ln1035_12_fu_1024_p2 = ((channeldata_V_12_fu_1014_p4 > ap_sig_allocacmp_oldMax_V_12_load) ? 1'b1 : 1'b0);

assign icmp_ln1035_13_fu_1049_p2 = ((channeldata_V_13_fu_1039_p4 > ap_sig_allocacmp_oldMax_V_13_load) ? 1'b1 : 1'b0);

assign icmp_ln1035_14_fu_1074_p2 = ((channeldata_V_14_fu_1064_p4 > ap_sig_allocacmp_oldMax_V_14_load) ? 1'b1 : 1'b0);

assign icmp_ln1035_15_fu_1099_p2 = ((channeldata_V_15_fu_1089_p4 > ap_sig_allocacmp_oldMax_V_15_load) ? 1'b1 : 1'b0);

assign icmp_ln1035_1_fu_749_p2 = ((channeldata_V_1_fu_739_p4 > ap_sig_allocacmp_oldMax_V_1_load) ? 1'b1 : 1'b0);

assign icmp_ln1035_2_fu_774_p2 = ((channeldata_V_2_fu_764_p4 > ap_sig_allocacmp_oldMax_V_2_load) ? 1'b1 : 1'b0);

assign icmp_ln1035_3_fu_799_p2 = ((channeldata_V_3_fu_789_p4 > ap_sig_allocacmp_oldMax_V_3_load) ? 1'b1 : 1'b0);

assign icmp_ln1035_4_fu_824_p2 = ((channeldata_V_4_fu_814_p4 > ap_sig_allocacmp_oldMax_V_4_load) ? 1'b1 : 1'b0);

assign icmp_ln1035_5_fu_849_p2 = ((channeldata_V_5_fu_839_p4 > ap_sig_allocacmp_oldMax_V_5_load) ? 1'b1 : 1'b0);

assign icmp_ln1035_6_fu_874_p2 = ((channeldata_V_6_fu_864_p4 > ap_sig_allocacmp_oldMax_V_6_load) ? 1'b1 : 1'b0);

assign icmp_ln1035_7_fu_899_p2 = ((channeldata_V_7_fu_889_p4 > ap_sig_allocacmp_oldMax_V_7_load) ? 1'b1 : 1'b0);

assign icmp_ln1035_8_fu_924_p2 = ((channeldata_V_8_fu_914_p4 > ap_sig_allocacmp_oldMax_V_8_load) ? 1'b1 : 1'b0);

assign icmp_ln1035_9_fu_949_p2 = ((channeldata_V_9_fu_939_p4 > ap_sig_allocacmp_oldMax_V_9_load) ? 1'b1 : 1'b0);

assign icmp_ln1035_fu_724_p2 = ((channeldata_V_fu_720_p1 > ap_sig_allocacmp_oldMax_V_load) ? 1'b1 : 1'b0);

assign icmp_ln158_1_fu_1114_p2 = ((kx_2_fu_666_p2 == 2'd2) ? 1'b1 : 1'b0);

assign icmp_ln158_fu_660_p2 = ((ap_sig_allocacmp_kx_1 == 2'd2) ? 1'b1 : 1'b0);

assign kx_2_fu_666_p2 = (ap_sig_allocacmp_kx_1 + 2'd1);

assign select_ln167_10_fu_980_p3 = ((icmp_ln1035_10_fu_974_p2[0:0] == 1'b1) ? channeldata_V_10_fu_964_p4 : ap_sig_allocacmp_oldMax_V_10_load);

assign select_ln167_11_fu_1005_p3 = ((icmp_ln1035_11_fu_999_p2[0:0] == 1'b1) ? channeldata_V_11_fu_989_p4 : ap_sig_allocacmp_oldMax_V_11_load);

assign select_ln167_12_fu_1030_p3 = ((icmp_ln1035_12_fu_1024_p2[0:0] == 1'b1) ? channeldata_V_12_fu_1014_p4 : ap_sig_allocacmp_oldMax_V_12_load);

assign select_ln167_13_fu_1055_p3 = ((icmp_ln1035_13_fu_1049_p2[0:0] == 1'b1) ? channeldata_V_13_fu_1039_p4 : ap_sig_allocacmp_oldMax_V_13_load);

assign select_ln167_14_fu_1080_p3 = ((icmp_ln1035_14_fu_1074_p2[0:0] == 1'b1) ? channeldata_V_14_fu_1064_p4 : ap_sig_allocacmp_oldMax_V_14_load);

assign select_ln167_15_fu_1105_p3 = ((icmp_ln1035_15_fu_1099_p2[0:0] == 1'b1) ? channeldata_V_15_fu_1089_p4 : ap_sig_allocacmp_oldMax_V_15_load);

assign select_ln167_1_fu_755_p3 = ((icmp_ln1035_1_fu_749_p2[0:0] == 1'b1) ? channeldata_V_1_fu_739_p4 : ap_sig_allocacmp_oldMax_V_1_load);

assign select_ln167_2_fu_780_p3 = ((icmp_ln1035_2_fu_774_p2[0:0] == 1'b1) ? channeldata_V_2_fu_764_p4 : ap_sig_allocacmp_oldMax_V_2_load);

assign select_ln167_3_fu_805_p3 = ((icmp_ln1035_3_fu_799_p2[0:0] == 1'b1) ? channeldata_V_3_fu_789_p4 : ap_sig_allocacmp_oldMax_V_3_load);

assign select_ln167_4_fu_830_p3 = ((icmp_ln1035_4_fu_824_p2[0:0] == 1'b1) ? channeldata_V_4_fu_814_p4 : ap_sig_allocacmp_oldMax_V_4_load);

assign select_ln167_5_fu_855_p3 = ((icmp_ln1035_5_fu_849_p2[0:0] == 1'b1) ? channeldata_V_5_fu_839_p4 : ap_sig_allocacmp_oldMax_V_5_load);

assign select_ln167_6_fu_880_p3 = ((icmp_ln1035_6_fu_874_p2[0:0] == 1'b1) ? channeldata_V_6_fu_864_p4 : ap_sig_allocacmp_oldMax_V_6_load);

assign select_ln167_7_fu_905_p3 = ((icmp_ln1035_7_fu_899_p2[0:0] == 1'b1) ? channeldata_V_7_fu_889_p4 : ap_sig_allocacmp_oldMax_V_7_load);

assign select_ln167_8_fu_930_p3 = ((icmp_ln1035_8_fu_924_p2[0:0] == 1'b1) ? channeldata_V_8_fu_914_p4 : ap_sig_allocacmp_oldMax_V_8_load);

assign select_ln167_9_fu_955_p3 = ((icmp_ln1035_9_fu_949_p2[0:0] == 1'b1) ? channeldata_V_9_fu_939_p4 : ap_sig_allocacmp_oldMax_V_9_load);

assign select_ln167_fu_730_p3 = ((icmp_ln1035_fu_724_p2[0:0] == 1'b1) ? channeldata_V_fu_720_p1 : ap_sig_allocacmp_oldMax_V_load);

assign zext_ln156_cast_fu_552_p1 = zext_ln156;

endmodule //StreamingMaxPool_hls_0_StreamingMaxPool_Precision_Pipeline_VITIS_LOOP_158_6
//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/code_gen_ipgen_StreamingFIFO_rtl_13_tpblmmir/Q_srl.v


// original source:
// https://github.com/nachiket/tdfc/blob/master/verilog/queues/Q_srl_oreg3_prefull_SIMPLE.v


// Copyright (c) 1999 The Regents of the University of California
// Copyright (c) 2010 The Regents of the University of Pennsylvania
// Copyright (c) 2011 Department of Electrical and Electronic Engineering, Imperial College London
// Copyright (c) 2020 Xilinx
//
// Permission to use, copy, modify, and distribute this software and
// its documentation for any purpose, without fee, and without a
// written agreement is hereby granted, provided that the above copyright
// notice and this paragraph and the following two paragraphs appear in
// all copies.
//
// IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR
// DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
// LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION,
// EVEN IF THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
// THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
// INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
// AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE PROVIDED HEREUNDER IS ON
// AN "AS IS" BASIS, AND THE UNIVERSITY OF CALIFORNIA HAS NO OBLIGATIONS TO
// PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
//

// Q_srl_oreg3_prefull_SIMPLE.v
//
//  - In-page queue with parameterizable depth, bit width
//  - Stream I/O is triple (data, valid, back-pressure),
//      with EOS concatenated into the data
//  - Flow control for input & output is combinationally decoupled
//  - 2 <= depth <= 256
//      * (depth >= 2)  is required to decouple I/O flow control,
//          where empty => no produce,  full => no consume,
//          and depth 1 would ping-pong between the two at half rate
//      * (depth <= 256) can be modified
//           by changing ''synthesis loop_limit X'' below
//          and changing ''addrwidth'' or its log computation
//  - 1 <= width
//  - Queue storage is in SRL16E, up to depth 16 per LUT per bit-slice,
//      plus output register (for fast output)
//  - Queue addressing is done by ''addr'' up-down counter
//  - Queue fullness is checked by comparator (addr==depth)
//  - Queue fullness                           is pre-computed for next cycle
//  - Queue input back-pressure                is pre-computed for next cycle
//  - Queue output valid (state!=state__empty) is pre-computed for next cycle
//      (necessary since SRL data output reg requires non-boolean state)
//  - FSM has 3 states (empty, one, more)
//  - When empty, continue to emit most recently emitted value (for debugging)
//
//  - Queue slots used      = / (state==state_empty) ? 0
//                            | (state==state_one)   ? 1
//                            \ (state==state_more)  ? addr+2
//  - Queue slots used     <=  depth
//  - Queue slots remaining =  depth - used
//                          = / (state==state_empty) ? depth
//                            | (state==state_one)   ? depth-1
//                            \ (state==state_more)  ? depth-2-addr
//
//  - Synplify 7.1 / 8.0
//  - Eylon Caspi,  9/11/03, 8/18/04, 3/29/05


`ifdef  Q_srl
`else
`define Q_srl


module Q_srl (clock, reset, i_d, i_v, i_r, o_d, o_v, o_r, count, maxcount);

   parameter depth = 16;   // - greatest #items in queue  (2 <= depth <= 256)
   parameter width = 16;   // - width of data (i_d, o_d)

   localparam countwidth = $clog2(depth + 1);
   localparam addrwidth = $clog2(depth);

   input     clock;
   input     reset;

   input  [width-1:0] i_d;	// - input  stream data (concat data + eos)
   input              i_v;	// - input  stream valid
   output             i_r;	// - input  stream ready
   wire               i_b;  // - input  stream back-pressure

   output [width-1:0] o_d;	// - output stream data (concat data + eos)
   output             o_v;	// - output stream valid
   input              o_r;	// - output stream ready
   wire               o_b;	// - output stream back-pressure

   output [countwidth-1:0] count;  // - output number of elems in queue
   output [countwidth-1:0] maxcount;  // - maximum observed count since reset

   reg [countwidth-1:0] maxcount_reg;  // - maximum count seen until now
   reg    [addrwidth-1:0] addr, addr_, a_;		// - SRL16 address
							//     for data output
   reg 			  shift_en_;			// - SRL16 shift enable
   reg    [width-1:0] 	  srl [depth-2:0];		// - SRL16 memory
   reg 			  shift_en_o_;			// - SRLO  shift enable
   reg    [width-1:0] 	  srlo_, srlo			// - SRLO  output reg
			  /* synthesis syn_allow_retiming=0 */ ;

   parameter state_empty = 2'd0;    // - state empty : o_v=0 o_d=UNDEFINED
   parameter state_one   = 2'd1;    // - state one   : o_v=1 o_d=srlo
   parameter state_more  = 2'd2;    // - state more  : o_v=1 o_d=srlo
				    //     #items in srl = addr+2

   reg [1:0] state, state_;	    // - state register

   wire      addr_full_;	    // - true iff addr==depth-2 on NEXT cycle
   reg       addr_full; 	    // - true iff addr==depth-2
   wire      addr_zero_;	    // - true iff addr==0
   wire      o_v_reg_;		    // - true iff state_empty   on NEXT cycle
   reg       o_v_reg  		    // - true iff state_empty
	     /* synthesis syn_allow_retiming=0 */ ;
   wire      i_b_reg_;		    // - true iff !full         on NEXT cycle
   reg       i_b_reg  		    // - true iff !full
	     /* synthesis syn_allow_retiming=0 */ ;

   assign addr_full_ = (state_==state_more) && (addr_==depth-2);
						// - queue full
   assign addr_zero_ = (addr==0);		// - queue contains 2 (or 1,0)
   assign o_v_reg_   = (state_!=state_empty);	// - output valid if non-empty
   assign i_b_reg_   = addr_full_;		// - input bp if full
   assign o_d = srlo;				// - output data from queue
   assign o_v = o_v_reg;			// - output valid if non-empty
   assign i_b = i_b_reg;			// - input bp if full
   assign maxcount = maxcount_reg;

   assign i_r = !i_b;
   assign o_b = !o_r;

   assign count = (state==state_more ? addr+2 : (state==state_one ? 1 : 0));

   // - ''always'' block with both FFs and SRL16 does not work,
   //      since FFs need reset but SRL16 does not

   always @(posedge clock) begin	// - seq always: FFs
      if (reset) begin
	 state     <= state_empty;
	 addr      <= 0;
         addr_full <= 0;
	 o_v_reg   <= 0;

	 i_b_reg   <= 0;
	 maxcount_reg <= 0;

      end
      else begin
	 state     <= state_;
	 addr      <= addr_;
         addr_full <= addr_full_;
	 o_v_reg   <= o_v_reg_;
	 i_b_reg   <= i_b_reg_;
	 maxcount_reg <= (count > maxcount_reg ? count : maxcount_reg);
      end
   end // always @ (posedge clock)

   always @(posedge clock) begin	// - seq always: srlo
      // - infer enabled output reg at end of shift chain
      // - input first element from i_d, all subsequent elements from SRL16
      if (reset) begin
	 srlo <= 0;
      end
      else begin
	 if (shift_en_o_) begin
	    srlo <= srlo_;
	 end
      end
   end // always @ (posedge clock)

   always @(posedge clock) begin			// - seq always: srl
      // - infer enabled SRL16E from shifting srl array
      // - no reset capability;  srl[] contents undefined on reset
      if (shift_en_) begin
	 // synthesis loop_limit 256
	 for (a_=depth-2; a_>0; a_=a_-1) begin
	    srl[a_] = srl[a_-1];
	 end
	 srl[0] <= i_d;
      end
   end // always @ (posedge clock or negedge reset)

   always @* begin					// - combi always
        srlo_       <=  'bx;
        shift_en_o_ <= 1'bx;
        shift_en_   <= 1'bx;
        addr_       <=  'bx;
        state_      <= 2'bx;
      case (state)

	state_empty: begin		    // - (empty, will not produce)
	      if (i_v) begin		    // - empty & i_v => consume
		 srlo_       <= i_d;
		 shift_en_o_ <= 1;
		 shift_en_   <= 1'bx;
		 addr_       <= 0;
		 state_      <= state_one;
	      end
	      else	begin		    // - empty & !i_v => idle
		 srlo_       <= 'bx;
		 shift_en_o_ <= 0;
		 shift_en_   <= 1'bx;
		 addr_       <= 0;
		 state_      <= state_empty;
	      end
	end

	state_one: begin		    // - (contains one)
	      if (i_v && o_b) begin	    // - one & i_v & o_b => consume
		 srlo_       <= 'bx;
		 shift_en_o_ <= 0;
		 shift_en_   <= 1;
		 addr_       <= 0;
		 state_      <= state_more;
	      end
	      else if (i_v && !o_b) begin   // - one & i_v & !o_b => cons+prod
		 srlo_       <= i_d;
		 shift_en_o_ <= 1;
		 shift_en_   <= 1;
		 addr_       <= 0;
		 state_      <= state_one;
	      end
	      else if (!i_v && o_b) begin   // - one & !i_v & o_b => idle
		 srlo_       <= 'bx;
		 shift_en_o_ <= 0;
		 shift_en_   <= 1'bx;
		 addr_       <= 0;
		 state_      <= state_one;
	      end
	      else if (!i_v && !o_b) begin  // - one & !i_v & !o_b => produce
		 srlo_       <= 'bx;
		 shift_en_o_ <= 0;
		 shift_en_   <= 1'bx;
		 addr_       <= 0;
		 state_      <= state_empty;
	      end
	end // case: state_one

	state_more: begin		    // - (contains more than one)
	   if (addr_full || (depth==2)) begin
					    // - (full, will not consume)
					    // - (full here if depth==2)
	      if (o_b) begin		    // - full & o_b => idle
		 srlo_       <= 'bx;
		 shift_en_o_ <= 0;
		 shift_en_   <= 0;
		 addr_       <= addr;
		 state_      <= state_more;
	      end
	      else begin		    // - full & !o_b => produce
		 srlo_       <= srl[addr];
		 shift_en_o_ <= 1;
		 shift_en_   <= 0;
//		 addr_       <= addr-1;
//		 state_      <= state_more;
		 addr_       <= addr_zero_ ? 0         : addr-1;
		 state_      <= addr_zero_ ? state_one : state_more;
	      end
	   end
	   else begin			    // - (mid: neither empty nor full)
	      if (i_v && o_b) begin	    // - mid & i_v & o_b => consume
		 srlo_       <= 'bx;
		 shift_en_o_ <= 0;
		 shift_en_   <= 1;
		 addr_       <= addr+1;
		 state_      <= state_more;
	      end
	      else if (i_v && !o_b) begin   // - mid & i_v & !o_b => cons+prod
		 srlo_       <= srl[addr];
		 shift_en_o_ <= 1;
		 shift_en_   <= 1;
		 addr_       <= addr;
		 state_      <= state_more;
	      end
	      else if (!i_v && o_b) begin   // - mid & !i_v & o_b => idle
		 srlo_       <= 'bx;
		 shift_en_o_ <= 0;
		 shift_en_   <= 0;
		 addr_       <= addr;
		 state_      <= state_more;
	      end
	      else if (!i_v && !o_b) begin  // - mid & !i_v & !o_b => produce
		 srlo_       <= srl[addr];
		 shift_en_o_ <= 1;
		 shift_en_   <= 0;
		 addr_       <= addr_zero_ ? 0         : addr-1;
		 state_      <= addr_zero_ ? state_one : state_more;
	      end
	   end // else: !if(addr_full)
	end // case: state_more

	default: begin
		 srlo_       <=  'bx;
		 shift_en_o_ <= 1'bx;
		 shift_en_   <= 1'bx;
		 addr_       <=  'bx;
		 state_      <= 2'bx;
	end // case: default

      endcase // case(state)
   end // always @ *

endmodule // Q_srl


`endif  // `ifdef  Q_srl
//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/vivado_stitch_proj_w5fn6zuu/finn_vivado_stitch_proj.gen/sources_1/bd/finn_design/ipshared/6bf6/hdl/verilog/StreamingMaxPool_hls_0_hls_deadlock_idx1_monitor.v


`timescale 1 ns / 1 ps

module StreamingMaxPool_hls_0_hls_deadlock_idx1_monitor ( // for module StreamingMaxPool_hls_0_StreamingMaxPool_hls_0_inst.grp_StreamingMaxPool_Precision_28u_2u_16u_ap_uint_4_0_64_s_fu_28
    input wire clock,
    input wire reset,
    input wire [1:0] axis_block_sigs,
    input wire [3:0] inst_idle_sigs,
    input wire [0:0] inst_block_sigs,
    output wire block
);

// signal declare
reg monitor_find_block;
wire idx3_block;
wire idx2_block;
wire sub_parallel_block;
wire all_sub_parallel_has_block;
wire all_sub_single_has_block;
wire cur_axis_has_block;
wire seq_is_axis_block;

assign block = monitor_find_block;
assign idx3_block = axis_block_sigs[1];
assign idx2_block = axis_block_sigs[0];
assign all_sub_parallel_has_block = 1'b0;
assign all_sub_single_has_block = 1'b0 | (idx3_block & (axis_block_sigs[1])) | (idx2_block & (axis_block_sigs[0]));
assign cur_axis_has_block = 1'b0;
assign seq_is_axis_block = all_sub_parallel_has_block | all_sub_single_has_block | cur_axis_has_block;

always @(posedge clock) begin
    if (reset == 1'b1)
        monitor_find_block <= 1'b0;
    else if (seq_is_axis_block == 1'b1)
        monitor_find_block <= 1'b1;
    else
        monitor_find_block <= 1'b0;
end


// instant sub module
endmodule
//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/vivado_stitch_proj_w5fn6zuu/finn_vivado_stitch_proj.gen/sources_1/bd/finn_design/ipshared/fb57/hdl/verilog/MVAU_hls_1_flow_control_loop_pipe_sequential_init.v


// ==============================================================
// Vitis HLS - High-Level Synthesis from C, C++ and OpenCL v2022.2 (64-bit)
// Tool Version Limit: 2019.12
// Copyright 1986-2022 Xilinx, Inc. All Rights Reserved.
// ==============================================================

`timescale 1 ns / 1 ps

module MVAU_hls_1_flow_control_loop_pipe_sequential_init(
        ap_clk,
        ap_rst,
        ap_start,
        ap_ready,
        ap_done,
        ap_start_int,
        ap_ready_int,
        ap_done_int,
        ap_continue_int,
        ap_loop_init,
        ap_loop_exit_ready,
        ap_loop_exit_done
);

input   ap_clk;
input   ap_rst;

//Block level handshake with outside loop
input   ap_start;
output  ap_ready;
output  ap_done;

//Block level handshake with loop body
output  ap_start_int;
input   ap_ready_int;
input   ap_done_int;
output  ap_continue_int;

//Init live in variables
output   ap_loop_init;
wire     ap_loop_init;
reg ap_loop_init_int;
reg ap_done;
reg ap_done_cache;

//Exit signal from loop body
input   ap_loop_exit_ready;
input   ap_loop_exit_done;

// power-on initialization
initial begin
#0 ap_loop_init_int = 1'b1;
#0 ap_done_cache = 1'b0;
end

assign ap_start_int = ap_start;

assign ap_continue_int = 1'b1;

assign ap_ready = ap_loop_exit_ready;

//ap_loop_init is valid for the first II
//of the first loop run so as to enable
//the init block ops which are pushed into
//the first state of the pipeline region
always @ (posedge ap_clk)
begin
    if (ap_rst == 1'b1) begin
        ap_loop_init_int <= 1'b1;
    end else if(ap_loop_exit_done == 1'b1) begin
        ap_loop_init_int <= 1'b1;
    end else if(ap_ready_int == 1'b1) begin
        ap_loop_init_int <= 1'b0;
    end
end

assign ap_loop_init = ap_loop_init_int & ap_start;

// if no ap_continue port and current module is not top module, 
// ap_done handshakes with ap_start. Internally, flow control sends out 
// ap_conintue_int = 1'b1 so the ap_done_int is asserted high for 1 clock cycle.
// ap_done_cache is used to record ap_done_int, and de-assert if ap_start_int
// is asserted, so DUT can start the next run
always @(posedge ap_clk)
begin
    if (ap_rst == 1'b1) begin
        ap_done_cache <= 1'b0;
    end else if (ap_done_int == 1'b1) begin
        ap_done_cache <= 1'b1;
    end else if (ap_start_int == 1'b1) begin
        ap_done_cache <= 1'b0;
    end
end

// if no ap_continue port and current module is not top module, ap_done handshakes with ap_start
always @(*)
begin
    if ((ap_done_int == 1'b1) || ((ap_done_cache == 1'b1) && (ap_start_int == 1'b0))) begin
        ap_done = 1'b1;
    end else begin
        ap_done = 1'b0;
    end
end

endmodule
        
//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/code_gen_ipgen_StreamingDataWidthConverter_rtl_3_aheji69x/StreamingDataWidthConverter_rtl_3.v


/******************************************************************************
 * Copyright (C) 2023, Advanced Micro Devices, Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *  1. Redistributions of source code must retain the above copyright notice,
 *     this list of conditions and the following disclaimer.
 *
 *  2. Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *
 *  3. Neither the name of the copyright holder nor the names of its
 *     contributors may be used to endorse or promote products derived from
 *     this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION). HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *****************************************************************************/

module StreamingDataWidthConverter_rtl_3 #(
	parameter  IBITS = 4,
	parameter  OBITS = 128,

	parameter  AXI_IBITS = (IBITS+7)/8 * 8,
	parameter  AXI_OBITS = (OBITS+7)/8 * 8
)(
	//- Global Control ------------------
	(* X_INTERFACE_INFO = "xilinx.com:signal:clock:1.0 ap_clk CLK" *)
	(* X_INTERFACE_PARAMETER = "ASSOCIATED_BUSIF in0_V:out_V, ASSOCIATED_RESET ap_rst_n" *)
	input	ap_clk,
	(* X_INTERFACE_PARAMETER = "POLARITY ACTIVE_LOW" *)
	input	ap_rst_n,

	//- AXI Stream - Input --------------
	output	in0_V_TREADY,
	input	in0_V_TVALID,
	input	[AXI_IBITS-1:0]  in0_V_TDATA,

	//- AXI Stream - Output -------------
	input	out_V_TREADY,
	output	out_V_TVALID,
	output	[AXI_OBITS-1:0]  out_V_TDATA
);

	dwc_axi #(
		.IBITS(IBITS),
		.OBITS(OBITS)
	) impl (
		.ap_clk(ap_clk),
		.ap_rst_n(ap_rst_n),
		.s_axis_tready(in0_V_TREADY),
		.s_axis_tvalid(in0_V_TVALID),
		.s_axis_tdata(in0_V_TDATA),
		.m_axis_tready(out_V_TREADY),
		.m_axis_tvalid(out_V_TVALID),
		.m_axis_tdata(out_V_TDATA)
	);

endmodule
//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/vivado_stitch_proj_w5fn6zuu/finn_vivado_stitch_proj.gen/sources_1/bd/finn_design/ip/finn_design_StreamingFIFO_rtl_7_0/synth/finn_design_StreamingFIFO_rtl_7_0.v


// (c) Copyright 1995-2026 Xilinx, Inc. All rights reserved.
// 
// This file contains confidential and proprietary information
// of Xilinx, Inc. and is protected under U.S. and
// international copyright and other intellectual property
// laws.
// 
// DISCLAIMER
// This disclaimer is not a license and does not grant any
// rights to the materials distributed herewith. Except as
// otherwise provided in a valid license issued to you by
// Xilinx, and to the maximum extent permitted by applicable
// law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
// WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
// AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
// BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
// INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
// (2) Xilinx shall not be liable (whether in contract or tort,
// including negligence, or under any other theory of
// liability) for any loss or damage of any kind or nature
// related to, arising under or in connection with these
// materials, including for any direct, or any indirect,
// special, incidental, or consequential loss or damage
// (including loss of data, profits, goodwill, or any type of
// loss or damage suffered as a result of any action brought
// by a third party) even if such damage or loss was
// reasonably foreseeable or Xilinx had been advised of the
// possibility of the same.
// 
// CRITICAL APPLICATIONS
// Xilinx products are not designed or intended to be fail-
// safe, or for use in any application requiring fail-safe
// performance, such as life-support or safety devices or
// systems, Class III medical devices, nuclear facilities,
// applications related to the deployment of airbags, or any
// other applications that could lead to death, personal
// injury, or severe property or environmental damage
// (individually and collectively, "Critical
// Applications"). Customer assumes the sole risk and
// liability of any use of Xilinx products in Critical
// Applications, subject only to applicable laws and
// regulations governing limitations on product liability.
// 
// THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
// PART OF THIS FILE AT ALL TIMES.
// 
// DO NOT MODIFY THIS FILE.


// IP VLNV: xilinx.com:module_ref:StreamingFIFO_rtl_7:1.0
// IP Revision: 1

(* X_CORE_INFO = "StreamingFIFO_rtl_7,Vivado 2022.2" *)
(* CHECK_LICENSE_TYPE = "finn_design_StreamingFIFO_rtl_7_0,StreamingFIFO_rtl_7,{}" *)
(* CORE_GENERATION_INFO = "finn_design_StreamingFIFO_rtl_7_0,StreamingFIFO_rtl_7,{x_ipProduct=Vivado 2022.2,x_ipVendor=xilinx.com,x_ipLibrary=module_ref,x_ipName=StreamingFIFO_rtl_7,x_ipVersion=1.0,x_ipCoreRevision=1,x_ipLanguage=VERILOG,x_ipSimLanguage=MIXED}" *)
(* IP_DEFINITION_SOURCE = "module_ref" *)
(* DowngradeIPIdentifiedWarnings = "yes" *)
module finn_design_StreamingFIFO_rtl_7_0 (
  ap_clk,
  ap_rst_n,
  count,
  maxcount,
  in0_V_TREADY,
  in0_V_TVALID,
  in0_V_TDATA,
  out_V_TREADY,
  out_V_TVALID,
  out_V_TDATA
);

(* X_INTERFACE_PARAMETER = "XIL_INTERFACENAME ap_clk, ASSOCIATED_RESET ap_rst_n, ASSOCIATED_BUSIF in0_V:out_V, FREQ_HZ 100000000, FREQ_TOLERANCE_HZ 0, PHASE 0.0, CLK_DOMAIN finn_design_ap_clk_0, INSERT_VIP 0" *)
(* X_INTERFACE_INFO = "xilinx.com:signal:clock:1.0 ap_clk CLK" *)
input wire ap_clk;
(* X_INTERFACE_PARAMETER = "XIL_INTERFACENAME ap_rst_n, POLARITY ACTIVE_LOW, INSERT_VIP 0" *)
(* X_INTERFACE_INFO = "xilinx.com:signal:reset:1.0 ap_rst_n RST" *)
input wire ap_rst_n;
output wire [8 : 0] count;
output wire [8 : 0] maxcount;
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 in0_V TREADY" *)
output wire in0_V_TREADY;
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 in0_V TVALID" *)
input wire in0_V_TVALID;
(* X_INTERFACE_PARAMETER = "XIL_INTERFACENAME in0_V, TDATA_NUM_BYTES 8, TDEST_WIDTH 0, TID_WIDTH 0, TUSER_WIDTH 0, HAS_TREADY 1, HAS_TSTRB 0, HAS_TKEEP 0, HAS_TLAST 0, FREQ_HZ 100000000, PHASE 0.0, CLK_DOMAIN finn_design_ap_clk_0, LAYERED_METADATA undef, INSERT_VIP 0" *)
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 in0_V TDATA" *)
input wire [63 : 0] in0_V_TDATA;
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 out_V TREADY" *)
input wire out_V_TREADY;
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 out_V TVALID" *)
output wire out_V_TVALID;
(* X_INTERFACE_PARAMETER = "XIL_INTERFACENAME out_V, TDATA_NUM_BYTES 8, TDEST_WIDTH 0, TID_WIDTH 0, TUSER_WIDTH 0, HAS_TREADY 1, HAS_TSTRB 0, HAS_TKEEP 0, HAS_TLAST 0, FREQ_HZ 100000000, PHASE 0.0, CLK_DOMAIN finn_design_ap_clk_0, LAYERED_METADATA undef, INSERT_VIP 0" *)
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 out_V TDATA" *)
output wire [63 : 0] out_V_TDATA;

  StreamingFIFO_rtl_7 inst (
    .ap_clk(ap_clk),
    .ap_rst_n(ap_rst_n),
    .count(count),
    .maxcount(maxcount),
    .in0_V_TREADY(in0_V_TREADY),
    .in0_V_TVALID(in0_V_TVALID),
    .in0_V_TDATA(in0_V_TDATA),
    .out_V_TREADY(out_V_TREADY),
    .out_V_TVALID(out_V_TVALID),
    .out_V_TDATA(out_V_TDATA)
  );
endmodule
//Added from /home/robotics/Documents/bharat-ai-soc-student-challenge/New_Train/new_res_brevitas/finn/finn_zybo_project/finn_build_temp/vivado_stitch_proj_w5fn6zuu/finn_vivado_stitch_proj.gen/sources_1/bd/finn_design/ip/finn_design_StreamingFIFO_rtl_13_0/synth/finn_design_StreamingFIFO_rtl_13_0.v


// (c) Copyright 1995-2026 Xilinx, Inc. All rights reserved.
// 
// This file contains confidential and proprietary information
// of Xilinx, Inc. and is protected under U.S. and
// international copyright and other intellectual property
// laws.
// 
// DISCLAIMER
// This disclaimer is not a license and does not grant any
// rights to the materials distributed herewith. Except as
// otherwise provided in a valid license issued to you by
// Xilinx, and to the maximum extent permitted by applicable
// law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
// WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
// AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
// BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
// INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
// (2) Xilinx shall not be liable (whether in contract or tort,
// including negligence, or under any other theory of
// liability) for any loss or damage of any kind or nature
// related to, arising under or in connection with these
// materials, including for any direct, or any indirect,
// special, incidental, or consequential loss or damage
// (including loss of data, profits, goodwill, or any type of
// loss or damage suffered as a result of any action brought
// by a third party) even if such damage or loss was
// reasonably foreseeable or Xilinx had been advised of the
// possibility of the same.
// 
// CRITICAL APPLICATIONS
// Xilinx products are not designed or intended to be fail-
// safe, or for use in any application requiring fail-safe
// performance, such as life-support or safety devices or
// systems, Class III medical devices, nuclear facilities,
// applications related to the deployment of airbags, or any
// other applications that could lead to death, personal
// injury, or severe property or environmental damage
// (individually and collectively, "Critical
// Applications"). Customer assumes the sole risk and
// liability of any use of Xilinx products in Critical
// Applications, subject only to applicable laws and
// regulations governing limitations on product liability.
// 
// THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
// PART OF THIS FILE AT ALL TIMES.
// 
// DO NOT MODIFY THIS FILE.


// IP VLNV: xilinx.com:module_ref:StreamingFIFO_rtl_13:1.0
// IP Revision: 1

(* X_CORE_INFO = "StreamingFIFO_rtl_13,Vivado 2022.2" *)
(* CHECK_LICENSE_TYPE = "finn_design_StreamingFIFO_rtl_13_0,StreamingFIFO_rtl_13,{}" *)
(* CORE_GENERATION_INFO = "finn_design_StreamingFIFO_rtl_13_0,StreamingFIFO_rtl_13,{x_ipProduct=Vivado 2022.2,x_ipVendor=xilinx.com,x_ipLibrary=module_ref,x_ipName=StreamingFIFO_rtl_13,x_ipVersion=1.0,x_ipCoreRevision=1,x_ipLanguage=VERILOG,x_ipSimLanguage=MIXED}" *)
(* IP_DEFINITION_SOURCE = "module_ref" *)
(* DowngradeIPIdentifiedWarnings = "yes" *)
module finn_design_StreamingFIFO_rtl_13_0 (
  ap_clk,
  ap_rst_n,
  count,
  maxcount,
  in0_V_TREADY,
  in0_V_TVALID,
  in0_V_TDATA,
  out_V_TREADY,
  out_V_TVALID,
  out_V_TDATA
);

(* X_INTERFACE_PARAMETER = "XIL_INTERFACENAME ap_clk, ASSOCIATED_RESET ap_rst_n, ASSOCIATED_BUSIF in0_V:out_V, FREQ_HZ 100000000, FREQ_TOLERANCE_HZ 0, PHASE 0.0, CLK_DOMAIN finn_design_ap_clk_0, INSERT_VIP 0" *)
(* X_INTERFACE_INFO = "xilinx.com:signal:clock:1.0 ap_clk CLK" *)
input wire ap_clk;
(* X_INTERFACE_PARAMETER = "XIL_INTERFACENAME ap_rst_n, POLARITY ACTIVE_LOW, INSERT_VIP 0" *)
(* X_INTERFACE_INFO = "xilinx.com:signal:reset:1.0 ap_rst_n RST" *)
input wire ap_rst_n;
output wire [10 : 0] count;
output wire [10 : 0] maxcount;
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 in0_V TREADY" *)
output wire in0_V_TREADY;
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 in0_V TVALID" *)
input wire in0_V_TVALID;
(* X_INTERFACE_PARAMETER = "XIL_INTERFACENAME in0_V, TDATA_NUM_BYTES 1, TDEST_WIDTH 0, TID_WIDTH 0, TUSER_WIDTH 0, HAS_TREADY 1, HAS_TSTRB 0, HAS_TKEEP 0, HAS_TLAST 0, FREQ_HZ 100000000, PHASE 0.0, CLK_DOMAIN finn_design_ap_clk_0, LAYERED_METADATA undef, INSERT_VIP 0" *)
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 in0_V TDATA" *)
input wire [7 : 0] in0_V_TDATA;
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 out_V TREADY" *)
input wire out_V_TREADY;
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 out_V TVALID" *)
output wire out_V_TVALID;
(* X_INTERFACE_PARAMETER = "XIL_INTERFACENAME out_V, TDATA_NUM_BYTES 1, TDEST_WIDTH 0, TID_WIDTH 0, TUSER_WIDTH 0, HAS_TREADY 1, HAS_TSTRB 0, HAS_TKEEP 0, HAS_TLAST 0, FREQ_HZ 100000000, PHASE 0.0, CLK_DOMAIN finn_design_ap_clk_0, LAYERED_METADATA undef, INSERT_VIP 0" *)
(* X_INTERFACE_INFO = "xilinx.com:interface:axis:1.0 out_V TDATA" *)
output wire [7 : 0] out_V_TDATA;

  StreamingFIFO_rtl_13 inst (
    .ap_clk(ap_clk),
    .ap_rst_n(ap_rst_n),
    .count(count),
    .maxcount(maxcount),
    .in0_V_TREADY(in0_V_TREADY),
    .in0_V_TVALID(in0_V_TVALID),
    .in0_V_TDATA(in0_V_TDATA),
    .out_V_TREADY(out_V_TREADY),
    .out_V_TVALID(out_V_TVALID),
    .out_V_TDATA(out_V_TDATA)
  );
endmodule
